function l(e) {
    return e != null
}

function we(e) {
    this.name = "DeveloperError", this.message = e;
    var t;
    try {
        throw new Error
    } catch (n) {
        t = n.stack
    }
    this.stack = t
}
l(Object.create) && (we.prototype = Object.create(Error.prototype), we.prototype.constructor = we);
we.prototype.toString = function() {
    var e = this.name + ": " + this.message;
    return l(this.stack) && (e += `
` + this.stack.toString()), e
};
we.throwInstantiationError = function() {
    throw new we("This function defines an interface and should not be called directly.")
};
var wt = {};
wt.typeOf = {};

function $T(e) {
    return e + " is required, actual value was undefined"
}

function Ms(e, t, n) {
    return "Expected " + n + " to be typeof " + t + ", actual typeof was " + e
}
wt.defined = function(e, t) {
    if (!l(t)) throw new we($T(e))
};
wt.typeOf.func = function(e, t) {
    if (typeof t != "function") throw new we(Ms(typeof t, "function", e))
};
wt.typeOf.string = function(e, t) {
    if (typeof t != "string") throw new we(Ms(typeof t, "string", e))
};
wt.typeOf.number = function(e, t) {
    if (typeof t != "number") throw new we(Ms(typeof t, "number", e))
};
wt.typeOf.number.lessThan = function(e, t, n) {
    if (wt.typeOf.number(e, t), t >= n) throw new we("Expected " + e + " to be less than " + n + ", actual value was " + t)
};
wt.typeOf.number.lessThanOrEquals = function(e, t, n) {
    if (wt.typeOf.number(e, t), t > n) throw new we("Expected " + e + " to be less than or equal to " + n + ", actual value was " + t)
};
wt.typeOf.number.greaterThan = function(e, t, n) {
    if (wt.typeOf.number(e, t), t <= n) throw new we("Expected " + e + " to be greater than " + n + ", actual value was " + t)
};
wt.typeOf.number.greaterThanOrEquals = function(e, t, n) {
    if (wt.typeOf.number(e, t), t < n) throw new we("Expected " + e + " to be greater than or equal to" + n + ", actual value was " + t)
};
wt.typeOf.object = function(e, t) {
    if (typeof t != "object") throw new we(Ms(typeof t, "object", e))
};
wt.typeOf.bool = function(e, t) {
    if (typeof t != "boolean") throw new we(Ms(typeof t, "boolean", e))
};
wt.typeOf.number.equals = function(e, t, n, r) {
    if (wt.typeOf.number(e, n), wt.typeOf.number(t, r), n !== r) throw new we(e + " must be equal to " + t + ", the actual values are " + n + " and " + r)
};

function p(e, t) {
    return e != null ? e : t
}
p.EMPTY_OBJECT = Object.freeze({});

function Ns(e) {
    e == null && (e = new Date().getTime()), this.N = 624, this.M = 397, this.MATRIX_A = 2567483615, this.UPPER_MASK = 2147483648, this.LOWER_MASK = 2147483647, this.mt = new Array(this.N), this.mti = this.N + 1, this.init_genrand(e)
}
Ns.prototype.init_genrand = function(e) {
    for (this.mt[0] = e >>> 0, this.mti = 1; this.mti < this.N; this.mti++) {
        var e = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
        this.mt[this.mti] = (((e & 4294901760) >>> 16) * 1812433253 << 16) + (e & 65535) * 1812433253 + this.mti, this.mt[this.mti] >>>= 0
    }
};
Ns.prototype.genrand_int32 = function() {
    var e, t = new Array(0, this.MATRIX_A);
    if (this.mti >= this.N) {
        var n;
        for (this.mti == this.N + 1 && this.init_genrand(5489), n = 0; n < this.N - this.M; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, this.mt[n] = this.mt[n + this.M] ^ e >>> 1 ^ t[e & 1];
        for (; n < this.N - 1; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, this.mt[n] = this.mt[n + (this.M - this.N)] ^ e >>> 1 ^ t[e & 1];
        e = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK, this.mt[this.N - 1] = this.mt[this.M - 1] ^ e >>> 1 ^ t[e & 1], this.mti = 0
    }
    return e = this.mt[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, e ^= e >>> 18, e >>> 0
};
Ns.prototype.random = function() {
    return this.genrand_int32() * (1 / 4294967296)
};
var T = {};
T.EPSILON1 = .1;
T.EPSILON2 = .01;
T.EPSILON3 = .001;
T.EPSILON4 = 1e-4;
T.EPSILON5 = 1e-5;
T.EPSILON6 = 1e-6;
T.EPSILON7 = 1e-7;
T.EPSILON8 = 1e-8;
T.EPSILON9 = 1e-9;
T.EPSILON10 = 1e-10;
T.EPSILON11 = 1e-11;
T.EPSILON12 = 1e-12;
T.EPSILON13 = 1e-13;
T.EPSILON14 = 1e-14;
T.EPSILON15 = 1e-15;
T.EPSILON16 = 1e-16;
T.EPSILON17 = 1e-17;
T.EPSILON18 = 1e-18;
T.EPSILON19 = 1e-19;
T.EPSILON20 = 1e-20;
T.EPSILON21 = 1e-21;
T.GRAVITATIONALPARAMETER = 3986004418e5;
T.SOLAR_RADIUS = 6955e5;
T.LUNAR_RADIUS = 1737400;
T.SIXTY_FOUR_KILOBYTES = 64 * 1024;
T.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;
T.sign = p(Math.sign, function(t) {
    return t = +t, t === 0 || t !== t ? t : t > 0 ? 1 : -1
});
T.signNotZero = function(e) {
    return e < 0 ? -1 : 1
};
T.toSNorm = function(e, t) {
    return t = p(t, 255), Math.round((T.clamp(e, -1, 1) * .5 + .5) * t)
};
T.fromSNorm = function(e, t) {
    return t = p(t, 255), T.clamp(e, 0, t) / t * 2 - 1
};
T.normalize = function(e, t, n) {
    return n = Math.max(n - t, 0), n === 0 ? 0 : T.clamp((e - t) / n, 0, 1)
};
T.sinh = p(Math.sinh, function(t) {
    return (Math.exp(t) - Math.exp(-t)) / 2
});
T.cosh = p(Math.cosh, function(t) {
    return (Math.exp(t) + Math.exp(-t)) / 2
});
T.lerp = function(e, t, n) {
    return (1 - n) * e + n * t
};
T.PI = Math.PI;
T.ONE_OVER_PI = 1 / Math.PI;
T.PI_OVER_TWO = Math.PI / 2;
T.PI_OVER_THREE = Math.PI / 3;
T.PI_OVER_FOUR = Math.PI / 4;
T.PI_OVER_SIX = Math.PI / 6;
T.THREE_PI_OVER_TWO = 3 * Math.PI / 2;
T.TWO_PI = 2 * Math.PI;
T.ONE_OVER_TWO_PI = 1 / (2 * Math.PI);
T.RADIANS_PER_DEGREE = Math.PI / 180;
T.DEGREES_PER_RADIAN = 180 / Math.PI;
T.RADIANS_PER_ARCSECOND = T.RADIANS_PER_DEGREE / 3600;
T.toRadians = function(e) {
    return e * T.RADIANS_PER_DEGREE
};
T.toDegrees = function(e) {
    return e * T.DEGREES_PER_RADIAN
};
T.convertLongitudeRange = function(e) {
    var t = T.TWO_PI,
        n = e - Math.floor(e / t) * t;
    return n < -Math.PI ? n + t : n >= Math.PI ? n - t : n
};
T.clampToLatitudeRange = function(e) {
    return T.clamp(e, -1 * T.PI_OVER_TWO, T.PI_OVER_TWO)
};
T.negativePiToPi = function(e) {
    return T.zeroToTwoPi(e + T.PI) - T.PI
};
T.zeroToTwoPi = function(e) {
    var t = T.mod(e, T.TWO_PI);
    return Math.abs(t) < T.EPSILON14 && Math.abs(e) > T.EPSILON14 ? T.TWO_PI : t
};
T.mod = function(e, t) {
    return (e % t + t) % t
};
T.equalsEpsilon = function(e, t, n, r) {
    n = p(n, 0), r = p(r, n);
    var i = Math.abs(e - t);
    return i <= r || i <= n * Math.max(Math.abs(e), Math.abs(t))
};
T.lessThan = function(e, t, n) {
    return e - t < -n
};
T.lessThanOrEquals = function(e, t, n) {
    return e - t < n
};
T.greaterThan = function(e, t, n) {
    return e - t > n
};
T.greaterThanOrEquals = function(e, t, n) {
    return e - t > -n
};
var Xs = [1];
T.factorial = function(e) {
    var t = Xs.length;
    if (e >= t)
        for (var n = Xs[t - 1], r = t; r <= e; r++) {
            var i = n * r;
            Xs.push(i), n = i
        }
    return Xs[e]
};
T.incrementWrap = function(e, t, n) {
    return n = p(n, 0), ++e, e > t && (e = n), e
};
T.isPowerOfTwo = function(e) {
    return e !== 0 && (e & e - 1) === 0
};
T.nextPowerOfTwo = function(e) {
    return --e, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, ++e, e
};
T.clamp = function(e, t, n) {
    return e < t ? t : e > n ? n : e
};
var _p = new Ns;
T.setRandomNumberSeed = function(e) {
    _p = new Ns(e)
};
T.nextRandomNumber = function() {
    return _p.random()
};
T.randomBetween = function(e, t) {
    return T.nextRandomNumber() * (t - e) + e
};
T.acosClamped = function(e) {
    return Math.acos(T.clamp(e, -1, 1))
};
T.asinClamped = function(e) {
    return Math.asin(T.clamp(e, -1, 1))
};
T.chordLength = function(e, t) {
    return 2 * t * Math.sin(e * .5)
};
T.logBase = function(e, t) {
    return Math.log(e) / Math.log(t)
};
T.cbrt = p(Math.cbrt, function(t) {
    var n = Math.pow(Math.abs(t), .3333333333333333);
    return t < 0 ? -n : n
});
T.log2 = p(Math.log2, function(t) {
    return Math.log(t) * Math.LOG2E
});
T.fog = function(e, t) {
    var n = e * t;
    return 1 - Math.exp(-(n * n))
};
T.fastApproximateAtan = function(e) {
    return e * (-.1784 * Math.abs(e) - .0663 * e * e + 1.0301)
};
T.fastApproximateAtan2 = function(e, t) {
    var n, r, i = Math.abs(e);
    n = Math.abs(t), r = Math.max(i, n), n = Math.min(i, n);
    var a = n / r;
    return i = T.fastApproximateAtan(a), i = Math.abs(t) > Math.abs(e) ? T.PI_OVER_TWO - i : i, i = e < 0 ? T.PI - i : i, i = t < 0 ? -i : i, i
};

function R(e, t) {
    this.x = p(e, 0), this.y = p(t, 0)
}
R.fromElements = function(e, t, n) {
    return l(n) ? (n.x = e, n.y = t, n) : new R(e, t)
};
R.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.x = e.x, t.y = e.y, t) : new R(e.x, e.y)
};
R.fromCartesian3 = R.clone;
R.fromCartesian4 = R.clone;
R.packedLength = 2;
R.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.x, t[n] = e.y, t
};
R.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new R), n.x = e[t++], n.y = e[t], n
};
R.packArray = function(e, t) {
    var n = e.length,
        r = n * 2;
    if (!l(t)) t = new Array(r);
    else {
        if (!Array.isArray(t) && t.length !== r) throw new we("If result is a typed array, it must have exactly array.length * 2 elements");
        t.length !== r && (t.length = r)
    }
    for (var i = 0; i < n; ++i) R.pack(e[i], t, i * 2);
    return t
};
R.unpackArray = function(e, t) {
    var n = e.length;
    l(t) ? t.length = n / 2 : t = new Array(n / 2);
    for (var r = 0; r < n; r += 2) {
        var i = r / 2;
        t[i] = R.unpack(e, r, t[i])
    }
    return t
};
R.fromArray = R.unpack;
R.maximumComponent = function(e) {
    return Math.max(e.x, e.y)
};
R.minimumComponent = function(e) {
    return Math.min(e.x, e.y)
};
R.minimumByComponent = function(e, t, n) {
    return n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n
};
R.maximumByComponent = function(e, t, n) {
    return n.x = Math.max(e.x, t.x), n.y = Math.max(e.y, t.y), n
};
R.magnitudeSquared = function(e) {
    return e.x * e.x + e.y * e.y
};
R.magnitude = function(e) {
    return Math.sqrt(R.magnitudeSquared(e))
};
var wc = new R;
R.distance = function(e, t) {
    return R.subtract(e, t, wc), R.magnitude(wc)
};
R.distanceSquared = function(e, t) {
    return R.subtract(e, t, wc), R.magnitudeSquared(wc)
};
R.normalize = function(e, t) {
    var n = R.magnitude(e);
    return t.x = e.x / n, t.y = e.y / n, t
};
R.dot = function(e, t) {
    return e.x * t.x + e.y * t.y
};
R.cross = function(e, t) {
    return e.x * t.y - e.y * t.x
};
R.multiplyComponents = function(e, t, n) {
    return n.x = e.x * t.x, n.y = e.y * t.y, n
};
R.divideComponents = function(e, t, n) {
    return n.x = e.x / t.x, n.y = e.y / t.y, n
};
R.add = function(e, t, n) {
    return n.x = e.x + t.x, n.y = e.y + t.y, n
};
R.subtract = function(e, t, n) {
    return n.x = e.x - t.x, n.y = e.y - t.y, n
};
R.multiplyByScalar = function(e, t, n) {
    return n.x = e.x * t, n.y = e.y * t, n
};
R.divideByScalar = function(e, t, n) {
    return n.x = e.x / t, n.y = e.y / t, n
};
R.negate = function(e, t) {
    return t.x = -e.x, t.y = -e.y, t
};
R.abs = function(e, t) {
    return t.x = Math.abs(e.x), t.y = Math.abs(e.y), t
};
var Zd = new R;
R.lerp = function(e, t, n, r) {
    return R.multiplyByScalar(t, n, Zd), r = R.multiplyByScalar(e, 1 - n, r), R.add(Zd, r, r)
};
var Kd = new R,
    $d = new R;
R.angleBetween = function(e, t) {
    return R.normalize(e, Kd), R.normalize(t, $d), T.acosClamped(R.dot(Kd, $d))
};
var JT = new R;
R.mostOrthogonalAxis = function(e, t) {
    var n = R.normalize(e, JT);
    return R.abs(n, n), n.x <= n.y ? t = R.clone(R.UNIT_X, t) : t = R.clone(R.UNIT_Y, t), t
};
R.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.x === t.x && e.y === t.y
};
R.equalsArray = function(e, t, n) {
    return e.x === t[n] && e.y === t[n + 1]
};
R.equalsEpsilon = function(e, t, n, r) {
    return e === t || l(e) && l(t) && T.equalsEpsilon(e.x, t.x, n, r) && T.equalsEpsilon(e.y, t.y, n, r)
};
R.ZERO = Object.freeze(new R(0, 0));
R.UNIT_X = Object.freeze(new R(1, 0));
R.UNIT_Y = Object.freeze(new R(0, 1));
R.prototype.clone = function(e) {
    return R.clone(this, e)
};
R.prototype.equals = function(e) {
    return R.equals(this, e)
};
R.prototype.equalsEpsilon = function(e, t, n) {
    return R.equalsEpsilon(this, e, t, n)
};
R.prototype.toString = function() {
    return "(" + this.x + ", " + this.y + ")"
};

function u(e, t, n) {
    this.x = p(e, 0), this.y = p(t, 0), this.z = p(n, 0)
}
u.fromSpherical = function(e, t) {
    l(t) || (t = new u);
    var n = e.clock,
        r = e.cone,
        i = p(e.magnitude, 1),
        a = i * Math.sin(r);
    return t.x = a * Math.cos(n), t.y = a * Math.sin(n), t.z = i * Math.cos(r), t
};
u.fromElements = function(e, t, n, r) {
    return l(r) ? (r.x = e, r.y = t, r.z = n, r) : new u(e, t, n)
};
u.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.x = e.x, t.y = e.y, t.z = e.z, t) : new u(e.x, e.y, e.z)
};
u.fromCartesian4 = u.clone;
u.packedLength = 3;
u.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.x, t[n++] = e.y, t[n] = e.z, t
};
u.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new u), n.x = e[t++], n.y = e[t++], n.z = e[t], n
};
u.packArray = function(e, t) {
    var n = e.length,
        r = n * 3;
    if (!l(t)) t = new Array(r);
    else {
        if (!Array.isArray(t) && t.length !== r) throw new we("If result is a typed array, it must have exactly array.length * 3 elements");
        t.length !== r && (t.length = r)
    }
    for (var i = 0; i < n; ++i) u.pack(e[i], t, i * 3);
    return t
};
u.unpackArray = function(e, t) {
    var n = e.length;
    l(t) ? t.length = n / 3 : t = new Array(n / 3);
    for (var r = 0; r < n; r += 3) {
        var i = r / 3;
        t[i] = u.unpack(e, r, t[i])
    }
    return t
};
u.fromArray = u.unpack;
u.maximumComponent = function(e) {
    return Math.max(e.x, e.y, e.z)
};
u.minimumComponent = function(e) {
    return Math.min(e.x, e.y, e.z)
};
u.minimumByComponent = function(e, t, n) {
    return n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n.z = Math.min(e.z, t.z), n
};
u.maximumByComponent = function(e, t, n) {
    return n.x = Math.max(e.x, t.x), n.y = Math.max(e.y, t.y), n.z = Math.max(e.z, t.z), n
};
u.magnitudeSquared = function(e) {
    return e.x * e.x + e.y * e.y + e.z * e.z
};
u.magnitude = function(e) {
    return Math.sqrt(u.magnitudeSquared(e))
};
var xc = new u;
u.distance = function(e, t) {
    return u.subtract(e, t, xc), u.magnitude(xc)
};
u.distanceSquared = function(e, t) {
    return u.subtract(e, t, xc), u.magnitudeSquared(xc)
};
u.normalize = function(e, t) {
    var n = u.magnitude(e);
    return t.x = e.x / n, t.y = e.y / n, t.z = e.z / n, t
};
u.dot = function(e, t) {
    return e.x * t.x + e.y * t.y + e.z * t.z
};
u.multiplyComponents = function(e, t, n) {
    return n.x = e.x * t.x, n.y = e.y * t.y, n.z = e.z * t.z, n
};
u.divideComponents = function(e, t, n) {
    return n.x = e.x / t.x, n.y = e.y / t.y, n.z = e.z / t.z, n
};
u.add = function(e, t, n) {
    return n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z, n
};
u.subtract = function(e, t, n) {
    return n.x = e.x - t.x, n.y = e.y - t.y, n.z = e.z - t.z, n
};
u.multiplyByScalar = function(e, t, n) {
    return n.x = e.x * t, n.y = e.y * t, n.z = e.z * t, n
};
u.divideByScalar = function(e, t, n) {
    return n.x = e.x / t, n.y = e.y / t, n.z = e.z / t, n
};
u.negate = function(e, t) {
    return t.x = -e.x, t.y = -e.y, t.z = -e.z, t
};
u.abs = function(e, t) {
    return t.x = Math.abs(e.x), t.y = Math.abs(e.y), t.z = Math.abs(e.z), t
};
var Jd = new u;
u.lerp = function(e, t, n, r) {
    return u.multiplyByScalar(t, n, Jd), r = u.multiplyByScalar(e, 1 - n, r), u.add(Jd, r, r)
};
var js = new u,
    pf = new u;
u.angleBetween = function(e, t) {
    u.normalize(e, js), u.normalize(t, pf);
    var n = u.dot(js, pf),
        r = u.magnitude(u.cross(js, pf, js));
    return Math.atan2(r, n)
};
var QT = new u;
u.mostOrthogonalAxis = function(e, t) {
    var n = u.normalize(e, QT);
    return u.abs(n, n), n.x <= n.y ? n.x <= n.z ? t = u.clone(u.UNIT_X, t) : t = u.clone(u.UNIT_Z, t) : n.y <= n.z ? t = u.clone(u.UNIT_Y, t) : t = u.clone(u.UNIT_Z, t), t
};
u.projectVector = function(e, t, n) {
    var r = u.dot(e, t) / u.dot(t, t);
    return u.multiplyByScalar(t, r, n)
};
u.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.x === t.x && e.y === t.y && e.z === t.z
};
u.equalsArray = function(e, t, n) {
    return e.x === t[n] && e.y === t[n + 1] && e.z === t[n + 2]
};
u.equalsEpsilon = function(e, t, n, r) {
    return e === t || l(e) && l(t) && T.equalsEpsilon(e.x, t.x, n, r) && T.equalsEpsilon(e.y, t.y, n, r) && T.equalsEpsilon(e.z, t.z, n, r)
};
u.cross = function(e, t, n) {
    var r = e.x,
        i = e.y,
        a = e.z,
        o = t.x,
        s = t.y,
        c = t.z,
        f = i * c - a * s,
        h = a * o - r * c,
        d = r * s - i * o;
    return n.x = f, n.y = h, n.z = d, n
};
u.midpoint = function(e, t, n) {
    return n.x = (e.x + t.x) * .5, n.y = (e.y + t.y) * .5, n.z = (e.z + t.z) * .5, n
};
u.fromDegrees = function(e, t, n, r, i) {
    return e = T.toRadians(e), t = T.toRadians(t), u.fromRadians(e, t, n, r, i)
};
var sr = new u,
    Ka = new u,
    eE = new u(6378137 * 6378137, 6378137 * 6378137, 6356752314245179e-9 * 6356752314245179e-9);
u.fromRadians = function(e, t, n, r, i) {
    n = p(n, 0);
    var a = l(r) ? r.radiiSquared : eE,
        o = Math.cos(t);
    sr.x = o * Math.cos(e), sr.y = o * Math.sin(e), sr.z = Math.sin(t), sr = u.normalize(sr, sr), u.multiplyComponents(a, sr, Ka);
    var s = Math.sqrt(u.dot(sr, Ka));
    return Ka = u.divideByScalar(Ka, s, Ka), sr = u.multiplyByScalar(sr, n, sr), l(i) || (i = new u), u.add(Ka, sr, i)
};
u.fromDegreesArray = function(e, t, n) {
    var r = e.length;
    l(n) ? n.length = r / 2 : n = new Array(r / 2);
    for (var i = 0; i < r; i += 2) {
        var a = e[i],
            o = e[i + 1],
            s = i / 2;
        n[s] = u.fromDegrees(a, o, 0, t, n[s])
    }
    return n
};
u.fromRadiansArray = function(e, t, n) {
    var r = e.length;
    l(n) ? n.length = r / 2 : n = new Array(r / 2);
    for (var i = 0; i < r; i += 2) {
        var a = e[i],
            o = e[i + 1],
            s = i / 2;
        n[s] = u.fromRadians(a, o, 0, t, n[s])
    }
    return n
};
u.fromDegreesArrayHeights = function(e, t, n) {
    var r = e.length;
    l(n) ? n.length = r / 3 : n = new Array(r / 3);
    for (var i = 0; i < r; i += 3) {
        var a = e[i],
            o = e[i + 1],
            s = e[i + 2],
            c = i / 3;
        n[c] = u.fromDegrees(a, o, s, t, n[c])
    }
    return n
};
u.fromRadiansArrayHeights = function(e, t, n) {
    var r = e.length;
    l(n) ? n.length = r / 3 : n = new Array(r / 3);
    for (var i = 0; i < r; i += 3) {
        var a = e[i],
            o = e[i + 1],
            s = e[i + 2],
            c = i / 3;
        n[c] = u.fromRadians(a, o, s, t, n[c])
    }
    return n
};
u.ZERO = Object.freeze(new u(0, 0, 0));
u.UNIT_X = Object.freeze(new u(1, 0, 0));
u.UNIT_Y = Object.freeze(new u(0, 1, 0));
u.UNIT_Z = Object.freeze(new u(0, 0, 1));
u.prototype.clone = function(e) {
    return u.clone(this, e)
};
u.prototype.equals = function(e) {
    return u.equals(this, e)
};
u.prototype.equalsEpsilon = function(e, t, n) {
    return u.equalsEpsilon(this, e, t, n)
};
u.prototype.toString = function() {
    return "(" + this.x + ", " + this.y + ", " + this.z + ")"
};
var Qd = 1 / 256,
    e_ = 256,
    Ee = {};
Ee.octEncodeInRange = function(e, t, n) {
    if (n.x = e.x / (Math.abs(e.x) + Math.abs(e.y) + Math.abs(e.z)), n.y = e.y / (Math.abs(e.x) + Math.abs(e.y) + Math.abs(e.z)), e.z < 0) {
        var r = n.x,
            i = n.y;
        n.x = (1 - Math.abs(i)) * T.signNotZero(r), n.y = (1 - Math.abs(r)) * T.signNotZero(i)
    }
    return n.x = T.toSNorm(n.x, t), n.y = T.toSNorm(n.y, t), n
};
Ee.octEncode = function(e, t) {
    return Ee.octEncodeInRange(e, 255, t)
};
var qo = new R,
    t_ = new Uint8Array(1);

function Zs(e) {
    return t_[0] = e, t_[0]
}
Ee.octEncodeToCartesian4 = function(e, t) {
    return Ee.octEncodeInRange(e, 65535, qo), t.x = Zs(qo.x * Qd), t.y = Zs(qo.x), t.z = Zs(qo.y * Qd), t.w = Zs(qo.y), t
};
Ee.octDecodeInRange = function(e, t, n, r) {
    if (r.x = T.fromSNorm(e, n), r.y = T.fromSNorm(t, n), r.z = 1 - (Math.abs(r.x) + Math.abs(r.y)), r.z < 0) {
        var i = r.x;
        r.x = (1 - Math.abs(r.y)) * T.signNotZero(i), r.y = (1 - Math.abs(i)) * T.signNotZero(r.y)
    }
    return u.normalize(r, r)
};
Ee.octDecode = function(e, t, n) {
    return Ee.octDecodeInRange(e, t, 255, n)
};
Ee.octDecodeFromCartesian4 = function(e, t) {
    var n = e.x,
        r = e.y,
        i = e.z,
        a = e.w,
        o = n * e_ + r,
        s = i * e_ + a;
    return Ee.octDecodeInRange(o, s, 65535, t)
};
Ee.octPackFloat = function(e) {
    return 256 * e.x + e.y
};
var Jh = new R;
Ee.octEncodeFloat = function(e) {
    return Ee.octEncode(e, Jh), Ee.octPackFloat(Jh)
};
Ee.octDecodeFloat = function(e, t) {
    var n = e / 256,
        r = Math.floor(n),
        i = (n - r) * 256;
    return Ee.octDecode(r, i, t)
};
Ee.octPack = function(e, t, n, r) {
    var i = Ee.octEncodeFloat(e),
        a = Ee.octEncodeFloat(t),
        o = Ee.octEncode(n, Jh);
    return r.x = 65536 * o.x + i, r.y = 65536 * o.y + a, r
};
Ee.octUnpack = function(e, t, n, r) {
    var i = e.x / 65536,
        a = Math.floor(i),
        o = (i - a) * 65536;
    i = e.y / 65536;
    var s = Math.floor(i),
        c = (i - s) * 65536;
    Ee.octDecodeFloat(o, t), Ee.octDecodeFloat(c, n), Ee.octDecode(a, s, r)
};
Ee.compressTextureCoordinates = function(e) {
    var t = e.x * 4095 | 0,
        n = e.y * 4095 | 0;
    return 4096 * t + n
};
Ee.decompressTextureCoordinates = function(e, t) {
    var n = e / 4096,
        r = Math.floor(n);
    return t.x = r / 4095, t.y = (e - r * 4096) / 4095, t
};

function gf(e) {
    return e >> 1 ^ -(e & 1)
}
Ee.zigZagDeltaDecode = function(e, t, n) {
    for (var r = e.length, i = 0, a = 0, o = 0, s = 0; s < r; ++s) i += gf(e[s]), a += gf(t[s]), e[s] = i, t[s] = a, l(n) && (o += gf(n[s]), n[s] = o)
};
var tE = new u,
    nE = new u;

function vp(e, t, n, r, i) {
    var a = e.x,
        o = e.y,
        s = e.z,
        c = t.x,
        f = t.y,
        h = t.z,
        d = a * a * c * c,
        _ = o * o * f * f,
        v = s * s * h * h,
        m = d + _ + v,
        g = Math.sqrt(1 / m),
        y = u.multiplyByScalar(e, g, tE);
    if (m < r) return isFinite(g) ? u.clone(y, i) : void 0;
    var E = n.x,
        w = n.y,
        C = n.z,
        A = nE;
    A.x = y.x * E * 2, A.y = y.y * w * 2, A.z = y.z * C * 2;
    var x = (1 - g) * u.magnitude(e) / (.5 * u.magnitude(A)),
        P = 0,
        I, D, O, F, z, b, M, G, V, B, Y;
    do {
        x -= P, O = 1 / (1 + x * E), F = 1 / (1 + x * w), z = 1 / (1 + x * C), b = O * O, M = F * F, G = z * z, V = b * O, B = M * F, Y = G * z, I = d * b + _ * M + v * G - 1, D = d * V * E + _ * B * w + v * Y * C;
        var j = -2 * D;
        P = I / j
    } while (Math.abs(I) > T.EPSILON12);
    return l(i) ? (i.x = a * O, i.y = o * F, i.z = s * z, i) : new u(a * O, o * F, s * z)
}

function K(e, t, n) {
    this.longitude = p(e, 0), this.latitude = p(t, 0), this.height = p(n, 0)
}
K.fromRadians = function(e, t, n, r) {
    return n = p(n, 0), l(r) ? (r.longitude = e, r.latitude = t, r.height = n, r) : new K(e, t, n)
};
K.fromDegrees = function(e, t, n, r) {
    return e = T.toRadians(e), t = T.toRadians(t), K.fromRadians(e, t, n, r)
};
var rE = new u,
    iE = new u,
    aE = new u,
    oE = new u(1 / 6378137, 1 / 6378137, 1 / 6356752314245179e-9),
    sE = new u(1 / (6378137 * 6378137), 1 / (6378137 * 6378137), 1 / (6356752314245179e-9 * 6356752314245179e-9)),
    uE = T.EPSILON1;
K.fromCartesian = function(e, t, n) {
    var r = l(t) ? t.oneOverRadii : oE,
        i = l(t) ? t.oneOverRadiiSquared : sE,
        a = l(t) ? t._centerToleranceSquared : uE,
        o = vp(e, r, i, a, iE);
    if (!!l(o)) {
        var s = u.multiplyComponents(o, i, rE);
        s = u.normalize(s, s);
        var c = u.subtract(e, o, aE),
            f = Math.atan2(s.y, s.x),
            h = Math.asin(s.z),
            d = T.sign(u.dot(c, e)) * u.magnitude(c);
        return l(n) ? (n.longitude = f, n.latitude = h, n.height = d, n) : new K(f, h, d)
    }
};
K.toCartesian = function(e, t, n) {
    return u.fromRadians(e.longitude, e.latitude, e.height, t, n)
};
K.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.longitude = e.longitude, t.latitude = e.latitude, t.height = e.height, t) : new K(e.longitude, e.latitude, e.height)
};
K.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.longitude === t.longitude && e.latitude === t.latitude && e.height === t.height
};
K.equalsEpsilon = function(e, t, n) {
    return n = p(n, 0), e === t || l(e) && l(t) && Math.abs(e.longitude - t.longitude) <= n && Math.abs(e.latitude - t.latitude) <= n && Math.abs(e.height - t.height) <= n
};
K.ZERO = Object.freeze(new K(0, 0, 0));
K.prototype.clone = function(e) {
    return K.clone(this, e)
};
K.prototype.equals = function(e) {
    return K.equals(this, e)
};
K.prototype.equalsEpsilon = function(e, t) {
    return K.equalsEpsilon(this, e, t)
};
K.prototype.toString = function() {
    return "(" + this.longitude + ", " + this.latitude + ", " + this.height + ")"
};

function mp(e, t, n, r) {
    t = p(t, 0), n = p(n, 0), r = p(r, 0), e._radii = new u(t, n, r), e._radiiSquared = new u(t * t, n * n, r * r), e._radiiToTheFourth = new u(t * t * t * t, n * n * n * n, r * r * r * r), e._oneOverRadii = new u(t === 0 ? 0 : 1 / t, n === 0 ? 0 : 1 / n, r === 0 ? 0 : 1 / r), e._oneOverRadiiSquared = new u(t === 0 ? 0 : 1 / (t * t), n === 0 ? 0 : 1 / (n * n), r === 0 ? 0 : 1 / (r * r)), e._minimumRadius = Math.min(t, n, r), e._maximumRadius = Math.max(t, n, r), e._centerToleranceSquared = T.EPSILON1, e._radiiSquared.z !== 0 && (e._squaredXOverSquaredZ = e._radiiSquared.x / e._radiiSquared.z)
}

function ne(e, t, n) {
    this._radii = void 0, this._radiiSquared = void 0, this._radiiToTheFourth = void 0, this._oneOverRadii = void 0, this._oneOverRadiiSquared = void 0, this._minimumRadius = void 0, this._maximumRadius = void 0, this._centerToleranceSquared = void 0, this._squaredXOverSquaredZ = void 0, mp(this, e, t, n)
}
Object.defineProperties(ne.prototype, {
    radii: {
        get: function() {
            return this._radii
        }
    },
    radiiSquared: {
        get: function() {
            return this._radiiSquared
        }
    },
    radiiToTheFourth: {
        get: function() {
            return this._radiiToTheFourth
        }
    },
    oneOverRadii: {
        get: function() {
            return this._oneOverRadii
        }
    },
    oneOverRadiiSquared: {
        get: function() {
            return this._oneOverRadiiSquared
        }
    },
    minimumRadius: {
        get: function() {
            return this._minimumRadius
        }
    },
    maximumRadius: {
        get: function() {
            return this._maximumRadius
        }
    }
});
ne.clone = function(e, t) {
    if (!!l(e)) {
        var n = e._radii;
        return l(t) ? (u.clone(n, t._radii), u.clone(e._radiiSquared, t._radiiSquared), u.clone(e._radiiToTheFourth, t._radiiToTheFourth), u.clone(e._oneOverRadii, t._oneOverRadii), u.clone(e._oneOverRadiiSquared, t._oneOverRadiiSquared), t._minimumRadius = e._minimumRadius, t._maximumRadius = e._maximumRadius, t._centerToleranceSquared = e._centerToleranceSquared, t) : new ne(n.x, n.y, n.z)
    }
};
ne.fromCartesian3 = function(e, t) {
    return l(t) || (t = new ne), l(e) && mp(t, e.x, e.y, e.z), t
};
ne.WGS84 = Object.freeze(new ne(6378137, 6378137, 6356752314245179e-9));
ne.UNIT_SPHERE = Object.freeze(new ne(1, 1, 1));
ne.MOON = Object.freeze(new ne(T.LUNAR_RADIUS, T.LUNAR_RADIUS, T.LUNAR_RADIUS));
ne.prototype.clone = function(e) {
    return ne.clone(this, e)
};
ne.packedLength = u.packedLength;
ne.pack = function(e, t, n) {
    return n = p(n, 0), u.pack(e._radii, t, n), t
};
ne.unpack = function(e, t, n) {
    t = p(t, 0);
    var r = u.unpack(e, t);
    return ne.fromCartesian3(r, n)
};
ne.prototype.geocentricSurfaceNormal = u.normalize;
ne.prototype.geodeticSurfaceNormalCartographic = function(e, t) {
    var n = e.longitude,
        r = e.latitude,
        i = Math.cos(r),
        a = i * Math.cos(n),
        o = i * Math.sin(n),
        s = Math.sin(r);
    return l(t) || (t = new u), t.x = a, t.y = o, t.z = s, u.normalize(t, t)
};
ne.prototype.geodeticSurfaceNormal = function(e, t) {
    if (!u.equalsEpsilon(e, u.ZERO, T.EPSILON14)) return l(t) || (t = new u), t = u.multiplyComponents(e, this._oneOverRadiiSquared, t), u.normalize(t, t)
};
var cE = new u,
    fE = new u;
ne.prototype.cartographicToCartesian = function(e, t) {
    var n = cE,
        r = fE;
    this.geodeticSurfaceNormalCartographic(e, n), u.multiplyComponents(this._radiiSquared, n, r);
    var i = Math.sqrt(u.dot(n, r));
    return u.divideByScalar(r, i, r), u.multiplyByScalar(n, e.height, n), l(t) || (t = new u), u.add(r, n, t)
};
ne.prototype.cartographicArrayToCartesianArray = function(e, t) {
    var n = e.length;
    l(t) ? t.length = n : t = new Array(n);
    for (var r = 0; r < n; r++) t[r] = this.cartographicToCartesian(e[r], t[r]);
    return t
};
var hE = new u,
    lE = new u,
    dE = new u;
ne.prototype.cartesianToCartographic = function(e, t) {
    var n = this.scaleToGeodeticSurface(e, lE);
    if (!!l(n)) {
        var r = this.geodeticSurfaceNormal(n, hE),
            i = u.subtract(e, n, dE),
            a = Math.atan2(r.y, r.x),
            o = Math.asin(r.z),
            s = T.sign(u.dot(i, e)) * u.magnitude(i);
        return l(t) ? (t.longitude = a, t.latitude = o, t.height = s, t) : new K(a, o, s)
    }
};
ne.prototype.cartesianArrayToCartographicArray = function(e, t) {
    var n = e.length;
    l(t) ? t.length = n : t = new Array(n);
    for (var r = 0; r < n; ++r) t[r] = this.cartesianToCartographic(e[r], t[r]);
    return t
};
ne.prototype.scaleToGeodeticSurface = function(e, t) {
    return vp(e, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, t)
};
ne.prototype.scaleToGeocentricSurface = function(e, t) {
    l(t) || (t = new u);
    var n = e.x,
        r = e.y,
        i = e.z,
        a = this._oneOverRadiiSquared,
        o = 1 / Math.sqrt(n * n * a.x + r * r * a.y + i * i * a.z);
    return u.multiplyByScalar(e, o, t)
};
ne.prototype.transformPositionToScaledSpace = function(e, t) {
    return l(t) || (t = new u), u.multiplyComponents(e, this._oneOverRadii, t)
};
ne.prototype.transformPositionFromScaledSpace = function(e, t) {
    return l(t) || (t = new u), u.multiplyComponents(e, this._radii, t)
};
ne.prototype.equals = function(e) {
    return this === e || l(e) && u.equals(this._radii, e._radii)
};
ne.prototype.toString = function() {
    return this._radii.toString()
};
ne.prototype.getSurfaceNormalIntersectionWithZAxis = function(e, t, n) {
    t = p(t, 0);
    var r = this._squaredXOverSquaredZ;
    if (l(n) || (n = new u), n.x = 0, n.y = 0, n.z = e.z * (1 - r), !(Math.abs(n.z) >= this._radii.z - t)) return n
};
var _E = [.14887433898163, .43339539412925, .67940956829902, .86506336668898, .97390652851717, 0],
    vE = [.29552422471475, .26926671930999, .21908636251598, .14945134915058, .066671344308684, 0];

function n_(e, t, n) {
    for (var r = .5 * (t + e), i = .5 * (t - e), a = 0, o = 0; o < 5; o++) {
        var s = i * _E[o];
        a += vE[o] * (n(r + s) + n(r - s))
    }
    return a *= i, a
}
ne.prototype.surfaceArea = function(e) {
    for (var t = e.west, n = e.east, r = e.south, i = e.north; n < t;) n += T.TWO_PI;
    var a = this._radiiSquared,
        o = a.x,
        s = a.y,
        c = a.z,
        f = o * s;
    return n_(r, i, function(h) {
        var d = Math.cos(h),
            _ = Math.sin(h);
        return Math.cos(h) * n_(t, n, function(v) {
            var m = Math.cos(v),
                g = Math.sin(v);
            return Math.sqrt(f * _ * _ + c * (s * m * m + o * g * g) * d * d)
        })
    })
};

function un(e) {
    this._ellipsoid = p(e, ne.WGS84), this._semimajorAxis = this._ellipsoid.maximumRadius, this._oneOverSemimajorAxis = 1 / this._semimajorAxis
}
Object.defineProperties(un.prototype, {
    ellipsoid: {
        get: function() {
            return this._ellipsoid
        }
    }
});
un.prototype.project = function(e, t) {
    var n = this._semimajorAxis,
        r = e.longitude * n,
        i = e.latitude * n,
        a = e.height;
    return l(t) ? (t.x = r, t.y = i, t.z = a, t) : new u(r, i, a)
};
un.prototype.unproject = function(e, t) {
    var n = this._oneOverSemimajorAxis,
        r = e.x * n,
        i = e.y * n,
        a = e.z;
    return l(t) ? (t.longitude = r, t.latitude = i, t.height = a, t) : new K(r, i, a)
};
var mE = {
    OUTSIDE: -1,
    INTERSECTING: 0,
    INSIDE: 1
};
const nt = Object.freeze(mE);

function Yi(e, t) {
    this.start = p(e, 0), this.stop = p(t, 0)
}

function N(e, t, n, r, i, a, o, s, c) {
    this[0] = p(e, 0), this[1] = p(r, 0), this[2] = p(o, 0), this[3] = p(t, 0), this[4] = p(i, 0), this[5] = p(s, 0), this[6] = p(n, 0), this[7] = p(a, 0), this[8] = p(c, 0)
}
N.packedLength = 9;
N.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e[0], t[n++] = e[1], t[n++] = e[2], t[n++] = e[3], t[n++] = e[4], t[n++] = e[5], t[n++] = e[6], t[n++] = e[7], t[n++] = e[8], t
};
N.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new N), n[0] = e[t++], n[1] = e[t++], n[2] = e[t++], n[3] = e[t++], n[4] = e[t++], n[5] = e[t++], n[6] = e[t++], n[7] = e[t++], n[8] = e[t++], n
};
N.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t) : new N(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8])
};
N.fromArray = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new N), n[0] = e[t], n[1] = e[t + 1], n[2] = e[t + 2], n[3] = e[t + 3], n[4] = e[t + 4], n[5] = e[t + 5], n[6] = e[t + 6], n[7] = e[t + 7], n[8] = e[t + 8], n
};
N.fromColumnMajorArray = function(e, t) {
    return N.clone(e, t)
};
N.fromRowMajorArray = function(e, t) {
    return l(t) ? (t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], t) : new N(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8])
};
N.fromQuaternion = function(e, t) {
    var n = e.x * e.x,
        r = e.x * e.y,
        i = e.x * e.z,
        a = e.x * e.w,
        o = e.y * e.y,
        s = e.y * e.z,
        c = e.y * e.w,
        f = e.z * e.z,
        h = e.z * e.w,
        d = e.w * e.w,
        _ = n - o - f + d,
        v = 2 * (r - h),
        m = 2 * (i + c),
        g = 2 * (r + h),
        y = -n + o - f + d,
        E = 2 * (s - a),
        w = 2 * (i - c),
        C = 2 * (s + a),
        A = -n - o + f + d;
    return l(t) ? (t[0] = _, t[1] = g, t[2] = w, t[3] = v, t[4] = y, t[5] = C, t[6] = m, t[7] = E, t[8] = A, t) : new N(_, v, m, g, y, E, w, C, A)
};
N.fromHeadingPitchRoll = function(e, t) {
    var n = Math.cos(-e.pitch),
        r = Math.cos(-e.heading),
        i = Math.cos(e.roll),
        a = Math.sin(-e.pitch),
        o = Math.sin(-e.heading),
        s = Math.sin(e.roll),
        c = n * r,
        f = -i * o + s * a * r,
        h = s * o + i * a * r,
        d = n * o,
        _ = i * r + s * a * o,
        v = -s * r + i * a * o,
        m = -a,
        g = s * n,
        y = i * n;
    return l(t) ? (t[0] = c, t[1] = d, t[2] = m, t[3] = f, t[4] = _, t[5] = g, t[6] = h, t[7] = v, t[8] = y, t) : new N(c, f, h, d, _, v, m, g, y)
};
N.fromScale = function(e, t) {
    return l(t) ? (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e.y, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = e.z, t) : new N(e.x, 0, 0, 0, e.y, 0, 0, 0, e.z)
};
N.fromUniformScale = function(e, t) {
    return l(t) ? (t[0] = e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = e, t) : new N(e, 0, 0, 0, e, 0, 0, 0, e)
};
N.fromCrossProduct = function(e, t) {
    return l(t) ? (t[0] = 0, t[1] = e.z, t[2] = -e.y, t[3] = -e.z, t[4] = 0, t[5] = e.x, t[6] = e.y, t[7] = -e.x, t[8] = 0, t) : new N(0, -e.z, e.y, e.z, 0, -e.x, -e.y, e.x, 0)
};
N.fromRotationX = function(e, t) {
    var n = Math.cos(e),
        r = Math.sin(e);
    return l(t) ? (t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = n, t[5] = r, t[6] = 0, t[7] = -r, t[8] = n, t) : new N(1, 0, 0, 0, n, -r, 0, r, n)
};
N.fromRotationY = function(e, t) {
    var n = Math.cos(e),
        r = Math.sin(e);
    return l(t) ? (t[0] = n, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = r, t[7] = 0, t[8] = n, t) : new N(n, 0, r, 0, 1, 0, -r, 0, n)
};
N.fromRotationZ = function(e, t) {
    var n = Math.cos(e),
        r = Math.sin(e);
    return l(t) ? (t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t) : new N(n, -r, 0, r, n, 0, 0, 0, 1)
};
N.toArray = function(e, t) {
    return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t) : [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
};
N.getElementIndex = function(e, t) {
    return e * 3 + t
};
N.getColumn = function(e, t, n) {
    var r = t * 3,
        i = e[r],
        a = e[r + 1],
        o = e[r + 2];
    return n.x = i, n.y = a, n.z = o, n
};
N.setColumn = function(e, t, n, r) {
    r = N.clone(e, r);
    var i = t * 3;
    return r[i] = n.x, r[i + 1] = n.y, r[i + 2] = n.z, r
};
N.getRow = function(e, t, n) {
    var r = e[t],
        i = e[t + 3],
        a = e[t + 6];
    return n.x = r, n.y = i, n.z = a, n
};
N.setRow = function(e, t, n, r) {
    return r = N.clone(e, r), r[t] = n.x, r[t + 3] = n.y, r[t + 6] = n.z, r
};
var yf = new u;
N.getScale = function(e, t) {
    return t.x = u.magnitude(u.fromElements(e[0], e[1], e[2], yf)), t.y = u.magnitude(u.fromElements(e[3], e[4], e[5], yf)), t.z = u.magnitude(u.fromElements(e[6], e[7], e[8], yf)), t
};
var Sc = new u;
N.getMaximumScale = function(e) {
    return N.getScale(e, Sc), u.maximumComponent(Sc)
};
N.multiply = function(e, t, n) {
    var r = e[0] * t[0] + e[3] * t[1] + e[6] * t[2],
        i = e[1] * t[0] + e[4] * t[1] + e[7] * t[2],
        a = e[2] * t[0] + e[5] * t[1] + e[8] * t[2],
        o = e[0] * t[3] + e[3] * t[4] + e[6] * t[5],
        s = e[1] * t[3] + e[4] * t[4] + e[7] * t[5],
        c = e[2] * t[3] + e[5] * t[4] + e[8] * t[5],
        f = e[0] * t[6] + e[3] * t[7] + e[6] * t[8],
        h = e[1] * t[6] + e[4] * t[7] + e[7] * t[8],
        d = e[2] * t[6] + e[5] * t[7] + e[8] * t[8];
    return n[0] = r, n[1] = i, n[2] = a, n[3] = o, n[4] = s, n[5] = c, n[6] = f, n[7] = h, n[8] = d, n
};
N.add = function(e, t, n) {
    return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n[2] = e[2] + t[2], n[3] = e[3] + t[3], n[4] = e[4] + t[4], n[5] = e[5] + t[5], n[6] = e[6] + t[6], n[7] = e[7] + t[7], n[8] = e[8] + t[8], n
};
N.subtract = function(e, t, n) {
    return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[3] = e[3] - t[3], n[4] = e[4] - t[4], n[5] = e[5] - t[5], n[6] = e[6] - t[6], n[7] = e[7] - t[7], n[8] = e[8] - t[8], n
};
N.multiplyByVector = function(e, t, n) {
    var r = t.x,
        i = t.y,
        a = t.z,
        o = e[0] * r + e[3] * i + e[6] * a,
        s = e[1] * r + e[4] * i + e[7] * a,
        c = e[2] * r + e[5] * i + e[8] * a;
    return n.x = o, n.y = s, n.z = c, n
};
N.multiplyByScalar = function(e, t, n) {
    return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n[4] = e[4] * t, n[5] = e[5] * t, n[6] = e[6] * t, n[7] = e[7] * t, n[8] = e[8] * t, n
};
N.multiplyByScale = function(e, t, n) {
    return n[0] = e[0] * t.x, n[1] = e[1] * t.x, n[2] = e[2] * t.x, n[3] = e[3] * t.y, n[4] = e[4] * t.y, n[5] = e[5] * t.y, n[6] = e[6] * t.z, n[7] = e[7] * t.z, n[8] = e[8] * t.z, n
};
N.negate = function(e, t) {
    return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = -e[7], t[8] = -e[8], t
};
N.transpose = function(e, t) {
    var n = e[0],
        r = e[3],
        i = e[6],
        a = e[1],
        o = e[4],
        s = e[7],
        c = e[2],
        f = e[5],
        h = e[8];
    return t[0] = n, t[1] = r, t[2] = i, t[3] = a, t[4] = o, t[5] = s, t[6] = c, t[7] = f, t[8] = h, t
};
var pE = new u(1, 1, 1);
N.getRotation = function(e, t) {
    var n = u.divideComponents(pE, N.getScale(e, Sc), Sc);
    return t = N.multiplyByScale(e, n, t), t
};

function gE(e) {
    for (var t = 0, n = 0; n < 9; ++n) {
        var r = e[n];
        t += r * r
    }
    return Math.sqrt(t)
}
var Qh = [1, 0, 0],
    el = [2, 2, 1];

function yE(e) {
    for (var t = 0, n = 0; n < 3; ++n) {
        var r = e[N.getElementIndex(el[n], Qh[n])];
        t += 2 * r * r
    }
    return Math.sqrt(t)
}

function TE(e, t) {
    for (var n = T.EPSILON15, r = 0, i = 1, a = 0; a < 3; ++a) {
        var o = Math.abs(e[N.getElementIndex(el[a], Qh[a])]);
        o > r && (i = a, r = o)
    }
    var s = 1,
        c = 0,
        f = Qh[i],
        h = el[i];
    if (Math.abs(e[N.getElementIndex(h, f)]) > n) {
        var d = e[N.getElementIndex(h, h)],
            _ = e[N.getElementIndex(f, f)],
            v = e[N.getElementIndex(h, f)],
            m = (d - _) / 2 / v,
            g;
        m < 0 ? g = -1 / (-m + Math.sqrt(1 + m * m)) : g = 1 / (m + Math.sqrt(1 + m * m)), s = 1 / Math.sqrt(1 + g * g), c = g * s
    }
    return t = N.clone(N.IDENTITY, t), t[N.getElementIndex(f, f)] = t[N.getElementIndex(h, h)] = s, t[N.getElementIndex(h, f)] = c, t[N.getElementIndex(f, h)] = -c, t
}
var Ks = new N,
    r_ = new N;
N.computeEigenDecomposition = function(e, t) {
    var n = T.EPSILON20,
        r = 10,
        i = 0,
        a = 0;
    l(t) || (t = {});
    for (var o = t.unitary = N.clone(N.IDENTITY, t.unitary), s = t.diagonal = N.clone(e, t.diagonal), c = n * gE(s); a < r && yE(s) > c;) TE(s, Ks), N.transpose(Ks, r_), N.multiply(s, Ks, s), N.multiply(r_, s, s), N.multiply(o, Ks, o), ++i > 2 && (++a, i = 0);
    return t
};
N.abs = function(e, t) {
    return t[0] = Math.abs(e[0]), t[1] = Math.abs(e[1]), t[2] = Math.abs(e[2]), t[3] = Math.abs(e[3]), t[4] = Math.abs(e[4]), t[5] = Math.abs(e[5]), t[6] = Math.abs(e[6]), t[7] = Math.abs(e[7]), t[8] = Math.abs(e[8]), t
};
N.determinant = function(e) {
    var t = e[0],
        n = e[3],
        r = e[6],
        i = e[1],
        a = e[4],
        o = e[7],
        s = e[2],
        c = e[5],
        f = e[8];
    return t * (a * f - c * o) + i * (c * r - n * f) + s * (n * o - a * r)
};
N.inverse = function(e, t) {
    var n = e[0],
        r = e[1],
        i = e[2],
        a = e[3],
        o = e[4],
        s = e[5],
        c = e[6],
        f = e[7],
        h = e[8],
        d = N.determinant(e);
    t[0] = o * h - f * s, t[1] = f * i - r * h, t[2] = r * s - o * i, t[3] = c * s - a * h, t[4] = n * h - c * i, t[5] = a * i - n * s, t[6] = a * f - c * o, t[7] = c * r - n * f, t[8] = n * o - a * r;
    var _ = 1 / d;
    return N.multiplyByScalar(t, _, t)
};
var EE = new N;
N.inverseTranspose = function(e, t) {
    return N.inverse(N.transpose(e, EE), t)
};
N.equals = function(e, t) {
    return e === t || l(e) && l(t) && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8]
};
N.equalsEpsilon = function(e, t, n) {
    return n = p(n, 0), e === t || l(e) && l(t) && Math.abs(e[0] - t[0]) <= n && Math.abs(e[1] - t[1]) <= n && Math.abs(e[2] - t[2]) <= n && Math.abs(e[3] - t[3]) <= n && Math.abs(e[4] - t[4]) <= n && Math.abs(e[5] - t[5]) <= n && Math.abs(e[6] - t[6]) <= n && Math.abs(e[7] - t[7]) <= n && Math.abs(e[8] - t[8]) <= n
};
N.IDENTITY = Object.freeze(new N(1, 0, 0, 0, 1, 0, 0, 0, 1));
N.ZERO = Object.freeze(new N(0, 0, 0, 0, 0, 0, 0, 0, 0));
N.COLUMN0ROW0 = 0;
N.COLUMN0ROW1 = 1;
N.COLUMN0ROW2 = 2;
N.COLUMN1ROW0 = 3;
N.COLUMN1ROW1 = 4;
N.COLUMN1ROW2 = 5;
N.COLUMN2ROW0 = 6;
N.COLUMN2ROW1 = 7;
N.COLUMN2ROW2 = 8;
Object.defineProperties(N.prototype, {
    length: {
        get: function() {
            return N.packedLength
        }
    }
});
N.prototype.clone = function(e) {
    return N.clone(this, e)
};
N.prototype.equals = function(e) {
    return N.equals(this, e)
};
N.equalsArray = function(e, t, n) {
    return e[0] === t[n] && e[1] === t[n + 1] && e[2] === t[n + 2] && e[3] === t[n + 3] && e[4] === t[n + 4] && e[5] === t[n + 5] && e[6] === t[n + 6] && e[7] === t[n + 7] && e[8] === t[n + 8]
};
N.prototype.equalsEpsilon = function(e, t) {
    return N.equalsEpsilon(this, e, t)
};
N.prototype.toString = function() {
    return "(" + this[0] + ", " + this[3] + ", " + this[6] + `)
(` + this[1] + ", " + this[4] + ", " + this[7] + `)
(` + this[2] + ", " + this[5] + ", " + this[8] + ")"
};

function U(e, t, n, r) {
    this.x = p(e, 0), this.y = p(t, 0), this.z = p(n, 0), this.w = p(r, 0)
}
U.fromElements = function(e, t, n, r, i) {
    return l(i) ? (i.x = e, i.y = t, i.z = n, i.w = r, i) : new U(e, t, n, r)
};
U.fromColor = function(e, t) {
    return l(t) ? (t.x = e.red, t.y = e.green, t.z = e.blue, t.w = e.alpha, t) : new U(e.red, e.green, e.blue, e.alpha)
};
U.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t) : new U(e.x, e.y, e.z, e.w)
};
U.packedLength = 4;
U.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.x, t[n++] = e.y, t[n++] = e.z, t[n] = e.w, t
};
U.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new U), n.x = e[t++], n.y = e[t++], n.z = e[t++], n.w = e[t], n
};
U.packArray = function(e, t) {
    var n = e.length,
        r = n * 4;
    if (!l(t)) t = new Array(r);
    else {
        if (!Array.isArray(t) && t.length !== r) throw new we("If result is a typed array, it must have exactly array.length * 4 elements");
        t.length !== r && (t.length = r)
    }
    for (var i = 0; i < n; ++i) U.pack(e[i], t, i * 4);
    return t
};
U.unpackArray = function(e, t) {
    var n = e.length;
    l(t) ? t.length = n / 4 : t = new Array(n / 4);
    for (var r = 0; r < n; r += 4) {
        var i = r / 4;
        t[i] = U.unpack(e, r, t[i])
    }
    return t
};
U.fromArray = U.unpack;
U.maximumComponent = function(e) {
    return Math.max(e.x, e.y, e.z, e.w)
};
U.minimumComponent = function(e) {
    return Math.min(e.x, e.y, e.z, e.w)
};
U.minimumByComponent = function(e, t, n) {
    return n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n.z = Math.min(e.z, t.z), n.w = Math.min(e.w, t.w), n
};
U.maximumByComponent = function(e, t, n) {
    return n.x = Math.max(e.x, t.x), n.y = Math.max(e.y, t.y), n.z = Math.max(e.z, t.z), n.w = Math.max(e.w, t.w), n
};
U.magnitudeSquared = function(e) {
    return e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w
};
U.magnitude = function(e) {
    return Math.sqrt(U.magnitudeSquared(e))
};
var Rc = new U;
U.distance = function(e, t) {
    return U.subtract(e, t, Rc), U.magnitude(Rc)
};
U.distanceSquared = function(e, t) {
    return U.subtract(e, t, Rc), U.magnitudeSquared(Rc)
};
U.normalize = function(e, t) {
    var n = U.magnitude(e);
    return t.x = e.x / n, t.y = e.y / n, t.z = e.z / n, t.w = e.w / n, t
};
U.dot = function(e, t) {
    return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w
};
U.multiplyComponents = function(e, t, n) {
    return n.x = e.x * t.x, n.y = e.y * t.y, n.z = e.z * t.z, n.w = e.w * t.w, n
};
U.divideComponents = function(e, t, n) {
    return n.x = e.x / t.x, n.y = e.y / t.y, n.z = e.z / t.z, n.w = e.w / t.w, n
};
U.add = function(e, t, n) {
    return n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z, n.w = e.w + t.w, n
};
U.subtract = function(e, t, n) {
    return n.x = e.x - t.x, n.y = e.y - t.y, n.z = e.z - t.z, n.w = e.w - t.w, n
};
U.multiplyByScalar = function(e, t, n) {
    return n.x = e.x * t, n.y = e.y * t, n.z = e.z * t, n.w = e.w * t, n
};
U.divideByScalar = function(e, t, n) {
    return n.x = e.x / t, n.y = e.y / t, n.z = e.z / t, n.w = e.w / t, n
};
U.negate = function(e, t) {
    return t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = -e.w, t
};
U.abs = function(e, t) {
    return t.x = Math.abs(e.x), t.y = Math.abs(e.y), t.z = Math.abs(e.z), t.w = Math.abs(e.w), t
};
var i_ = new U;
U.lerp = function(e, t, n, r) {
    return U.multiplyByScalar(t, n, i_), r = U.multiplyByScalar(e, 1 - n, r), U.add(i_, r, r)
};
var AE = new U;
U.mostOrthogonalAxis = function(e, t) {
    var n = U.normalize(e, AE);
    return U.abs(n, n), n.x <= n.y ? n.x <= n.z ? n.x <= n.w ? t = U.clone(U.UNIT_X, t) : t = U.clone(U.UNIT_W, t) : n.z <= n.w ? t = U.clone(U.UNIT_Z, t) : t = U.clone(U.UNIT_W, t) : n.y <= n.z ? n.y <= n.w ? t = U.clone(U.UNIT_Y, t) : t = U.clone(U.UNIT_W, t) : n.z <= n.w ? t = U.clone(U.UNIT_Z, t) : t = U.clone(U.UNIT_W, t), t
};
U.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w
};
U.equalsArray = function(e, t, n) {
    return e.x === t[n] && e.y === t[n + 1] && e.z === t[n + 2] && e.w === t[n + 3]
};
U.equalsEpsilon = function(e, t, n, r) {
    return e === t || l(e) && l(t) && T.equalsEpsilon(e.x, t.x, n, r) && T.equalsEpsilon(e.y, t.y, n, r) && T.equalsEpsilon(e.z, t.z, n, r) && T.equalsEpsilon(e.w, t.w, n, r)
};
U.ZERO = Object.freeze(new U(0, 0, 0, 0));
U.UNIT_X = Object.freeze(new U(1, 0, 0, 0));
U.UNIT_Y = Object.freeze(new U(0, 1, 0, 0));
U.UNIT_Z = Object.freeze(new U(0, 0, 1, 0));
U.UNIT_W = Object.freeze(new U(0, 0, 0, 1));
U.prototype.clone = function(e) {
    return U.clone(this, e)
};
U.prototype.equals = function(e) {
    return U.equals(this, e)
};
U.prototype.equalsEpsilon = function(e, t, n) {
    return U.equalsEpsilon(this, e, t, n)
};
U.prototype.toString = function() {
    return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")"
};
var Wl = new Float32Array(1),
    vn = new Uint8Array(Wl.buffer),
    CE = new Uint32Array([287454020]),
    wE = new Uint8Array(CE.buffer),
    pp = wE[0] === 68;
U.packFloat = function(e, t) {
    return l(t) || (t = new U), Wl[0] = e, pp ? (t.x = vn[0], t.y = vn[1], t.z = vn[2], t.w = vn[3]) : (t.x = vn[3], t.y = vn[2], t.z = vn[1], t.w = vn[0]), t
};
U.unpackFloat = function(e) {
    return pp ? (vn[0] = e.x, vn[1] = e.y, vn[2] = e.z, vn[3] = e.w) : (vn[0] = e.w, vn[1] = e.z, vn[2] = e.y, vn[3] = e.x), Wl[0]
};

function je(e) {
    this.name = "RuntimeError", this.message = e;
    var t;
    try {
        throw new Error
    } catch (n) {
        t = n.stack
    }
    this.stack = t
}
l(Object.create) && (je.prototype = Object.create(Error.prototype), je.prototype.constructor = je);
je.prototype.toString = function() {
    var e = this.name + ": " + this.message;
    return l(this.stack) && (e += `
` + this.stack.toString()), e
};

function S(e, t, n, r, i, a, o, s, c, f, h, d, _, v, m, g) {
    this[0] = p(e, 0), this[1] = p(i, 0), this[2] = p(c, 0), this[3] = p(_, 0), this[4] = p(t, 0), this[5] = p(a, 0), this[6] = p(f, 0), this[7] = p(v, 0), this[8] = p(n, 0), this[9] = p(o, 0), this[10] = p(h, 0), this[11] = p(m, 0), this[12] = p(r, 0), this[13] = p(s, 0), this[14] = p(d, 0), this[15] = p(g, 0)
}
S.packedLength = 16;
S.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e[0], t[n++] = e[1], t[n++] = e[2], t[n++] = e[3], t[n++] = e[4], t[n++] = e[5], t[n++] = e[6], t[n++] = e[7], t[n++] = e[8], t[n++] = e[9], t[n++] = e[10], t[n++] = e[11], t[n++] = e[12], t[n++] = e[13], t[n++] = e[14], t[n] = e[15], t
};
S.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new S), n[0] = e[t++], n[1] = e[t++], n[2] = e[t++], n[3] = e[t++], n[4] = e[t++], n[5] = e[t++], n[6] = e[t++], n[7] = e[t++], n[8] = e[t++], n[9] = e[t++], n[10] = e[t++], n[11] = e[t++], n[12] = e[t++], n[13] = e[t++], n[14] = e[t++], n[15] = e[t], n
};
S.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t) : new S(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15])
};
S.fromArray = S.unpack;
S.fromColumnMajorArray = function(e, t) {
    return S.clone(e, t)
};
S.fromRowMajorArray = function(e, t) {
    return l(t) ? (t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15], t) : new S(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15])
};
S.fromRotationTranslation = function(e, t, n) {
    return t = p(t, u.ZERO), l(n) ? (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = 0, n[4] = e[3], n[5] = e[4], n[6] = e[5], n[7] = 0, n[8] = e[6], n[9] = e[7], n[10] = e[8], n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, n) : new S(e[0], e[3], e[6], t.x, e[1], e[4], e[7], t.y, e[2], e[5], e[8], t.z, 0, 0, 0, 1)
};
S.fromTranslationQuaternionRotationScale = function(e, t, n, r) {
    l(r) || (r = new S);
    var i = n.x,
        a = n.y,
        o = n.z,
        s = t.x * t.x,
        c = t.x * t.y,
        f = t.x * t.z,
        h = t.x * t.w,
        d = t.y * t.y,
        _ = t.y * t.z,
        v = t.y * t.w,
        m = t.z * t.z,
        g = t.z * t.w,
        y = t.w * t.w,
        E = s - d - m + y,
        w = 2 * (c - g),
        C = 2 * (f + v),
        A = 2 * (c + g),
        x = -s + d - m + y,
        P = 2 * (_ - h),
        I = 2 * (f - v),
        D = 2 * (_ + h),
        O = -s - d + m + y;
    return r[0] = E * i, r[1] = A * i, r[2] = I * i, r[3] = 0, r[4] = w * a, r[5] = x * a, r[6] = D * a, r[7] = 0, r[8] = C * o, r[9] = P * o, r[10] = O * o, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, r
};
S.fromTranslationRotationScale = function(e, t) {
    return S.fromTranslationQuaternionRotationScale(e.translation, e.rotation, e.scale, t)
};
S.fromTranslation = function(e, t) {
    return S.fromRotationTranslation(N.IDENTITY, e, t)
};
S.fromScale = function(e, t) {
    return l(t) ? (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e.y, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e.z, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t) : new S(e.x, 0, 0, 0, 0, e.y, 0, 0, 0, 0, e.z, 0, 0, 0, 0, 1)
};
S.fromUniformScale = function(e, t) {
    return l(t) ? (t[0] = e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t) : new S(e, 0, 0, 0, 0, e, 0, 0, 0, 0, e, 0, 0, 0, 0, 1)
};
var $a = new u,
    Ja = new u,
    Yo = new u;
S.fromCamera = function(e, t) {
    var n = e.position,
        r = e.direction,
        i = e.up;
    u.normalize(r, $a), u.normalize(u.cross($a, i, Ja), Ja), u.normalize(u.cross(Ja, $a, Yo), Yo);
    var a = Ja.x,
        o = Ja.y,
        s = Ja.z,
        c = $a.x,
        f = $a.y,
        h = $a.z,
        d = Yo.x,
        _ = Yo.y,
        v = Yo.z,
        m = n.x,
        g = n.y,
        y = n.z,
        E = a * -m + o * -g + s * -y,
        w = d * -m + _ * -g + v * -y,
        C = c * m + f * g + h * y;
    return l(t) ? (t[0] = a, t[1] = d, t[2] = -c, t[3] = 0, t[4] = o, t[5] = _, t[6] = -f, t[7] = 0, t[8] = s, t[9] = v, t[10] = -h, t[11] = 0, t[12] = E, t[13] = w, t[14] = C, t[15] = 1, t) : new S(a, o, s, E, d, _, v, w, -c, -f, -h, C, 0, 0, 0, 1)
};
S.computePerspectiveFieldOfView = function(e, t, n, r, i) {
    var a = Math.tan(e * .5),
        o = 1 / a,
        s = o / t,
        c = (r + n) / (n - r),
        f = 2 * r * n / (n - r);
    return i[0] = s, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = o, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = c, i[11] = -1, i[12] = 0, i[13] = 0, i[14] = f, i[15] = 0, i
};
S.computeOrthographicOffCenter = function(e, t, n, r, i, a, o) {
    var s = 1 / (t - e),
        c = 1 / (r - n),
        f = 1 / (a - i),
        h = -(t + e) * s,
        d = -(r + n) * c,
        _ = -(a + i) * f;
    return s *= 2, c *= 2, f *= -2, o[0] = s, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = c, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = f, o[11] = 0, o[12] = h, o[13] = d, o[14] = _, o[15] = 1, o
};
S.computePerspectiveOffCenter = function(e, t, n, r, i, a, o) {
    var s = 2 * i / (t - e),
        c = 2 * i / (r - n),
        f = (t + e) / (t - e),
        h = (r + n) / (r - n),
        d = -(a + i) / (a - i),
        _ = -1,
        v = -2 * a * i / (a - i);
    return o[0] = s, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = c, o[6] = 0, o[7] = 0, o[8] = f, o[9] = h, o[10] = d, o[11] = _, o[12] = 0, o[13] = 0, o[14] = v, o[15] = 0, o
};
S.computeInfinitePerspectiveOffCenter = function(e, t, n, r, i, a) {
    var o = 2 * i / (t - e),
        s = 2 * i / (r - n),
        c = (t + e) / (t - e),
        f = (r + n) / (r - n),
        h = -1,
        d = -1,
        _ = -2 * i;
    return a[0] = o, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = s, a[6] = 0, a[7] = 0, a[8] = c, a[9] = f, a[10] = h, a[11] = d, a[12] = 0, a[13] = 0, a[14] = _, a[15] = 0, a
};
S.computeViewportTransformation = function(e, t, n, r) {
    l(r) || (r = new S), e = p(e, p.EMPTY_OBJECT);
    var i = p(e.x, 0),
        a = p(e.y, 0),
        o = p(e.width, 0),
        s = p(e.height, 0);
    t = p(t, 0), n = p(n, 1);
    var c = o * .5,
        f = s * .5,
        h = (n - t) * .5,
        d = c,
        _ = f,
        v = h,
        m = i + c,
        g = a + f,
        y = t + h,
        E = 1;
    return r[0] = d, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = _, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = v, r[11] = 0, r[12] = m, r[13] = g, r[14] = y, r[15] = E, r
};
S.computeView = function(e, t, n, r, i) {
    return i[0] = r.x, i[1] = n.x, i[2] = -t.x, i[3] = 0, i[4] = r.y, i[5] = n.y, i[6] = -t.y, i[7] = 0, i[8] = r.z, i[9] = n.z, i[10] = -t.z, i[11] = 0, i[12] = -u.dot(r, e), i[13] = -u.dot(n, e), i[14] = u.dot(t, e), i[15] = 1, i
};
S.toArray = function(e, t) {
    return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t) : [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
};
S.getElementIndex = function(e, t) {
    return e * 4 + t
};
S.getColumn = function(e, t, n) {
    var r = t * 4,
        i = e[r],
        a = e[r + 1],
        o = e[r + 2],
        s = e[r + 3];
    return n.x = i, n.y = a, n.z = o, n.w = s, n
};
S.setColumn = function(e, t, n, r) {
    r = S.clone(e, r);
    var i = t * 4;
    return r[i] = n.x, r[i + 1] = n.y, r[i + 2] = n.z, r[i + 3] = n.w, r
};
S.setTranslation = function(e, t, n) {
    return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = e[15], n
};
var a_ = new u;
S.setScale = function(e, t, n) {
    var r = S.getScale(e, a_),
        i = u.divideComponents(t, r, a_);
    return S.multiplyByScale(e, i, n)
};
S.getRow = function(e, t, n) {
    var r = e[t],
        i = e[t + 4],
        a = e[t + 8],
        o = e[t + 12];
    return n.x = r, n.y = i, n.z = a, n.w = o, n
};
S.setRow = function(e, t, n, r) {
    return r = S.clone(e, r), r[t] = n.x, r[t + 4] = n.y, r[t + 8] = n.z, r[t + 12] = n.w, r
};
var Tf = new u;
S.getScale = function(e, t) {
    return t.x = u.magnitude(u.fromElements(e[0], e[1], e[2], Tf)), t.y = u.magnitude(u.fromElements(e[4], e[5], e[6], Tf)), t.z = u.magnitude(u.fromElements(e[8], e[9], e[10], Tf)), t
};
var o_ = new u;
S.getMaximumScale = function(e) {
    return S.getScale(e, o_), u.maximumComponent(o_)
};
S.multiply = function(e, t, n) {
    var r = e[0],
        i = e[1],
        a = e[2],
        o = e[3],
        s = e[4],
        c = e[5],
        f = e[6],
        h = e[7],
        d = e[8],
        _ = e[9],
        v = e[10],
        m = e[11],
        g = e[12],
        y = e[13],
        E = e[14],
        w = e[15],
        C = t[0],
        A = t[1],
        x = t[2],
        P = t[3],
        I = t[4],
        D = t[5],
        O = t[6],
        F = t[7],
        z = t[8],
        b = t[9],
        M = t[10],
        G = t[11],
        V = t[12],
        B = t[13],
        Y = t[14],
        j = t[15],
        Z = r * C + s * A + d * x + g * P,
        Q = i * C + c * A + _ * x + y * P,
        ie = a * C + f * A + v * x + E * P,
        Ae = o * C + h * A + m * x + w * P,
        re = r * I + s * D + d * O + g * F,
        ve = i * I + c * D + _ * O + y * F,
        qe = a * I + f * D + v * O + E * F,
        De = o * I + h * D + m * O + w * F,
        _e = r * z + s * b + d * M + g * G,
        Oe = i * z + c * b + _ * M + y * G,
        Fe = a * z + f * b + v * M + E * G,
        ce = o * z + h * b + m * M + w * G,
        He = r * V + s * B + d * Y + g * j,
        le = i * V + c * B + _ * Y + y * j,
        ft = a * V + f * B + v * Y + E * j,
        Pt = o * V + h * B + m * Y + w * j;
    return n[0] = Z, n[1] = Q, n[2] = ie, n[3] = Ae, n[4] = re, n[5] = ve, n[6] = qe, n[7] = De, n[8] = _e, n[9] = Oe, n[10] = Fe, n[11] = ce, n[12] = He, n[13] = le, n[14] = ft, n[15] = Pt, n
};
S.add = function(e, t, n) {
    return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n[2] = e[2] + t[2], n[3] = e[3] + t[3], n[4] = e[4] + t[4], n[5] = e[5] + t[5], n[6] = e[6] + t[6], n[7] = e[7] + t[7], n[8] = e[8] + t[8], n[9] = e[9] + t[9], n[10] = e[10] + t[10], n[11] = e[11] + t[11], n[12] = e[12] + t[12], n[13] = e[13] + t[13], n[14] = e[14] + t[14], n[15] = e[15] + t[15], n
};
S.subtract = function(e, t, n) {
    return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[3] = e[3] - t[3], n[4] = e[4] - t[4], n[5] = e[5] - t[5], n[6] = e[6] - t[6], n[7] = e[7] - t[7], n[8] = e[8] - t[8], n[9] = e[9] - t[9], n[10] = e[10] - t[10], n[11] = e[11] - t[11], n[12] = e[12] - t[12], n[13] = e[13] - t[13], n[14] = e[14] - t[14], n[15] = e[15] - t[15], n
};
S.multiplyTransformation = function(e, t, n) {
    var r = e[0],
        i = e[1],
        a = e[2],
        o = e[4],
        s = e[5],
        c = e[6],
        f = e[8],
        h = e[9],
        d = e[10],
        _ = e[12],
        v = e[13],
        m = e[14],
        g = t[0],
        y = t[1],
        E = t[2],
        w = t[4],
        C = t[5],
        A = t[6],
        x = t[8],
        P = t[9],
        I = t[10],
        D = t[12],
        O = t[13],
        F = t[14],
        z = r * g + o * y + f * E,
        b = i * g + s * y + h * E,
        M = a * g + c * y + d * E,
        G = r * w + o * C + f * A,
        V = i * w + s * C + h * A,
        B = a * w + c * C + d * A,
        Y = r * x + o * P + f * I,
        j = i * x + s * P + h * I,
        Z = a * x + c * P + d * I,
        Q = r * D + o * O + f * F + _,
        ie = i * D + s * O + h * F + v,
        Ae = a * D + c * O + d * F + m;
    return n[0] = z, n[1] = b, n[2] = M, n[3] = 0, n[4] = G, n[5] = V, n[6] = B, n[7] = 0, n[8] = Y, n[9] = j, n[10] = Z, n[11] = 0, n[12] = Q, n[13] = ie, n[14] = Ae, n[15] = 1, n
};
S.multiplyByMatrix3 = function(e, t, n) {
    var r = e[0],
        i = e[1],
        a = e[2],
        o = e[4],
        s = e[5],
        c = e[6],
        f = e[8],
        h = e[9],
        d = e[10],
        _ = t[0],
        v = t[1],
        m = t[2],
        g = t[3],
        y = t[4],
        E = t[5],
        w = t[6],
        C = t[7],
        A = t[8],
        x = r * _ + o * v + f * m,
        P = i * _ + s * v + h * m,
        I = a * _ + c * v + d * m,
        D = r * g + o * y + f * E,
        O = i * g + s * y + h * E,
        F = a * g + c * y + d * E,
        z = r * w + o * C + f * A,
        b = i * w + s * C + h * A,
        M = a * w + c * C + d * A;
    return n[0] = x, n[1] = P, n[2] = I, n[3] = 0, n[4] = D, n[5] = O, n[6] = F, n[7] = 0, n[8] = z, n[9] = b, n[10] = M, n[11] = 0, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n
};
S.multiplyByTranslation = function(e, t, n) {
    var r = t.x,
        i = t.y,
        a = t.z,
        o = r * e[0] + i * e[4] + a * e[8] + e[12],
        s = r * e[1] + i * e[5] + a * e[9] + e[13],
        c = r * e[2] + i * e[6] + a * e[10] + e[14];
    return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = o, n[13] = s, n[14] = c, n[15] = e[15], n
};
var $s = new u;
S.multiplyByUniformScale = function(e, t, n) {
    return $s.x = t, $s.y = t, $s.z = t, S.multiplyByScale(e, $s, n)
};
S.multiplyByScale = function(e, t, n) {
    var r = t.x,
        i = t.y,
        a = t.z;
    return r === 1 && i === 1 && a === 1 ? S.clone(e, n) : (n[0] = r * e[0], n[1] = r * e[1], n[2] = r * e[2], n[3] = 0, n[4] = i * e[4], n[5] = i * e[5], n[6] = i * e[6], n[7] = 0, n[8] = a * e[8], n[9] = a * e[9], n[10] = a * e[10], n[11] = 0, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = 1, n)
};
S.multiplyByVector = function(e, t, n) {
    var r = t.x,
        i = t.y,
        a = t.z,
        o = t.w,
        s = e[0] * r + e[4] * i + e[8] * a + e[12] * o,
        c = e[1] * r + e[5] * i + e[9] * a + e[13] * o,
        f = e[2] * r + e[6] * i + e[10] * a + e[14] * o,
        h = e[3] * r + e[7] * i + e[11] * a + e[15] * o;
    return n.x = s, n.y = c, n.z = f, n.w = h, n
};
S.multiplyByPointAsVector = function(e, t, n) {
    var r = t.x,
        i = t.y,
        a = t.z,
        o = e[0] * r + e[4] * i + e[8] * a,
        s = e[1] * r + e[5] * i + e[9] * a,
        c = e[2] * r + e[6] * i + e[10] * a;
    return n.x = o, n.y = s, n.z = c, n
};
S.multiplyByPoint = function(e, t, n) {
    var r = t.x,
        i = t.y,
        a = t.z,
        o = e[0] * r + e[4] * i + e[8] * a + e[12],
        s = e[1] * r + e[5] * i + e[9] * a + e[13],
        c = e[2] * r + e[6] * i + e[10] * a + e[14];
    return n.x = o, n.y = s, n.z = c, n
};
S.multiplyByScalar = function(e, t, n) {
    return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n[4] = e[4] * t, n[5] = e[5] * t, n[6] = e[6] * t, n[7] = e[7] * t, n[8] = e[8] * t, n[9] = e[9] * t, n[10] = e[10] * t, n[11] = e[11] * t, n[12] = e[12] * t, n[13] = e[13] * t, n[14] = e[14] * t, n[15] = e[15] * t, n
};
S.negate = function(e, t) {
    return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = -e[7], t[8] = -e[8], t[9] = -e[9], t[10] = -e[10], t[11] = -e[11], t[12] = -e[12], t[13] = -e[13], t[14] = -e[14], t[15] = -e[15], t
};
S.transpose = function(e, t) {
    var n = e[1],
        r = e[2],
        i = e[3],
        a = e[6],
        o = e[7],
        s = e[11];
    return t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = r, t[9] = a, t[10] = e[10], t[11] = e[14], t[12] = i, t[13] = o, t[14] = s, t[15] = e[15], t
};
S.abs = function(e, t) {
    return t[0] = Math.abs(e[0]), t[1] = Math.abs(e[1]), t[2] = Math.abs(e[2]), t[3] = Math.abs(e[3]), t[4] = Math.abs(e[4]), t[5] = Math.abs(e[5]), t[6] = Math.abs(e[6]), t[7] = Math.abs(e[7]), t[8] = Math.abs(e[8]), t[9] = Math.abs(e[9]), t[10] = Math.abs(e[10]), t[11] = Math.abs(e[11]), t[12] = Math.abs(e[12]), t[13] = Math.abs(e[13]), t[14] = Math.abs(e[14]), t[15] = Math.abs(e[15]), t
};
S.equals = function(e, t) {
    return e === t || l(e) && l(t) && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[3] === t[3] && e[7] === t[7] && e[11] === t[11] && e[15] === t[15]
};
S.equalsEpsilon = function(e, t, n) {
    return n = p(n, 0), e === t || l(e) && l(t) && Math.abs(e[0] - t[0]) <= n && Math.abs(e[1] - t[1]) <= n && Math.abs(e[2] - t[2]) <= n && Math.abs(e[3] - t[3]) <= n && Math.abs(e[4] - t[4]) <= n && Math.abs(e[5] - t[5]) <= n && Math.abs(e[6] - t[6]) <= n && Math.abs(e[7] - t[7]) <= n && Math.abs(e[8] - t[8]) <= n && Math.abs(e[9] - t[9]) <= n && Math.abs(e[10] - t[10]) <= n && Math.abs(e[11] - t[11]) <= n && Math.abs(e[12] - t[12]) <= n && Math.abs(e[13] - t[13]) <= n && Math.abs(e[14] - t[14]) <= n && Math.abs(e[15] - t[15]) <= n
};
S.getTranslation = function(e, t) {
    return t.x = e[12], t.y = e[13], t.z = e[14], t
};
S.getMatrix3 = function(e, t) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t
};
var xE = new N,
    SE = new N,
    RE = new U,
    DE = new U(0, 0, 0, 1);
S.inverse = function(e, t) {
    var n = e[0],
        r = e[4],
        i = e[8],
        a = e[12],
        o = e[1],
        s = e[5],
        c = e[9],
        f = e[13],
        h = e[2],
        d = e[6],
        _ = e[10],
        v = e[14],
        m = e[3],
        g = e[7],
        y = e[11],
        E = e[15],
        w = _ * E,
        C = v * y,
        A = d * E,
        x = v * g,
        P = d * y,
        I = _ * g,
        D = h * E,
        O = v * m,
        F = h * y,
        z = _ * m,
        b = h * g,
        M = d * m,
        G = w * s + x * c + P * f - (C * s + A * c + I * f),
        V = C * o + D * c + z * f - (w * o + O * c + F * f),
        B = A * o + O * s + b * f - (x * o + D * s + M * f),
        Y = I * o + F * s + M * c - (P * o + z * s + b * c),
        j = C * r + A * i + I * a - (w * r + x * i + P * a),
        Z = w * n + O * i + F * a - (C * n + D * i + z * a),
        Q = x * n + D * r + M * a - (A * n + O * r + b * a),
        ie = P * n + z * r + b * i - (I * n + F * r + M * i);
    w = i * f, C = a * c, A = r * f, x = a * s, P = r * c, I = i * s, D = n * f, O = a * o, F = n * c, z = i * o, b = n * s, M = r * o;
    var Ae = w * g + x * y + P * E - (C * g + A * y + I * E),
        re = C * m + D * y + z * E - (w * m + O * y + F * E),
        ve = A * m + O * g + b * E - (x * m + D * g + M * E),
        qe = I * m + F * g + M * y - (P * m + z * g + b * y),
        De = A * _ + I * v + C * d - (P * v + w * d + x * _),
        _e = F * v + w * h + O * _ - (D * _ + z * v + C * h),
        Oe = D * d + M * v + x * h - (b * v + A * h + O * d),
        Fe = b * _ + P * h + z * d - (F * d + M * _ + I * h),
        ce = n * G + r * V + i * B + a * Y;
    if (Math.abs(ce) < T.EPSILON21) {
        if (N.equalsEpsilon(S.getMatrix3(e, xE), SE, T.EPSILON7) && U.equals(S.getRow(e, 3, RE), DE)) return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 0, t[11] = 0, t[12] = -e[12], t[13] = -e[13], t[14] = -e[14], t[15] = 1, t;
        throw new je("matrix is not invertible because its determinate is zero.")
    }
    return ce = 1 / ce, t[0] = G * ce, t[1] = V * ce, t[2] = B * ce, t[3] = Y * ce, t[4] = j * ce, t[5] = Z * ce, t[6] = Q * ce, t[7] = ie * ce, t[8] = Ae * ce, t[9] = re * ce, t[10] = ve * ce, t[11] = qe * ce, t[12] = De * ce, t[13] = _e * ce, t[14] = Oe * ce, t[15] = Fe * ce, t
};
S.inverseTransformation = function(e, t) {
    var n = e[0],
        r = e[1],
        i = e[2],
        a = e[4],
        o = e[5],
        s = e[6],
        c = e[8],
        f = e[9],
        h = e[10],
        d = e[12],
        _ = e[13],
        v = e[14],
        m = -n * d - r * _ - i * v,
        g = -a * d - o * _ - s * v,
        y = -c * d - f * _ - h * v;
    return t[0] = n, t[1] = a, t[2] = c, t[3] = 0, t[4] = r, t[5] = o, t[6] = f, t[7] = 0, t[8] = i, t[9] = s, t[10] = h, t[11] = 0, t[12] = m, t[13] = g, t[14] = y, t[15] = 1, t
};
var IE = new S;
S.inverseTranspose = function(e, t) {
    return S.inverse(S.transpose(e, IE), t)
};
S.IDENTITY = Object.freeze(new S(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
S.ZERO = Object.freeze(new S(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));
S.COLUMN0ROW0 = 0;
S.COLUMN0ROW1 = 1;
S.COLUMN0ROW2 = 2;
S.COLUMN0ROW3 = 3;
S.COLUMN1ROW0 = 4;
S.COLUMN1ROW1 = 5;
S.COLUMN1ROW2 = 6;
S.COLUMN1ROW3 = 7;
S.COLUMN2ROW0 = 8;
S.COLUMN2ROW1 = 9;
S.COLUMN2ROW2 = 10;
S.COLUMN2ROW3 = 11;
S.COLUMN3ROW0 = 12;
S.COLUMN3ROW1 = 13;
S.COLUMN3ROW2 = 14;
S.COLUMN3ROW3 = 15;
Object.defineProperties(S.prototype, {
    length: {
        get: function() {
            return S.packedLength
        }
    }
});
S.prototype.clone = function(e) {
    return S.clone(this, e)
};
S.prototype.equals = function(e) {
    return S.equals(this, e)
};
S.equalsArray = function(e, t, n) {
    return e[0] === t[n] && e[1] === t[n + 1] && e[2] === t[n + 2] && e[3] === t[n + 3] && e[4] === t[n + 4] && e[5] === t[n + 5] && e[6] === t[n + 6] && e[7] === t[n + 7] && e[8] === t[n + 8] && e[9] === t[n + 9] && e[10] === t[n + 10] && e[11] === t[n + 11] && e[12] === t[n + 12] && e[13] === t[n + 13] && e[14] === t[n + 14] && e[15] === t[n + 15]
};
S.prototype.equalsEpsilon = function(e, t) {
    return S.equalsEpsilon(this, e, t)
};
S.prototype.toString = function() {
    return "(" + this[0] + ", " + this[4] + ", " + this[8] + ", " + this[12] + `)
(` + this[1] + ", " + this[5] + ", " + this[9] + ", " + this[13] + `)
(` + this[2] + ", " + this[6] + ", " + this[10] + ", " + this[14] + `)
(` + this[3] + ", " + this[7] + ", " + this[11] + ", " + this[15] + ")"
};

function W(e, t, n, r) {
    this.west = p(e, 0), this.south = p(t, 0), this.east = p(n, 0), this.north = p(r, 0)
}
Object.defineProperties(W.prototype, {
    width: {
        get: function() {
            return W.computeWidth(this)
        }
    },
    height: {
        get: function() {
            return W.computeHeight(this)
        }
    }
});
W.packedLength = 4;
W.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.west, t[n++] = e.south, t[n++] = e.east, t[n] = e.north, t
};
W.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new W), n.west = e[t++], n.south = e[t++], n.east = e[t++], n.north = e[t], n
};
W.computeWidth = function(e) {
    var t = e.east,
        n = e.west;
    return t < n && (t += T.TWO_PI), t - n
};
W.computeHeight = function(e) {
    return e.north - e.south
};
W.fromDegrees = function(e, t, n, r, i) {
    return e = T.toRadians(p(e, 0)), t = T.toRadians(p(t, 0)), n = T.toRadians(p(n, 0)), r = T.toRadians(p(r, 0)), l(i) ? (i.west = e, i.south = t, i.east = n, i.north = r, i) : new W(e, t, n, r)
};
W.fromRadians = function(e, t, n, r, i) {
    return l(i) ? (i.west = p(e, 0), i.south = p(t, 0), i.east = p(n, 0), i.north = p(r, 0), i) : new W(e, t, n, r)
};
W.fromCartographicArray = function(e, t) {
    for (var n = Number.MAX_VALUE, r = -Number.MAX_VALUE, i = Number.MAX_VALUE, a = -Number.MAX_VALUE, o = Number.MAX_VALUE, s = -Number.MAX_VALUE, c = 0, f = e.length; c < f; c++) {
        var h = e[c];
        n = Math.min(n, h.longitude), r = Math.max(r, h.longitude), o = Math.min(o, h.latitude), s = Math.max(s, h.latitude);
        var d = h.longitude >= 0 ? h.longitude : h.longitude + T.TWO_PI;
        i = Math.min(i, d), a = Math.max(a, d)
    }
    return r - n > a - i && (n = i, r = a, r > T.PI && (r = r - T.TWO_PI), n > T.PI && (n = n - T.TWO_PI)), l(t) ? (t.west = n, t.south = o, t.east = r, t.north = s, t) : new W(n, o, r, s)
};
W.fromCartesianArray = function(e, t, n) {
    t = p(t, ne.WGS84);
    for (var r = Number.MAX_VALUE, i = -Number.MAX_VALUE, a = Number.MAX_VALUE, o = -Number.MAX_VALUE, s = Number.MAX_VALUE, c = -Number.MAX_VALUE, f = 0, h = e.length; f < h; f++) {
        var d = t.cartesianToCartographic(e[f]);
        r = Math.min(r, d.longitude), i = Math.max(i, d.longitude), s = Math.min(s, d.latitude), c = Math.max(c, d.latitude);
        var _ = d.longitude >= 0 ? d.longitude : d.longitude + T.TWO_PI;
        a = Math.min(a, _), o = Math.max(o, _)
    }
    return i - r > o - a && (r = a, i = o, i > T.PI && (i = i - T.TWO_PI), r > T.PI && (r = r - T.TWO_PI)), l(n) ? (n.west = r, n.south = s, n.east = i, n.north = c, n) : new W(r, s, i, c)
};
W.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.west = e.west, t.south = e.south, t.east = e.east, t.north = e.north, t) : new W(e.west, e.south, e.east, e.north)
};
W.equalsEpsilon = function(e, t, n) {
    return n = p(n, 0), e === t || l(e) && l(t) && Math.abs(e.west - t.west) <= n && Math.abs(e.south - t.south) <= n && Math.abs(e.east - t.east) <= n && Math.abs(e.north - t.north) <= n
};
W.prototype.clone = function(e) {
    return W.clone(this, e)
};
W.prototype.equals = function(e) {
    return W.equals(this, e)
};
W.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.west === t.west && e.south === t.south && e.east === t.east && e.north === t.north
};
W.prototype.equalsEpsilon = function(e, t) {
    return W.equalsEpsilon(this, e, t)
};
W.validate = function(e) {};
W.southwest = function(e, t) {
    return l(t) ? (t.longitude = e.west, t.latitude = e.south, t.height = 0, t) : new K(e.west, e.south)
};
W.northwest = function(e, t) {
    return l(t) ? (t.longitude = e.west, t.latitude = e.north, t.height = 0, t) : new K(e.west, e.north)
};
W.northeast = function(e, t) {
    return l(t) ? (t.longitude = e.east, t.latitude = e.north, t.height = 0, t) : new K(e.east, e.north)
};
W.southeast = function(e, t) {
    return l(t) ? (t.longitude = e.east, t.latitude = e.south, t.height = 0, t) : new K(e.east, e.south)
};
W.center = function(e, t) {
    var n = e.east,
        r = e.west;
    n < r && (n += T.TWO_PI);
    var i = T.negativePiToPi((r + n) * .5),
        a = (e.south + e.north) * .5;
    return l(t) ? (t.longitude = i, t.latitude = a, t.height = 0, t) : new K(i, a)
};
W.intersection = function(e, t, n) {
    var r = e.east,
        i = e.west,
        a = t.east,
        o = t.west;
    r < i && a > 0 ? r += T.TWO_PI : a < o && r > 0 && (a += T.TWO_PI), r < i && o < 0 ? o += T.TWO_PI : a < o && i < 0 && (i += T.TWO_PI);
    var s = T.negativePiToPi(Math.max(i, o)),
        c = T.negativePiToPi(Math.min(r, a));
    if (!((e.west < e.east || t.west < t.east) && c <= s)) {
        var f = Math.max(e.south, t.south),
            h = Math.min(e.north, t.north);
        if (!(f >= h)) return l(n) ? (n.west = s, n.south = f, n.east = c, n.north = h, n) : new W(s, f, c, h)
    }
};
W.simpleIntersection = function(e, t, n) {
    var r = Math.max(e.west, t.west),
        i = Math.max(e.south, t.south),
        a = Math.min(e.east, t.east),
        o = Math.min(e.north, t.north);
    if (!(i >= o || r >= a)) return l(n) ? (n.west = r, n.south = i, n.east = a, n.north = o, n) : new W(r, i, a, o)
};
W.union = function(e, t, n) {
    l(n) || (n = new W);
    var r = e.east,
        i = e.west,
        a = t.east,
        o = t.west;
    r < i && a > 0 ? r += T.TWO_PI : a < o && r > 0 && (a += T.TWO_PI), r < i && o < 0 ? o += T.TWO_PI : a < o && i < 0 && (i += T.TWO_PI);
    var s = T.convertLongitudeRange(Math.min(i, o)),
        c = T.convertLongitudeRange(Math.max(r, a));
    return n.west = s, n.south = Math.min(e.south, t.south), n.east = c, n.north = Math.max(e.north, t.north), n
};
W.expand = function(e, t, n) {
    return l(n) || (n = new W), n.west = Math.min(e.west, t.longitude), n.south = Math.min(e.south, t.latitude), n.east = Math.max(e.east, t.longitude), n.north = Math.max(e.north, t.latitude), n
};
W.contains = function(e, t) {
    var n = t.longitude,
        r = t.latitude,
        i = e.west,
        a = e.east;
    return a < i && (a += T.TWO_PI, n < 0 && (n += T.TWO_PI)), (n > i || T.equalsEpsilon(n, i, T.EPSILON14)) && (n < a || T.equalsEpsilon(n, a, T.EPSILON14)) && r >= e.south && r <= e.north
};
var PE = new K;
W.subsample = function(e, t, n, r) {
    t = p(t, ne.WGS84), n = p(n, 0), l(r) || (r = []);
    var i = 0,
        a = e.north,
        o = e.south,
        s = e.east,
        c = e.west,
        f = PE;
    f.height = n, f.longitude = c, f.latitude = a, r[i] = t.cartographicToCartesian(f, r[i]), i++, f.longitude = s, r[i] = t.cartographicToCartesian(f, r[i]), i++, f.latitude = o, r[i] = t.cartographicToCartesian(f, r[i]), i++, f.longitude = c, r[i] = t.cartographicToCartesian(f, r[i]), i++, a < 0 ? f.latitude = a : o > 0 ? f.latitude = o : f.latitude = 0;
    for (var h = 1; h < 8; ++h) f.longitude = -Math.PI + h * T.PI_OVER_TWO, W.contains(e, f) && (r[i] = t.cartographicToCartesian(f, r[i]), i++);
    return f.latitude === 0 && (f.longitude = c, r[i] = t.cartographicToCartesian(f, r[i]), i++, f.longitude = s, r[i] = t.cartographicToCartesian(f, r[i]), i++), r.length = i, r
};
W.MAX_VALUE = Object.freeze(new W(-Math.PI, -T.PI_OVER_TWO, Math.PI, T.PI_OVER_TWO));

function q(e, t) {
    this.center = u.clone(p(e, u.ZERO)), this.radius = p(t, 0)
}
var ql = new u,
    Yl = new u,
    Xl = new u,
    jl = new u,
    Zl = new u,
    Kl = new u,
    $l = new u,
    Jt = new u,
    Jl = new u,
    Ql = new u,
    ed = new u,
    td = new u,
    OE = 4 / 3 * T.PI;
q.fromPoints = function(e, t) {
    if (l(t) || (t = new q), !l(e) || e.length === 0) return t.center = u.clone(u.ZERO, t.center), t.radius = 0, t;
    var n = u.clone(e[0], $l),
        r = u.clone(n, ql),
        i = u.clone(n, Yl),
        a = u.clone(n, Xl),
        o = u.clone(n, jl),
        s = u.clone(n, Zl),
        c = u.clone(n, Kl),
        f = e.length,
        h;
    for (h = 1; h < f; h++) {
        u.clone(e[h], n);
        var d = n.x,
            _ = n.y,
            v = n.z;
        d < r.x && u.clone(n, r), d > o.x && u.clone(n, o), _ < i.y && u.clone(n, i), _ > s.y && u.clone(n, s), v < a.z && u.clone(n, a), v > c.z && u.clone(n, c)
    }
    var m = u.magnitudeSquared(u.subtract(o, r, Jt)),
        g = u.magnitudeSquared(u.subtract(s, i, Jt)),
        y = u.magnitudeSquared(u.subtract(c, a, Jt)),
        E = r,
        w = o,
        C = m;
    g > C && (C = g, E = i, w = s), y > C && (C = y, E = a, w = c);
    var A = Jl;
    A.x = (E.x + w.x) * .5, A.y = (E.y + w.y) * .5, A.z = (E.z + w.z) * .5;
    var x = u.magnitudeSquared(u.subtract(w, A, Jt)),
        P = Math.sqrt(x),
        I = Ql;
    I.x = r.x, I.y = i.y, I.z = a.z;
    var D = ed;
    D.x = o.x, D.y = s.y, D.z = c.z;
    var O = u.midpoint(I, D, td),
        F = 0;
    for (h = 0; h < f; h++) {
        u.clone(e[h], n);
        var z = u.magnitude(u.subtract(n, O, Jt));
        z > F && (F = z);
        var b = u.magnitudeSquared(u.subtract(n, A, Jt));
        if (b > x) {
            var M = Math.sqrt(b);
            P = (P + M) * .5, x = P * P;
            var G = M - P;
            A.x = (P * A.x + G * n.x) / M, A.y = (P * A.y + G * n.y) / M, A.z = (P * A.z + G * n.z) / M
        }
    }
    return P < F ? (u.clone(A, t.center), t.radius = P) : (u.clone(O, t.center), t.radius = F), t
};
var ME = new un,
    NE = new u,
    bE = new u,
    Ef = new K,
    Af = new K;
q.fromRectangle2D = function(e, t, n) {
    return q.fromRectangleWithHeights2D(e, t, 0, 0, n)
};
q.fromRectangleWithHeights2D = function(e, t, n, r, i) {
    if (l(i) || (i = new q), !l(e)) return i.center = u.clone(u.ZERO, i.center), i.radius = 0, i;
    t = p(t, ME), W.southwest(e, Ef), Ef.height = n, W.northeast(e, Af), Af.height = r;
    var a = t.project(Ef, NE),
        o = t.project(Af, bE),
        s = o.x - a.x,
        c = o.y - a.y,
        f = o.z - a.z;
    i.radius = Math.sqrt(s * s + c * c + f * f) * .5;
    var h = i.center;
    return h.x = a.x + s * .5, h.y = a.y + c * .5, h.z = a.z + f * .5, i
};
var FE = [];
q.fromRectangle3D = function(e, t, n, r) {
    if (t = p(t, ne.WGS84), n = p(n, 0), l(r) || (r = new q), !l(e)) return r.center = u.clone(u.ZERO, r.center), r.radius = 0, r;
    var i = W.subsample(e, t, n, FE);
    return q.fromPoints(i, r)
};
q.fromVertices = function(e, t, n, r) {
    if (l(r) || (r = new q), !l(e) || e.length === 0) return r.center = u.clone(u.ZERO, r.center), r.radius = 0, r;
    t = p(t, u.ZERO), n = p(n, 3);
    var i = $l;
    i.x = e[0] + t.x, i.y = e[1] + t.y, i.z = e[2] + t.z;
    var a = u.clone(i, ql),
        o = u.clone(i, Yl),
        s = u.clone(i, Xl),
        c = u.clone(i, jl),
        f = u.clone(i, Zl),
        h = u.clone(i, Kl),
        d = e.length,
        _;
    for (_ = 0; _ < d; _ += n) {
        var v = e[_] + t.x,
            m = e[_ + 1] + t.y,
            g = e[_ + 2] + t.z;
        i.x = v, i.y = m, i.z = g, v < a.x && u.clone(i, a), v > c.x && u.clone(i, c), m < o.y && u.clone(i, o), m > f.y && u.clone(i, f), g < s.z && u.clone(i, s), g > h.z && u.clone(i, h)
    }
    var y = u.magnitudeSquared(u.subtract(c, a, Jt)),
        E = u.magnitudeSquared(u.subtract(f, o, Jt)),
        w = u.magnitudeSquared(u.subtract(h, s, Jt)),
        C = a,
        A = c,
        x = y;
    E > x && (x = E, C = o, A = f), w > x && (x = w, C = s, A = h);
    var P = Jl;
    P.x = (C.x + A.x) * .5, P.y = (C.y + A.y) * .5, P.z = (C.z + A.z) * .5;
    var I = u.magnitudeSquared(u.subtract(A, P, Jt)),
        D = Math.sqrt(I),
        O = Ql;
    O.x = a.x, O.y = o.y, O.z = s.z;
    var F = ed;
    F.x = c.x, F.y = f.y, F.z = h.z;
    var z = u.midpoint(O, F, td),
        b = 0;
    for (_ = 0; _ < d; _ += n) {
        i.x = e[_] + t.x, i.y = e[_ + 1] + t.y, i.z = e[_ + 2] + t.z;
        var M = u.magnitude(u.subtract(i, z, Jt));
        M > b && (b = M);
        var G = u.magnitudeSquared(u.subtract(i, P, Jt));
        if (G > I) {
            var V = Math.sqrt(G);
            D = (D + V) * .5, I = D * D;
            var B = V - D;
            P.x = (D * P.x + B * i.x) / V, P.y = (D * P.y + B * i.y) / V, P.z = (D * P.z + B * i.z) / V
        }
    }
    return D < b ? (u.clone(P, r.center), r.radius = D) : (u.clone(z, r.center), r.radius = b), r
};
q.fromEncodedCartesianVertices = function(e, t, n) {
    if (l(n) || (n = new q), !l(e) || !l(t) || e.length !== t.length || e.length === 0) return n.center = u.clone(u.ZERO, n.center), n.radius = 0, n;
    var r = $l;
    r.x = e[0] + t[0], r.y = e[1] + t[1], r.z = e[2] + t[2];
    var i = u.clone(r, ql),
        a = u.clone(r, Yl),
        o = u.clone(r, Xl),
        s = u.clone(r, jl),
        c = u.clone(r, Zl),
        f = u.clone(r, Kl),
        h = e.length,
        d;
    for (d = 0; d < h; d += 3) {
        var _ = e[d] + t[d],
            v = e[d + 1] + t[d + 1],
            m = e[d + 2] + t[d + 2];
        r.x = _, r.y = v, r.z = m, _ < i.x && u.clone(r, i), _ > s.x && u.clone(r, s), v < a.y && u.clone(r, a), v > c.y && u.clone(r, c), m < o.z && u.clone(r, o), m > f.z && u.clone(r, f)
    }
    var g = u.magnitudeSquared(u.subtract(s, i, Jt)),
        y = u.magnitudeSquared(u.subtract(c, a, Jt)),
        E = u.magnitudeSquared(u.subtract(f, o, Jt)),
        w = i,
        C = s,
        A = g;
    y > A && (A = y, w = a, C = c), E > A && (A = E, w = o, C = f);
    var x = Jl;
    x.x = (w.x + C.x) * .5, x.y = (w.y + C.y) * .5, x.z = (w.z + C.z) * .5;
    var P = u.magnitudeSquared(u.subtract(C, x, Jt)),
        I = Math.sqrt(P),
        D = Ql;
    D.x = i.x, D.y = a.y, D.z = o.z;
    var O = ed;
    O.x = s.x, O.y = c.y, O.z = f.z;
    var F = u.midpoint(D, O, td),
        z = 0;
    for (d = 0; d < h; d += 3) {
        r.x = e[d] + t[d], r.y = e[d + 1] + t[d + 1], r.z = e[d + 2] + t[d + 2];
        var b = u.magnitude(u.subtract(r, F, Jt));
        b > z && (z = b);
        var M = u.magnitudeSquared(u.subtract(r, x, Jt));
        if (M > P) {
            var G = Math.sqrt(M);
            I = (I + G) * .5, P = I * I;
            var V = G - I;
            x.x = (I * x.x + V * r.x) / G, x.y = (I * x.y + V * r.y) / G, x.z = (I * x.z + V * r.z) / G
        }
    }
    return I < z ? (u.clone(x, n.center), n.radius = I) : (u.clone(F, n.center), n.radius = z), n
};
q.fromCornerPoints = function(e, t, n) {
    l(n) || (n = new q);
    var r = u.midpoint(e, t, n.center);
    return n.radius = u.distance(r, t), n
};
q.fromEllipsoid = function(e, t) {
    return l(t) || (t = new q), u.clone(u.ZERO, t.center), t.radius = e.maximumRadius, t
};
var LE = new u;
q.fromBoundingSpheres = function(e, t) {
    if (l(t) || (t = new q), !l(e) || e.length === 0) return t.center = u.clone(u.ZERO, t.center), t.radius = 0, t;
    var n = e.length;
    if (n === 1) return q.clone(e[0], t);
    if (n === 2) return q.union(e[0], e[1], t);
    var r = [],
        i;
    for (i = 0; i < n; i++) r.push(e[i].center);
    t = q.fromPoints(r, t);
    var a = t.center,
        o = t.radius;
    for (i = 0; i < n; i++) {
        var s = e[i];
        o = Math.max(o, u.distance(a, s.center, LE) + s.radius)
    }
    return t.radius = o, t
};
var UE = new u,
    zE = new u,
    BE = new u;
q.fromOrientedBoundingBox = function(e, t) {
    l(t) || (t = new q);
    var n = e.halfAxes,
        r = N.getColumn(n, 0, UE),
        i = N.getColumn(n, 1, zE),
        a = N.getColumn(n, 2, BE);
    return u.add(r, i, r), u.add(r, a, r), t.center = u.clone(e.center, t.center), t.radius = u.magnitude(r), t
};
q.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.center = u.clone(e.center, t.center), t.radius = e.radius, t) : new q(e.center, e.radius)
};
q.packedLength = 4;
q.pack = function(e, t, n) {
    n = p(n, 0);
    var r = e.center;
    return t[n++] = r.x, t[n++] = r.y, t[n++] = r.z, t[n] = e.radius, t
};
q.unpack = function(e, t, n) {
    t = p(t, 0), l(n) || (n = new q);
    var r = n.center;
    return r.x = e[t++], r.y = e[t++], r.z = e[t++], n.radius = e[t], n
};
var VE = new u,
    GE = new u;
q.union = function(e, t, n) {
    l(n) || (n = new q);
    var r = e.center,
        i = e.radius,
        a = t.center,
        o = t.radius,
        s = u.subtract(a, r, VE),
        c = u.magnitude(s);
    if (i >= c + o) return e.clone(n), n;
    if (o >= c + i) return t.clone(n), n;
    var f = (i + c + o) * .5,
        h = u.multiplyByScalar(s, (-i + f) / c, GE);
    return u.add(h, r, h), u.clone(h, n.center), n.radius = f, n
};
var HE = new u;
q.expand = function(e, t, n) {
    n = q.clone(e, n);
    var r = u.magnitude(u.subtract(t, n.center, HE));
    return r > n.radius && (n.radius = r), n
};
q.intersectPlane = function(e, t) {
    var n = e.center,
        r = e.radius,
        i = t.normal,
        a = u.dot(i, n) + t.distance;
    return a < -r ? nt.OUTSIDE : a < r ? nt.INTERSECTING : nt.INSIDE
};
q.transform = function(e, t, n) {
    return l(n) || (n = new q), n.center = S.multiplyByPoint(t, e.center, n.center), n.radius = S.getMaximumScale(t) * e.radius, n
};
var kE = new u;
q.distanceSquaredTo = function(e, t) {
    var n = u.subtract(e.center, t, kE);
    return u.magnitudeSquared(n) - e.radius * e.radius
};
q.transformWithoutScale = function(e, t, n) {
    return l(n) || (n = new q), n.center = S.multiplyByPoint(t, e.center, n.center), n.radius = e.radius, n
};
var WE = new u;
q.computePlaneDistances = function(e, t, n, r) {
    l(r) || (r = new Yi);
    var i = u.subtract(e.center, t, WE),
        a = u.dot(n, i);
    return r.start = a - e.radius, r.stop = a + e.radius, r
};
var s_ = new u,
    qE = new u,
    YE = new u,
    XE = new u,
    jE = new u,
    ZE = new K,
    gp = new Array(8);
for (var Cf = 0; Cf < 8; ++Cf) gp[Cf] = new u;
var KE = new un;
q.projectTo2D = function(e, t, n) {
    t = p(t, KE);
    var r = t.ellipsoid,
        i = e.center,
        a = e.radius,
        o;
    u.equals(i, u.ZERO) ? o = u.clone(u.UNIT_X, s_) : o = r.geodeticSurfaceNormal(i, s_);
    var s = u.cross(u.UNIT_Z, o, qE);
    u.normalize(s, s);
    var c = u.cross(o, s, YE);
    u.normalize(c, c), u.multiplyByScalar(o, a, o), u.multiplyByScalar(c, a, c), u.multiplyByScalar(s, a, s);
    var f = u.negate(c, jE),
        h = u.negate(s, XE),
        d = gp,
        _ = d[0];
    u.add(o, c, _), u.add(_, s, _), _ = d[1], u.add(o, c, _), u.add(_, h, _), _ = d[2], u.add(o, f, _), u.add(_, h, _), _ = d[3], u.add(o, f, _), u.add(_, s, _), u.negate(o, o), _ = d[4], u.add(o, c, _), u.add(_, s, _), _ = d[5], u.add(o, c, _), u.add(_, h, _), _ = d[6], u.add(o, f, _), u.add(_, h, _), _ = d[7], u.add(o, f, _), u.add(_, s, _);
    for (var v = d.length, m = 0; m < v; ++m) {
        var g = d[m];
        u.add(i, g, g);
        var y = r.cartesianToCartographic(g, ZE);
        t.project(y, g)
    }
    n = q.fromPoints(d, n), i = n.center;
    var E = i.x,
        w = i.y,
        C = i.z;
    return i.x = C, i.y = E, i.z = w, n
};
q.isOccluded = function(e, t) {
    return !t.isBoundingSphereVisible(e)
};
q.equals = function(e, t) {
    return e === t || l(e) && l(t) && u.equals(e.center, t.center) && e.radius === t.radius
};
q.prototype.intersectPlane = function(e) {
    return q.intersectPlane(this, e)
};
q.prototype.distanceSquaredTo = function(e) {
    return q.distanceSquaredTo(this, e)
};
q.prototype.computePlaneDistances = function(e, t, n) {
    return q.computePlaneDistances(this, e, t, n)
};
q.prototype.isOccluded = function(e) {
    return q.isOccluded(this, e)
};
q.prototype.equals = function(e) {
    return q.equals(this, e)
};
q.prototype.clone = function(e) {
    return q.clone(this, e)
};
q.prototype.volume = function() {
    var e = this.radius;
    return OE * e * e * e
};
var yp, Tp, tl;
he.defer = Fs;
he.resolve = go;
he.reject = $E;
he.join = e1;
he.all = Cp;
he.map = nd;
he.reduce = t1;
he.any = QE;
he.some = Ap;
he.chain = n1;
he.isPromise = Ep;

function he(e, t, n, r) {
    return go(e).then(t, n, r)
}

function go(e) {
    var t, n;
    return e instanceof bs ? t = e : Ep(e) ? (n = Fs(), e.then(function(r) {
        n.resolve(r)
    }, function(r) {
        n.reject(r)
    }, function(r) {
        n.progress(r)
    }), t = n.promise) : t = JE(e), t
}

function $E(e) {
    return he(e, yo)
}

function bs(e) {
    this.then = e
}
bs.prototype = {
    always: function(e, t) {
        return this.then(e, e, t)
    },
    otherwise: function(e) {
        return this.then(tl, e)
    },
    yield: function(e) {
        return this.then(function() {
            return e
        })
    },
    spread: function(e) {
        return this.then(function(t) {
            return Cp(t, function(n) {
                return e.apply(tl, n)
            })
        })
    }
};

function JE(e) {
    var t = new bs(function(n) {
        try {
            return go(n ? n(e) : e)
        } catch (r) {
            return yo(r)
        }
    });
    return t
}

function yo(e) {
    var t = new bs(function(n, r) {
        try {
            return r ? go(r(e)) : yo(e)
        } catch (i) {
            return yo(i)
        }
    });
    return t
}

function Fs() {
    var e, t, n, r, i, a, o;
    return t = new bs(s), e = {
        then: s,
        resolve: c,
        reject: f,
        progress: h,
        promise: t,
        resolver: {
            resolve: c,
            reject: f,
            progress: h
        }
    }, n = [], r = [], i = function(d, _, v) {
        var m, g;
        return m = Fs(), g = typeof v == "function" ? function(y) {
            try {
                m.progress(v(y))
            } catch (E) {
                m.progress(E)
            }
        } : function(y) {
            m.progress(y)
        }, n.push(function(y) {
            y.then(d, _).then(m.resolve, m.reject, g)
        }), r.push(g), m.promise
    }, a = function(d) {
        return u_(r, d), d
    }, o = function(d) {
        return d = go(d), i = d.then, o = go, a = nl, u_(n, d), r = n = tl, d
    }, e;

    function s(d, _, v) {
        return i(d, _, v)
    }

    function c(d) {
        return o(d)
    }

    function f(d) {
        return o(yo(d))
    }

    function h(d) {
        return a(d)
    }
}

function Ep(e) {
    return e && typeof e.then == "function"
}

function Ap(e, t, n, r, i) {
    return wp(2, arguments), he(e, function(a) {
        var o, s, c, f, h, d, _, v, m, g;
        if (m = a.length >>> 0, o = Math.max(0, Math.min(t, m)), c = [], s = m - o + 1, f = [], h = Fs(), !o) h.resolve(c);
        else
            for (v = h.progress, _ = function(w) {
                    f.push(w), --s || (d = _ = nl, h.reject(f))
                }, d = function(w) {
                    c.push(w), --o || (d = _ = nl, h.resolve(c))
                }, g = 0; g < m; ++g) g in a && he(a[g], E, y, v);
        return h.then(n, r, i);

        function y(w) {
            _(w)
        }

        function E(w) {
            d(w)
        }
    })
}

function QE(e, t, n, r) {
    function i(a) {
        return t ? t(a[0]) : a[0]
    }
    return Ap(e, 1, i, n, r)
}

function Cp(e, t, n, r) {
    return wp(1, arguments), nd(e, xp).then(t, n, r)
}

function e1() {
    return nd(arguments, xp)
}

function nd(e, t) {
    return he(e, function(n) {
        var r, i, a, o, s, c;
        if (a = i = n.length >>> 0, r = [], c = Fs(), !a) c.resolve(r);
        else
            for (o = function(h, d) {
                    he(h, t).then(function(_) {
                        r[d] = _, --a || c.resolve(r)
                    }, c.reject)
                }, s = 0; s < i; s++) s in n ? o(n[s], s) : --a;
        return c.promise
    })
}

function t1(e, t) {
    var n = Tp.call(arguments, 1);
    return he(e, function(r) {
        var i;
        return i = r.length, n[0] = function(a, o, s) {
            return he(a, function(c) {
                return he(o, function(f) {
                    return t(c, f, s, i)
                })
            })
        }, yp.apply(r, n)
    })
}

function n1(e, t, n) {
    var r = arguments.length > 2;
    return he(e, function(i) {
        return i = r ? n : i, t.resolve(i), i
    }, function(i) {
        return t.reject(i), yo(i)
    }, t.progress)
}

function u_(e, t) {
    for (var n, r = 0; n = e[r++];) n(t)
}

function wp(e, t) {
    for (var n, r = t.length; r > e;)
        if (n = t[--r], n != null && typeof n != "function") throw new Error("arg " + r + " must be a function")
}

function nl() {}
Tp = [].slice;
yp = [].reduce || function(e) {
    var t, n, r, i, a;
    if (a = 0, t = Object(this), i = t.length >>> 0, n = arguments, n.length <= 1)
        for (;;) {
            if (a in t) {
                r = t[a++];
                break
            }
            if (++a >= i) throw new TypeError
        } else r = n[1];
    for (; a < i; ++a) a in t && (r = e(r, t[a], a, t));
    return r
};

function xp(e) {
    return e
}
var Li, Rt = {
        requestFullscreen: void 0,
        exitFullscreen: void 0,
        fullscreenEnabled: void 0,
        fullscreenElement: void 0,
        fullscreenchange: void 0,
        fullscreenerror: void 0
    },
    Vn = {};
Object.defineProperties(Vn, {
    element: {
        get: function() {
            if (!!Vn.supportsFullscreen()) return document[Rt.fullscreenElement]
        }
    },
    changeEventName: {
        get: function() {
            if (!!Vn.supportsFullscreen()) return Rt.fullscreenchange
        }
    },
    errorEventName: {
        get: function() {
            if (!!Vn.supportsFullscreen()) return Rt.fullscreenerror
        }
    },
    enabled: {
        get: function() {
            if (!!Vn.supportsFullscreen()) return document[Rt.fullscreenEnabled]
        }
    },
    fullscreen: {
        get: function() {
            if (!!Vn.supportsFullscreen()) return Vn.element !== null
        }
    }
});
Vn.supportsFullscreen = function() {
    if (l(Li)) return Li;
    Li = !1;
    var e = document.body;
    if (typeof e.requestFullscreen == "function") return Rt.requestFullscreen = "requestFullscreen", Rt.exitFullscreen = "exitFullscreen", Rt.fullscreenEnabled = "fullscreenEnabled", Rt.fullscreenElement = "fullscreenElement", Rt.fullscreenchange = "fullscreenchange", Rt.fullscreenerror = "fullscreenerror", Li = !0, Li;
    for (var t = ["webkit", "moz", "o", "ms", "khtml"], n, r = 0, i = t.length; r < i; ++r) {
        var a = t[r];
        n = a + "RequestFullscreen", typeof e[n] == "function" ? (Rt.requestFullscreen = n, Li = !0) : (n = a + "RequestFullScreen", typeof e[n] == "function" && (Rt.requestFullscreen = n, Li = !0)), n = a + "ExitFullscreen", typeof document[n] == "function" ? Rt.exitFullscreen = n : (n = a + "CancelFullScreen", typeof document[n] == "function" && (Rt.exitFullscreen = n)), n = a + "FullscreenEnabled", document[n] !== void 0 ? Rt.fullscreenEnabled = n : (n = a + "FullScreenEnabled", document[n] !== void 0 && (Rt.fullscreenEnabled = n)), n = a + "FullscreenElement", document[n] !== void 0 ? Rt.fullscreenElement = n : (n = a + "FullScreenElement", document[n] !== void 0 && (Rt.fullscreenElement = n)), n = a + "fullscreenchange", document["on" + n] !== void 0 && (a === "ms" && (n = "MSFullscreenChange"), Rt.fullscreenchange = n), n = a + "fullscreenerror", document["on" + n] !== void 0 && (a === "ms" && (n = "MSFullscreenError"), Rt.fullscreenerror = n)
    }
    return Li
};
Vn.requestFullscreen = function(e, t) {
    !Vn.supportsFullscreen() || e[Rt.requestFullscreen]({
        vrDisplay: t
    })
};
Vn.exitFullscreen = function() {
    !Vn.supportsFullscreen() || document[Rt.exitFullscreen]()
};
Vn._names = Rt;
var pn;
typeof navigator < "u" ? pn = navigator : pn = {};

function Ia(e) {
    for (var t = e.split("."), n = 0, r = t.length; n < r; ++n) t[n] = parseInt(t[n], 10);
    return t
}
var Js, Sp;

function rd() {
    if (!l(Js) && (Js = !1, !Ls())) {
        var e = / Chrome\/([\.0-9]+)/.exec(pn.userAgent);
        e !== null && (Js = !0, Sp = Ia(e[1]))
    }
    return Js
}

function r1() {
    return rd() && Sp
}
var Qs, Rp;

function Dp() {
    if (!l(Qs) && (Qs = !1, !rd() && !Ls() && / Safari\/[\.0-9]+/.test(pn.userAgent))) {
        var e = / Version\/([\.0-9]+)/.exec(pn.userAgent);
        e !== null && (Qs = !0, Rp = Ia(e[1]))
    }
    return Qs
}

function i1() {
    return Dp() && Rp
}
var eu, rl;

function Ip() {
    if (!l(eu)) {
        eu = !1;
        var e = / AppleWebKit\/([\.0-9]+)(\+?)/.exec(pn.userAgent);
        e !== null && (eu = !0, rl = Ia(e[1]), rl.isNightly = !!e[2])
    }
    return eu
}

function a1() {
    return Ip() && rl
}
var Xo, il;

function Pp() {
    if (!l(Xo)) {
        Xo = !1;
        var e;
        pn.appName === "Microsoft Internet Explorer" ? (e = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(pn.userAgent), e !== null && (Xo = !0, il = Ia(e[1]))) : pn.appName === "Netscape" && (e = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(pn.userAgent), e !== null && (Xo = !0, il = Ia(e[1])))
    }
    return Xo
}

function o1() {
    return Pp() && il
}
var tu, Op;

function Ls() {
    if (!l(tu)) {
        tu = !1;
        var e = / Edge\/([\.0-9]+)/.exec(pn.userAgent);
        e !== null && (tu = !0, Op = Ia(e[1]))
    }
    return tu
}

function s1() {
    return Ls() && Op
}
var nu, Mp;

function id() {
    if (!l(nu)) {
        nu = !1;
        var e = /Firefox\/([\.0-9]+)/.exec(pn.userAgent);
        e !== null && (nu = !0, Mp = Ia(e[1]))
    }
    return nu
}
var wf;

function u1() {
    return l(wf) || (wf = /Windows/i.test(pn.appVersion)), wf
}

function c1() {
    return id() && Mp
}
var xf;

function f1() {
    return l(xf) || (xf = !id() && typeof PointerEvent < "u" && (!l(pn.pointerEnabled) || pn.pointerEnabled)), xf
}
var Np, ru;

function bp() {
    if (!l(ru)) {
        var e = document.createElement("canvas");
        e.setAttribute("style", "image-rendering: -moz-crisp-edges;image-rendering: pixelated;");
        var t = e.style.imageRendering;
        ru = l(t) && t !== "", ru && (Np = t)
    }
    return ru
}

function h1() {
    return bp() ? Np : void 0
}

function _n() {
    return _n._result
}
_n._promise = void 0;
_n._result = void 0;
_n.initialize = function() {
    if (l(_n._promise)) return _n._promise;
    var e = he.defer();
    if (_n._promise = e.promise, Ls()) return _n._result = !1, e.resolve(_n._result), e.promise;
    var t = new Image;
    return t.onload = function() {
        _n._result = t.width > 0 && t.height > 0, e.resolve(_n._result)
    }, t.onerror = function() {
        _n._result = !1, e.resolve(_n._result)
    }, t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.promise
};
Object.defineProperties(_n, {
    initialized: {
        get: function() {
            return l(_n._result)
        }
    }
});
var Ku = [];
typeof ArrayBuffer < "u" && (Ku.push(Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array), typeof Uint8ClampedArray < "u" && Ku.push(Uint8ClampedArray), typeof Uint8ClampedArray < "u" && Ku.push(Uint8ClampedArray));
var An = {
    isChrome: rd,
    chromeVersion: r1,
    isSafari: Dp,
    safariVersion: i1,
    isWebkit: Ip,
    webkitVersion: a1,
    isInternetExplorer: Pp,
    internetExplorerVersion: o1,
    isEdge: Ls,
    edgeVersion: s1,
    isFirefox: id,
    firefoxVersion: c1,
    isWindows: u1,
    hardwareConcurrency: p(pn.hardwareConcurrency, 3),
    supportsPointerEvents: f1,
    supportsImageRenderingPixelated: bp,
    supportsWebP: _n,
    imageRenderingValue: h1,
    typedArrayTypes: Ku
};
An.supportsFullscreen = function() {
    return Vn.supportsFullscreen()
};
An.supportsTypedArrays = function() {
    return typeof ArrayBuffer < "u"
};
An.supportsWebWorkers = function() {
    return typeof Worker < "u"
};
An.supportsWebAssembly = function() {
    return typeof WebAssembly < "u" && !An.isEdge()
};

function Sf(e, t, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n * 6 < 1 ? e + (t - e) * 6 * n : n * 2 < 1 ? t : n * 3 < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e
}

function H(e, t, n, r) {
    this.red = p(e, 1), this.green = p(t, 1), this.blue = p(n, 1), this.alpha = p(r, 1)
}
H.fromCartesian4 = function(e, t) {
    return l(t) ? (t.red = e.x, t.green = e.y, t.blue = e.z, t.alpha = e.w, t) : new H(e.x, e.y, e.z, e.w)
};
H.fromBytes = function(e, t, n, r, i) {
    return e = H.byteToFloat(p(e, 255)), t = H.byteToFloat(p(t, 255)), n = H.byteToFloat(p(n, 255)), r = H.byteToFloat(p(r, 255)), l(i) ? (i.red = e, i.green = t, i.blue = n, i.alpha = r, i) : new H(e, t, n, r)
};
H.fromAlpha = function(e, t, n) {
    return l(n) ? (n.red = e.red, n.green = e.green, n.blue = e.blue, n.alpha = t, n) : new H(e.red, e.green, e.blue, t)
};
var Rf, ad, Si;
An.supportsTypedArrays() && (Rf = new ArrayBuffer(4), ad = new Uint32Array(Rf), Si = new Uint8Array(Rf));
H.fromRgba = function(e, t) {
    return ad[0] = e, H.fromBytes(Si[0], Si[1], Si[2], Si[3], t)
};
H.fromHsl = function(e, t, n, r, i) {
    e = p(e, 0) % 1, t = p(t, 0), n = p(n, 0), r = p(r, 1);
    var a = n,
        o = n,
        s = n;
    if (t !== 0) {
        var c;
        n < .5 ? c = n * (1 + t) : c = n + t - n * t;
        var f = 2 * n - c;
        a = Sf(f, c, e + 1 / 3), o = Sf(f, c, e), s = Sf(f, c, e - 1 / 3)
    }
    return l(i) ? (i.red = a, i.green = o, i.blue = s, i.alpha = r, i) : new H(a, o, s, r)
};
H.fromRandom = function(e, t) {
    e = p(e, p.EMPTY_OBJECT);
    var n = e.red;
    if (!l(n)) {
        var r = p(e.minimumRed, 0),
            i = p(e.maximumRed, 1);
        n = r + T.nextRandomNumber() * (i - r)
    }
    var a = e.green;
    if (!l(a)) {
        var o = p(e.minimumGreen, 0),
            s = p(e.maximumGreen, 1);
        a = o + T.nextRandomNumber() * (s - o)
    }
    var c = e.blue;
    if (!l(c)) {
        var f = p(e.minimumBlue, 0),
            h = p(e.maximumBlue, 1);
        c = f + T.nextRandomNumber() * (h - f)
    }
    var d = e.alpha;
    if (!l(d)) {
        var _ = p(e.minimumAlpha, 0),
            v = p(e.maximumAlpha, 1);
        d = _ + T.nextRandomNumber() * (v - _)
    }
    return l(t) ? (t.red = n, t.green = a, t.blue = c, t.alpha = d, t) : new H(n, a, c, d)
};
var l1 = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i,
    d1 = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i,
    _1 = /^rgba?\(\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)(?:\s*,\s*([0-9.]+))?\s*\)$/i,
    v1 = /^hsla?\(\s*([0-9.]+)\s*,\s*([0-9.]+%)\s*,\s*([0-9.]+%)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
H.fromCssColorString = function(e, t) {
    l(t) || (t = new H), e = e.replace(/\s/g, "");
    var n = H[e.toUpperCase()];
    if (l(n)) return H.clone(n, t), t;
    var r = l1.exec(e);
    return r !== null ? (t.red = parseInt(r[1], 16) / 15, t.green = parseInt(r[2], 16) / 15, t.blue = parseInt(r[3], 16) / 15, t.alpha = parseInt(p(r[4], "f"), 16) / 15, t) : (r = d1.exec(e), r !== null ? (t.red = parseInt(r[1], 16) / 255, t.green = parseInt(r[2], 16) / 255, t.blue = parseInt(r[3], 16) / 255, t.alpha = parseInt(p(r[4], "ff"), 16) / 255, t) : (r = _1.exec(e), r !== null ? (t.red = parseFloat(r[1]) / (r[1].substr(-1) === "%" ? 100 : 255), t.green = parseFloat(r[2]) / (r[2].substr(-1) === "%" ? 100 : 255), t.blue = parseFloat(r[3]) / (r[3].substr(-1) === "%" ? 100 : 255), t.alpha = parseFloat(p(r[4], "1.0")), t) : (r = v1.exec(e), r !== null ? H.fromHsl(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, parseFloat(p(r[4], "1.0")), t) : (t = void 0, t))))
};
H.packedLength = 4;
H.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.red, t[n++] = e.green, t[n++] = e.blue, t[n] = e.alpha, t
};
H.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new H), n.red = e[t++], n.green = e[t++], n.blue = e[t++], n.alpha = e[t], n
};
H.byteToFloat = function(e) {
    return e / 255
};
H.floatToByte = function(e) {
    return e === 1 ? 255 : e * 256 | 0
};
H.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.red = e.red, t.green = e.green, t.blue = e.blue, t.alpha = e.alpha, t) : new H(e.red, e.green, e.blue, e.alpha)
};
H.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.red === t.red && e.green === t.green && e.blue === t.blue && e.alpha === t.alpha
};
H.equalsArray = function(e, t, n) {
    return e.red === t[n] && e.green === t[n + 1] && e.blue === t[n + 2] && e.alpha === t[n + 3]
};
H.prototype.clone = function(e) {
    return H.clone(this, e)
};
H.prototype.equals = function(e) {
    return H.equals(this, e)
};
H.prototype.equalsEpsilon = function(e, t) {
    return this === e || l(e) && Math.abs(this.red - e.red) <= t && Math.abs(this.green - e.green) <= t && Math.abs(this.blue - e.blue) <= t && Math.abs(this.alpha - e.alpha) <= t
};
H.prototype.toString = function() {
    return "(" + this.red + ", " + this.green + ", " + this.blue + ", " + this.alpha + ")"
};
H.prototype.toCssColorString = function() {
    var e = H.floatToByte(this.red),
        t = H.floatToByte(this.green),
        n = H.floatToByte(this.blue);
    return this.alpha === 1 ? "rgb(" + e + "," + t + "," + n + ")" : "rgba(" + e + "," + t + "," + n + "," + this.alpha + ")"
};
H.prototype.toCssHexString = function() {
    var e = H.floatToByte(this.red).toString(16);
    e.length < 2 && (e = "0" + e);
    var t = H.floatToByte(this.green).toString(16);
    t.length < 2 && (t = "0" + t);
    var n = H.floatToByte(this.blue).toString(16);
    if (n.length < 2 && (n = "0" + n), this.alpha < 1) {
        var r = H.floatToByte(this.alpha).toString(16);
        return r.length < 2 && (r = "0" + r), "#" + e + t + n + r
    }
    return "#" + e + t + n
};
H.prototype.toBytes = function(e) {
    var t = H.floatToByte(this.red),
        n = H.floatToByte(this.green),
        r = H.floatToByte(this.blue),
        i = H.floatToByte(this.alpha);
    return l(e) ? (e[0] = t, e[1] = n, e[2] = r, e[3] = i, e) : [t, n, r, i]
};
H.prototype.toRgba = function() {
    return Si[0] = H.floatToByte(this.red), Si[1] = H.floatToByte(this.green), Si[2] = H.floatToByte(this.blue), Si[3] = H.floatToByte(this.alpha), ad[0]
};
H.prototype.brighten = function(e, t) {
    return e = 1 - e, t.red = 1 - (1 - this.red) * e, t.green = 1 - (1 - this.green) * e, t.blue = 1 - (1 - this.blue) * e, t.alpha = this.alpha, t
};
H.prototype.darken = function(e, t) {
    return e = 1 - e, t.red = this.red * e, t.green = this.green * e, t.blue = this.blue * e, t.alpha = this.alpha, t
};
H.prototype.withAlpha = function(e, t) {
    return H.fromAlpha(this, e, t)
};
H.add = function(e, t, n) {
    return n.red = e.red + t.red, n.green = e.green + t.green, n.blue = e.blue + t.blue, n.alpha = e.alpha + t.alpha, n
};
H.subtract = function(e, t, n) {
    return n.red = e.red - t.red, n.green = e.green - t.green, n.blue = e.blue - t.blue, n.alpha = e.alpha - t.alpha, n
};
H.multiply = function(e, t, n) {
    return n.red = e.red * t.red, n.green = e.green * t.green, n.blue = e.blue * t.blue, n.alpha = e.alpha * t.alpha, n
};
H.divide = function(e, t, n) {
    return n.red = e.red / t.red, n.green = e.green / t.green, n.blue = e.blue / t.blue, n.alpha = e.alpha / t.alpha, n
};
H.mod = function(e, t, n) {
    return n.red = e.red % t.red, n.green = e.green % t.green, n.blue = e.blue % t.blue, n.alpha = e.alpha % t.alpha, n
};
H.lerp = function(e, t, n, r) {
    return r.red = T.lerp(e.red, t.red, n), r.green = T.lerp(e.green, t.green, n), r.blue = T.lerp(e.blue, t.blue, n), r.alpha = T.lerp(e.alpha, t.alpha, n), r
};
H.multiplyByScalar = function(e, t, n) {
    return n.red = e.red * t, n.green = e.green * t, n.blue = e.blue * t, n.alpha = e.alpha * t, n
};
H.divideByScalar = function(e, t, n) {
    return n.red = e.red / t, n.green = e.green / t, n.blue = e.blue / t, n.alpha = e.alpha / t, n
};
H.WHITE = Object.freeze(H.fromCssColorString("#FFFFFF"));
H.TRANSPARENT = Object.freeze(new H(0, 0, 0, 0));
var m1 = {
    DEPTH_BUFFER_BIT: 256,
    STENCIL_BUFFER_BIT: 1024,
    COLOR_BUFFER_BIT: 16384,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    ZERO: 0,
    ONE: 1,
    SRC_COLOR: 768,
    ONE_MINUS_SRC_COLOR: 769,
    SRC_ALPHA: 770,
    ONE_MINUS_SRC_ALPHA: 771,
    DST_ALPHA: 772,
    ONE_MINUS_DST_ALPHA: 773,
    DST_COLOR: 774,
    ONE_MINUS_DST_COLOR: 775,
    SRC_ALPHA_SATURATE: 776,
    FUNC_ADD: 32774,
    BLEND_EQUATION: 32777,
    BLEND_EQUATION_RGB: 32777,
    BLEND_EQUATION_ALPHA: 34877,
    FUNC_SUBTRACT: 32778,
    FUNC_REVERSE_SUBTRACT: 32779,
    BLEND_DST_RGB: 32968,
    BLEND_SRC_RGB: 32969,
    BLEND_DST_ALPHA: 32970,
    BLEND_SRC_ALPHA: 32971,
    CONSTANT_COLOR: 32769,
    ONE_MINUS_CONSTANT_COLOR: 32770,
    CONSTANT_ALPHA: 32771,
    ONE_MINUS_CONSTANT_ALPHA: 32772,
    BLEND_COLOR: 32773,
    ARRAY_BUFFER: 34962,
    ELEMENT_ARRAY_BUFFER: 34963,
    ARRAY_BUFFER_BINDING: 34964,
    ELEMENT_ARRAY_BUFFER_BINDING: 34965,
    STREAM_DRAW: 35040,
    STATIC_DRAW: 35044,
    DYNAMIC_DRAW: 35048,
    BUFFER_SIZE: 34660,
    BUFFER_USAGE: 34661,
    CURRENT_VERTEX_ATTRIB: 34342,
    FRONT: 1028,
    BACK: 1029,
    FRONT_AND_BACK: 1032,
    CULL_FACE: 2884,
    BLEND: 3042,
    DITHER: 3024,
    STENCIL_TEST: 2960,
    DEPTH_TEST: 2929,
    SCISSOR_TEST: 3089,
    POLYGON_OFFSET_FILL: 32823,
    SAMPLE_ALPHA_TO_COVERAGE: 32926,
    SAMPLE_COVERAGE: 32928,
    NO_ERROR: 0,
    INVALID_ENUM: 1280,
    INVALID_VALUE: 1281,
    INVALID_OPERATION: 1282,
    OUT_OF_MEMORY: 1285,
    CW: 2304,
    CCW: 2305,
    LINE_WIDTH: 2849,
    ALIASED_POINT_SIZE_RANGE: 33901,
    ALIASED_LINE_WIDTH_RANGE: 33902,
    CULL_FACE_MODE: 2885,
    FRONT_FACE: 2886,
    DEPTH_RANGE: 2928,
    DEPTH_WRITEMASK: 2930,
    DEPTH_CLEAR_VALUE: 2931,
    DEPTH_FUNC: 2932,
    STENCIL_CLEAR_VALUE: 2961,
    STENCIL_FUNC: 2962,
    STENCIL_FAIL: 2964,
    STENCIL_PASS_DEPTH_FAIL: 2965,
    STENCIL_PASS_DEPTH_PASS: 2966,
    STENCIL_REF: 2967,
    STENCIL_VALUE_MASK: 2963,
    STENCIL_WRITEMASK: 2968,
    STENCIL_BACK_FUNC: 34816,
    STENCIL_BACK_FAIL: 34817,
    STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
    STENCIL_BACK_PASS_DEPTH_PASS: 34819,
    STENCIL_BACK_REF: 36003,
    STENCIL_BACK_VALUE_MASK: 36004,
    STENCIL_BACK_WRITEMASK: 36005,
    VIEWPORT: 2978,
    SCISSOR_BOX: 3088,
    COLOR_CLEAR_VALUE: 3106,
    COLOR_WRITEMASK: 3107,
    UNPACK_ALIGNMENT: 3317,
    PACK_ALIGNMENT: 3333,
    MAX_TEXTURE_SIZE: 3379,
    MAX_VIEWPORT_DIMS: 3386,
    SUBPIXEL_BITS: 3408,
    RED_BITS: 3410,
    GREEN_BITS: 3411,
    BLUE_BITS: 3412,
    ALPHA_BITS: 3413,
    DEPTH_BITS: 3414,
    STENCIL_BITS: 3415,
    POLYGON_OFFSET_UNITS: 10752,
    POLYGON_OFFSET_FACTOR: 32824,
    TEXTURE_BINDING_2D: 32873,
    SAMPLE_BUFFERS: 32936,
    SAMPLES: 32937,
    SAMPLE_COVERAGE_VALUE: 32938,
    SAMPLE_COVERAGE_INVERT: 32939,
    COMPRESSED_TEXTURE_FORMATS: 34467,
    DONT_CARE: 4352,
    FASTEST: 4353,
    NICEST: 4354,
    GENERATE_MIPMAP_HINT: 33170,
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    DEPTH_COMPONENT: 6402,
    ALPHA: 6406,
    RGB: 6407,
    RGBA: 6408,
    LUMINANCE: 6409,
    LUMINANCE_ALPHA: 6410,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    UNSIGNED_SHORT_5_6_5: 33635,
    FRAGMENT_SHADER: 35632,
    VERTEX_SHADER: 35633,
    MAX_VERTEX_ATTRIBS: 34921,
    MAX_VERTEX_UNIFORM_VECTORS: 36347,
    MAX_VARYING_VECTORS: 36348,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
    MAX_TEXTURE_IMAGE_UNITS: 34930,
    MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
    SHADER_TYPE: 35663,
    DELETE_STATUS: 35712,
    LINK_STATUS: 35714,
    VALIDATE_STATUS: 35715,
    ATTACHED_SHADERS: 35717,
    ACTIVE_UNIFORMS: 35718,
    ACTIVE_ATTRIBUTES: 35721,
    SHADING_LANGUAGE_VERSION: 35724,
    CURRENT_PROGRAM: 35725,
    NEVER: 512,
    LESS: 513,
    EQUAL: 514,
    LEQUAL: 515,
    GREATER: 516,
    NOTEQUAL: 517,
    GEQUAL: 518,
    ALWAYS: 519,
    KEEP: 7680,
    REPLACE: 7681,
    INCR: 7682,
    DECR: 7683,
    INVERT: 5386,
    INCR_WRAP: 34055,
    DECR_WRAP: 34056,
    VENDOR: 7936,
    RENDERER: 7937,
    VERSION: 7938,
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987,
    TEXTURE_MAG_FILTER: 10240,
    TEXTURE_MIN_FILTER: 10241,
    TEXTURE_WRAP_S: 10242,
    TEXTURE_WRAP_T: 10243,
    TEXTURE_2D: 3553,
    TEXTURE: 5890,
    TEXTURE_CUBE_MAP: 34067,
    TEXTURE_BINDING_CUBE_MAP: 34068,
    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
    MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
    TEXTURE0: 33984,
    TEXTURE1: 33985,
    TEXTURE2: 33986,
    TEXTURE3: 33987,
    TEXTURE4: 33988,
    TEXTURE5: 33989,
    TEXTURE6: 33990,
    TEXTURE7: 33991,
    TEXTURE8: 33992,
    TEXTURE9: 33993,
    TEXTURE10: 33994,
    TEXTURE11: 33995,
    TEXTURE12: 33996,
    TEXTURE13: 33997,
    TEXTURE14: 33998,
    TEXTURE15: 33999,
    TEXTURE16: 34e3,
    TEXTURE17: 34001,
    TEXTURE18: 34002,
    TEXTURE19: 34003,
    TEXTURE20: 34004,
    TEXTURE21: 34005,
    TEXTURE22: 34006,
    TEXTURE23: 34007,
    TEXTURE24: 34008,
    TEXTURE25: 34009,
    TEXTURE26: 34010,
    TEXTURE27: 34011,
    TEXTURE28: 34012,
    TEXTURE29: 34013,
    TEXTURE30: 34014,
    TEXTURE31: 34015,
    ACTIVE_TEXTURE: 34016,
    REPEAT: 10497,
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    INT_VEC2: 35667,
    INT_VEC3: 35668,
    INT_VEC4: 35669,
    BOOL: 35670,
    BOOL_VEC2: 35671,
    BOOL_VEC3: 35672,
    BOOL_VEC4: 35673,
    FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    SAMPLER_2D: 35678,
    SAMPLER_CUBE: 35680,
    VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
    VERTEX_ATTRIB_ARRAY_SIZE: 34339,
    VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
    VERTEX_ATTRIB_ARRAY_TYPE: 34341,
    VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
    VERTEX_ATTRIB_ARRAY_POINTER: 34373,
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
    IMPLEMENTATION_COLOR_READ_TYPE: 35738,
    IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
    COMPILE_STATUS: 35713,
    LOW_FLOAT: 36336,
    MEDIUM_FLOAT: 36337,
    HIGH_FLOAT: 36338,
    LOW_INT: 36339,
    MEDIUM_INT: 36340,
    HIGH_INT: 36341,
    FRAMEBUFFER: 36160,
    RENDERBUFFER: 36161,
    RGBA4: 32854,
    RGB5_A1: 32855,
    RGB565: 36194,
    DEPTH_COMPONENT16: 33189,
    STENCIL_INDEX: 6401,
    STENCIL_INDEX8: 36168,
    DEPTH_STENCIL: 34041,
    RENDERBUFFER_WIDTH: 36162,
    RENDERBUFFER_HEIGHT: 36163,
    RENDERBUFFER_INTERNAL_FORMAT: 36164,
    RENDERBUFFER_RED_SIZE: 36176,
    RENDERBUFFER_GREEN_SIZE: 36177,
    RENDERBUFFER_BLUE_SIZE: 36178,
    RENDERBUFFER_ALPHA_SIZE: 36179,
    RENDERBUFFER_DEPTH_SIZE: 36180,
    RENDERBUFFER_STENCIL_SIZE: 36181,
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
    COLOR_ATTACHMENT0: 36064,
    DEPTH_ATTACHMENT: 36096,
    STENCIL_ATTACHMENT: 36128,
    DEPTH_STENCIL_ATTACHMENT: 33306,
    NONE: 0,
    FRAMEBUFFER_COMPLETE: 36053,
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
    FRAMEBUFFER_UNSUPPORTED: 36061,
    FRAMEBUFFER_BINDING: 36006,
    RENDERBUFFER_BINDING: 36007,
    MAX_RENDERBUFFER_SIZE: 34024,
    INVALID_FRAMEBUFFER_OPERATION: 1286,
    UNPACK_FLIP_Y_WEBGL: 37440,
    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
    CONTEXT_LOST_WEBGL: 37442,
    UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
    BROWSER_DEFAULT_WEBGL: 37444,
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    HALF_FLOAT_OES: 36193,
    DOUBLE: 5130,
    READ_BUFFER: 3074,
    UNPACK_ROW_LENGTH: 3314,
    UNPACK_SKIP_ROWS: 3315,
    UNPACK_SKIP_PIXELS: 3316,
    PACK_ROW_LENGTH: 3330,
    PACK_SKIP_ROWS: 3331,
    PACK_SKIP_PIXELS: 3332,
    COLOR: 6144,
    DEPTH: 6145,
    STENCIL: 6146,
    RED: 6403,
    RGB8: 32849,
    RGBA8: 32856,
    RGB10_A2: 32857,
    TEXTURE_BINDING_3D: 32874,
    UNPACK_SKIP_IMAGES: 32877,
    UNPACK_IMAGE_HEIGHT: 32878,
    TEXTURE_3D: 32879,
    TEXTURE_WRAP_R: 32882,
    MAX_3D_TEXTURE_SIZE: 32883,
    UNSIGNED_INT_2_10_10_10_REV: 33640,
    MAX_ELEMENTS_VERTICES: 33e3,
    MAX_ELEMENTS_INDICES: 33001,
    TEXTURE_MIN_LOD: 33082,
    TEXTURE_MAX_LOD: 33083,
    TEXTURE_BASE_LEVEL: 33084,
    TEXTURE_MAX_LEVEL: 33085,
    MIN: 32775,
    MAX: 32776,
    DEPTH_COMPONENT24: 33190,
    MAX_TEXTURE_LOD_BIAS: 34045,
    TEXTURE_COMPARE_MODE: 34892,
    TEXTURE_COMPARE_FUNC: 34893,
    CURRENT_QUERY: 34917,
    QUERY_RESULT: 34918,
    QUERY_RESULT_AVAILABLE: 34919,
    STREAM_READ: 35041,
    STREAM_COPY: 35042,
    STATIC_READ: 35045,
    STATIC_COPY: 35046,
    DYNAMIC_READ: 35049,
    DYNAMIC_COPY: 35050,
    MAX_DRAW_BUFFERS: 34852,
    DRAW_BUFFER0: 34853,
    DRAW_BUFFER1: 34854,
    DRAW_BUFFER2: 34855,
    DRAW_BUFFER3: 34856,
    DRAW_BUFFER4: 34857,
    DRAW_BUFFER5: 34858,
    DRAW_BUFFER6: 34859,
    DRAW_BUFFER7: 34860,
    DRAW_BUFFER8: 34861,
    DRAW_BUFFER9: 34862,
    DRAW_BUFFER10: 34863,
    DRAW_BUFFER11: 34864,
    DRAW_BUFFER12: 34865,
    DRAW_BUFFER13: 34866,
    DRAW_BUFFER14: 34867,
    DRAW_BUFFER15: 34868,
    MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657,
    MAX_VERTEX_UNIFORM_COMPONENTS: 35658,
    SAMPLER_3D: 35679,
    SAMPLER_2D_SHADOW: 35682,
    FRAGMENT_SHADER_DERIVATIVE_HINT: 35723,
    PIXEL_PACK_BUFFER: 35051,
    PIXEL_UNPACK_BUFFER: 35052,
    PIXEL_PACK_BUFFER_BINDING: 35053,
    PIXEL_UNPACK_BUFFER_BINDING: 35055,
    FLOAT_MAT2x3: 35685,
    FLOAT_MAT2x4: 35686,
    FLOAT_MAT3x2: 35687,
    FLOAT_MAT3x4: 35688,
    FLOAT_MAT4x2: 35689,
    FLOAT_MAT4x3: 35690,
    SRGB: 35904,
    SRGB8: 35905,
    SRGB8_ALPHA8: 35907,
    COMPARE_REF_TO_TEXTURE: 34894,
    RGBA32F: 34836,
    RGB32F: 34837,
    RGBA16F: 34842,
    RGB16F: 34843,
    VERTEX_ATTRIB_ARRAY_INTEGER: 35069,
    MAX_ARRAY_TEXTURE_LAYERS: 35071,
    MIN_PROGRAM_TEXEL_OFFSET: 35076,
    MAX_PROGRAM_TEXEL_OFFSET: 35077,
    MAX_VARYING_COMPONENTS: 35659,
    TEXTURE_2D_ARRAY: 35866,
    TEXTURE_BINDING_2D_ARRAY: 35869,
    R11F_G11F_B10F: 35898,
    UNSIGNED_INT_10F_11F_11F_REV: 35899,
    RGB9_E5: 35901,
    UNSIGNED_INT_5_9_9_9_REV: 35902,
    TRANSFORM_FEEDBACK_BUFFER_MODE: 35967,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968,
    TRANSFORM_FEEDBACK_VARYINGS: 35971,
    TRANSFORM_FEEDBACK_BUFFER_START: 35972,
    TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973,
    TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976,
    RASTERIZER_DISCARD: 35977,
    MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979,
    INTERLEAVED_ATTRIBS: 35980,
    SEPARATE_ATTRIBS: 35981,
    TRANSFORM_FEEDBACK_BUFFER: 35982,
    TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983,
    RGBA32UI: 36208,
    RGB32UI: 36209,
    RGBA16UI: 36214,
    RGB16UI: 36215,
    RGBA8UI: 36220,
    RGB8UI: 36221,
    RGBA32I: 36226,
    RGB32I: 36227,
    RGBA16I: 36232,
    RGB16I: 36233,
    RGBA8I: 36238,
    RGB8I: 36239,
    RED_INTEGER: 36244,
    RGB_INTEGER: 36248,
    RGBA_INTEGER: 36249,
    SAMPLER_2D_ARRAY: 36289,
    SAMPLER_2D_ARRAY_SHADOW: 36292,
    SAMPLER_CUBE_SHADOW: 36293,
    UNSIGNED_INT_VEC2: 36294,
    UNSIGNED_INT_VEC3: 36295,
    UNSIGNED_INT_VEC4: 36296,
    INT_SAMPLER_2D: 36298,
    INT_SAMPLER_3D: 36299,
    INT_SAMPLER_CUBE: 36300,
    INT_SAMPLER_2D_ARRAY: 36303,
    UNSIGNED_INT_SAMPLER_2D: 36306,
    UNSIGNED_INT_SAMPLER_3D: 36307,
    UNSIGNED_INT_SAMPLER_CUBE: 36308,
    UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311,
    DEPTH_COMPONENT32F: 36012,
    DEPTH32F_STENCIL8: 36013,
    FLOAT_32_UNSIGNED_INT_24_8_REV: 36269,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297,
    FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298,
    FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299,
    FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300,
    FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301,
    FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302,
    FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303,
    FRAMEBUFFER_DEFAULT: 33304,
    UNSIGNED_INT_24_8: 34042,
    DEPTH24_STENCIL8: 35056,
    UNSIGNED_NORMALIZED: 35863,
    DRAW_FRAMEBUFFER_BINDING: 36006,
    READ_FRAMEBUFFER: 36008,
    DRAW_FRAMEBUFFER: 36009,
    READ_FRAMEBUFFER_BINDING: 36010,
    RENDERBUFFER_SAMPLES: 36011,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052,
    MAX_COLOR_ATTACHMENTS: 36063,
    COLOR_ATTACHMENT1: 36065,
    COLOR_ATTACHMENT2: 36066,
    COLOR_ATTACHMENT3: 36067,
    COLOR_ATTACHMENT4: 36068,
    COLOR_ATTACHMENT5: 36069,
    COLOR_ATTACHMENT6: 36070,
    COLOR_ATTACHMENT7: 36071,
    COLOR_ATTACHMENT8: 36072,
    COLOR_ATTACHMENT9: 36073,
    COLOR_ATTACHMENT10: 36074,
    COLOR_ATTACHMENT11: 36075,
    COLOR_ATTACHMENT12: 36076,
    COLOR_ATTACHMENT13: 36077,
    COLOR_ATTACHMENT14: 36078,
    COLOR_ATTACHMENT15: 36079,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182,
    MAX_SAMPLES: 36183,
    HALF_FLOAT: 5131,
    RG: 33319,
    RG_INTEGER: 33320,
    R8: 33321,
    RG8: 33323,
    R16F: 33325,
    R32F: 33326,
    RG16F: 33327,
    RG32F: 33328,
    R8I: 33329,
    R8UI: 33330,
    R16I: 33331,
    R16UI: 33332,
    R32I: 33333,
    R32UI: 33334,
    RG8I: 33335,
    RG8UI: 33336,
    RG16I: 33337,
    RG16UI: 33338,
    RG32I: 33339,
    RG32UI: 33340,
    VERTEX_ARRAY_BINDING: 34229,
    R8_SNORM: 36756,
    RG8_SNORM: 36757,
    RGB8_SNORM: 36758,
    RGBA8_SNORM: 36759,
    SIGNED_NORMALIZED: 36764,
    COPY_READ_BUFFER: 36662,
    COPY_WRITE_BUFFER: 36663,
    COPY_READ_BUFFER_BINDING: 36662,
    COPY_WRITE_BUFFER_BINDING: 36663,
    UNIFORM_BUFFER: 35345,
    UNIFORM_BUFFER_BINDING: 35368,
    UNIFORM_BUFFER_START: 35369,
    UNIFORM_BUFFER_SIZE: 35370,
    MAX_VERTEX_UNIFORM_BLOCKS: 35371,
    MAX_FRAGMENT_UNIFORM_BLOCKS: 35373,
    MAX_COMBINED_UNIFORM_BLOCKS: 35374,
    MAX_UNIFORM_BUFFER_BINDINGS: 35375,
    MAX_UNIFORM_BLOCK_SIZE: 35376,
    MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377,
    MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379,
    UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380,
    ACTIVE_UNIFORM_BLOCKS: 35382,
    UNIFORM_TYPE: 35383,
    UNIFORM_SIZE: 35384,
    UNIFORM_BLOCK_INDEX: 35386,
    UNIFORM_OFFSET: 35387,
    UNIFORM_ARRAY_STRIDE: 35388,
    UNIFORM_MATRIX_STRIDE: 35389,
    UNIFORM_IS_ROW_MAJOR: 35390,
    UNIFORM_BLOCK_BINDING: 35391,
    UNIFORM_BLOCK_DATA_SIZE: 35392,
    UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394,
    UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395,
    UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396,
    UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398,
    INVALID_INDEX: 4294967295,
    MAX_VERTEX_OUTPUT_COMPONENTS: 37154,
    MAX_FRAGMENT_INPUT_COMPONENTS: 37157,
    MAX_SERVER_WAIT_TIMEOUT: 37137,
    OBJECT_TYPE: 37138,
    SYNC_CONDITION: 37139,
    SYNC_STATUS: 37140,
    SYNC_FLAGS: 37141,
    SYNC_FENCE: 37142,
    SYNC_GPU_COMMANDS_COMPLETE: 37143,
    UNSIGNALED: 37144,
    SIGNALED: 37145,
    ALREADY_SIGNALED: 37146,
    TIMEOUT_EXPIRED: 37147,
    CONDITION_SATISFIED: 37148,
    WAIT_FAILED: 37149,
    SYNC_FLUSH_COMMANDS_BIT: 1,
    VERTEX_ATTRIB_ARRAY_DIVISOR: 35070,
    ANY_SAMPLES_PASSED: 35887,
    ANY_SAMPLES_PASSED_CONSERVATIVE: 36202,
    SAMPLER_BINDING: 35097,
    RGB10_A2UI: 36975,
    INT_2_10_10_10_REV: 36255,
    TRANSFORM_FEEDBACK: 36386,
    TRANSFORM_FEEDBACK_PAUSED: 36387,
    TRANSFORM_FEEDBACK_ACTIVE: 36388,
    TRANSFORM_FEEDBACK_BINDING: 36389,
    COMPRESSED_R11_EAC: 37488,
    COMPRESSED_SIGNED_R11_EAC: 37489,
    COMPRESSED_RG11_EAC: 37490,
    COMPRESSED_SIGNED_RG11_EAC: 37491,
    COMPRESSED_RGB8_ETC2: 37492,
    COMPRESSED_SRGB8_ETC2: 37493,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37494,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37495,
    COMPRESSED_RGBA8_ETC2_EAC: 37496,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37497,
    TEXTURE_IMMUTABLE_FORMAT: 37167,
    MAX_ELEMENT_INDEX: 36203,
    TEXTURE_IMMUTABLE_LEVELS: 33503,
    MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047
};
const L = Object.freeze(m1);
var Te = {
    BYTE: L.BYTE,
    UNSIGNED_BYTE: L.UNSIGNED_BYTE,
    SHORT: L.SHORT,
    UNSIGNED_SHORT: L.UNSIGNED_SHORT,
    INT: L.INT,
    UNSIGNED_INT: L.UNSIGNED_INT,
    FLOAT: L.FLOAT,
    DOUBLE: L.DOUBLE
};
Te.getSizeInBytes = function(e) {
    switch (e) {
        case Te.BYTE:
            return Int8Array.BYTES_PER_ELEMENT;
        case Te.UNSIGNED_BYTE:
            return Uint8Array.BYTES_PER_ELEMENT;
        case Te.SHORT:
            return Int16Array.BYTES_PER_ELEMENT;
        case Te.UNSIGNED_SHORT:
            return Uint16Array.BYTES_PER_ELEMENT;
        case Te.INT:
            return Int32Array.BYTES_PER_ELEMENT;
        case Te.UNSIGNED_INT:
            return Uint32Array.BYTES_PER_ELEMENT;
        case Te.FLOAT:
            return Float32Array.BYTES_PER_ELEMENT;
        case Te.DOUBLE:
            return Float64Array.BYTES_PER_ELEMENT
    }
};
Te.fromTypedArray = function(e) {
    if (e instanceof Int8Array) return Te.BYTE;
    if (e instanceof Uint8Array) return Te.UNSIGNED_BYTE;
    if (e instanceof Int16Array) return Te.SHORT;
    if (e instanceof Uint16Array) return Te.UNSIGNED_SHORT;
    if (e instanceof Int32Array) return Te.INT;
    if (e instanceof Uint32Array) return Te.UNSIGNED_INT;
    if (e instanceof Float32Array) return Te.FLOAT;
    if (e instanceof Float64Array) return Te.DOUBLE
};
Te.validate = function(e) {
    return l(e) && (e === Te.BYTE || e === Te.UNSIGNED_BYTE || e === Te.SHORT || e === Te.UNSIGNED_SHORT || e === Te.INT || e === Te.UNSIGNED_INT || e === Te.FLOAT || e === Te.DOUBLE)
};
Te.createTypedArray = function(e, t) {
    switch (e) {
        case Te.BYTE:
            return new Int8Array(t);
        case Te.UNSIGNED_BYTE:
            return new Uint8Array(t);
        case Te.SHORT:
            return new Int16Array(t);
        case Te.UNSIGNED_SHORT:
            return new Uint16Array(t);
        case Te.INT:
            return new Int32Array(t);
        case Te.UNSIGNED_INT:
            return new Uint32Array(t);
        case Te.FLOAT:
            return new Float32Array(t);
        case Te.DOUBLE:
            return new Float64Array(t)
    }
};
Te.createArrayBufferView = function(e, t, n, r) {
    switch (n = p(n, 0), r = p(r, (t.byteLength - n) / Te.getSizeInBytes(e)), e) {
        case Te.BYTE:
            return new Int8Array(t, n, r);
        case Te.UNSIGNED_BYTE:
            return new Uint8Array(t, n, r);
        case Te.SHORT:
            return new Int16Array(t, n, r);
        case Te.UNSIGNED_SHORT:
            return new Uint16Array(t, n, r);
        case Te.INT:
            return new Int32Array(t, n, r);
        case Te.UNSIGNED_INT:
            return new Uint32Array(t, n, r);
        case Te.FLOAT:
            return new Float32Array(t, n, r);
        case Te.DOUBLE:
            return new Float64Array(t, n, r)
    }
};
Te.fromName = function(e) {
    switch (e) {
        case "BYTE":
            return Te.BYTE;
        case "UNSIGNED_BYTE":
            return Te.UNSIGNED_BYTE;
        case "SHORT":
            return Te.SHORT;
        case "UNSIGNED_SHORT":
            return Te.UNSIGNED_SHORT;
        case "INT":
            return Te.INT;
        case "UNSIGNED_INT":
            return Te.UNSIGNED_INT;
        case "FLOAT":
            return Te.FLOAT;
        case "DOUBLE":
            return Te.DOUBLE
    }
};
const ee = Object.freeze(Te);

function rn() {
    this.high = u.clone(u.ZERO), this.low = u.clone(u.ZERO)
}
rn.encode = function(e, t) {
    l(t) || (t = {
        high: 0,
        low: 0
    });
    var n;
    return e >= 0 ? (n = Math.floor(e / 65536) * 65536, t.high = n, t.low = e - n) : (n = Math.floor(-e / 65536) * 65536, t.high = -n, t.low = e + n), t
};
var mi = {
    high: 0,
    low: 0
};
rn.fromCartesian = function(e, t) {
    l(t) || (t = new rn);
    var n = t.high,
        r = t.low;
    return rn.encode(e.x, mi), n.x = mi.high, r.x = mi.low, rn.encode(e.y, mi), n.y = mi.high, r.y = mi.low, rn.encode(e.z, mi), n.z = mi.high, r.z = mi.low, t
};
var Df = new rn;
rn.writeElements = function(e, t, n) {
    rn.fromCartesian(e, Df);
    var r = Df.high,
        i = Df.low;
    t[n] = r.x, t[n + 1] = r.y, t[n + 2] = r.z, t[n + 3] = i.x, t[n + 4] = i.y, t[n + 5] = i.z
};

function Xt(e, t, n) {
    this.heading = p(e, 0), this.pitch = p(t, 0), this.roll = p(n, 0)
}
Xt.fromQuaternion = function(e, t) {
    l(t) || (t = new Xt);
    var n = 2 * (e.w * e.y - e.z * e.x),
        r = 1 - 2 * (e.x * e.x + e.y * e.y),
        i = 2 * (e.w * e.x + e.y * e.z),
        a = 1 - 2 * (e.y * e.y + e.z * e.z),
        o = 2 * (e.w * e.z + e.x * e.y);
    return t.heading = -Math.atan2(o, a), t.roll = Math.atan2(i, r), t.pitch = -T.asinClamped(n), t
};
Xt.fromDegrees = function(e, t, n, r) {
    return l(r) || (r = new Xt), r.heading = e * T.RADIANS_PER_DEGREE, r.pitch = t * T.RADIANS_PER_DEGREE, r.roll = n * T.RADIANS_PER_DEGREE, r
};
Xt.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.heading = e.heading, t.pitch = e.pitch, t.roll = e.roll, t) : new Xt(e.heading, e.pitch, e.roll)
};
Xt.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.heading === t.heading && e.pitch === t.pitch && e.roll === t.roll
};
Xt.equalsEpsilon = function(e, t, n, r) {
    return e === t || l(e) && l(t) && T.equalsEpsilon(e.heading, t.heading, n, r) && T.equalsEpsilon(e.pitch, t.pitch, n, r) && T.equalsEpsilon(e.roll, t.roll, n, r)
};
Xt.prototype.clone = function(e) {
    return Xt.clone(this, e)
};
Xt.prototype.equals = function(e) {
    return Xt.equals(this, e)
};
Xt.prototype.equalsEpsilon = function(e, t, n) {
    return Xt.equalsEpsilon(this, e, t, n)
};
Xt.prototype.toString = function() {
    return "(" + this.heading + ", " + this.pitch + ", " + this.roll + ")"
};
var Nn = {
    UNSIGNED_BYTE: L.UNSIGNED_BYTE,
    UNSIGNED_SHORT: L.UNSIGNED_SHORT,
    UNSIGNED_INT: L.UNSIGNED_INT
};
Nn.getSizeInBytes = function(e) {
    switch (e) {
        case Nn.UNSIGNED_BYTE:
            return Uint8Array.BYTES_PER_ELEMENT;
        case Nn.UNSIGNED_SHORT:
            return Uint16Array.BYTES_PER_ELEMENT;
        case Nn.UNSIGNED_INT:
            return Uint32Array.BYTES_PER_ELEMENT
    }
};
Nn.fromSizeInBytes = function(e) {
    switch (e) {
        case 2:
            return Nn.UNSIGNED_SHORT;
        case 4:
            return Nn.UNSIGNED_INT;
        case 1:
            return Nn.UNSIGNED_BYTE
    }
};
Nn.validate = function(e) {
    return l(e) && (e === Nn.UNSIGNED_BYTE || e === Nn.UNSIGNED_SHORT || e === Nn.UNSIGNED_INT)
};
Nn.createTypedArray = function(e, t) {
    return e >= T.SIXTY_FOUR_KILOBYTES ? new Uint32Array(t) : new Uint16Array(t)
};
Nn.createTypedArrayFromArrayBuffer = function(e, t, n, r) {
    return e >= T.SIXTY_FOUR_KILOBYTES ? new Uint32Array(t, n, r) : new Uint16Array(t, n, r)
};
const yt = Object.freeze(Nn);
var Lr = {};
Lr.computeDiscriminant = function(e, t, n) {
    var r = t * t - 4 * e * n;
    return r
};

function c_(e, t, n) {
    var r = e + t;
    return T.sign(e) !== T.sign(t) && Math.abs(r / Math.max(Math.abs(e), Math.abs(t))) < n ? 0 : r
}
Lr.computeRealRoots = function(e, t, n) {
    var r;
    if (e === 0) return t === 0 ? [] : [-n / t];
    if (t === 0) {
        if (n === 0) return [0, 0];
        var i = Math.abs(n),
            a = Math.abs(e);
        if (i < a && i / a < T.EPSILON14) return [0, 0];
        if (i > a && a / i < T.EPSILON14) return [];
        if (r = -n / e, r < 0) return [];
        var o = Math.sqrt(r);
        return [-o, o]
    } else if (n === 0) return r = -t / e, r < 0 ? [r, 0] : [0, r];
    var s = t * t,
        c = 4 * e * n,
        f = c_(s, -c, T.EPSILON14);
    if (f < 0) return [];
    var h = -.5 * c_(t, T.sign(t) * Math.sqrt(f), T.EPSILON14);
    return t > 0 ? [h / e, n / h] : [n / h, h / e]
};
var Us = {};
Us.computeDiscriminant = function(e, t, n, r) {
    var i = e * e,
        a = t * t,
        o = n * n,
        s = r * r,
        c = 18 * e * t * n * r + a * o - 27 * i * s - 4 * (e * o * n + a * t * r);
    return c
};

function If(e, t, n, r) {
    var i = e,
        a = t / 3,
        o = n / 3,
        s = r,
        c = i * o,
        f = a * s,
        h = a * a,
        d = o * o,
        _ = i * o - h,
        v = i * s - a * o,
        m = a * s - d,
        g = 4 * _ * m - v * v,
        y, E;
    if (g < 0) {
        var w, C, A;
        h * f >= c * d ? (w = i, C = _, A = -2 * a * _ + i * v) : (w = s, C = m, A = -s * v + 2 * o * m);
        var x = A < 0 ? -1 : 1,
            P = -x * Math.abs(w) * Math.sqrt(-g);
        E = -A + P;
        var I = E / 2,
            D = I < 0 ? -Math.pow(-I, 1 / 3) : Math.pow(I, 1 / 3),
            O = E === P ? -D : -C / D;
        return y = C <= 0 ? D + O : -A / (D * D + O * O + C), h * f >= c * d ? [(y - a) / i] : [-s / (y + o)]
    }
    var F = _,
        z = -2 * a * _ + i * v,
        b = m,
        M = -s * v + 2 * o * m,
        G = Math.sqrt(g),
        V = Math.sqrt(3) / 2,
        B = Math.abs(Math.atan2(i * G, -z) / 3);
    y = 2 * Math.sqrt(-F);
    var Y = Math.cos(B);
    E = y * Y;
    var j = y * (-Y / 2 - V * Math.sin(B)),
        Z = E + j > 2 * a ? E - a : j - a,
        Q = i,
        ie = Z / Q;
    B = Math.abs(Math.atan2(s * G, -M) / 3), y = 2 * Math.sqrt(-b), Y = Math.cos(B), E = y * Y, j = y * (-Y / 2 - V * Math.sin(B));
    var Ae = -s,
        re = E + j < 2 * o ? E + o : j + o,
        ve = Ae / re,
        qe = Q * re,
        De = -Z * re - Q * Ae,
        _e = Z * Ae,
        Oe = (o * De - a * _e) / (-a * De + o * qe);
    return ie <= Oe ? ie <= ve ? Oe <= ve ? [ie, Oe, ve] : [ie, ve, Oe] : [ve, ie, Oe] : ie <= ve ? [Oe, ie, ve] : Oe <= ve ? [Oe, ve, ie] : [ve, Oe, ie]
}
Us.computeRealRoots = function(e, t, n, r) {
    var i, a;
    if (e === 0) return Lr.computeRealRoots(t, n, r);
    if (t === 0) {
        if (n === 0) {
            if (r === 0) return [0, 0, 0];
            a = -r / e;
            var o = a < 0 ? -Math.pow(-a, 1 / 3) : Math.pow(a, 1 / 3);
            return [o, o, o]
        } else if (r === 0) return i = Lr.computeRealRoots(e, 0, n), i.Length === 0 ? [0] : [i[0], 0, i[1]];
        return If(e, 0, n, r)
    } else {
        if (n === 0) return r === 0 ? (a = -t / e, a < 0 ? [a, 0, 0] : [0, 0, a]) : If(e, t, 0, r);
        if (r === 0) return i = Lr.computeRealRoots(e, t, n), i.length === 0 ? [0] : i[1] <= 0 ? [i[0], i[1], 0] : i[0] >= 0 ? [0, i[0], i[1]] : [i[0], 0, i[1]]
    }
    return If(e, t, n, r)
};
var od = {};
od.computeDiscriminant = function(e, t, n, r, i) {
    var a = e * e,
        o = a * e,
        s = t * t,
        c = s * t,
        f = n * n,
        h = f * n,
        d = r * r,
        _ = d * r,
        v = i * i,
        m = v * i,
        g = s * f * d - 4 * c * _ - 4 * e * h * d + 18 * e * t * n * _ - 27 * a * d * d + 256 * o * m + i * (18 * c * n * r - 4 * s * h + 16 * e * f * f - 80 * e * t * f * r - 6 * e * s * d + 144 * a * n * d) + v * (144 * e * s * n - 27 * s * s - 128 * a * f - 192 * a * t * r);
    return g
};

function Ir(e, t, n, r) {
    var i = e * e,
        a = t - 3 * i / 8,
        o = n - t * e / 2 + i * e / 8,
        s = r - n * e / 4 + t * i / 16 - 3 * i * i / 256,
        c = Us.computeRealRoots(1, 2 * a, a * a - 4 * s, -o * o);
    if (c.length > 0) {
        var f = -e / 4,
            h = c[c.length - 1];
        if (Math.abs(h) < T.EPSILON14) {
            var d = Lr.computeRealRoots(1, a, s);
            if (d.length === 2) {
                var _ = d[0],
                    v = d[1],
                    m;
                if (_ >= 0 && v >= 0) {
                    var g = Math.sqrt(_),
                        y = Math.sqrt(v);
                    return [f - y, f - g, f + g, f + y]
                } else {
                    if (_ >= 0 && v < 0) return m = Math.sqrt(_), [f - m, f + m];
                    if (_ < 0 && v >= 0) return m = Math.sqrt(v), [f - m, f + m]
                }
            }
            return []
        } else if (h > 0) {
            var E = Math.sqrt(h),
                w = (a + h - o / E) / 2,
                C = (a + h + o / E) / 2,
                A = Lr.computeRealRoots(1, E, w),
                x = Lr.computeRealRoots(1, -E, C);
            return A.length !== 0 ? (A[0] += f, A[1] += f, x.length !== 0 ? (x[0] += f, x[1] += f, A[1] <= x[0] ? [A[0], A[1], x[0], x[1]] : x[1] <= A[0] ? [x[0], x[1], A[0], A[1]] : A[0] >= x[0] && A[1] <= x[1] ? [x[0], A[0], A[1], x[1]] : x[0] >= A[0] && x[1] <= A[1] ? [A[0], x[0], x[1], A[1]] : A[0] > x[0] && A[0] < x[1] ? [x[0], A[0], x[1], A[1]] : [A[0], x[0], A[1], x[1]]) : A) : x.length !== 0 ? (x[0] += f, x[1] += f, x) : []
        }
    }
    return []
}

function jo(e, t, n, r) {
    var i = n * n,
        a = t * t,
        o = e * e,
        s = -2 * t,
        c = n * e + a - 4 * r,
        f = o * r - n * t * e + i,
        h = Us.computeRealRoots(1, s, c, f);
    if (h.length > 0) {
        var d = h[0],
            _ = t - d,
            v = _ * _,
            m = e / 2,
            g = _ / 2,
            y = v - 4 * r,
            E = v + 4 * Math.abs(r),
            w = o - 4 * d,
            C = o + 4 * Math.abs(d),
            A, x;
        if (d < 0 || y * C < w * E) {
            var P = Math.sqrt(w);
            A = P / 2, x = P === 0 ? 0 : (e * g - n) / P
        } else {
            var I = Math.sqrt(y);
            A = I === 0 ? 0 : (e * g - n) / I, x = I / 2
        }
        var D, O;
        m === 0 && A === 0 ? (D = 0, O = 0) : T.sign(m) === T.sign(A) ? (D = m + A, O = d / D) : (O = m - A, D = d / O);
        var F, z;
        g === 0 && x === 0 ? (F = 0, z = 0) : T.sign(g) === T.sign(x) ? (F = g + x, z = r / F) : (z = g - x, F = r / z);
        var b = Lr.computeRealRoots(1, D, F),
            M = Lr.computeRealRoots(1, O, z);
        if (b.length !== 0) return M.length !== 0 ? b[1] <= M[0] ? [b[0], b[1], M[0], M[1]] : M[1] <= b[0] ? [M[0], M[1], b[0], b[1]] : b[0] >= M[0] && b[1] <= M[1] ? [M[0], b[0], b[1], M[1]] : M[0] >= b[0] && M[1] <= b[1] ? [b[0], M[0], M[1], b[1]] : b[0] > M[0] && b[0] < M[1] ? [M[0], b[0], M[1], b[1]] : [b[0], M[0], b[1], M[1]] : b;
        if (M.length !== 0) return M
    }
    return []
}
od.computeRealRoots = function(e, t, n, r, i) {
    if (Math.abs(e) < T.EPSILON15) return Us.computeRealRoots(t, n, r, i);
    var a = t / e,
        o = n / e,
        s = r / e,
        c = i / e,
        f = a < 0 ? 1 : 0;
    switch (f += o < 0 ? f + 1 : f, f += s < 0 ? f + 1 : f, f += c < 0 ? f + 1 : f, f) {
        case 0:
            return Ir(a, o, s, c);
        case 1:
            return jo(a, o, s, c);
        case 2:
            return jo(a, o, s, c);
        case 3:
            return Ir(a, o, s, c);
        case 4:
            return Ir(a, o, s, c);
        case 5:
            return jo(a, o, s, c);
        case 6:
            return Ir(a, o, s, c);
        case 7:
            return Ir(a, o, s, c);
        case 8:
            return jo(a, o, s, c);
        case 9:
            return Ir(a, o, s, c);
        case 10:
            return Ir(a, o, s, c);
        case 11:
            return jo(a, o, s, c);
        case 12:
            return Ir(a, o, s, c);
        case 13:
            return Ir(a, o, s, c);
        case 14:
            return Ir(a, o, s, c);
        case 15:
            return Ir(a, o, s, c);
        default:
            return
    }
};

function Ke(e, t) {
    t = u.clone(p(t, u.ZERO)), u.equals(t, u.ZERO) || u.normalize(t, t), this.origin = u.clone(p(e, u.ZERO)), this.direction = t
}
Ke.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.origin = u.clone(e.origin), t.direction = u.clone(e.direction), t) : new Ke(e.origin, e.direction)
};
Ke.getPoint = function(e, t, n) {
    return l(n) || (n = new u), n = u.multiplyByScalar(e.direction, t, n), u.add(e.origin, n, n)
};
var Me = {};
Me.rayPlane = function(e, t, n) {
    l(n) || (n = new u);
    var r = e.origin,
        i = e.direction,
        a = t.normal,
        o = u.dot(a, i);
    if (!(Math.abs(o) < T.EPSILON15)) {
        var s = (-t.distance - u.dot(a, r)) / o;
        if (!(s < 0)) return n = u.multiplyByScalar(i, s, n), u.add(r, n, n)
    }
};
var p1 = new u,
    g1 = new u,
    Fp = new u,
    f_ = new u,
    h_ = new u;
Me.rayTriangleParametric = function(e, t, n, r, i) {
    i = p(i, !1);
    var a = e.origin,
        o = e.direction,
        s = u.subtract(n, t, p1),
        c = u.subtract(r, t, g1),
        f = u.cross(o, c, Fp),
        h = u.dot(s, f),
        d, _, v, m, g;
    if (i) {
        if (h < T.EPSILON6 || (d = u.subtract(a, t, f_), v = u.dot(d, f), v < 0 || v > h) || (_ = u.cross(d, s, h_), m = u.dot(o, _), m < 0 || v + m > h)) return;
        g = u.dot(c, _) / h
    } else {
        if (Math.abs(h) < T.EPSILON6) return;
        var y = 1 / h;
        if (d = u.subtract(a, t, f_), v = u.dot(d, f) * y, v < 0 || v > 1 || (_ = u.cross(d, s, h_), m = u.dot(o, _) * y, m < 0 || v + m > 1)) return;
        g = u.dot(c, _) * y
    }
    return g
};
Me.rayTriangle = function(e, t, n, r, i, a) {
    var o = Me.rayTriangleParametric(e, t, n, r, i);
    if (!(!l(o) || o < 0)) return l(a) || (a = new u), u.multiplyByScalar(e.direction, o, a), u.add(e.origin, a, a)
};
var y1 = new Ke;
Me.lineSegmentTriangle = function(e, t, n, r, i, a, o) {
    var s = y1;
    u.clone(e, s.origin), u.subtract(t, e, s.direction), u.normalize(s.direction, s.direction);
    var c = Me.rayTriangleParametric(s, n, r, i, a);
    if (!(!l(c) || c < 0 || c > u.distance(e, t))) return l(o) || (o = new u), u.multiplyByScalar(s.direction, c, o), u.add(s.origin, o, o)
};

function T1(e, t, n, r) {
    var i = t * t - 4 * e * n;
    if (!(i < 0)) {
        if (i > 0) {
            var a = 1 / (2 * e),
                o = Math.sqrt(i),
                s = (-t + o) * a,
                c = (-t - o) * a;
            return s < c ? (r.root0 = s, r.root1 = c) : (r.root0 = c, r.root1 = s), r
        }
        var f = -t / (2 * e);
        if (f !== 0) return r.root0 = r.root1 = f, r
    }
}
var E1 = {
    root0: 0,
    root1: 0
};

function Lp(e, t, n) {
    l(n) || (n = new Yi);
    var r = e.origin,
        i = e.direction,
        a = t.center,
        o = t.radius * t.radius,
        s = u.subtract(r, a, Fp),
        c = u.dot(i, i),
        f = 2 * u.dot(i, s),
        h = u.magnitudeSquared(s) - o,
        d = T1(c, f, h, E1);
    if (!!l(d)) return n.start = d.root0, n.stop = d.root1, n
}
Me.raySphere = function(e, t, n) {
    if (n = Lp(e, t, n), !(!l(n) || n.stop < 0)) return n.start = Math.max(n.start, 0), n
};
var A1 = new Ke;
Me.lineSegmentSphere = function(e, t, n, r) {
    var i = A1;
    u.clone(e, i.origin);
    var a = u.subtract(t, e, i.direction),
        o = u.magnitude(a);
    if (u.normalize(a, a), r = Lp(i, n, r), !(!l(r) || r.stop < 0 || r.start > o)) return r.start = Math.max(r.start, 0), r.stop = Math.min(r.stop, o), r
};
var C1 = new u,
    w1 = new u;
Me.rayEllipsoid = function(e, t) {
    var n = t.oneOverRadii,
        r = u.multiplyComponents(n, e.origin, C1),
        i = u.multiplyComponents(n, e.direction, w1),
        a = u.magnitudeSquared(r),
        o = u.dot(r, i),
        s, c, f, h, d;
    if (a > 1) {
        if (o >= 0) return;
        var _ = o * o;
        if (s = a - 1, c = u.magnitudeSquared(i), f = c * s, _ < f) return;
        if (_ > f) {
            h = o * o - f, d = -o + Math.sqrt(h);
            var v = d / c,
                m = s / d;
            return v < m ? new Yi(v, m) : {
                start: m,
                stop: v
            }
        }
        var g = Math.sqrt(s / c);
        return new Yi(g, g)
    } else if (a < 1) return s = a - 1, c = u.magnitudeSquared(i), f = c * s, h = o * o - f, d = -o + Math.sqrt(h), new Yi(0, d / c);
    if (o < 0) return c = u.magnitudeSquared(i), new Yi(0, -o / c)
};

function da(e, t, n) {
    var r = e + t;
    return T.sign(e) !== T.sign(t) && Math.abs(r / Math.max(Math.abs(e), Math.abs(t))) < n ? 0 : r
}

function x1(e, t, n, r, i) {
    var a = r * r,
        o = i * i,
        s = (e[N.COLUMN1ROW1] - e[N.COLUMN2ROW2]) * o,
        c = i * (r * da(e[N.COLUMN1ROW0], e[N.COLUMN0ROW1], T.EPSILON15) + t.y),
        f = e[N.COLUMN0ROW0] * a + e[N.COLUMN2ROW2] * o + r * t.x + n,
        h = o * da(e[N.COLUMN2ROW1], e[N.COLUMN1ROW2], T.EPSILON15),
        d = i * (r * da(e[N.COLUMN2ROW0], e[N.COLUMN0ROW2]) + t.z),
        _, v = [];
    if (d === 0 && h === 0) {
        if (_ = Lr.computeRealRoots(s, c, f), _.length === 0) return v;
        var m = _[0],
            g = Math.sqrt(Math.max(1 - m * m, 0));
        if (v.push(new u(r, i * m, i * -g)), v.push(new u(r, i * m, i * g)), _.length === 2) {
            var y = _[1],
                E = Math.sqrt(Math.max(1 - y * y, 0));
            v.push(new u(r, i * y, i * -E)), v.push(new u(r, i * y, i * E))
        }
        return v
    }
    var w = d * d,
        C = h * h,
        A = s * s,
        x = d * h,
        P = A + C,
        I = 2 * (c * s + x),
        D = 2 * f * s + c * c - C + w,
        O = 2 * (f * c - x),
        F = f * f - w;
    if (P === 0 && I === 0 && D === 0 && O === 0) return v;
    _ = od.computeRealRoots(P, I, D, O, F);
    var z = _.length;
    if (z === 0) return v;
    for (var b = 0; b < z; ++b) {
        var M = _[b],
            G = M * M,
            V = Math.max(1 - G, 0),
            B = Math.sqrt(V),
            Y;
        T.sign(s) === T.sign(f) ? Y = da(s * G + f, c * M, T.EPSILON12) : T.sign(f) === T.sign(c * M) ? Y = da(s * G, c * M + f, T.EPSILON12) : Y = da(s * G + c * M, f, T.EPSILON12);
        var j = da(h * M, d, T.EPSILON15),
            Z = Y * j;
        Z < 0 ? v.push(new u(r, i * M, i * B)) : Z > 0 ? v.push(new u(r, i * M, i * -B)) : B !== 0 ? (v.push(new u(r, i * M, i * -B)), v.push(new u(r, i * M, i * B)), ++b) : v.push(new u(r, i * M, i * B))
    }
    return v
}
var Pf = new u,
    l_ = new u,
    d_ = new u,
    iu = new u,
    S1 = new u,
    R1 = new N,
    D1 = new N,
    I1 = new N,
    P1 = new N,
    O1 = new N,
    __ = new N,
    v_ = new N,
    m_ = new u,
    M1 = new u,
    N1 = new K;
Me.grazingAltitudeLocation = function(e, t) {
    var n = e.origin,
        r = e.direction;
    if (!u.equals(n, u.ZERO)) {
        var i = t.geodeticSurfaceNormal(n, Pf);
        if (u.dot(r, i) >= 0) return n
    }
    var a = l(this.rayEllipsoid(e, t)),
        o = t.transformPositionToScaledSpace(r, Pf),
        s = u.normalize(o, o),
        c = u.mostOrthogonalAxis(o, iu),
        f = u.normalize(u.cross(c, s, l_), l_),
        h = u.normalize(u.cross(s, f, d_), d_),
        d = R1;
    d[0] = s.x, d[1] = s.y, d[2] = s.z, d[3] = f.x, d[4] = f.y, d[5] = f.z, d[6] = h.x, d[7] = h.y, d[8] = h.z;
    var _ = N.transpose(d, D1),
        v = N.fromScale(t.radii, I1),
        m = N.fromScale(t.oneOverRadii, P1),
        g = O1;
    g[0] = 0, g[1] = -r.z, g[2] = r.y, g[3] = r.z, g[4] = 0, g[5] = -r.x, g[6] = -r.y, g[7] = r.x, g[8] = 0;
    var y = N.multiply(N.multiply(_, m, __), g, __),
        E = N.multiply(N.multiply(y, v, v_), d, v_),
        w = N.multiplyByVector(y, n, S1),
        C = x1(E, u.negate(w, Pf), 0, 0, 1),
        A, x, P = C.length;
    if (P > 0) {
        for (var I = u.clone(u.ZERO, M1), D = Number.NEGATIVE_INFINITY, O = 0; O < P; ++O) {
            A = N.multiplyByVector(v, N.multiplyByVector(d, C[O], m_), m_);
            var F = u.normalize(u.subtract(A, n, iu), iu),
                z = u.dot(F, r);
            z > D && (D = z, I = u.clone(A, I))
        }
        var b = t.cartesianToCartographic(I, N1);
        return D = T.clamp(D, 0, 1), x = u.magnitude(u.subtract(I, n, iu)) * Math.sqrt(1 - D * D), x = a ? -x : x, b.height = x, t.cartographicToCartesian(b, new u)
    }
};
var b1 = new u;
Me.lineSegmentPlane = function(e, t, n, r) {
    l(r) || (r = new u);
    var i = u.subtract(t, e, b1),
        a = n.normal,
        o = u.dot(a, i);
    if (!(Math.abs(o) < T.EPSILON6)) {
        var s = u.dot(a, e),
            c = -(n.distance + s) / o;
        if (!(c < 0 || c > 1)) return u.multiplyByScalar(i, c, r), u.add(e, r, r), r
    }
};
Me.trianglePlaneIntersection = function(e, t, n, r) {
    var i = r.normal,
        a = r.distance,
        o = u.dot(i, e) + a < 0,
        s = u.dot(i, t) + a < 0,
        c = u.dot(i, n) + a < 0,
        f = 0;
    f += o ? 1 : 0, f += s ? 1 : 0, f += c ? 1 : 0;
    var h, d;
    if ((f === 1 || f === 2) && (h = new u, d = new u), f === 1) {
        if (o) return Me.lineSegmentPlane(e, t, r, h), Me.lineSegmentPlane(e, n, r, d), {
            positions: [e, t, n, h, d],
            indices: [0, 3, 4, 1, 2, 4, 1, 4, 3]
        };
        if (s) return Me.lineSegmentPlane(t, n, r, h), Me.lineSegmentPlane(t, e, r, d), {
            positions: [e, t, n, h, d],
            indices: [1, 3, 4, 2, 0, 4, 2, 4, 3]
        };
        if (c) return Me.lineSegmentPlane(n, e, r, h), Me.lineSegmentPlane(n, t, r, d), {
            positions: [e, t, n, h, d],
            indices: [2, 3, 4, 0, 1, 4, 0, 4, 3]
        }
    } else if (f === 2)
        if (o)
            if (s) {
                if (!c) return Me.lineSegmentPlane(e, n, r, h), Me.lineSegmentPlane(t, n, r, d), {
                    positions: [e, t, n, h, d],
                    indices: [0, 1, 4, 0, 4, 3, 2, 3, 4]
                }
            } else return Me.lineSegmentPlane(n, t, r, h), Me.lineSegmentPlane(e, t, r, d), {
                positions: [e, t, n, h, d],
                indices: [2, 0, 4, 2, 4, 3, 1, 3, 4]
            };
    else return Me.lineSegmentPlane(t, e, r, h), Me.lineSegmentPlane(n, e, r, d), {
        positions: [e, t, n, h, d],
        indices: [1, 2, 4, 1, 4, 3, 0, 3, 4]
    }
};
var F1 = {
    SHIFT: 0,
    CTRL: 1,
    ALT: 2
};
const gr = Object.freeze(F1);

function at(e, t, n, r) {
    this.near = p(e, 0), this.nearValue = p(t, 0), this.far = p(n, 1), this.farValue = p(r, 0)
}
at.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.near = e.near, t.nearValue = e.nearValue, t.far = e.far, t.farValue = e.farValue, t) : new at(e.near, e.nearValue, e.far, e.farValue)
};
at.packedLength = 4;
at.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.near, t[n++] = e.nearValue, t[n++] = e.far, t[n] = e.farValue, t
};
at.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new at), n.near = e[t++], n.nearValue = e[t++], n.far = e[t++], n.farValue = e[t], n
};
at.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.near === t.near && e.nearValue === t.nearValue && e.far === t.far && e.farValue === t.farValue
};
at.prototype.clone = function(e) {
    return at.clone(this, e)
};
at.prototype.equals = function(e) {
    return at.equals(this, e)
};

function Ne(e, t) {
    this.normal = u.clone(e), this.distance = t
}
Ne.fromPointNormal = function(e, t, n) {
    var r = -u.dot(t, e);
    return l(n) ? (u.clone(t, n.normal), n.distance = r, n) : new Ne(t, r)
};
var L1 = new u;
Ne.fromCartesian4 = function(e, t) {
    var n = u.fromCartesian4(e, L1),
        r = e.w;
    return l(t) ? (u.clone(n, t.normal), t.distance = r, t) : new Ne(n, r)
};
Ne.getPointDistance = function(e, t) {
    return u.dot(e.normal, t) + e.distance
};
var U1 = new u;
Ne.projectPointOntoPlane = function(e, t, n) {
    l(n) || (n = new u);
    var r = Ne.getPointDistance(e, t),
        i = u.multiplyByScalar(e.normal, r, U1);
    return u.subtract(t, i, n)
};
var z1 = new S,
    B1 = new U,
    V1 = new u;
Ne.transform = function(e, t, n) {
    var r = e.normal,
        i = e.distance,
        a = S.inverseTranspose(t, z1),
        o = U.fromElements(r.x, r.y, r.z, i, B1);
    o = S.multiplyByVector(a, o, o);
    var s = u.fromCartesian4(o, V1);
    return o = U.divideByScalar(o, u.magnitude(s), o), Ne.fromCartesian4(o, n)
};
Ne.clone = function(e, t) {
    return l(t) ? (u.clone(e.normal, t.normal), t.distance = e.distance, t) : new Ne(e.normal, e.distance)
};
Ne.equals = function(e, t) {
    return e.distance === t.distance && u.equals(e.normal, t.normal)
};
Ne.ORIGIN_XY_PLANE = Object.freeze(new Ne(u.UNIT_Z, 0));
Ne.ORIGIN_YZ_PLANE = Object.freeze(new Ne(u.UNIT_X, 0));
Ne.ORIGIN_ZX_PLANE = Object.freeze(new Ne(u.UNIT_Y, 0));

function Pn(e) {
    this.planes = p(e, [])
}
var As = [new u, new u, new u];
u.clone(u.UNIT_X, As[0]);
u.clone(u.UNIT_Y, As[1]);
u.clone(u.UNIT_Z, As[2]);
var Ui = new u,
    G1 = new u,
    Up = new Ne(new u(1, 0, 0), 0);
Pn.fromBoundingSphere = function(e, t) {
    l(t) || (t = new Pn);
    var n = As.length,
        r = t.planes;
    r.length = 2 * n;
    for (var i = e.center, a = e.radius, o = 0, s = 0; s < n; ++s) {
        var c = As[s],
            f = r[o],
            h = r[o + 1];
        l(f) || (f = r[o] = new U), l(h) || (h = r[o + 1] = new U), u.multiplyByScalar(c, -a, Ui), u.add(i, Ui, Ui), f.x = c.x, f.y = c.y, f.z = c.z, f.w = -u.dot(c, Ui), u.multiplyByScalar(c, a, Ui), u.add(i, Ui, Ui), h.x = -c.x, h.y = -c.y, h.z = -c.z, h.w = -u.dot(u.negate(c, G1), Ui), o += 2
    }
    return t
};
Pn.prototype.computeVisibility = function(e) {
    for (var t = this.planes, n = !1, r = 0, i = t.length; r < i; ++r) {
        var a = e.intersectPlane(Ne.fromCartesian4(t[r], Up));
        if (a === nt.OUTSIDE) return nt.OUTSIDE;
        a === nt.INTERSECTING && (n = !0)
    }
    return n ? nt.INTERSECTING : nt.INSIDE
};
Pn.prototype.computeVisibilityWithPlaneMask = function(e, t) {
    if (t === Pn.MASK_OUTSIDE || t === Pn.MASK_INSIDE) return t;
    for (var n = Pn.MASK_INSIDE, r = this.planes, i = 0, a = r.length; i < a; ++i) {
        var o = i < 31 ? 1 << i : 0;
        if (!(i < 31 && (t & o) === 0)) {
            var s = e.intersectPlane(Ne.fromCartesian4(r[i], Up));
            if (s === nt.OUTSIDE) return Pn.MASK_OUTSIDE;
            s === nt.INTERSECTING && (n |= o)
        }
    }
    return n
};
Pn.MASK_OUTSIDE = 4294967295;
Pn.MASK_INSIDE = 0;
Pn.MASK_INDETERMINATE = 2147483647;

function Wn(e) {
    e = p(e, p.EMPTY_OBJECT), this.left = e.left, this._left = void 0, this.right = e.right, this._right = void 0, this.top = e.top, this._top = void 0, this.bottom = e.bottom, this._bottom = void 0, this.near = p(e.near, 1), this._near = this.near, this.far = p(e.far, 5e8), this._far = this.far, this._cullingVolume = new Pn, this._orthographicMatrix = new S
}

function zp(e) {
    (e.top !== e._top || e.bottom !== e._bottom || e.left !== e._left || e.right !== e._right || e.near !== e._near || e.far !== e._far) && (e._left = e.left, e._right = e.right, e._top = e.top, e._bottom = e.bottom, e._near = e.near, e._far = e.far, e._orthographicMatrix = S.computeOrthographicOffCenter(e.left, e.right, e.bottom, e.top, e.near, e.far, e._orthographicMatrix))
}
Object.defineProperties(Wn.prototype, {
    projectionMatrix: {
        get: function() {
            return zp(this), this._orthographicMatrix
        }
    }
});
var H1 = new u,
    k1 = new u,
    W1 = new u,
    Of = new u;
Wn.prototype.computeCullingVolume = function(e, t, n) {
    var r = this._cullingVolume.planes,
        i = this.top,
        a = this.bottom,
        o = this.right,
        s = this.left,
        c = this.near,
        f = this.far,
        h = u.cross(t, n, H1);
    u.normalize(h, h);
    var d = k1;
    u.multiplyByScalar(t, c, d), u.add(e, d, d);
    var _ = W1;
    u.multiplyByScalar(h, s, _), u.add(d, _, _);
    var v = r[0];
    return l(v) || (v = r[0] = new U), v.x = h.x, v.y = h.y, v.z = h.z, v.w = -u.dot(h, _), u.multiplyByScalar(h, o, _), u.add(d, _, _), v = r[1], l(v) || (v = r[1] = new U), v.x = -h.x, v.y = -h.y, v.z = -h.z, v.w = -u.dot(u.negate(h, Of), _), u.multiplyByScalar(n, a, _), u.add(d, _, _), v = r[2], l(v) || (v = r[2] = new U), v.x = n.x, v.y = n.y, v.z = n.z, v.w = -u.dot(n, _), u.multiplyByScalar(n, i, _), u.add(d, _, _), v = r[3], l(v) || (v = r[3] = new U), v.x = -n.x, v.y = -n.y, v.z = -n.z, v.w = -u.dot(u.negate(n, Of), _), v = r[4], l(v) || (v = r[4] = new U), v.x = t.x, v.y = t.y, v.z = t.z, v.w = -u.dot(t, d), u.multiplyByScalar(t, f, _), u.add(e, _, _), v = r[5], l(v) || (v = r[5] = new U), v.x = -t.x, v.y = -t.y, v.z = -t.z, v.w = -u.dot(u.negate(t, Of), _), this._cullingVolume
};
Wn.prototype.getPixelDimensions = function(e, t, n, r, i) {
    zp(this);
    var a = this.right - this.left,
        o = this.top - this.bottom,
        s = r * a / e,
        c = r * o / t;
    return i.x = s, i.y = c, i
};
Wn.prototype.clone = function(e) {
    return l(e) || (e = new Wn), e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e._left = void 0, e._right = void 0, e._top = void 0, e._bottom = void 0, e._near = void 0, e._far = void 0, e
};
Wn.prototype.equals = function(e) {
    return l(e) && e instanceof Wn && this.right === e.right && this.left === e.left && this.top === e.top && this.bottom === e.bottom && this.near === e.near && this.far === e.far
};
Wn.prototype.equalsEpsilon = function(e, t, n) {
    return e === this || l(e) && e instanceof Wn && T.equalsEpsilon(this.right, e.right, t, n) && T.equalsEpsilon(this.left, e.left, t, n) && T.equalsEpsilon(this.top, e.top, t, n) && T.equalsEpsilon(this.bottom, e.bottom, t, n) && T.equalsEpsilon(this.near, e.near, t, n) && T.equalsEpsilon(this.far, e.far, t, n)
};

function lt(e) {
    e = p(e, p.EMPTY_OBJECT), this._offCenterFrustum = new Wn, this.width = e.width, this._width = void 0, this.aspectRatio = e.aspectRatio, this._aspectRatio = void 0, this.near = p(e.near, 1), this._near = this.near, this.far = p(e.far, 5e8), this._far = this.far
}
lt.packedLength = 4;
lt.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.width, t[n++] = e.aspectRatio, t[n++] = e.near, t[n] = e.far, t
};
lt.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new lt), n.width = e[t++], n.aspectRatio = e[t++], n.near = e[t++], n.far = e[t], n
};

function Pa(e) {
    var t = e._offCenterFrustum;
    if (e.width !== e._width || e.aspectRatio !== e._aspectRatio || e.near !== e._near || e.far !== e._far) {
        e._aspectRatio = e.aspectRatio, e._width = e.width, e._near = e.near, e._far = e.far;
        var n = 1 / e.aspectRatio;
        t.right = e.width * .5, t.left = -t.right, t.top = n * t.right, t.bottom = -t.top, t.near = e.near, t.far = e.far
    }
}
Object.defineProperties(lt.prototype, {
    projectionMatrix: {
        get: function() {
            return Pa(this), this._offCenterFrustum.projectionMatrix
        }
    }
});
lt.prototype.computeCullingVolume = function(e, t, n) {
    return Pa(this), this._offCenterFrustum.computeCullingVolume(e, t, n)
};
lt.prototype.getPixelDimensions = function(e, t, n, r, i) {
    return Pa(this), this._offCenterFrustum.getPixelDimensions(e, t, n, r, i)
};
lt.prototype.clone = function(e) {
    return l(e) || (e = new lt), e.aspectRatio = this.aspectRatio, e.width = this.width, e.near = this.near, e.far = this.far, e._aspectRatio = void 0, e._width = void 0, e._near = void 0, e._far = void 0, this._offCenterFrustum.clone(e._offCenterFrustum), e
};
lt.prototype.equals = function(e) {
    return !l(e) || !(e instanceof lt) ? !1 : (Pa(this), Pa(e), this.width === e.width && this.aspectRatio === e.aspectRatio && this._offCenterFrustum.equals(e._offCenterFrustum))
};
lt.prototype.equalsEpsilon = function(e, t, n) {
    return !l(e) || !(e instanceof lt) ? !1 : (Pa(this), Pa(e), T.equalsEpsilon(this.width, e.width, t, n) && T.equalsEpsilon(this.aspectRatio, e.aspectRatio, t, n) && this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum, t, n))
};

function X(e, t, n, r) {
    this.x = p(e, 0), this.y = p(t, 0), this.z = p(n, 0), this.w = p(r, 0)
}
var Zo = new u;
X.fromAxisAngle = function(e, t, n) {
    var r = t / 2,
        i = Math.sin(r);
    Zo = u.normalize(e, Zo);
    var a = Zo.x * i,
        o = Zo.y * i,
        s = Zo.z * i,
        c = Math.cos(r);
    return l(n) ? (n.x = a, n.y = o, n.z = s, n.w = c, n) : new X(a, o, s, c)
};
var q1 = [1, 2, 0],
    Y1 = new Array(3);
X.fromRotationMatrix = function(e, t) {
    var n, r, i, a, o, s = e[N.COLUMN0ROW0],
        c = e[N.COLUMN1ROW1],
        f = e[N.COLUMN2ROW2],
        h = s + c + f;
    if (h > 0) n = Math.sqrt(h + 1), o = .5 * n, n = .5 / n, r = (e[N.COLUMN1ROW2] - e[N.COLUMN2ROW1]) * n, i = (e[N.COLUMN2ROW0] - e[N.COLUMN0ROW2]) * n, a = (e[N.COLUMN0ROW1] - e[N.COLUMN1ROW0]) * n;
    else {
        var d = q1,
            _ = 0;
        c > s && (_ = 1), f > s && f > c && (_ = 2);
        var v = d[_],
            m = d[v];
        n = Math.sqrt(e[N.getElementIndex(_, _)] - e[N.getElementIndex(v, v)] - e[N.getElementIndex(m, m)] + 1);
        var g = Y1;
        g[_] = .5 * n, n = .5 / n, o = (e[N.getElementIndex(m, v)] - e[N.getElementIndex(v, m)]) * n, g[v] = (e[N.getElementIndex(v, _)] + e[N.getElementIndex(_, v)]) * n, g[m] = (e[N.getElementIndex(m, _)] + e[N.getElementIndex(_, m)]) * n, r = -g[0], i = -g[1], a = -g[2]
    }
    return l(t) ? (t.x = r, t.y = i, t.z = a, t.w = o, t) : new X(r, i, a, o)
};
var p_ = new X,
    g_ = new X,
    Mf = new X,
    y_ = new X;
X.fromHeadingPitchRoll = function(e, t) {
    return y_ = X.fromAxisAngle(u.UNIT_X, e.roll, p_), Mf = X.fromAxisAngle(u.UNIT_Y, -e.pitch, t), t = X.multiply(Mf, y_, Mf), g_ = X.fromAxisAngle(u.UNIT_Z, -e.heading, p_), X.multiply(g_, t, t)
};
var au = new u,
    Nf = new u,
    Nr = new X,
    T_ = new X,
    ou = new X;
X.packedLength = 4;
X.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.x, t[n++] = e.y, t[n++] = e.z, t[n] = e.w, t
};
X.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new X), n.x = e[t], n.y = e[t + 1], n.z = e[t + 2], n.w = e[t + 3], n
};
X.packedInterpolationLength = 3;
X.convertPackedArrayForInterpolation = function(e, t, n, r) {
    X.unpack(e, n * 4, ou), X.conjugate(ou, ou);
    for (var i = 0, a = n - t + 1; i < a; i++) {
        var o = i * 3;
        X.unpack(e, (t + i) * 4, Nr), X.multiply(Nr, ou, Nr), Nr.w < 0 && X.negate(Nr, Nr), X.computeAxis(Nr, au);
        var s = X.computeAngle(Nr);
        l(r) || (r = []), r[o] = au.x * s, r[o + 1] = au.y * s, r[o + 2] = au.z * s
    }
};
X.unpackInterpolationResult = function(e, t, n, r, i) {
    l(i) || (i = new X), u.fromArray(e, 0, Nf);
    var a = u.magnitude(Nf);
    return X.unpack(t, r * 4, T_), a === 0 ? X.clone(X.IDENTITY, Nr) : X.fromAxisAngle(Nf, a, Nr), X.multiply(Nr, T_, i)
};
X.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t) : new X(e.x, e.y, e.z, e.w)
};
X.conjugate = function(e, t) {
    return t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w, t
};
X.magnitudeSquared = function(e) {
    return e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w
};
X.magnitude = function(e) {
    return Math.sqrt(X.magnitudeSquared(e))
};
X.normalize = function(e, t) {
    var n = 1 / X.magnitude(e),
        r = e.x * n,
        i = e.y * n,
        a = e.z * n,
        o = e.w * n;
    return t.x = r, t.y = i, t.z = a, t.w = o, t
};
X.inverse = function(e, t) {
    var n = X.magnitudeSquared(e);
    return t = X.conjugate(e, t), X.multiplyByScalar(t, 1 / n, t)
};
X.add = function(e, t, n) {
    return n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z, n.w = e.w + t.w, n
};
X.subtract = function(e, t, n) {
    return n.x = e.x - t.x, n.y = e.y - t.y, n.z = e.z - t.z, n.w = e.w - t.w, n
};
X.negate = function(e, t) {
    return t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = -e.w, t
};
X.dot = function(e, t) {
    return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w
};
X.multiply = function(e, t, n) {
    var r = e.x,
        i = e.y,
        a = e.z,
        o = e.w,
        s = t.x,
        c = t.y,
        f = t.z,
        h = t.w,
        d = o * s + r * h + i * f - a * c,
        _ = o * c - r * f + i * h + a * s,
        v = o * f + r * c - i * s + a * h,
        m = o * h - r * s - i * c - a * f;
    return n.x = d, n.y = _, n.z = v, n.w = m, n
};
X.multiplyByScalar = function(e, t, n) {
    return n.x = e.x * t, n.y = e.y * t, n.z = e.z * t, n.w = e.w * t, n
};
X.divideByScalar = function(e, t, n) {
    return n.x = e.x / t, n.y = e.y / t, n.z = e.z / t, n.w = e.w / t, n
};
X.computeAxis = function(e, t) {
    var n = e.w;
    if (Math.abs(n - 1) < T.EPSILON6) return t.x = t.y = t.z = 0, t;
    var r = 1 / Math.sqrt(1 - n * n);
    return t.x = e.x * r, t.y = e.y * r, t.z = e.z * r, t
};
X.computeAngle = function(e) {
    return Math.abs(e.w - 1) < T.EPSILON6 ? 0 : 2 * Math.acos(e.w)
};
var bf = new X;
X.lerp = function(e, t, n, r) {
    return bf = X.multiplyByScalar(t, n, bf), r = X.multiplyByScalar(e, 1 - n, r), X.add(bf, r, r)
};
var E_ = new X,
    Ff = new X,
    Lf = new X;
X.slerp = function(e, t, n, r) {
    var i = X.dot(e, t),
        a = t;
    if (i < 0 && (i = -i, a = E_ = X.negate(t, E_)), 1 - i < T.EPSILON6) return X.lerp(e, a, n, r);
    var o = Math.acos(i);
    return Ff = X.multiplyByScalar(e, Math.sin((1 - n) * o), Ff), Lf = X.multiplyByScalar(a, Math.sin(n * o), Lf), r = X.add(Ff, Lf, r), X.multiplyByScalar(r, 1 / Math.sin(o), r)
};
X.log = function(e, t) {
    var n = T.acosClamped(e.w),
        r = 0;
    return n !== 0 && (r = n / Math.sin(n)), u.multiplyByScalar(e, r, t)
};
X.exp = function(e, t) {
    var n = u.magnitude(e),
        r = 0;
    return n !== 0 && (r = Math.sin(n) / n), t.x = e.x * r, t.y = e.y * r, t.z = e.z * r, t.w = Math.cos(n), t
};
var X1 = new u,
    j1 = new u,
    ms = new X,
    lo = new X;
X.computeInnerQuadrangle = function(e, t, n, r) {
    var i = X.conjugate(t, ms);
    X.multiply(i, n, lo);
    var a = X.log(lo, X1);
    X.multiply(i, e, lo);
    var o = X.log(lo, j1);
    return u.add(a, o, a), u.multiplyByScalar(a, .25, a), u.negate(a, a), X.exp(a, ms), X.multiply(t, ms, r)
};
X.squad = function(e, t, n, r, i, a) {
    var o = X.slerp(e, t, i, ms),
        s = X.slerp(n, r, i, lo);
    return X.slerp(o, s, 2 * i * (1 - i), a)
};
var Z1 = new X,
    Bp = 1.9011074535173003,
    Dc = An.supportsTypedArrays() ? new Float32Array(8) : [],
    Ic = An.supportsTypedArrays() ? new Float32Array(8) : [],
    pi = An.supportsTypedArrays() ? new Float32Array(8) : [],
    gi = An.supportsTypedArrays() ? new Float32Array(8) : [];
for (var Ko = 0; Ko < 7; ++Ko) {
    var Uf = Ko + 1,
        A_ = 2 * Uf + 1;
    Dc[Ko] = 1 / (Uf * A_), Ic[Ko] = Uf / A_
}
Dc[7] = Bp / (8 * 17);
Ic[7] = Bp * 8 / 17;
X.fastSlerp = function(e, t, n, r) {
    var i = X.dot(e, t),
        a;
    i >= 0 ? a = 1 : (a = -1, i = -i);
    for (var o = i - 1, s = 1 - n, c = n * n, f = s * s, h = 7; h >= 0; --h) pi[h] = (Dc[h] * c - Ic[h]) * o, gi[h] = (Dc[h] * f - Ic[h]) * o;
    var d = a * n * (1 + pi[0] * (1 + pi[1] * (1 + pi[2] * (1 + pi[3] * (1 + pi[4] * (1 + pi[5] * (1 + pi[6] * (1 + pi[7])))))))),
        _ = s * (1 + gi[0] * (1 + gi[1] * (1 + gi[2] * (1 + gi[3] * (1 + gi[4] * (1 + gi[5] * (1 + gi[6] * (1 + gi[7])))))))),
        v = X.multiplyByScalar(e, _, Z1);
    return X.multiplyByScalar(t, d, r), X.add(v, r, r)
};
X.fastSquad = function(e, t, n, r, i, a) {
    var o = X.fastSlerp(e, t, i, ms),
        s = X.fastSlerp(n, r, i, lo);
    return X.fastSlerp(o, s, 2 * i * (1 - i), a)
};
X.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w
};
X.equalsEpsilon = function(e, t, n) {
    return n = p(n, 0), e === t || l(e) && l(t) && Math.abs(e.x - t.x) <= n && Math.abs(e.y - t.y) <= n && Math.abs(e.z - t.z) <= n && Math.abs(e.w - t.w) <= n
};
X.ZERO = Object.freeze(new X(0, 0, 0, 0));
X.IDENTITY = Object.freeze(new X(0, 0, 0, 1));
X.prototype.clone = function(e) {
    return X.clone(this, e)
};
X.prototype.equals = function(e) {
    return X.equals(this, e)
};
X.prototype.equalsEpsilon = function(e, t) {
    return X.equalsEpsilon(this, e, t)
};
X.prototype.toString = function() {
    return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")"
};

function Zi() {
    this._array = [], this._hash = {}
}
Object.defineProperties(Zi.prototype, {
    length: {
        get: function() {
            return this._array.length
        }
    },
    values: {
        get: function() {
            return this._array
        }
    }
});
Zi.prototype.contains = function(e) {
    return l(this._hash[e])
};
Zi.prototype.set = function(e, t) {
    var n = this._hash[e];
    t !== n && (this.remove(e), this._hash[e] = t, this._array.push(t))
};
Zi.prototype.get = function(e) {
    return this._hash[e]
};
Zi.prototype.remove = function(e) {
    var t = this._hash[e],
        n = l(t);
    if (n) {
        var r = this._array;
        r.splice(r.indexOf(t), 1), delete this._hash[e]
    }
    return n
};
Zi.prototype.removeAll = function() {
    var e = this._array;
    e.length > 0 && (this._hash = {}, e.length = 0)
};

function K1() {
    return !0
}

function Pe(e, t) {
    function n() {}
    for (var r in e) typeof e[r] == "function" && (e[r] = n);
    e.isDestroyed = K1
}
var al;
typeof performance < "u" && typeof performance.now == "function" && isFinite(performance.now()) ? al = function() {
    return performance.now()
} : al = function() {
    return Date.now()
};
const bn = al;
var $1 = {
    LEFT_DOWN: 0,
    LEFT_UP: 1,
    LEFT_CLICK: 2,
    LEFT_DOUBLE_CLICK: 3,
    RIGHT_DOWN: 5,
    RIGHT_UP: 6,
    RIGHT_CLICK: 7,
    MIDDLE_DOWN: 10,
    MIDDLE_UP: 11,
    MIDDLE_CLICK: 12,
    MOUSE_MOVE: 15,
    WHEEL: 16,
    PINCH_START: 17,
    PINCH_END: 18,
    PINCH_MOVE: 19
};
const ot = Object.freeze($1);

function ta(e, t, n) {
    var r = e._element;
    if (r === document) return n.x = t.clientX, n.y = t.clientY, n;
    var i = r.getBoundingClientRect();
    return n.x = t.clientX - i.left, n.y = t.clientY - i.top, n
}

function sd(e, t) {
    var n = e;
    return l(t) && (n += "+" + t), n
}

function Ua(e) {
    if (e.shiftKey) return gr.SHIFT;
    if (e.ctrlKey) return gr.CTRL;
    if (e.altKey) return gr.ALT
}
var Vt = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};

function jn(e, t, n, r) {
    function i(a) {
        r(e, a)
    }
    An.isInternetExplorer() ? n.addEventListener(t, i, !1) : n.addEventListener(t, i, {
        capture: !1,
        passive: !1
    }), e._removalFunctions.push(function() {
        n.removeEventListener(t, i, !1)
    })
}

function J1(e) {
    var t = e._element,
        n = l(t.disableRootEvents) ? t : document;
    An.supportsPointerEvents() ? (jn(e, "pointerdown", t, iA), jn(e, "pointerup", t, M_), jn(e, "pointermove", t, aA), jn(e, "pointercancel", t, M_)) : (jn(e, "mousedown", t, Vp), jn(e, "mouseup", n, Gp), jn(e, "mousemove", n, Hp), jn(e, "touchstart", t, nA), jn(e, "touchend", n, R_), jn(e, "touchmove", n, rA), jn(e, "touchcancel", n, R_)), jn(e, "dblclick", t, eA);
    var r;
    "onwheel" in t ? r = "wheel" : document.onmousewheel !== void 0 ? r = "mousewheel" : r = "DOMMouseScroll", jn(e, r, t, tA)
}

function Q1(e) {
    for (var t = e._removalFunctions, n = 0; n < t.length; ++n) t[n]()
}
var C_ = {
    position: new R
};

function ud(e) {
    e._lastSeenTouchEvent = bn()
}

function cd(e) {
    return bn() - e._lastSeenTouchEvent > Vr.mouseEmulationIgnoreMilliseconds
}

function ol(e, t, n) {
    var r = e.x - t.x,
        i = e.y - t.y,
        a = Math.sqrt(r * r + i * i);
    return a < n
}

function Vp(e, t) {
    if (!!cd(e)) {
        var n = t.button;
        e._buttonDown[n] = !0;
        var r;
        if (n === Vt.LEFT) r = ot.LEFT_DOWN;
        else if (n === Vt.MIDDLE) r = ot.MIDDLE_DOWN;
        else if (n === Vt.RIGHT) r = ot.RIGHT_DOWN;
        else return;
        var i = ta(e, t, e._primaryPosition);
        R.clone(i, e._primaryStartPosition), R.clone(i, e._primaryPreviousPosition);
        var a = Ua(t),
            o = e.getInputAction(r, a);
        l(o) && (R.clone(i, C_.position), o(C_), t.preventDefault())
    }
}
var w_ = {
        position: new R
    },
    x_ = {
        position: new R
    };

function zf(e, t, n, r) {
    var i = Ua(r),
        a = e.getInputAction(t, i),
        o = e.getInputAction(n, i);
    if (l(a) || l(o)) {
        var s = ta(e, r, e._primaryPosition);
        if (l(a) && (R.clone(s, w_.position), a(w_)), l(o)) {
            var c = e._primaryStartPosition;
            ol(c, s, e._clickPixelTolerance) && (R.clone(s, x_.position), o(x_))
        }
    }
}

function Gp(e, t) {
    if (!!cd(e)) {
        var n = t.button;
        n !== Vt.LEFT && n !== Vt.MIDDLE && n !== Vt.RIGHT || (e._buttonDown[Vt.LEFT] && (zf(e, ot.LEFT_UP, ot.LEFT_CLICK, t), e._buttonDown[Vt.LEFT] = !1), e._buttonDown[Vt.MIDDLE] && (zf(e, ot.MIDDLE_UP, ot.MIDDLE_CLICK, t), e._buttonDown[Vt.MIDDLE] = !1), e._buttonDown[Vt.RIGHT] && (zf(e, ot.RIGHT_UP, ot.RIGHT_CLICK, t), e._buttonDown[Vt.RIGHT] = !1))
    }
}
var Bf = {
    startPosition: new R,
    endPosition: new R
};

function Hp(e, t) {
    if (!!cd(e)) {
        var n = Ua(t),
            r = ta(e, t, e._primaryPosition),
            i = e._primaryPreviousPosition,
            a = e.getInputAction(ot.MOUSE_MOVE, n);
        l(a) && (R.clone(i, Bf.startPosition), R.clone(r, Bf.endPosition), a(Bf)), R.clone(r, i), (e._buttonDown[Vt.LEFT] || e._buttonDown[Vt.MIDDLE] || e._buttonDown[Vt.RIGHT]) && t.preventDefault()
    }
}
var S_ = {
    position: new R
};

function eA(e, t) {
    var n = t.button,
        r;
    if (n === Vt.LEFT) r = ot.LEFT_DOUBLE_CLICK;
    else return;
    var i = Ua(t),
        a = e.getInputAction(r, i);
    l(a) && (ta(e, t, S_.position), a(S_))
}

function tA(e, t) {
    var n;
    if (l(t.deltaY)) {
        var r = t.deltaMode;
        r === t.DOM_DELTA_PIXEL ? n = -t.deltaY : r === t.DOM_DELTA_LINE ? n = -t.deltaY * 40 : n = -t.deltaY * 120
    } else t.detail > 0 ? n = t.detail * -120 : n = t.wheelDelta;
    if (!!l(n)) {
        var i = Ua(t),
            a = e.getInputAction(ot.WHEEL, i);
        l(a) && (a(n), t.preventDefault())
    }
}

function nA(e, t) {
    ud(e);
    var n = t.changedTouches,
        r, i = n.length,
        a, o, s = e._positions;
    for (r = 0; r < i; ++r) a = n[r], o = a.identifier, s.set(o, ta(e, a, new R));
    qc(e, t);
    var c = e._previousPositions;
    for (r = 0; r < i; ++r) a = n[r], o = a.identifier, c.set(o, R.clone(s.get(o)))
}

function R_(e, t) {
    ud(e);
    var n = t.changedTouches,
        r, i = n.length,
        a, o, s = e._positions;
    for (r = 0; r < i; ++r) a = n[r], o = a.identifier, s.remove(o);
    qc(e, t);
    var c = e._previousPositions;
    for (r = 0; r < i; ++r) a = n[r], o = a.identifier, c.remove(o)
}
var D_ = {
        position: new R
    },
    Vf = {
        position1: new R,
        position2: new R
    },
    I_ = {
        position: new R
    },
    P_ = {
        position: new R
    },
    O_ = {
        position: new R
    };

function qc(e, t) {
    var n = Ua(t),
        r = e._positions,
        i = r.length,
        a, o, s = e._isPinching;
    if (i !== 1 && e._buttonDown[Vt.LEFT]) {
        if (e._buttonDown[Vt.LEFT] = !1, l(e._touchHoldTimer) && (clearTimeout(e._touchHoldTimer), e._touchHoldTimer = void 0), a = e.getInputAction(ot.LEFT_UP, n), l(a) && (R.clone(e._primaryPosition, I_.position), a(I_)), i === 0 && !e._isTouchHolding && (o = e.getInputAction(ot.LEFT_CLICK, n), l(o))) {
            var c = e._primaryStartPosition,
                f = e._previousPositions.values[0];
            ol(c, f, e._clickPixelTolerance) && (R.clone(e._primaryPosition, P_.position), o(P_))
        }
        e._isTouchHolding = !1
    }
    if (i === 0 && s && (e._isPinching = !1, a = e.getInputAction(ot.PINCH_END, n), l(a) && a()), i === 1 && !s) {
        var h = r.values[0];
        R.clone(h, e._primaryPosition), R.clone(h, e._primaryStartPosition), R.clone(h, e._primaryPreviousPosition), e._buttonDown[Vt.LEFT] = !0, a = e.getInputAction(ot.LEFT_DOWN, n), l(a) && (R.clone(h, D_.position), a(D_)), e._touchHoldTimer = setTimeout(function() {
            if (!e.isDestroyed() && (e._touchHoldTimer = void 0, e._isTouchHolding = !0, o = e.getInputAction(ot.RIGHT_CLICK, n), l(o))) {
                var d = e._primaryStartPosition,
                    _ = e._previousPositions.values[0];
                ol(d, _, e._holdPixelTolerance) && (R.clone(e._primaryPosition, O_.position), o(O_))
            }
        }, Vr.touchHoldDelayMilliseconds), t.preventDefault()
    }
    i === 2 && !s && (e._isPinching = !0, a = e.getInputAction(ot.PINCH_START, n), l(a) && (R.clone(r.values[0], Vf.position1), R.clone(r.values[1], Vf.position2), a(Vf), t.preventDefault()))
}

function rA(e, t) {
    ud(e);
    var n = t.changedTouches,
        r, i = n.length,
        a, o, s = e._positions;
    for (r = 0; r < i; ++r) {
        a = n[r], o = a.identifier;
        var c = s.get(o);
        l(c) && ta(e, a, c)
    }
    kp(e, t);
    var f = e._previousPositions;
    for (r = 0; r < i; ++r) a = n[r], o = a.identifier, R.clone(s.get(o), f.get(o))
}
var Gf = {
        startPosition: new R,
        endPosition: new R
    },
    $o = {
        distance: {
            startPosition: new R,
            endPosition: new R
        },
        angleAndHeight: {
            startPosition: new R,
            endPosition: new R
        }
    };

function kp(e, t) {
    var n = Ua(t),
        r = e._positions,
        i = e._previousPositions,
        a = r.length,
        o;
    if (a === 1 && e._buttonDown[Vt.LEFT]) {
        var s = r.values[0];
        R.clone(s, e._primaryPosition);
        var c = e._primaryPreviousPosition;
        o = e.getInputAction(ot.MOUSE_MOVE, n), l(o) && (R.clone(c, Gf.startPosition), R.clone(s, Gf.endPosition), o(Gf)), R.clone(s, c), t.preventDefault()
    } else if (a === 2 && e._isPinching && (o = e.getInputAction(ot.PINCH_MOVE, n), l(o))) {
        var f = r.values[0],
            h = r.values[1],
            d = i.values[0],
            _ = i.values[1],
            v = h.x - f.x,
            m = h.y - f.y,
            g = Math.sqrt(v * v + m * m),
            y = _.x - d.x,
            E = _.y - d.y,
            w = Math.sqrt(y * y + E * E),
            C = (h.y + f.y) * .125,
            A = (_.y + d.y) * .125,
            x = Math.atan2(m, v),
            P = Math.atan2(E, y);
        R.fromElements(0, w, $o.distance.startPosition), R.fromElements(0, g, $o.distance.endPosition), R.fromElements(P, A, $o.angleAndHeight.startPosition), R.fromElements(x, C, $o.angleAndHeight.endPosition), o($o)
    }
}

function iA(e, t) {
    if (t.target.setPointerCapture(t.pointerId), t.pointerType === "touch") {
        var n = e._positions,
            r = t.pointerId;
        n.set(r, ta(e, t, new R)), qc(e, t);
        var i = e._previousPositions;
        i.set(r, R.clone(n.get(r)))
    } else Vp(e, t)
}

function M_(e, t) {
    if (t.pointerType === "touch") {
        var n = e._positions,
            r = t.pointerId;
        n.remove(r), qc(e, t);
        var i = e._previousPositions;
        i.remove(r)
    } else Gp(e, t)
}

function aA(e, t) {
    if (t.pointerType === "touch") {
        var n = e._positions,
            r = t.pointerId,
            i = n.get(r);
        if (!l(i)) return;
        ta(e, t, i), kp(e, t);
        var a = e._previousPositions;
        R.clone(n.get(r), a.get(r))
    } else Hp(e, t)
}

function Vr(e) {
    this._inputEvents = {}, this._buttonDown = {
        LEFT: !1,
        MIDDLE: !1,
        RIGHT: !1
    }, this._isPinching = !1, this._isTouchHolding = !1, this._lastSeenTouchEvent = -Vr.mouseEmulationIgnoreMilliseconds, this._primaryStartPosition = new R, this._primaryPosition = new R, this._primaryPreviousPosition = new R, this._positions = new Zi, this._previousPositions = new Zi, this._removalFunctions = [], this._touchHoldTimer = void 0, this._clickPixelTolerance = 5, this._holdPixelTolerance = 25, this._element = p(e, document), J1(this)
}
Vr.prototype.setInputAction = function(e, t, n) {
    var r = sd(t, n);
    this._inputEvents[r] = e
};
Vr.prototype.getInputAction = function(e, t) {
    var n = sd(e, t);
    return this._inputEvents[n]
};
Vr.prototype.removeInputAction = function(e, t) {
    var n = sd(e, t);
    delete this._inputEvents[n]
};
Vr.prototype.isDestroyed = function() {
    return !1
};
Vr.prototype.destroy = function() {
    return Q1(this), Pe(this)
};
Vr.mouseEmulationIgnoreMilliseconds = 800;
Vr.touchHoldDelayMilliseconds = 1500;

function Po(e, t, n) {
    for (var r = 0, i = e.length - 1, a, o; r <= i;) {
        if (a = ~~((r + i) / 2), o = n(e[a], t), o < 0) {
            r = a + 1;
            continue
        }
        if (o > 0) {
            i = a - 1;
            continue
        }
        return a
    }
    return ~(i + 1)
}

function fd(e, t, n, r, i) {
    this.xPoleWander = e, this.yPoleWander = t, this.xPoleOffset = n, this.yPoleOffset = r, this.ut1MinusUtc = i
}

function Hf() {
    var e = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g,
        t = arguments,
        n = 0,
        r = t[n++],
        i = function(f, h, d, _) {
            d || (d = " ");
            var v = f.length >= h ? "" : Array(1 + h - f.length >>> 0).join(d);
            return _ ? f + v : v + f
        },
        a = function(f, h, d, _, v, m) {
            var g = _ - f.length;
            return g > 0 && (d || !v ? f = i(f, _, m, d) : f = f.slice(0, h.length) + i("", g, "0", !0) + f.slice(h.length)), f
        },
        o = function(f, h, d, _, v, m, g) {
            var y = f >>> 0;
            return d = d && y && {
                2: "0b",
                8: "0",
                16: "0x"
            }[h] || "", f = d + i(y.toString(h), m || 0, "0", !1), a(f, d, _, v, g)
        },
        s = function(f, h, d, _, v, m) {
            return _ != null && (f = f.slice(0, _)), a(f, "", h, d, v, m)
        },
        c = function(f, h, d, _, v, m, g) {
            var y, E, w, C, A;
            if (f == "%%") return "%";
            for (var x = !1, P = "", I = !1, D = !1, O = " ", F = d.length, z = 0; d && z < F; z++) switch (d.charAt(z)) {
                case " ":
                    P = " ";
                    break;
                case "+":
                    P = "+";
                    break;
                case "-":
                    x = !0;
                    break;
                case "'":
                    O = d.charAt(z + 1);
                    break;
                case "0":
                    I = !0;
                    break;
                case "#":
                    D = !0;
                    break
            }
            if (_ ? _ == "*" ? _ = +t[n++] : _.charAt(0) == "*" ? _ = +t[_.slice(1, -1)] : _ = +_ : _ = 0, _ < 0 && (_ = -_, x = !0), !isFinite(_)) throw new Error("sprintf: (minimum-)width must be finite");
            switch (m ? m == "*" ? m = +t[n++] : m.charAt(0) == "*" ? m = +t[m.slice(1, -1)] : m = +m : m = "fFeE".indexOf(g) > -1 ? 6 : g == "d" ? 0 : void 0, A = h ? t[h.slice(0, -1)] : t[n++], g) {
                case "s":
                    return s(String(A), x, _, m, I, O);
                case "c":
                    return s(String.fromCharCode(+A), x, _, m, I);
                case "b":
                    return o(A, 2, D, x, _, m, I);
                case "o":
                    return o(A, 8, D, x, _, m, I);
                case "x":
                    return o(A, 16, D, x, _, m, I);
                case "X":
                    return o(A, 16, D, x, _, m, I).toUpperCase();
                case "u":
                    return o(A, 10, D, x, _, m, I);
                case "i":
                case "d":
                    return y = +A || 0, y = Math.round(y - y % 1), E = y < 0 ? "-" : P, A = E + i(String(Math.abs(y)), m, "0", !1), a(A, E, x, _, I);
                case "e":
                case "E":
                case "f":
                case "F":
                case "g":
                case "G":
                    return y = +A, E = y < 0 ? "-" : P, w = ["toExponential", "toFixed", "toPrecision"]["efg".indexOf(g.toLowerCase())], C = ["toString", "toUpperCase"]["eEfFgG".indexOf(g) % 2], A = E + Math.abs(y)[w](m), a(A, E, x, _, I)[C]();
                default:
                    return f
            }
        };
    return r.replace(e, c)
}

function Wp(e, t, n, r, i, a, o, s) {
    this.year = e, this.month = t, this.day = n, this.hour = r, this.minute = i, this.second = a, this.millisecond = o, this.isLeapSecond = s
}

function N_(e) {
    return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0
}

function ut(e, t) {
    this.julianDate = e, this.offset = t
}
var oA = {
    SECONDS_PER_MILLISECOND: .001,
    SECONDS_PER_MINUTE: 60,
    MINUTES_PER_HOUR: 60,
    HOURS_PER_DAY: 24,
    SECONDS_PER_HOUR: 3600,
    MINUTES_PER_DAY: 1440,
    SECONDS_PER_DAY: 86400,
    DAYS_PER_JULIAN_CENTURY: 36525,
    PICOSECOND: 1e-9,
    MODIFIED_JULIAN_DATE_DIFFERENCE: 24000005e-1
};
const pt = Object.freeze(oA);
var sA = {
    UTC: 0,
    TAI: 1
};
const ke = Object.freeze(sA);
var qp = new Wp,
    kf = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    Wf = 29;

function hd(e, t) {
    return $.compare(e.julianDate, t.julianDate)
}
var To = new ut;

function Yc(e) {
    To.julianDate = e;
    var t = $.leapSeconds,
        n = Po(t, To, hd);
    n < 0 && (n = ~n), n >= t.length && (n = t.length - 1);
    var r = t[n].offset;
    if (n > 0) {
        var i = $.secondsDifference(t[n].julianDate, e);
        i > r && (n--, r = t[n].offset)
    }
    $.addSeconds(e, r, e)
}

function b_(e, t) {
    To.julianDate = e;
    var n = $.leapSeconds,
        r = Po(n, To, hd);
    if (r < 0 && (r = ~r), r === 0) return $.addSeconds(e, -n[0].offset, t);
    if (r >= n.length) return $.addSeconds(e, -n[r - 1].offset, t);
    var i = $.secondsDifference(n[r].julianDate, e);
    if (i === 0) return $.addSeconds(e, -n[r].offset, t);
    if (!(i <= 1)) return $.addSeconds(e, -n[--r].offset, t)
}

function na(e, t, n) {
    var r = t / pt.SECONDS_PER_DAY | 0;
    return e += r, t -= pt.SECONDS_PER_DAY * r, t < 0 && (e--, t += pt.SECONDS_PER_DAY), n.dayNumber = e, n.secondsOfDay = t, n
}

function ld(e, t, n, r, i, a, o) {
    var s = (t - 14) / 12 | 0,
        c = e + 4800 + s,
        f = (1461 * c / 4 | 0) + (367 * (t - 2 - 12 * s) / 12 | 0) - (3 * ((c + 100) / 100 | 0) / 4 | 0) + n - 32075;
    r = r - 12, r < 0 && (r += 24);
    var h = a + (r * pt.SECONDS_PER_HOUR + i * pt.SECONDS_PER_MINUTE + o * pt.SECONDS_PER_MILLISECOND);
    return h >= 43200 && (f -= 1), [f, h]
}
var uA = /^(\d{4})$/,
    cA = /^(\d{4})-(\d{2})$/,
    fA = /^(\d{4})-?(\d{3})$/,
    hA = /^(\d{4})-?W(\d{2})-?(\d{1})?$/,
    lA = /^(\d{4})-?(\d{2})-?(\d{2})$/,
    dd = /([Z+\-])?(\d{2})?:?(\d{2})?$/,
    dA = /^(\d{2})(\.\d+)?/.source + dd.source,
    _A = /^(\d{2}):?(\d{2})(\.\d+)?/.source + dd.source,
    vA = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + dd.source;

function $(e, t, n) {
    this.dayNumber = void 0, this.secondsOfDay = void 0, e = p(e, 0), t = p(t, 0), n = p(n, ke.UTC);
    var r = e | 0;
    t = t + (e - r) * pt.SECONDS_PER_DAY, na(r, t, this), n === ke.UTC && Yc(this)
}
$.fromGregorianDate = function(e, t) {
    var n = ld(e.year, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
    return l(t) ? (na(n[0], n[1], t), Yc(t), t) : new $(n[0], n[1], ke.UTC)
};
$.fromDate = function(e, t) {
    var n = ld(e.getUTCFullYear(), e.getUTCMonth() + 1, e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds());
    return l(t) ? (na(n[0], n[1], t), Yc(t), t) : new $(n[0], n[1], ke.UTC)
};
$.fromIso8601 = function(e, t) {
    e = e.replace(",", ".");
    var n = e.split("T"),
        r, i = 1,
        a = 1,
        o = 0,
        s = 0,
        c = 0,
        f = 0,
        h = n[0],
        d = n[1],
        _, v;
    if (n = h.match(lA), n !== null) r = +n[1], i = +n[2], a = +n[3];
    else if (n = h.match(cA), n !== null) r = +n[1], i = +n[2];
    else if (n = h.match(uA), n !== null) r = +n[1];
    else {
        var m;
        if (n = h.match(fA), n !== null) r = +n[1], m = +n[2], v = N_(r);
        else if (n = h.match(hA), n !== null) {
            r = +n[1];
            var g = +n[2],
                y = +n[3] || 0,
                E = new Date(Date.UTC(r, 0, 4));
            m = g * 7 + y - E.getUTCDay() - 3
        }
        _ = new Date(Date.UTC(r, 0, 1)), _.setUTCDate(m), i = _.getUTCMonth() + 1, a = _.getUTCDate()
    }
    v = N_(r);
    var w;
    if (l(d)) {
        n = d.match(vA), n !== null ? (o = +n[1], s = +n[2], c = +n[3], f = +(n[4] || 0) * 1e3, w = 5) : (n = d.match(_A), n !== null ? (o = +n[1], s = +n[2], c = +(n[3] || 0) * 60, w = 4) : (n = d.match(dA), n !== null && (o = +n[1], s = +(n[2] || 0) * 60, w = 3)));
        var C = n[w],
            A = +n[w + 1],
            x = +(n[w + 2] || 0);
        switch (C) {
            case "+":
                o = o - A, s = s - x;
                break;
            case "-":
                o = o + A, s = s + x;
                break;
            case "Z":
                break;
            default:
                s = s + new Date(Date.UTC(r, i - 1, a, o, s)).getTimezoneOffset();
                break
        }
    }
    var P = c === 60;
    for (P && c--; s >= 60;) s -= 60, o++;
    for (; o >= 24;) o -= 24, a++;
    for (_ = v && i === 2 ? Wf : kf[i - 1]; a > _;) a -= _, i++, i > 12 && (i -= 12, r++), _ = v && i === 2 ? Wf : kf[i - 1];
    for (; s < 0;) s += 60, o--;
    for (; o < 0;) o += 24, a--;
    for (; a < 1;) i--, i < 1 && (i += 12, r--), _ = v && i === 2 ? Wf : kf[i - 1], a += _;
    var I = ld(r, i, a, o, s, c, f);
    return l(t) ? (na(I[0], I[1], t), Yc(t)) : t = new $(I[0], I[1], ke.UTC), P && $.addSeconds(t, 1, t), t
};
$.now = function(e) {
    return $.fromDate(new Date, e)
};
var su = new $(0, 0, ke.TAI);
$.toGregorianDate = function(e, t) {
    var n = !1,
        r = b_(e, su);
    l(r) || ($.addSeconds(e, -1, su), r = b_(su, su), n = !0);
    var i = r.dayNumber,
        a = r.secondsOfDay;
    a >= 43200 && (i += 1);
    var o = i + 68569 | 0,
        s = 4 * o / 146097 | 0;
    o = o - ((146097 * s + 3) / 4 | 0) | 0;
    var c = 4e3 * (o + 1) / 1461001 | 0;
    o = o - (1461 * c / 4 | 0) + 31 | 0;
    var f = 80 * o / 2447 | 0,
        h = o - (2447 * f / 80 | 0) | 0;
    o = f / 11 | 0;
    var d = f + 2 - 12 * o | 0,
        _ = 100 * (s - 49) + c + o | 0,
        v = a / pt.SECONDS_PER_HOUR | 0,
        m = a - v * pt.SECONDS_PER_HOUR,
        g = m / pt.SECONDS_PER_MINUTE | 0;
    m = m - g * pt.SECONDS_PER_MINUTE;
    var y = m | 0,
        E = (m - y) / pt.SECONDS_PER_MILLISECOND;
    return v += 12, v > 23 && (v -= 24), n && (y += 1), l(t) ? (t.year = _, t.month = d, t.day = h, t.hour = v, t.minute = g, t.second = y, t.millisecond = E, t.isLeapSecond = n, t) : new Wp(_, d, h, v, g, y, E, n)
};
$.toDate = function(e) {
    var t = $.toGregorianDate(e, qp),
        n = t.second;
    return t.isLeapSecond && (n -= 1), new Date(Date.UTC(t.year, t.month - 1, t.day, t.hour, t.minute, n, t.millisecond))
};
$.toIso8601 = function(e, t) {
    var n = $.toGregorianDate(e, qp),
        r = n.year,
        i = n.month,
        a = n.day,
        o = n.hour,
        s = n.minute,
        c = n.second,
        f = n.millisecond;
    r === 1e4 && i === 1 && a === 1 && o === 0 && s === 0 && c === 0 && f === 0 && (r = 9999, i = 12, a = 31, o = 24);
    var h;
    return !l(t) && f !== 0 ? (h = (f * .01).toString().replace(".", ""), Hf("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", r, i, a, o, s, c, h)) : !l(t) || t === 0 ? Hf("%04d-%02d-%02dT%02d:%02d:%02dZ", r, i, a, o, s, c) : (h = (f * .01).toFixed(t).replace(".", "").slice(0, t), Hf("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", r, i, a, o, s, c, h))
};
$.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.dayNumber = e.dayNumber, t.secondsOfDay = e.secondsOfDay, t) : new $(e.dayNumber, e.secondsOfDay, ke.TAI)
};
$.compare = function(e, t) {
    var n = e.dayNumber - t.dayNumber;
    return n !== 0 ? n : e.secondsOfDay - t.secondsOfDay
};
$.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.dayNumber === t.dayNumber && e.secondsOfDay === t.secondsOfDay
};
$.equalsEpsilon = function(e, t, n) {
    return n = p(n, 0), e === t || l(e) && l(t) && Math.abs($.secondsDifference(e, t)) <= n
};
$.totalDays = function(e) {
    return e.dayNumber + e.secondsOfDay / pt.SECONDS_PER_DAY
};
$.secondsDifference = function(e, t) {
    var n = (e.dayNumber - t.dayNumber) * pt.SECONDS_PER_DAY;
    return n + (e.secondsOfDay - t.secondsOfDay)
};
$.daysDifference = function(e, t) {
    var n = e.dayNumber - t.dayNumber,
        r = (e.secondsOfDay - t.secondsOfDay) / pt.SECONDS_PER_DAY;
    return n + r
};
$.computeTaiMinusUtc = function(e) {
    To.julianDate = e;
    var t = $.leapSeconds,
        n = Po(t, To, hd);
    return n < 0 && (n = ~n, --n, n < 0 && (n = 0)), t[n].offset
};
$.addSeconds = function(e, t, n) {
    return na(e.dayNumber, e.secondsOfDay + t, n)
};
$.addMinutes = function(e, t, n) {
    var r = e.secondsOfDay + t * pt.SECONDS_PER_MINUTE;
    return na(e.dayNumber, r, n)
};
$.addHours = function(e, t, n) {
    var r = e.secondsOfDay + t * pt.SECONDS_PER_HOUR;
    return na(e.dayNumber, r, n)
};
$.addDays = function(e, t, n) {
    var r = e.dayNumber + t;
    return na(r, e.secondsOfDay, n)
};
$.lessThan = function(e, t) {
    return $.compare(e, t) < 0
};
$.lessThanOrEquals = function(e, t) {
    return $.compare(e, t) <= 0
};
$.greaterThan = function(e, t) {
    return $.compare(e, t) > 0
};
$.greaterThanOrEquals = function(e, t) {
    return $.compare(e, t) >= 0
};
$.prototype.clone = function(e) {
    return $.clone(this, e)
};
$.prototype.equals = function(e) {
    return $.equals(this, e)
};
$.prototype.equalsEpsilon = function(e, t) {
    return $.equalsEpsilon(this, e, t)
};
$.prototype.toString = function() {
    return $.toIso8601(this)
};
$.leapSeconds = [new ut(new $(2441317, 43210, ke.TAI), 10), new ut(new $(2441499, 43211, ke.TAI), 11), new ut(new $(2441683, 43212, ke.TAI), 12), new ut(new $(2442048, 43213, ke.TAI), 13), new ut(new $(2442413, 43214, ke.TAI), 14), new ut(new $(2442778, 43215, ke.TAI), 15), new ut(new $(2443144, 43216, ke.TAI), 16), new ut(new $(2443509, 43217, ke.TAI), 17), new ut(new $(2443874, 43218, ke.TAI), 18), new ut(new $(2444239, 43219, ke.TAI), 19), new ut(new $(2444786, 43220, ke.TAI), 20), new ut(new $(2445151, 43221, ke.TAI), 21), new ut(new $(2445516, 43222, ke.TAI), 22), new ut(new $(2446247, 43223, ke.TAI), 23), new ut(new $(2447161, 43224, ke.TAI), 24), new ut(new $(2447892, 43225, ke.TAI), 25), new ut(new $(2448257, 43226, ke.TAI), 26), new ut(new $(2448804, 43227, ke.TAI), 27), new ut(new $(2449169, 43228, ke.TAI), 28), new ut(new $(2449534, 43229, ke.TAI), 29), new ut(new $(2450083, 43230, ke.TAI), 30), new ut(new $(2450630, 43231, ke.TAI), 31), new ut(new $(2451179, 43232, ke.TAI), 32), new ut(new $(2453736, 43233, ke.TAI), 33), new ut(new $(2454832, 43234, ke.TAI), 34), new ut(new $(2456109, 43235, ke.TAI), 35), new ut(new $(2457204, 43236, ke.TAI), 36), new ut(new $(2457754, 43237, ke.TAI), 37)];

function it(e) {
    if (e instanceof it) this.scheme = e.scheme, this.authority = e.authority, this.path = e.path, this.query = e.query, this.fragment = e.fragment;
    else if (e) {
        var t = mA.exec(e);
        this.scheme = t[1], this.authority = t[2], this.path = t[3], this.query = t[4], this.fragment = t[5]
    }
}
it.prototype.scheme = null;
it.prototype.authority = null;
it.prototype.path = "";
it.prototype.query = null;
it.prototype.fragment = null;
var mA = new RegExp("^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$");
it.prototype.getScheme = function() {
    return this.scheme
};
it.prototype.getAuthority = function() {
    return this.authority
};
it.prototype.getPath = function() {
    return this.path
};
it.prototype.getQuery = function() {
    return this.query
};
it.prototype.getFragment = function() {
    return this.fragment
};
it.prototype.isAbsolute = function() {
    return !!this.scheme && !this.fragment
};
it.prototype.isSameDocumentAs = function(e) {
    return e.scheme == this.scheme && e.authority == this.authority && e.path == this.path && e.query == this.query
};
it.prototype.equals = function(e) {
    return this.isSameDocumentAs(e) && e.fragment == this.fragment
};
it.prototype.normalize = function() {
    this.removeDotSegments(), this.scheme && (this.scheme = this.scheme.toLowerCase()), this.authority && (this.authority = this.authority.replace(gA, yA).replace(uu, cu)), this.path && (this.path = this.path.replace(uu, cu)), this.query && (this.query = this.query.replace(uu, cu)), this.fragment && (this.fragment = this.fragment.replace(uu, cu))
};
var uu = /%[0-9a-z]{2}/gi,
    pA = /[a-zA-Z0-9\-\._~]/,
    gA = /(.*@)?([^@:]*)(:.*)?/;

function cu(e) {
    var t = unescape(e);
    return pA.test(t) ? t : e.toUpperCase()
}

function yA(e, t, n, r) {
    return (t || "") + n.toLowerCase() + (r || "")
}
it.prototype.resolve = function(e) {
    var t = new it;
    return this.scheme ? (t.scheme = this.scheme, t.authority = this.authority, t.path = this.path, t.query = this.query) : (t.scheme = e.scheme, this.authority ? (t.authority = this.authority, t.path = this.path, t.query = this.query) : (t.authority = e.authority, this.path == "" ? (t.path = e.path, t.query = this.query || e.query) : (this.path.charAt(0) == "/" ? (t.path = this.path, t.removeDotSegments()) : (e.authority && e.path == "" ? t.path = "/" + this.path : t.path = e.path.substring(0, e.path.lastIndexOf("/") + 1) + this.path, t.removeDotSegments()), t.query = this.query))), t.fragment = this.fragment, t
};
it.prototype.removeDotSegments = function() {
    var e = this.path.split("/"),
        t = [],
        n, r = e[0] == "";
    for (r && e.shift(), e[0] == "" && e.shift(); e.length;) n = e.shift(), n == ".." ? t.pop() : n != "." && t.push(n);
    (n == "." || n == "..") && t.push(""), r && t.unshift(""), this.path = t.join("/")
};
it.prototype.toString = function() {
    var e = "";
    return this.scheme && (e += this.scheme + ":"), this.authority && (e += "//" + this.authority), e += this.path, this.query && (e += "?" + this.query), this.fragment && (e += "#" + this.fragment), e
};

function TA(e) {
    return (e.length === 0 || e[e.length - 1] !== "/") && (e = e + "/"), e
}

function sn(e, t) {
    if (e === null || typeof e != "object") return e;
    t = p(t, !1);
    var n = new e.constructor;
    for (var r in e)
        if (e.hasOwnProperty(r)) {
            var i = e[r];
            t && (i = sn(i, t)), n[r] = i
        }
    return n
}

function En(e, t, n) {
    n = p(n, !1);
    var r = {},
        i = l(e),
        a = l(t),
        o, s, c;
    if (i)
        for (o in e) e.hasOwnProperty(o) && (s = e[o], a && n && typeof s == "object" && t.hasOwnProperty(o) ? (c = t[o], typeof c == "object" ? r[o] = En(s, c, n) : r[o] = s) : r[o] = s);
    if (a)
        for (o in t) t.hasOwnProperty(o) && !r.hasOwnProperty(o) && (c = t[o], r[o] = c);
    return r
}

function Xc(e, t) {
    var n;
    return typeof document < "u" && (n = document), Xc._implementation(e, t, n)
}
Xc._implementation = function(e, t, n) {
    if (!l(t)) {
        if (typeof n > "u") return e;
        t = p(n.baseURI, n.location.href)
    }
    var r = new it(t),
        i = new it(e);
    return i.resolve(r).toString()
};

function EA(e, t) {
    var n = "",
        r = e.lastIndexOf("/");
    return r !== -1 && (n = e.substring(0, r + 1)), t && (e = new it(e), l(e.query) && (n += "?" + e.query), l(e.fragment) && (n += "#" + e.fragment)), n
}

function AA(e) {
    var t = new it(e);
    t.normalize();
    var n = t.path,
        r = n.lastIndexOf("/");
    return r !== -1 && (n = n.substr(r + 1)), r = n.lastIndexOf("."), r === -1 ? n = "" : n = n.substr(r + 1), n
}
var CA = /^blob:/i;

function Yp(e) {
    return CA.test(e)
}
var Zr;

function Xp(e) {
    l(Zr) || (Zr = document.createElement("a")), Zr.href = window.location.href;
    var t = Zr.host,
        n = Zr.protocol;
    return Zr.href = e, Zr.href = Zr.href, n !== Zr.protocol || t !== Zr.host
}
var wA = /^data:/i;

function jp(e) {
    return wA.test(e)
}

function xA(e) {
    var t = he.defer(),
        n = document.createElement("script");
    n.async = !0, n.src = e;
    var r = document.getElementsByTagName("head")[0];
    return n.onload = function() {
        n.onload = void 0, r.removeChild(n), t.resolve()
    }, n.onerror = function(i) {
        t.reject(i)
    }, r.appendChild(n), t.promise
}

function SA(e) {
    var t = "";
    for (var n in e)
        if (e.hasOwnProperty(n)) {
            var r = e[n],
                i = encodeURIComponent(n) + "=";
            if (Array.isArray(r))
                for (var a = 0, o = r.length; a < o; ++a) t += i + encodeURIComponent(r[a]) + "&";
            else t += i + encodeURIComponent(r) + "&"
        }
    return t = t.slice(0, -1), t
}

function RA(e) {
    var t = {};
    if (e === "") return t;
    for (var n = e.replace(/\+/g, "%20").split(/[&;]/), r = 0, i = n.length; r < i; ++r) {
        var a = n[r].split("="),
            o = decodeURIComponent(a[0]),
            s = a[1];
        l(s) ? s = decodeURIComponent(s) : s = "";
        var c = t[o];
        typeof c == "string" ? t[o] = [c, s] : Array.isArray(c) ? c.push(s) : t[o] = s
    }
    return t
}
var DA = {
    UNISSUED: 0,
    ISSUED: 1,
    ACTIVE: 2,
    RECEIVED: 3,
    CANCELLED: 4,
    FAILED: 5
};
const It = Object.freeze(DA);
var IA = {
    TERRAIN: 0,
    IMAGERY: 1,
    TILES3D: 2,
    OTHER: 3
};
const _d = Object.freeze(IA);

function Eo(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = p(e.throttleByServer, !1),
        n = p(e.throttle, !1);
    this.url = e.url, this.requestFunction = e.requestFunction, this.cancelFunction = e.cancelFunction, this.priorityFunction = e.priorityFunction, this.priority = p(e.priority, 0), this.throttle = n, this.throttleByServer = t, this.type = p(e.type, _d.OTHER), this.serverKey = void 0, this.state = It.UNISSUED, this.deferred = void 0, this.cancelled = !1
}
Eo.prototype.cancel = function() {
    this.cancelled = !0
};
Eo.prototype.clone = function(e) {
    return l(e) ? (e.url = this.url, e.requestFunction = this.requestFunction, e.cancelFunction = this.cancelFunction, e.priorityFunction = this.priorityFunction, e.priority = this.priority, e.throttle = this.throttle, e.throttleByServer = this.throttleByServer, e.type = this.type, e.serverKey = this.serverKey, e.state = this.RequestState.UNISSUED, e.deferred = void 0, e.cancelled = !1, e) : new Eo(this)
};

function PA(e) {
    var t = {};
    if (!e) return t;
    for (var n = e.split(`\r
`), r = 0; r < n.length; ++r) {
        var i = n[r],
            a = i.indexOf(": ");
        if (a > 0) {
            var o = i.substring(0, a),
                s = i.substring(a + 2);
            t[o] = s
        }
    }
    return t
}

function Cs(e, t, n) {
    this.statusCode = e, this.response = t, this.responseHeaders = n, typeof this.responseHeaders == "string" && (this.responseHeaders = PA(this.responseHeaders))
}
Cs.prototype.toString = function() {
    var e = "Request has failed.";
    return l(this.statusCode) && (e += " Status Code: " + this.statusCode), e
};

function ht() {
    this._listeners = [], this._scopes = [], this._toRemove = [], this._insideRaiseEvent = !1
}
Object.defineProperties(ht.prototype, {
    numberOfListeners: {
        get: function() {
            return this._listeners.length - this._toRemove.length
        }
    }
});
ht.prototype.addEventListener = function(e, t) {
    this._listeners.push(e), this._scopes.push(t);
    var n = this;
    return function() {
        n.removeEventListener(e, t)
    }
};
ht.prototype.removeEventListener = function(e, t) {
    for (var n = this._listeners, r = this._scopes, i = -1, a = 0; a < n.length; a++)
        if (n[a] === e && r[a] === t) {
            i = a;
            break
        }
    return i !== -1 ? (this._insideRaiseEvent ? (this._toRemove.push(i), n[i] = void 0, r[i] = void 0) : (n.splice(i, 1), r.splice(i, 1)), !0) : !1
};

function OA(e, t) {
    return t - e
}
ht.prototype.raiseEvent = function() {
    this._insideRaiseEvent = !0;
    var e, t = this._listeners,
        n = this._scopes,
        r = t.length;
    for (e = 0; e < r; e++) {
        var i = t[e];
        l(i) && t[e].apply(n[e], arguments)
    }
    var a = this._toRemove;
    if (r = a.length, r > 0) {
        for (a.sort(OA), e = 0; e < r; e++) {
            var o = a[e];
            t.splice(o, 1), n.splice(o, 1)
        }
        a.length = 0
    }
    this._insideRaiseEvent = !1
};

function za(e) {
    this._comparator = e.comparator, this._array = [], this._length = 0, this._maximumLength = void 0
}
Object.defineProperties(za.prototype, {
    length: {
        get: function() {
            return this._length
        }
    },
    internalArray: {
        get: function() {
            return this._array
        }
    },
    maximumLength: {
        get: function() {
            return this._maximumLength
        },
        set: function(e) {
            var t = this._length;
            if (e < t) {
                for (var n = this._array, r = e; r < t; ++r) n[r] = void 0;
                this._length = e, n.length = e
            }
            this._maximumLength = e
        }
    },
    comparator: {
        get: function() {
            return this._comparator
        }
    }
});

function vd(e, t, n) {
    var r = e[t];
    e[t] = e[n], e[n] = r
}
za.prototype.reserve = function(e) {
    e = p(e, this._length), this._array.length = e
};
za.prototype.heapify = function(e) {
    e = p(e, 0);
    for (var t = this._length, n = this._comparator, r = this._array, i = -1, a = !0; a;) {
        var o = 2 * (e + 1),
            s = o - 1;
        s < t && n(r[s], r[e]) < 0 ? i = s : i = e, o < t && n(r[o], r[i]) < 0 && (i = o), i !== e ? (vd(r, i, e), e = i) : a = !1
    }
};
za.prototype.resort = function() {
    for (var e = this._length, t = Math.ceil(e / 2); t >= 0; --t) this.heapify(t)
};
za.prototype.insert = function(e) {
    var t = this._array,
        n = this._comparator,
        r = this._maximumLength,
        i = this._length++;
    for (i < t.length ? t[i] = e : t.push(e); i !== 0;) {
        var a = Math.floor((i - 1) / 2);
        if (n(t[i], t[a]) < 0) vd(t, i, a), i = a;
        else break
    }
    var o;
    return l(r) && this._length > r && (o = t[r], this._length = r), o
};
za.prototype.pop = function(e) {
    if (e = p(e, 0), this._length !== 0) {
        var t = this._array,
            n = t[e];
        return vd(t, e, --this._length), this.heapify(e), t[this._length] = void 0, n
    }
};

function MA(e, t) {
    return e.priority - t.priority
}
var Je = {
        numberOfAttemptedRequests: 0,
        numberOfActiveRequests: 0,
        numberOfCancelledRequests: 0,
        numberOfCancelledActiveRequests: 0,
        numberOfFailedRequests: 0,
        numberOfActiveRequestsEver: 0,
        lastNumberOfActiveRequests: 0
    },
    ps = 20,
    On = new za({
        comparator: MA
    });
On.maximumLength = ps;
On.reserve(ps);
var Jr = [],
    Ii = {},
    NA = typeof document < "u" ? new it(document.location.href) : new it,
    jc = new ht;

function Et() {}
Et.maximumRequests = 50;
Et.maximumRequestsPerServer = 6;
Et.requestsByServer = {
    "api.cesium.com:443": 18,
    "assets.cesium.com:443": 18
};
Et.throttleRequests = !0;
Et.debugShowStatistics = !1;
Et.requestCompletedEvent = jc;
Object.defineProperties(Et, {
    statistics: {
        get: function() {
            return Je
        }
    },
    priorityHeapLength: {
        get: function() {
            return ps
        },
        set: function(e) {
            if (e < ps)
                for (; On.length > e;) {
                    var t = On.pop();
                    Sa(t)
                }
            ps = e, On.maximumLength = e, On.reserve(e)
        }
    }
});

function Zp(e) {
    l(e.priorityFunction) && (e.priority = e.priorityFunction())
}

function Kp(e) {
    var t = p(Et.requestsByServer[e], Et.maximumRequestsPerServer);
    return Ii[e] < t
}

function $p(e) {
    return e.state === It.UNISSUED && (e.state = It.ISSUED, e.deferred = he.defer()), e.deferred.promise
}

function bA(e) {
    return function(t) {
        if (e.state !== It.CANCELLED) {
            var n = e.deferred;
            --Je.numberOfActiveRequests, --Ii[e.serverKey], jc.raiseEvent(), e.state = It.RECEIVED, e.deferred = void 0, n.resolve(t)
        }
    }
}

function FA(e) {
    return function(t) {
        e.state !== It.CANCELLED && (++Je.numberOfFailedRequests, --Je.numberOfActiveRequests, --Ii[e.serverKey], jc.raiseEvent(t), e.state = It.FAILED, e.deferred.reject(t))
    }
}

function Jp(e) {
    var t = $p(e);
    return e.state = It.ACTIVE, Jr.push(e), ++Je.numberOfActiveRequests, ++Je.numberOfActiveRequestsEver, ++Ii[e.serverKey], e.requestFunction().then(bA(e)).otherwise(FA(e)), t
}

function Sa(e) {
    var t = e.state === It.ACTIVE;
    if (e.state = It.CANCELLED, ++Je.numberOfCancelledRequests, l(e.deferred)) {
        var n = e.deferred;
        e.deferred = void 0, n.reject()
    }
    t && (--Je.numberOfActiveRequests, --Ii[e.serverKey], ++Je.numberOfCancelledActiveRequests), l(e.cancelFunction) && e.cancelFunction()
}
Et.update = function() {
    var e, t, n = 0,
        r = Jr.length;
    for (e = 0; e < r; ++e) {
        if (t = Jr[e], t.cancelled && Sa(t), t.state !== It.ACTIVE) {
            ++n;
            continue
        }
        n > 0 && (Jr[e - n] = t)
    }
    Jr.length -= n;
    var i = On.internalArray,
        a = On.length;
    for (e = 0; e < a; ++e) Zp(i[e]);
    On.resort();
    for (var o = Math.max(Et.maximumRequests - Jr.length, 0), s = 0; s < o && On.length > 0;) {
        if (t = On.pop(), t.cancelled) {
            Sa(t);
            continue
        }
        if (t.throttleByServer && !Kp(t.serverKey)) {
            Sa(t);
            continue
        }
        Jp(t), ++s
    }
    LA()
};
Et.getServerKey = function(e) {
    var t = new it(e).resolve(NA);
    t.normalize();
    var n = t.authority;
    /:/.test(n) || (n = n + ":" + (t.scheme === "https" ? "443" : "80"));
    var r = Ii[n];
    return l(r) || (Ii[n] = 0), n
};
Et.request = function(e) {
    if (jp(e.url) || Yp(e.url)) return jc.raiseEvent(), e.state = It.RECEIVED, e.requestFunction();
    if (++Je.numberOfAttemptedRequests, l(e.serverKey) || (e.serverKey = Et.getServerKey(e.url)), !(Et.throttleRequests && e.throttleByServer && !Kp(e.serverKey))) {
        if (!Et.throttleRequests || !e.throttle) return Jp(e);
        if (!(Jr.length >= Et.maximumRequests)) {
            Zp(e);
            var t = On.insert(e);
            if (l(t)) {
                if (t === e) return;
                Sa(t)
            }
            return $p(e)
        }
    }
};

function LA() {
    !Et.debugShowStatistics || (Je.numberOfActiveRequests === 0 && Je.lastNumberOfActiveRequests > 0 && (Je.numberOfAttemptedRequests > 0 && (console.log("Number of attempted requests: " + Je.numberOfAttemptedRequests), Je.numberOfAttemptedRequests = 0), Je.numberOfCancelledRequests > 0 && (console.log("Number of cancelled requests: " + Je.numberOfCancelledRequests), Je.numberOfCancelledRequests = 0), Je.numberOfCancelledActiveRequests > 0 && (console.log("Number of cancelled active requests: " + Je.numberOfCancelledActiveRequests), Je.numberOfCancelledActiveRequests = 0), Je.numberOfFailedRequests > 0 && (console.log("Number of failed requests: " + Je.numberOfFailedRequests), Je.numberOfFailedRequests = 0)), Je.lastNumberOfActiveRequests = Je.numberOfActiveRequests)
}
Et.clearForSpecs = function() {
    for (; On.length > 0;) {
        var e = On.pop();
        Sa(e)
    }
    for (var t = Jr.length, n = 0; n < t; ++n) Sa(Jr[n]);
    Jr.length = 0, Ii = {}, Je.numberOfAttemptedRequests = 0, Je.numberOfActiveRequests = 0, Je.numberOfCancelledRequests = 0, Je.numberOfCancelledActiveRequests = 0, Je.numberOfFailedRequests = 0, Je.numberOfActiveRequestsEver = 0, Je.lastNumberOfActiveRequests = 0
};
Et.numberOfActiveRequestsByServer = function(e) {
    return Ii[e]
};
Et.requestHeap = On;
var Oo = {},
    Ao = {};
Oo.add = function(e, t) {
    var n = e.toLowerCase() + ":" + t;
    l(Ao[n]) || (Ao[n] = !0)
};
Oo.remove = function(e, t) {
    var n = e.toLowerCase() + ":" + t;
    l(Ao[n]) && delete Ao[n]
};

function UA(e) {
    var t = new it(e);
    t.normalize();
    var n = t.getAuthority();
    if (!!l(n)) {
        if (n.indexOf("@") !== -1) {
            var r = n.split("@");
            n = r[1]
        }
        if (n.indexOf(":") === -1) {
            var i = t.getScheme();
            if (l(i) || (i = window.location.protocol, i = i.substring(0, i.length - 1)), i === "http") n += ":80";
            else if (i === "https") n += ":443";
            else return
        }
        return n
    }
}
Oo.contains = function(e) {
    var t = UA(e);
    return !!(l(t) && l(Ao[t]))
};
Oo.clear = function() {
    Ao = {}
};
var Qp = function() {
    try {
        var e = new XMLHttpRequest;
        return e.open("GET", "#", !0), e.responseType = "blob", e.responseType === "blob"
    } catch {
        return !1
    }
}();

function md(e, t, n, r) {
    var i = e.query;
    if (!l(i) || i.length === 0) return {};
    var a;
    if (i.indexOf("=") === -1) {
        var o = {};
        o[i] = void 0, a = o
    } else a = RA(i);
    n ? t._queryParameters = Pc(a, t._queryParameters, r) : t._queryParameters = a, e.query = void 0
}

function zA(e, t) {
    var n = t._queryParameters,
        r = Object.keys(n);
    r.length === 1 && !l(n[r[0]]) ? e.query = r[0] : e.query = SA(n)
}

function ti(e, t) {
    return l(e) ? l(e.clone) ? e.clone() : sn(e) : t
}

function pd(e) {
    if (e.state === It.ISSUED || e.state === It.ACTIVE) throw new je("The Resource is already being fetched.");
    e.state = It.UNISSUED, e.deferred = void 0
}

function Pc(e, t, n) {
    if (!n) return En(e, t);
    var r = sn(e, !0);
    for (var i in t)
        if (t.hasOwnProperty(i)) {
            var a = r[i],
                o = t[i];
            l(a) ? (Array.isArray(a) || (a = r[i] = [a]), r[i] = a.concat(o)) : r[i] = Array.isArray(o) ? o.slice() : o
        }
    return r
}

function J(e) {
    e = p(e, p.EMPTY_OBJECT), typeof e == "string" && (e = {
        url: e
    }), this._url = void 0, this._templateValues = ti(e.templateValues, {}), this._queryParameters = ti(e.queryParameters, {}), this.headers = ti(e.headers, {}), this.request = p(e.request, new Eo), this.proxy = e.proxy, this.retryCallback = e.retryCallback, this.retryAttempts = p(e.retryAttempts, 0), this._retryCount = 0;
    var t = new it(e.url);
    md(t, this, !0, !0), t.fragment = void 0, this._url = t.toString()
}
J.createIfNeeded = function(e) {
    return e instanceof J ? e.getDerivedResource({
        request: e.request
    }) : typeof e != "string" ? e : new J({
        url: e
    })
};
var Qa;
J.supportsImageBitmapOptions = function() {
    if (l(Qa)) return Qa;
    if (typeof createImageBitmap != "function") return Qa = he.resolve(!1), Qa;
    var e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWP4////fwAJ+wP9CNHoHgAAAABJRU5ErkJggg==";
    return Qa = J.fetchBlob({
        url: e
    }).then(function(t) {
        return createImageBitmap(t, {
            imageOrientation: "flipY",
            premultiplyAlpha: "none"
        })
    }).then(function(t) {
        return !0
    }).otherwise(function() {
        return !1
    }), Qa
};
Object.defineProperties(J, {
    isBlobSupported: {
        get: function() {
            return Qp
        }
    }
});
Object.defineProperties(J.prototype, {
    queryParameters: {
        get: function() {
            return this._queryParameters
        }
    },
    templateValues: {
        get: function() {
            return this._templateValues
        }
    },
    url: {
        get: function() {
            return this.getUrlComponent(!0, !0)
        },
        set: function(e) {
            var t = new it(e);
            md(t, this, !1), t.fragment = void 0, this._url = t.toString()
        }
    },
    extension: {
        get: function() {
            return AA(this._url)
        }
    },
    isDataUri: {
        get: function() {
            return jp(this._url)
        }
    },
    isBlobUri: {
        get: function() {
            return Yp(this._url)
        }
    },
    isCrossOriginUrl: {
        get: function() {
            return Xp(this._url)
        }
    },
    hasHeaders: {
        get: function() {
            return Object.keys(this.headers).length > 0
        }
    }
});
J.prototype.toString = function() {
    return this.getUrlComponent(!0, !0)
};
J.prototype.getUrlComponent = function(e, t) {
    if (this.isDataUri) return this._url;
    var n = new it(this._url);
    e && zA(n, this);
    var r = n.toString().replace(/%7B/g, "{").replace(/%7D/g, "}"),
        i = this._templateValues;
    return r = r.replace(/{(.*?)}/g, function(a, o) {
        var s = i[o];
        return l(s) ? encodeURIComponent(s) : a
    }), t && l(this.proxy) && (r = this.proxy.getURL(r)), r
};
J.prototype.setQueryParameters = function(e, t) {
    t ? this._queryParameters = Pc(this._queryParameters, e, !1) : this._queryParameters = Pc(e, this._queryParameters, !1)
};
J.prototype.appendQueryParameters = function(e) {
    this._queryParameters = Pc(e, this._queryParameters, !0)
};
J.prototype.setTemplateValues = function(e, t) {
    t ? this._templateValues = En(this._templateValues, e) : this._templateValues = En(e, this._templateValues)
};
J.prototype.getDerivedResource = function(e) {
    var t = this.clone();
    if (t._retryCount = 0, l(e.url)) {
        var n = new it(e.url),
            r = p(e.preserveQueryParameters, !1);
        md(n, t, !0, r), n.fragment = void 0, t._url = n.resolve(new it(Xc(this._url))).toString()
    }
    return l(e.queryParameters) && (t._queryParameters = En(e.queryParameters, t._queryParameters)), l(e.templateValues) && (t._templateValues = En(e.templateValues, t.templateValues)), l(e.headers) && (t.headers = En(e.headers, t.headers)), l(e.proxy) && (t.proxy = e.proxy), l(e.request) && (t.request = e.request), l(e.retryCallback) && (t.retryCallback = e.retryCallback), l(e.retryAttempts) && (t.retryAttempts = e.retryAttempts), t
};
J.prototype.retryOnError = function(e) {
    var t = this.retryCallback;
    if (typeof t != "function" || this._retryCount >= this.retryAttempts) return he(!1);
    var n = this;
    return he(t(this, e)).then(function(r) {
        return ++n._retryCount, r
    })
};
J.prototype.clone = function(e) {
    return l(e) || (e = new J({
        url: this._url
    })), e._url = this._url, e._queryParameters = sn(this._queryParameters), e._templateValues = sn(this._templateValues), e.headers = sn(this.headers), e.proxy = this.proxy, e.retryCallback = this.retryCallback, e.retryAttempts = this.retryAttempts, e._retryCount = 0, e.request = this.request.clone(), e
};
J.prototype.getBaseUri = function(e) {
    return EA(this.getUrlComponent(e), e)
};
J.prototype.appendForwardSlash = function() {
    this._url = TA(this._url)
};
J.prototype.fetchArrayBuffer = function() {
    return this.fetch({
        responseType: "arraybuffer"
    })
};
J.fetchArrayBuffer = function(e) {
    var t = new J(e);
    return t.fetchArrayBuffer()
};
J.prototype.fetchBlob = function() {
    return this.fetch({
        responseType: "blob"
    })
};
J.fetchBlob = function(e) {
    var t = new J(e);
    return t.fetchBlob()
};
J.prototype.fetchImage = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = p(e.preferImageBitmap, !1),
        n = p(e.preferBlob, !1),
        r = p(e.flipY, !1);
    if (pd(this.request), !Qp || this.isDataUri || this.isBlobUri || !this.hasHeaders && !n) return sl({
        resource: this,
        flipY: r,
        preferImageBitmap: t
    });
    var i = this.fetchBlob();
    if (!!l(i)) {
        var a, o, s, c;
        return J.supportsImageBitmapOptions().then(function(f) {
            return a = f, o = a && t, i
        }).then(function(f) {
            if (!!l(f)) {
                if (c = f, o) return J.createImageBitmapFromBlob(f, {
                    flipY: r,
                    premultiplyAlpha: !1
                });
                var h = window.URL.createObjectURL(f);
                return s = new J({
                    url: h
                }), sl({
                    resource: s,
                    flipY: r,
                    preferImageBitmap: !1
                })
            }
        }).then(function(f) {
            if (!!l(f)) return f.blob = c, o || window.URL.revokeObjectURL(s.url), f
        }).otherwise(function(f) {
            return l(s) && window.URL.revokeObjectURL(s.url), f.blob = c, he.reject(f)
        })
    }
};

function sl(e) {
    var t = e.resource,
        n = e.flipY,
        r = e.preferImageBitmap,
        i = t.request;
    i.url = t.url, i.requestFunction = function() {
        var o = !1;
        !t.isDataUri && !t.isBlobUri && (o = t.isCrossOriginUrl);
        var s = he.defer();
        return J._Implementations.createImage(i, o, s, n, r), s.promise
    };
    var a = Et.request(i);
    if (!!l(a)) return a.otherwise(function(o) {
        return i.state !== It.FAILED ? he.reject(o) : t.retryOnError(o).then(function(s) {
            return s ? (i.state = It.UNISSUED, i.deferred = void 0, sl({
                resource: t,
                flipY: n,
                preferImageBitmap: r
            })) : he.reject(o)
        })
    })
}
J.fetchImage = function(e) {
    var t = new J(e);
    return t.fetchImage({
        flipY: e.flipY,
        preferBlob: e.preferBlob,
        preferImageBitmap: e.preferImageBitmap
    })
};
J.prototype.fetchText = function() {
    return this.fetch({
        responseType: "text"
    })
};
J.fetchText = function(e) {
    var t = new J(e);
    return t.fetchText()
};
J.prototype.fetchJson = function() {
    var e = this.fetch({
        responseType: "text",
        headers: {
            Accept: "application/json,*/*;q=0.01"
        }
    });
    if (!!l(e)) return e.then(function(t) {
        if (!!l(t)) return JSON.parse(t)
    })
};
J.fetchJson = function(e) {
    var t = new J(e);
    return t.fetchJson()
};
J.prototype.fetchXML = function() {
    return this.fetch({
        responseType: "document",
        overrideMimeType: "text/xml"
    })
};
J.fetchXML = function(e) {
    var t = new J(e);
    return t.fetchXML()
};
J.prototype.fetchJsonp = function(e) {
    e = p(e, "callback"), pd(this.request);
    var t;
    do t = "loadJsonp" + Math.random().toString().substring(2, 8); while (l(window[t]));
    return e0(this, e, t)
};

function e0(e, t, n) {
    var r = {};
    r[t] = n, e.setQueryParameters(r);
    var i = e.request;
    i.url = e.url, i.requestFunction = function() {
        var o = he.defer();
        return window[n] = function(s) {
            o.resolve(s);
            try {
                delete window[n]
            } catch {
                window[n] = void 0
            }
        }, J._Implementations.loadAndExecuteScript(e.url, n, o), o.promise
    };
    var a = Et.request(i);
    if (!!l(a)) return a.otherwise(function(o) {
        return i.state !== It.FAILED ? he.reject(o) : e.retryOnError(o).then(function(s) {
            return s ? (i.state = It.UNISSUED, i.deferred = void 0, e0(e, t, n)) : he.reject(o)
        })
    })
}
J.fetchJsonp = function(e) {
    var t = new J(e);
    return t.fetchJsonp(e.callbackParameterName)
};
J.prototype._makeRequest = function(e) {
    var t = this;
    pd(t.request);
    var n = t.request;
    n.url = t.url, n.requestFunction = function() {
        var i = e.responseType,
            a = En(e.headers, t.headers),
            o = e.overrideMimeType,
            s = e.method,
            c = e.data,
            f = he.defer(),
            h = J._Implementations.loadWithXhr(t.url, i, s, c, a, f, o);
        return l(h) && l(h.abort) && (n.cancelFunction = function() {
            h.abort()
        }), f.promise
    };
    var r = Et.request(n);
    if (!!l(r)) return r.then(function(i) {
        return n.cancelFunction = void 0, i
    }).otherwise(function(i) {
        return n.cancelFunction = void 0, n.state !== It.FAILED ? he.reject(i) : t.retryOnError(i).then(function(a) {
            return a ? (n.state = It.UNISSUED, n.deferred = void 0, t.fetch(e)) : he.reject(i)
        })
    })
};
var BA = /^data:(.*?)(;base64)?,(.*)$/;

function $u(e, t) {
    var n = decodeURIComponent(t);
    return e ? atob(n) : n
}

function F_(e, t) {
    for (var n = $u(e, t), r = new ArrayBuffer(n.length), i = new Uint8Array(r), a = 0; a < n.length; a++) i[a] = n.charCodeAt(a);
    return r
}

function VA(e, t) {
    t = p(t, "");
    var n = e[1],
        r = !!e[2],
        i = e[3];
    switch (t) {
        case "":
        case "text":
            return $u(r, i);
        case "arraybuffer":
            return F_(r, i);
        case "blob":
            var a = F_(r, i);
            return new Blob([a], {
                type: n
            });
        case "document":
            var o = new DOMParser;
            return o.parseFromString($u(r, i), n);
        case "json":
            return JSON.parse($u(r, i))
    }
}
J.prototype.fetch = function(e) {
    return e = ti(e, {}), e.method = "GET", this._makeRequest(e)
};
J.fetch = function(e) {
    var t = new J(e);
    return t.fetch({
        responseType: e.responseType,
        overrideMimeType: e.overrideMimeType
    })
};
J.prototype.delete = function(e) {
    return e = ti(e, {}), e.method = "DELETE", this._makeRequest(e)
};
J.delete = function(e) {
    var t = new J(e);
    return t.delete({
        responseType: e.responseType,
        overrideMimeType: e.overrideMimeType,
        data: e.data
    })
};
J.prototype.head = function(e) {
    return e = ti(e, {}), e.method = "HEAD", this._makeRequest(e)
};
J.head = function(e) {
    var t = new J(e);
    return t.head({
        responseType: e.responseType,
        overrideMimeType: e.overrideMimeType
    })
};
J.prototype.options = function(e) {
    return e = ti(e, {}), e.method = "OPTIONS", this._makeRequest(e)
};
J.options = function(e) {
    var t = new J(e);
    return t.options({
        responseType: e.responseType,
        overrideMimeType: e.overrideMimeType
    })
};
J.prototype.post = function(e, t) {
    return wt.defined("data", e), t = ti(t, {}), t.method = "POST", t.data = e, this._makeRequest(t)
};
J.post = function(e) {
    var t = new J(e);
    return t.post(e.data, {
        responseType: e.responseType,
        overrideMimeType: e.overrideMimeType
    })
};
J.prototype.put = function(e, t) {
    return wt.defined("data", e), t = ti(t, {}), t.method = "PUT", t.data = e, this._makeRequest(t)
};
J.put = function(e) {
    var t = new J(e);
    return t.put(e.data, {
        responseType: e.responseType,
        overrideMimeType: e.overrideMimeType
    })
};
J.prototype.patch = function(e, t) {
    return wt.defined("data", e), t = ti(t, {}), t.method = "PATCH", t.data = e, this._makeRequest(t)
};
J.patch = function(e) {
    var t = new J(e);
    return t.patch(e.data, {
        responseType: e.responseType,
        overrideMimeType: e.overrideMimeType
    })
};
J._Implementations = {};

function GA(e, t, n) {
    var r = new Image;
    r.onload = function() {
        n.resolve(r)
    }, r.onerror = function(i) {
        n.reject(i)
    }, t && (Oo.contains(e) ? r.crossOrigin = "use-credentials" : r.crossOrigin = ""), r.src = e
}
J._Implementations.createImage = function(e, t, n, r, i) {
    var a = e.url;
    J.supportsImageBitmapOptions().then(function(o) {
        if (!(o && i)) {
            GA(a, t, n);
            return
        }
        var s = "blob",
            c = "GET",
            f = he.defer(),
            h = J._Implementations.loadWithXhr(a, s, c, void 0, void 0, f, void 0, void 0, void 0);
        return l(h) && l(h.abort) && (e.cancelFunction = function() {
            h.abort()
        }), f.promise.then(function(d) {
            if (!l(d)) {
                n.reject(new je("Successfully retrieved " + a + " but it contained no content."));
                return
            }
            return J.createImageBitmapFromBlob(d, {
                flipY: r,
                premultiplyAlpha: !1
            })
        }).then(n.resolve)
    }).otherwise(n.reject)
};
J.createImageBitmapFromBlob = function(e, t) {
    return wt.defined("options", t), wt.typeOf.bool("options.flipY", t.flipY), wt.typeOf.bool("options.premultiplyAlpha", t.premultiplyAlpha), createImageBitmap(e, {
        imageOrientation: t.flipY ? "flipY" : "none",
        premultiplyAlpha: t.premultiplyAlpha ? "premultiply" : "none"
    })
};

function L_(e, t) {
    switch (t) {
        case "text":
            return e.toString("utf8");
        case "json":
            return JSON.parse(e.toString("utf8"));
        default:
            return new Uint8Array(e).buffer
    }
}

function HA(e, t, n, r, i, a, o) {
    var s = require("url").parse(e),
        c = s.protocol === "https:" ? require("https") : require("http"),
        f = require("zlib"),
        h = {
            protocol: s.protocol,
            hostname: s.hostname,
            port: s.port,
            path: s.path,
            query: s.query,
            method: n,
            headers: i
        };
    c.request(h).on("response", function(d) {
        if (d.statusCode < 200 || d.statusCode >= 300) {
            a.reject(new Cs(d.statusCode, d, d.headers));
            return
        }
        var _ = [];
        d.on("data", function(v) {
            _.push(v)
        }), d.on("end", function() {
            var v = Buffer.concat(_);
            d.headers["content-encoding"] === "gzip" ? f.gunzip(v, function(m, g) {
                m ? a.reject(new je("Error decompressing response.")) : a.resolve(L_(g, t))
            }) : a.resolve(L_(v, t))
        })
    }).on("error", function(d) {
        a.reject(new Cs)
    }).end()
}
var kA = typeof XMLHttpRequest > "u";
J._Implementations.loadWithXhr = function(e, t, n, r, i, a, o) {
    var s = BA.exec(e);
    if (s !== null) {
        a.resolve(VA(s, t));
        return
    }
    if (kA) {
        HA(e, t, n, r, i, a);
        return
    }
    var c = new XMLHttpRequest;
    if (Oo.contains(e) && (c.withCredentials = !0), c.open(n, e, !0), l(o) && l(c.overrideMimeType) && c.overrideMimeType(o), l(i))
        for (var f in i) i.hasOwnProperty(f) && c.setRequestHeader(f, i[f]);
    l(t) && (c.responseType = t);
    var h = !1;
    return typeof e == "string" && (h = e.indexOf("file://") === 0 || typeof window < "u" && window.location.origin === "file://"), c.onload = function() {
        if ((c.status < 200 || c.status >= 300) && !(h && c.status === 0)) {
            a.reject(new Cs(c.status, c.response, c.getAllResponseHeaders()));
            return
        }
        var d = c.response,
            _ = c.responseType;
        if (n === "HEAD" || n === "OPTIONS") {
            var v = c.getAllResponseHeaders(),
                m = v.trim().split(/[\r\n]+/),
                g = {};
            m.forEach(function(y) {
                var E = y.split(": "),
                    w = E.shift();
                g[w] = E.join(": ")
            }), a.resolve(g);
            return
        }
        if (c.status === 204) a.resolve();
        else if (l(d) && (!l(t) || _ === t)) a.resolve(d);
        else if (t === "json" && typeof d == "string") try {
            a.resolve(JSON.parse(d))
        } catch (y) {
            a.reject(y)
        } else(_ === "" || _ === "document") && l(c.responseXML) && c.responseXML.hasChildNodes() ? a.resolve(c.responseXML) : (_ === "" || _ === "text") && l(c.responseText) ? a.resolve(c.responseText) : a.reject(new je("Invalid XMLHttpRequest response type."))
    }, c.onerror = function(d) {
        a.reject(new Cs)
    }, c.send(r), c
};
J._Implementations.loadAndExecuteScript = function(e, t, n) {
    return xA(e).otherwise(n.reject)
};
J._DefaultImplementations = {};
J._DefaultImplementations.createImage = J._Implementations.createImage;
J._DefaultImplementations.loadWithXhr = J._Implementations.loadWithXhr;
J._DefaultImplementations.loadAndExecuteScript = J._Implementations.loadAndExecuteScript;
J.DEFAULT = Object.freeze(new J({
    url: typeof document > "u" ? "" : document.location.href.split("?")[0]
}));

function Zc(e) {
    if (e = p(e, p.EMPTY_OBJECT), this._dates = void 0, this._samples = void 0, this._dateColumn = -1, this._xPoleWanderRadiansColumn = -1, this._yPoleWanderRadiansColumn = -1, this._ut1MinusUtcSecondsColumn = -1, this._xCelestialPoleOffsetRadiansColumn = -1, this._yCelestialPoleOffsetRadiansColumn = -1, this._taiMinusUtcSecondsColumn = -1, this._columnCount = 0, this._lastIndex = -1, this._downloadPromise = void 0, this._dataError = void 0, this._addNewLeapSeconds = p(e.addNewLeapSeconds, !0), l(e.data)) qf(this, e.data);
    else if (l(e.url)) {
        var t = J.createIfNeeded(e.url),
            n = this;
        this._downloadPromise = t.fetchJson().then(function(r) {
            qf(n, r)
        }).otherwise(function() {
            n._dataError = "An error occurred while retrieving the EOP data from the URL " + t.url + "."
        })
    } else qf(this, {
        columnNames: ["dateIso8601", "modifiedJulianDateUtc", "xPoleWanderRadians", "yPoleWanderRadians", "ut1MinusUtcSeconds", "lengthOfDayCorrectionSeconds", "xCelestialPoleOffsetRadians", "yCelestialPoleOffsetRadians", "taiMinusUtcSeconds"],
        samples: []
    })
}
Zc.NONE = Object.freeze({
    getPromiseToLoad: function() {
        return he.resolve()
    },
    compute: function(e, t) {
        return l(t) ? (t.xPoleWander = 0, t.yPoleWander = 0, t.xPoleOffset = 0, t.yPoleOffset = 0, t.ut1MinusUtc = 0) : t = new fd(0, 0, 0, 0, 0), t
    }
});
Zc.prototype.getPromiseToLoad = function() {
    return he(this._downloadPromise)
};
Zc.prototype.compute = function(e, t) {
    if (!l(this._samples)) {
        if (l(this._dataError)) throw new je(this._dataError);
        return
    }
    if (l(t) || (t = new fd(0, 0, 0, 0, 0)), this._samples.length === 0) return t.xPoleWander = 0, t.yPoleWander = 0, t.xPoleOffset = 0, t.yPoleOffset = 0, t.ut1MinusUtc = 0, t;
    var n = this._dates,
        r = this._lastIndex,
        i = 0,
        a = 0;
    if (l(r)) {
        var o = n[r],
            s = n[r + 1],
            c = $.lessThanOrEquals(o, e),
            f = !l(s),
            h = f || $.greaterThanOrEquals(s, e);
        if (c && h) return i = r, !f && s.equals(e) && ++i, a = i + 1, z_(this, n, this._samples, e, i, a, t), t
    }
    var d = Po(n, e, $.compare, this._dateColumn);
    return d >= 0 ? (d < n.length - 1 && n[d + 1].equals(e) && ++d, i = d, a = d) : (a = ~d, i = a - 1, i < 0 && (i = 0)), this._lastIndex = i, z_(this, n, this._samples, e, i, a, t), t
};

function WA(e, t) {
    return $.compare(e.julianDate, t)
}

function qf(e, t) {
    if (!l(t.columnNames)) {
        e._dataError = "Error in loaded EOP data: The columnNames property is required.";
        return
    }
    if (!l(t.samples)) {
        e._dataError = "Error in loaded EOP data: The samples property is required.";
        return
    }
    var n = t.columnNames.indexOf("modifiedJulianDateUtc"),
        r = t.columnNames.indexOf("xPoleWanderRadians"),
        i = t.columnNames.indexOf("yPoleWanderRadians"),
        a = t.columnNames.indexOf("ut1MinusUtcSeconds"),
        o = t.columnNames.indexOf("xCelestialPoleOffsetRadians"),
        s = t.columnNames.indexOf("yCelestialPoleOffsetRadians"),
        c = t.columnNames.indexOf("taiMinusUtcSeconds");
    if (n < 0 || r < 0 || i < 0 || a < 0 || o < 0 || s < 0 || c < 0) {
        e._dataError = "Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns";
        return
    }
    var f = e._samples = t.samples,
        h = e._dates = [];
    e._dateColumn = n, e._xPoleWanderRadiansColumn = r, e._yPoleWanderRadiansColumn = i, e._ut1MinusUtcSecondsColumn = a, e._xCelestialPoleOffsetRadiansColumn = o, e._yCelestialPoleOffsetRadiansColumn = s, e._taiMinusUtcSecondsColumn = c, e._columnCount = t.columnNames.length, e._lastIndex = void 0;
    for (var d, _ = e._addNewLeapSeconds, v = 0, m = f.length; v < m; v += e._columnCount) {
        var g = f[v + n],
            y = f[v + c],
            E = g + pt.MODIFIED_JULIAN_DATE_DIFFERENCE,
            w = new $(E, y, ke.TAI);
        if (h.push(w), _) {
            if (y !== d && l(d)) {
                var C = $.leapSeconds,
                    A = Po(C, w, WA);
                if (A < 0) {
                    var x = new ut(w, y);
                    C.splice(~A, 0, x)
                }
            }
            d = y
        }
    }
}

function U_(e, t, n, r, i) {
    var a = n * r;
    i.xPoleWander = t[a + e._xPoleWanderRadiansColumn], i.yPoleWander = t[a + e._yPoleWanderRadiansColumn], i.xPoleOffset = t[a + e._xCelestialPoleOffsetRadiansColumn], i.yPoleOffset = t[a + e._yCelestialPoleOffsetRadiansColumn], i.ut1MinusUtc = t[a + e._ut1MinusUtcSecondsColumn]
}

function Jo(e, t, n) {
    return t + e * (n - t)
}

function z_(e, t, n, r, i, a, o) {
    var s = e._columnCount;
    if (a > t.length - 1) return o.xPoleWander = 0, o.yPoleWander = 0, o.xPoleOffset = 0, o.yPoleOffset = 0, o.ut1MinusUtc = 0, o;
    var c = t[i],
        f = t[a];
    if (c.equals(f) || r.equals(c)) return U_(e, n, i, s, o), o;
    if (r.equals(f)) return U_(e, n, a, s, o), o;
    var h = $.secondsDifference(r, c) / $.secondsDifference(f, c),
        d = i * s,
        _ = a * s,
        v = n[d + e._ut1MinusUtcSecondsColumn],
        m = n[_ + e._ut1MinusUtcSecondsColumn],
        g = m - v;
    if (g > .5 || g < -.5) {
        var y = n[d + e._taiMinusUtcSecondsColumn],
            E = n[_ + e._taiMinusUtcSecondsColumn];
        y !== E && (f.equals(r) ? v = m : m -= E - y)
    }
    return o.xPoleWander = Jo(h, n[d + e._xPoleWanderRadiansColumn], n[_ + e._xPoleWanderRadiansColumn]), o.yPoleWander = Jo(h, n[d + e._yPoleWanderRadiansColumn], n[_ + e._yPoleWanderRadiansColumn]), o.xPoleOffset = Jo(h, n[d + e._xCelestialPoleOffsetRadiansColumn], n[_ + e._xCelestialPoleOffsetRadiansColumn]), o.yPoleOffset = Jo(h, n[d + e._yCelestialPoleOffsetRadiansColumn], n[_ + e._yCelestialPoleOffsetRadiansColumn]), o.ut1MinusUtc = Jo(h, v, m), o
}
var t0 = /((?:.*\/)|^)Cesium\.js(?:\?|\#|$)/;

function qA() {
    for (var e = document.getElementsByTagName("script"), t = 0, n = e.length; t < n; ++t) {
        var r = e[t].getAttribute("src"),
            i = t0.exec(r);
        if (i !== null) return i[1]
    }
}
var eo;

function YA(e) {
    return typeof document > "u" ? e : (l(eo) || (eo = document.createElement("a")), eo.href = e, eo.href = eo.href, eo.href)
}
var Aa;

function n0() {
    if (l(Aa)) return Aa;
    var e;
    return typeof CESIUM_BASE_URL < "u" ? e = CESIUM_BASE_URL : typeof define == "object" && l(define.amd) && !define.amd.toUrlUndefined && l(require.toUrl) ? e = Xc("..", Hn("Core/buildModuleUrl.js")) : e = qA(), Aa = new J({
        url: YA(e)
    }), Aa.appendForwardSlash(), Aa
}

function r0(e) {
    var t = n0().getDerivedResource({
        url: e
    });
    return t.url
}
var Yf;

function Hn(e) {
    l(Yf) || (Yf = r0);
    var t = Yf(e);
    return t
}
Hn._cesiumScriptRegex = t0;
Hn._buildModuleUrlFromBaseUrl = r0;
Hn._clearBaseResource = function() {
    Aa = void 0
};
Hn.setBaseUrl = function(e) {
    Aa = J.DEFAULT.getDerivedResource({
        url: e
    })
};
Hn.getCesiumBaseUrl = n0;

function i0(e, t, n) {
    this.x = e, this.y = t, this.s = n
}

function gd(e) {
    e = p(e, p.EMPTY_OBJECT), this._xysFileUrlTemplate = J.createIfNeeded(e.xysFileUrlTemplate), this._interpolationOrder = p(e.interpolationOrder, 9), this._sampleZeroJulianEphemerisDate = p(e.sampleZeroJulianEphemerisDate, 24423965e-1), this._sampleZeroDateTT = new $(this._sampleZeroJulianEphemerisDate, 0, ke.TAI), this._stepSizeDays = p(e.stepSizeDays, 1), this._samplesPerXysFile = p(e.samplesPerXysFile, 1e3), this._totalSamples = p(e.totalSamples, 27426), this._samples = new Array(this._totalSamples * 3), this._chunkDownloadsInProgress = [];
    for (var t = this._interpolationOrder, n = this._denominators = new Array(t + 1), r = this._xTable = new Array(t + 1), i = Math.pow(this._stepSizeDays, t), a = 0; a <= t; ++a) {
        n[a] = i, r[a] = a * this._stepSizeDays;
        for (var o = 0; o <= t; ++o) o !== a && (n[a] *= a - o);
        n[a] = 1 / n[a]
    }
    this._work = new Array(t + 1), this._coef = new Array(t + 1)
}
var XA = new $(0, 0, ke.TAI);

function ul(e, t, n) {
    var r = XA;
    return r.dayNumber = t, r.secondsOfDay = n, $.daysDifference(r, e._sampleZeroDateTT)
}
gd.prototype.preload = function(e, t, n, r) {
    var i = ul(this, e, t),
        a = ul(this, n, r),
        o = i / this._stepSizeDays - this._interpolationOrder / 2 | 0;
    o < 0 && (o = 0);
    var s = a / this._stepSizeDays - this._interpolationOrder / 2 | 0 + this._interpolationOrder;
    s >= this._totalSamples && (s = this._totalSamples - 1);
    for (var c = o / this._samplesPerXysFile | 0, f = s / this._samplesPerXysFile | 0, h = [], d = c; d <= f; ++d) h.push(cl(this, d));
    return he.all(h)
};
gd.prototype.computeXysRadians = function(e, t, n) {
    var r = ul(this, e, t);
    if (!(r < 0)) {
        var i = r / this._stepSizeDays | 0;
        if (!(i >= this._totalSamples)) {
            var a = this._interpolationOrder,
                o = i - (a / 2 | 0);
            o < 0 && (o = 0);
            var s = o + a;
            s >= this._totalSamples && (s = this._totalSamples - 1, o = s - a, o < 0 && (o = 0));
            var c = !1,
                f = this._samples;
            if (l(f[o * 3]) || (cl(this, o / this._samplesPerXysFile | 0), c = !0), l(f[s * 3]) || (cl(this, s / this._samplesPerXysFile | 0), c = !0), !c) {
                l(n) ? (n.x = 0, n.y = 0, n.s = 0) : n = new i0(0, 0, 0);
                var h = r - o * this._stepSizeDays,
                    d = this._work,
                    _ = this._denominators,
                    v = this._coef,
                    m = this._xTable,
                    g, y;
                for (g = 0; g <= a; ++g) d[g] = h - m[g];
                for (g = 0; g <= a; ++g) {
                    for (v[g] = 1, y = 0; y <= a; ++y) y !== g && (v[g] *= d[y]);
                    v[g] *= _[g];
                    var E = (o + g) * 3;
                    n.x += v[g] * f[E++], n.y += v[g] * f[E++], n.s += v[g] * f[E]
                }
                return n
            }
        }
    }
};

function cl(e, t) {
    if (e._chunkDownloadsInProgress[t]) return e._chunkDownloadsInProgress[t];
    var n = he.defer();
    e._chunkDownloadsInProgress[t] = n;
    var r, i = e._xysFileUrlTemplate;
    return l(i) ? r = i.getDerivedResource({
        templateValues: {
            0: t
        }
    }) : r = new J({
        url: Hn("Assets/IAU2006_XYS/IAU2006_XYS_" + t + ".json")
    }), he(r.fetchJson(), function(a) {
        e._chunkDownloadsInProgress[t] = !1;
        for (var o = e._samples, s = a.samples, c = t * e._samplesPerXysFile * 3, f = 0, h = s.length; f < h; ++f) o[c + f] = s[f];
        n.resolve()
    }), n.promise
}
var xe = {},
    Xf = {
        up: {
            south: "east",
            north: "west",
            west: "south",
            east: "north"
        },
        down: {
            south: "west",
            north: "east",
            west: "north",
            east: "south"
        },
        south: {
            up: "west",
            down: "east",
            west: "down",
            east: "up"
        },
        north: {
            up: "east",
            down: "west",
            west: "up",
            east: "down"
        },
        west: {
            up: "north",
            down: "south",
            north: "down",
            south: "up"
        },
        east: {
            up: "south",
            down: "north",
            north: "up",
            south: "down"
        }
    },
    to = {
        north: [-1, 0, 0],
        east: [0, 1, 0],
        up: [0, 0, 1],
        south: [1, 0, 0],
        west: [0, -1, 0],
        down: [0, 0, -1]
    },
    jf = {},
    zn = {
        east: new u,
        north: new u,
        up: new u,
        west: new u,
        south: new u,
        down: new u
    },
    zi = new u,
    Bi = new u,
    Vi = new u;
xe.localFrameToFixedFrameGenerator = function(e, t) {
    if (!Xf.hasOwnProperty(e) || !Xf[e].hasOwnProperty(t)) throw new we("firstAxis and secondAxis must be east, north, up, west, south or down.");
    var n = Xf[e][t],
        r, i = e + t;
    return l(jf[i]) ? r = jf[i] : (r = function(a, o, s) {
        if (l(s) || (s = new S), u.equalsEpsilon(a, u.ZERO, T.EPSILON14)) u.unpack(to[e], 0, zi), u.unpack(to[t], 0, Bi), u.unpack(to[n], 0, Vi);
        else if (T.equalsEpsilon(a.x, 0, T.EPSILON14) && T.equalsEpsilon(a.y, 0, T.EPSILON14)) {
            var c = T.sign(a.z);
            u.unpack(to[e], 0, zi), e !== "east" && e !== "west" && u.multiplyByScalar(zi, c, zi), u.unpack(to[t], 0, Bi), t !== "east" && t !== "west" && u.multiplyByScalar(Bi, c, Bi), u.unpack(to[n], 0, Vi), n !== "east" && n !== "west" && u.multiplyByScalar(Vi, c, Vi)
        } else {
            o = p(o, ne.WGS84), o.geodeticSurfaceNormal(a, zn.up);
            var f = zn.up,
                h = zn.east;
            h.x = -a.y, h.y = a.x, h.z = 0, u.normalize(h, zn.east), u.cross(f, h, zn.north), u.multiplyByScalar(zn.up, -1, zn.down), u.multiplyByScalar(zn.east, -1, zn.west), u.multiplyByScalar(zn.north, -1, zn.south), zi = zn[e], Bi = zn[t], Vi = zn[n]
        }
        return s[0] = zi.x, s[1] = zi.y, s[2] = zi.z, s[3] = 0, s[4] = Bi.x, s[5] = Bi.y, s[6] = Bi.z, s[7] = 0, s[8] = Vi.x, s[9] = Vi.y, s[10] = Vi.z, s[11] = 0, s[12] = a.x, s[13] = a.y, s[14] = a.z, s[15] = 1, s
    }, jf[i] = r), r
};
xe.eastNorthUpToFixedFrame = xe.localFrameToFixedFrameGenerator("east", "north");
xe.northEastDownToFixedFrame = xe.localFrameToFixedFrameGenerator("north", "east");
xe.northUpEastToFixedFrame = xe.localFrameToFixedFrameGenerator("north", "up");
xe.northWestUpToFixedFrame = xe.localFrameToFixedFrameGenerator("north", "west");
var jA = new X,
    ZA = new u(1, 1, 1),
    KA = new S;
xe.headingPitchRollToFixedFrame = function(e, t, n, r, i) {
    r = p(r, xe.eastNorthUpToFixedFrame);
    var a = X.fromHeadingPitchRoll(t, jA),
        o = S.fromTranslationQuaternionRotationScale(u.ZERO, a, ZA, KA);
    return i = r(e, n, i), S.multiply(i, o, i)
};
var $A = new S,
    JA = new N;
xe.headingPitchRollQuaternion = function(e, t, n, r, i) {
    var a = xe.headingPitchRollToFixedFrame(e, t, n, r, $A),
        o = S.getMatrix3(a, JA);
    return X.fromRotationMatrix(o, i)
};
var QA = new u(1, 1, 1),
    eC = new u,
    B_ = new S,
    tC = new S,
    nC = new N,
    rC = new X;
xe.fixedFrameToHeadingPitchRoll = function(e, t, n, r) {
    t = p(t, ne.WGS84), n = p(n, xe.eastNorthUpToFixedFrame), l(r) || (r = new Xt);
    var i = S.getTranslation(e, eC);
    if (u.equals(i, u.ZERO)) return r.heading = 0, r.pitch = 0, r.roll = 0, r;
    var a = S.inverseTransformation(n(i, t, B_), B_),
        o = S.setScale(e, QA, tC);
    o = S.setTranslation(o, u.ZERO, o), a = S.multiply(a, o, a);
    var s = X.fromRotationMatrix(S.getMatrix3(a, nC), rC);
    return s = X.normalize(s, s), Xt.fromQuaternion(s, r)
};
var iC = 6 * 3600 + 41 * 60 + 50.54841,
    aC = 8640184812866e-6,
    oC = .093104,
    sC = -62e-7,
    uC = 11772758384668e-32,
    cC = 72921158553e-15,
    fC = T.TWO_PI / 86400,
    fu = new $;
xe.computeTemeToPseudoFixedMatrix = function(e, t) {
    fu = $.addSeconds(e, -$.computeTaiMinusUtc(e), fu);
    var n = fu.dayNumber,
        r = fu.secondsOfDay,
        i, a = n - 2451545;
    r >= 43200 ? i = (a + .5) / pt.DAYS_PER_JULIAN_CENTURY : i = (a - .5) / pt.DAYS_PER_JULIAN_CENTURY;
    var o = iC + i * (aC + i * (oC + i * sC)),
        s = o * fC % T.TWO_PI,
        c = cC + uC * (n - 24515455e-1),
        f = (r + pt.SECONDS_PER_DAY * .5) % pt.SECONDS_PER_DAY,
        h = s + c * f,
        d = Math.cos(h),
        _ = Math.sin(h);
    return l(t) ? (t[0] = d, t[1] = -_, t[2] = 0, t[3] = _, t[4] = d, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t) : new N(d, _, 0, -_, d, 0, 0, 0, 1)
};
xe.iau2006XysData = new gd;
xe.earthOrientationParameters = Zc.NONE;
var fl = 32.184,
    hC = 2451545;
xe.preloadIcrfFixed = function(e) {
    var t = e.start.dayNumber,
        n = e.start.secondsOfDay + fl,
        r = e.stop.dayNumber,
        i = e.stop.secondsOfDay + fl,
        a = xe.iau2006XysData.preload(t, n, r, i),
        o = xe.earthOrientationParameters.getPromiseToLoad();
    return he.all([a, o])
};
xe.computeIcrfToFixedMatrix = function(e, t) {
    l(t) || (t = new N);
    var n = xe.computeFixedToIcrfMatrix(e, t);
    if (!!l(n)) return N.transpose(n, t)
};
var lC = new i0(0, 0, 0),
    dC = new fd(0, 0, 0, 0, 0),
    Zf = new N,
    Kf = new N;
xe.computeFixedToIcrfMatrix = function(e, t) {
    l(t) || (t = new N);
    var n = xe.earthOrientationParameters.compute(e, dC);
    if (!!l(n)) {
        var r = e.dayNumber,
            i = e.secondsOfDay + fl,
            a = xe.iau2006XysData.computeXysRadians(r, i, lC);
        if (!!l(a)) {
            var o = a.x + n.xPoleOffset,
                s = a.y + n.yPoleOffset,
                c = 1 / (1 + Math.sqrt(1 - o * o - s * s)),
                f = Zf;
            f[0] = 1 - c * o * o, f[3] = -c * o * s, f[6] = o, f[1] = -c * o * s, f[4] = 1 - c * s * s, f[7] = s, f[2] = -o, f[5] = -s, f[8] = 1 - c * (o * o + s * s);
            var h = N.fromRotationZ(-a.s, Kf),
                d = N.multiply(f, h, Zf),
                _ = e.dayNumber,
                v = e.secondsOfDay - $.computeTaiMinusUtc(e) + n.ut1MinusUtc,
                m = _ - 2451545,
                g = v / pt.SECONDS_PER_DAY,
                y = .779057273264 + g + .00273781191135448 * (m + g);
            y = y % 1 * T.TWO_PI;
            var E = N.fromRotationZ(y, Kf),
                w = N.multiply(d, E, Zf),
                C = Math.cos(n.xPoleWander),
                A = Math.cos(n.yPoleWander),
                x = Math.sin(n.xPoleWander),
                P = Math.sin(n.yPoleWander),
                I = r - hC + i / pt.SECONDS_PER_DAY;
            I /= 36525;
            var D = -47e-6 * I * T.RADIANS_PER_DEGREE / 3600,
                O = Math.cos(D),
                F = Math.sin(D),
                z = Kf;
            return z[0] = C * O, z[1] = C * F, z[2] = x, z[3] = -A * F + P * x * O, z[4] = A * O + P * x * F, z[5] = -P * C, z[6] = -P * F - A * x * O, z[7] = P * O - A * x * F, z[8] = A * C, N.multiply(w, z, t)
        }
    }
};
var _C = new U;
xe.pointToWindowCoordinates = function(e, t, n, r) {
    return r = xe.pointToGLWindowCoordinates(e, t, n, r), r.y = 2 * t[5] - r.y, r
};
xe.pointToGLWindowCoordinates = function(e, t, n, r) {
    l(r) || (r = new R);
    var i = _C;
    return S.multiplyByVector(e, U.fromElements(n.x, n.y, n.z, 1, i), i), U.multiplyByScalar(i, 1 / i.w, i), S.multiplyByVector(t, i, i), R.fromCartesian4(i, r)
};
var vC = new u,
    mC = new u,
    pC = new u;
xe.rotationMatrixFromPositionVelocity = function(e, t, n, r) {
    var i = p(n, ne.WGS84).geodeticSurfaceNormal(e, vC),
        a = u.cross(t, i, mC);
    u.equalsEpsilon(a, u.ZERO, T.EPSILON6) && (a = u.clone(u.UNIT_X, a));
    var o = u.cross(a, t, pC);
    return u.normalize(o, o), u.cross(t, o, a), u.negate(a, a), u.normalize(a, a), l(r) || (r = new N), r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = a.x, r[4] = a.y, r[5] = a.z, r[6] = o.x, r[7] = o.y, r[8] = o.z, r
};
var a0 = new S(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1),
    o0 = new K,
    s0 = new u,
    gC = new u,
    yC = new N,
    hl = new S,
    u0 = new S;
xe.basisTo2D = function(e, t, n) {
    var r = S.getTranslation(t, gC),
        i = e.ellipsoid,
        a = i.cartesianToCartographic(r, o0),
        o = e.project(a, s0);
    u.fromElements(o.z, o.x, o.y, o);
    var s = xe.eastNorthUpToFixedFrame(r, i, hl),
        c = S.inverseTransformation(s, u0),
        f = S.getMatrix3(t, yC),
        h = S.multiplyByMatrix3(c, f, n);
    return S.multiply(a0, h, n), S.setTranslation(n, o, n), n
};
xe.wgs84To2DModelMatrix = function(e, t, n) {
    var r = e.ellipsoid,
        i = xe.eastNorthUpToFixedFrame(t, r, hl),
        a = S.inverseTransformation(i, u0),
        o = r.cartesianToCartographic(t, o0),
        s = e.project(o, s0);
    u.fromElements(s.z, s.x, s.y, s);
    var c = S.fromTranslation(s, hl);
    return S.multiply(a0, a, n), S.multiply(c, n, n), n
};
var Ju = {
    STREAM_DRAW: L.STREAM_DRAW,
    STATIC_DRAW: L.STATIC_DRAW,
    DYNAMIC_DRAW: L.DYNAMIC_DRAW,
    validate: function(e) {
        return e === Ju.STREAM_DRAW || e === Ju.STATIC_DRAW || e === Ju.DYNAMIC_DRAW
    }
};
const Ye = Object.freeze(Ju);

function _t(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.context._gl,
        n = e.bufferTarget,
        r = e.typedArray,
        i = e.sizeInBytes,
        a = e.usage,
        o = l(r);
    o && (i = r.byteLength);
    var s = t.createBuffer();
    t.bindBuffer(n, s), t.bufferData(n, o ? r : i, a), t.bindBuffer(n, null), this._gl = t, this._webgl2 = e.context._webgl2, this._bufferTarget = n, this._sizeInBytes = i, this._usage = a, this._buffer = s, this.vertexArrayDestroyable = !0
}
_t.createVertexBuffer = function(e) {
    return new _t({
        context: e.context,
        bufferTarget: L.ARRAY_BUFFER,
        typedArray: e.typedArray,
        sizeInBytes: e.sizeInBytes,
        usage: e.usage
    })
};
_t.createIndexBuffer = function(e) {
    var t = e.context,
        n = e.indexDatatype,
        r = yt.getSizeInBytes(n),
        i = new _t({
            context: t,
            bufferTarget: L.ELEMENT_ARRAY_BUFFER,
            typedArray: e.typedArray,
            sizeInBytes: e.sizeInBytes,
            usage: e.usage
        }),
        a = i.sizeInBytes / r;
    return Object.defineProperties(i, {
        indexDatatype: {
            get: function() {
                return n
            }
        },
        bytesPerIndex: {
            get: function() {
                return r
            }
        },
        numberOfIndices: {
            get: function() {
                return a
            }
        }
    }), i
};
Object.defineProperties(_t.prototype, {
    sizeInBytes: {
        get: function() {
            return this._sizeInBytes
        }
    },
    usage: {
        get: function() {
            return this._usage
        }
    }
});
_t.prototype._getBuffer = function() {
    return this._buffer
};
_t.prototype.copyFromArrayView = function(e, t) {
    t = p(t, 0);
    var n = this._gl,
        r = this._bufferTarget;
    n.bindBuffer(r, this._buffer), n.bufferSubData(r, t, e), n.bindBuffer(r, null)
};
_t.prototype.copyFromBuffer = function(e, t, n, r) {
    var i = L.COPY_READ_BUFFER,
        a = L.COPY_WRITE_BUFFER,
        o = this._gl;
    o.bindBuffer(a, this._buffer), o.bindBuffer(i, e._buffer), o.copyBufferSubData(i, a, t, n, r), o.bindBuffer(a, null), o.bindBuffer(i, null)
};
_t.prototype.getBufferData = function(e, t, n, r) {
    t = p(t, 0), n = p(n, 0);
    var i = this._gl,
        a = L.COPY_READ_BUFFER;
    i.bindBuffer(a, this._buffer), i.getBufferSubData(a, t, e, n, r), i.bindBuffer(a, null)
};
_t.prototype.isDestroyed = function() {
    return !1
};
_t.prototype.destroy = function() {
    return this._gl.deleteBuffer(this._buffer), Pe(this)
};
var pe = {
    _maximumCombinedTextureImageUnits: 0,
    _maximumCubeMapSize: 0,
    _maximumFragmentUniformVectors: 0,
    _maximumTextureImageUnits: 0,
    _maximumRenderbufferSize: 0,
    _maximumTextureSize: 0,
    _maximumVaryingVectors: 0,
    _maximumVertexAttributes: 0,
    _maximumVertexTextureImageUnits: 0,
    _maximumVertexUniformVectors: 0,
    _minimumAliasedLineWidth: 0,
    _maximumAliasedLineWidth: 0,
    _minimumAliasedPointSize: 0,
    _maximumAliasedPointSize: 0,
    _maximumViewportWidth: 0,
    _maximumViewportHeight: 0,
    _maximumTextureFilterAnisotropy: 0,
    _maximumDrawBuffers: 0,
    _maximumColorAttachments: 0,
    _highpFloatSupported: !1,
    _highpIntSupported: !1
};
Object.defineProperties(pe, {
    maximumCombinedTextureImageUnits: {
        get: function() {
            return pe._maximumCombinedTextureImageUnits
        }
    },
    maximumCubeMapSize: {
        get: function() {
            return pe._maximumCubeMapSize
        }
    },
    maximumFragmentUniformVectors: {
        get: function() {
            return pe._maximumFragmentUniformVectors
        }
    },
    maximumTextureImageUnits: {
        get: function() {
            return pe._maximumTextureImageUnits
        }
    },
    maximumRenderbufferSize: {
        get: function() {
            return pe._maximumRenderbufferSize
        }
    },
    maximumTextureSize: {
        get: function() {
            return pe._maximumTextureSize
        }
    },
    maximumVaryingVectors: {
        get: function() {
            return pe._maximumVaryingVectors
        }
    },
    maximumVertexAttributes: {
        get: function() {
            return pe._maximumVertexAttributes
        }
    },
    maximumVertexTextureImageUnits: {
        get: function() {
            return pe._maximumVertexTextureImageUnits
        }
    },
    maximumVertexUniformVectors: {
        get: function() {
            return pe._maximumVertexUniformVectors
        }
    },
    minimumAliasedLineWidth: {
        get: function() {
            return pe._minimumAliasedLineWidth
        }
    },
    maximumAliasedLineWidth: {
        get: function() {
            return pe._maximumAliasedLineWidth
        }
    },
    minimumAliasedPointSize: {
        get: function() {
            return pe._minimumAliasedPointSize
        }
    },
    maximumAliasedPointSize: {
        get: function() {
            return pe._maximumAliasedPointSize
        }
    },
    maximumViewportWidth: {
        get: function() {
            return pe._maximumViewportWidth
        }
    },
    maximumViewportHeight: {
        get: function() {
            return pe._maximumViewportHeight
        }
    },
    maximumTextureFilterAnisotropy: {
        get: function() {
            return pe._maximumTextureFilterAnisotropy
        }
    },
    maximumDrawBuffers: {
        get: function() {
            return pe._maximumDrawBuffers
        }
    },
    maximumColorAttachments: {
        get: function() {
            return pe._maximumColorAttachments
        }
    },
    highpFloatSupported: {
        get: function() {
            return pe._highpFloatSupported
        }
    },
    highpIntSupported: {
        get: function() {
            return pe._highpIntSupported
        }
    }
});
var Ei = {
    POINTS: L.POINTS,
    LINES: L.LINES,
    LINE_LOOP: L.LINE_LOOP,
    LINE_STRIP: L.LINE_STRIP,
    TRIANGLES: L.TRIANGLES,
    TRIANGLE_STRIP: L.TRIANGLE_STRIP,
    TRIANGLE_FAN: L.TRIANGLE_FAN
};
Ei.validate = function(e) {
    return e === Ei.POINTS || e === Ei.LINES || e === Ei.LINE_LOOP || e === Ei.LINE_STRIP || e === Ei.TRIANGLES || e === Ei.TRIANGLE_STRIP || e === Ei.TRIANGLE_FAN
};
const Ve = Object.freeze(Ei);

function an(e) {
    e = p(e, p.EMPTY_OBJECT), this._boundingVolume = e.boundingVolume, this._orientedBoundingBox = e.orientedBoundingBox, this._cull = p(e.cull, !0), this._occlude = p(e.occlude, !0), this._modelMatrix = e.modelMatrix, this._primitiveType = p(e.primitiveType, Ve.TRIANGLES), this._vertexArray = e.vertexArray, this._count = e.count, this._offset = p(e.offset, 0), this._instanceCount = p(e.instanceCount, 0), this._shaderProgram = e.shaderProgram, this._uniformMap = e.uniformMap, this._renderState = e.renderState, this._framebuffer = e.framebuffer, this._pass = e.pass, this._executeInClosestFrustum = p(e.executeInClosestFrustum, !1), this._owner = e.owner, this._debugShowBoundingVolume = p(e.debugShowBoundingVolume, !1), this._debugOverlappingFrustums = 0, this._castShadows = p(e.castShadows, !1), this._receiveShadows = p(e.receiveShadows, !1), this._pickId = e.pickId, this._pickOnly = p(e.pickOnly, !1), this.dirty = !0, this.lastDirtyTime = 0, this.derivedCommands = {}
}
Object.defineProperties(an.prototype, {
    boundingVolume: {
        get: function() {
            return this._boundingVolume
        },
        set: function(e) {
            this._boundingVolume !== e && (this._boundingVolume = e, this.dirty = !0)
        }
    },
    orientedBoundingBox: {
        get: function() {
            return this._orientedBoundingBox
        },
        set: function(e) {
            this._orientedBoundingBox !== e && (this._orientedBoundingBox = e, this.dirty = !0)
        }
    },
    cull: {
        get: function() {
            return this._cull
        },
        set: function(e) {
            this._cull !== e && (this._cull = e, this.dirty = !0)
        }
    },
    occlude: {
        get: function() {
            return this._occlude
        },
        set: function(e) {
            this._occlude !== e && (this._occlude = e, this.dirty = !0)
        }
    },
    modelMatrix: {
        get: function() {
            return this._modelMatrix
        },
        set: function(e) {
            this._modelMatrix !== e && (this._modelMatrix = e, this.dirty = !0)
        }
    },
    primitiveType: {
        get: function() {
            return this._primitiveType
        },
        set: function(e) {
            this._primitiveType !== e && (this._primitiveType = e, this.dirty = !0)
        }
    },
    vertexArray: {
        get: function() {
            return this._vertexArray
        },
        set: function(e) {
            this._vertexArray !== e && (this._vertexArray = e, this.dirty = !0)
        }
    },
    count: {
        get: function() {
            return this._count
        },
        set: function(e) {
            this._count !== e && (this._count = e, this.dirty = !0)
        }
    },
    offset: {
        get: function() {
            return this._offset
        },
        set: function(e) {
            this._offset !== e && (this._offset = e, this.dirty = !0)
        }
    },
    instanceCount: {
        get: function() {
            return this._instanceCount
        },
        set: function(e) {
            this._instanceCount !== e && (this._instanceCount = e, this.dirty = !0)
        }
    },
    shaderProgram: {
        get: function() {
            return this._shaderProgram
        },
        set: function(e) {
            this._shaderProgram !== e && (this._shaderProgram = e, this.dirty = !0)
        }
    },
    castShadows: {
        get: function() {
            return this._castShadows
        },
        set: function(e) {
            this._castShadows !== e && (this._castShadows = e, this.dirty = !0)
        }
    },
    receiveShadows: {
        get: function() {
            return this._receiveShadows
        },
        set: function(e) {
            this._receiveShadows !== e && (this._receiveShadows = e, this.dirty = !0)
        }
    },
    uniformMap: {
        get: function() {
            return this._uniformMap
        },
        set: function(e) {
            this._uniformMap !== e && (this._uniformMap = e, this.dirty = !0)
        }
    },
    renderState: {
        get: function() {
            return this._renderState
        },
        set: function(e) {
            this._renderState !== e && (this._renderState = e, this.dirty = !0)
        }
    },
    framebuffer: {
        get: function() {
            return this._framebuffer
        },
        set: function(e) {
            this._framebuffer !== e && (this._framebuffer = e, this.dirty = !0)
        }
    },
    pass: {
        get: function() {
            return this._pass
        },
        set: function(e) {
            this._pass !== e && (this._pass = e, this.dirty = !0)
        }
    },
    executeInClosestFrustum: {
        get: function() {
            return this._executeInClosestFrustum
        },
        set: function(e) {
            this._executeInClosestFrustum !== e && (this._executeInClosestFrustum = e, this.dirty = !0)
        }
    },
    owner: {
        get: function() {
            return this._owner
        },
        set: function(e) {
            this._owner !== e && (this._owner = e, this.dirty = !0)
        }
    },
    debugShowBoundingVolume: {
        get: function() {
            return this._debugShowBoundingVolume
        },
        set: function(e) {
            this._debugShowBoundingVolume !== e && (this._debugShowBoundingVolume = e, this.dirty = !0)
        }
    },
    debugOverlappingFrustums: {
        get: function() {
            return this._debugOverlappingFrustums
        },
        set: function(e) {
            this._debugOverlappingFrustums !== e && (this._debugOverlappingFrustums = e, this.dirty = !0)
        }
    },
    pickId: {
        get: function() {
            return this._pickId
        },
        set: function(e) {
            this._pickId !== e && (this._pickId = e, this.dirty = !0)
        }
    },
    pickOnly: {
        get: function() {
            return this._pickOnly
        },
        set: function(e) {
            this._pickOnly !== e && (this._pickOnly = e, this.dirty = !0)
        }
    }
});
an.shallowClone = function(e, t) {
    if (!!l(e)) return l(t) || (t = new an), t._boundingVolume = e._boundingVolume, t._orientedBoundingBox = e._orientedBoundingBox, t._cull = e._cull, t._occlude = e._occlude, t._modelMatrix = e._modelMatrix, t._primitiveType = e._primitiveType, t._vertexArray = e._vertexArray, t._count = e._count, t._offset = e._offset, t._instanceCount = e._instanceCount, t._shaderProgram = e._shaderProgram, t._uniformMap = e._uniformMap, t._renderState = e._renderState, t._framebuffer = e._framebuffer, t._pass = e._pass, t._executeInClosestFrustum = e._executeInClosestFrustum, t._owner = e._owner, t._debugShowBoundingVolume = e._debugShowBoundingVolume, t._debugOverlappingFrustums = e._debugOverlappingFrustums, t._castShadows = e._castShadows, t._receiveShadows = e._receiveShadows, t._pickId = e._pickId, t._pickOnly = e._pickOnly, t.dirty = !0, t.lastDirtyTime = 0, t
};
an.prototype.execute = function(e, t) {
    e.draw(this, t)
};
var TC = {
    ENVIRONMENT: 0,
    COMPUTE: 1,
    GLOBE: 2,
    TERRAIN_CLASSIFICATION: 3,
    CESIUM_3D_TILE: 4,
    CESIUM_3D_TILE_CLASSIFICATION: 5,
    CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW: 6,
    OPAQUE: 7,
    TRANSLUCENT: 8,
    OVERLAY: 9,
    NUMBER_OF_PASSES: 10
};
const ue = Object.freeze(TC);

function ge(e, t, n, r) {
    this.x = p(e, 0), this.y = p(t, 0), this.width = p(n, 0), this.height = p(r, 0)
}
ge.packedLength = 4;
ge.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.x, t[n++] = e.y, t[n++] = e.width, t[n] = e.height, t
};
ge.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new ge), n.x = e[t++], n.y = e[t++], n.width = e[t++], n.height = e[t], n
};
ge.fromPoints = function(e, t) {
    if (l(t) || (t = new ge), !l(e) || e.length === 0) return t.x = 0, t.y = 0, t.width = 0, t.height = 0, t;
    for (var n = e.length, r = e[0].x, i = e[0].y, a = e[0].x, o = e[0].y, s = 1; s < n; s++) {
        var c = e[s],
            f = c.x,
            h = c.y;
        r = Math.min(f, r), a = Math.max(f, a), i = Math.min(h, i), o = Math.max(h, o)
    }
    return t.x = r, t.y = i, t.width = a - r, t.height = o - i, t
};
var EC = new un,
    AC = new K,
    CC = new K;
ge.fromRectangle = function(e, t, n) {
    if (l(n) || (n = new ge), !l(e)) return n.x = 0, n.y = 0, n.width = 0, n.height = 0, n;
    t = p(t, EC);
    var r = t.project(W.southwest(e, AC)),
        i = t.project(W.northeast(e, CC));
    return R.subtract(i, r, i), n.x = r.x, n.y = r.y, n.width = i.x, n.height = i.y, n
};
ge.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height, t) : new ge(e.x, e.y, e.width, e.height)
};
ge.union = function(e, t, n) {
    l(n) || (n = new ge);
    var r = Math.min(e.x, t.x),
        i = Math.min(e.y, t.y),
        a = Math.max(e.x + e.width, t.x + t.width),
        o = Math.max(e.y + e.height, t.y + t.height);
    return n.x = r, n.y = i, n.width = a - r, n.height = o - i, n
};
ge.expand = function(e, t, n) {
    n = ge.clone(e, n);
    var r = t.x - n.x,
        i = t.y - n.y;
    return r > n.width ? n.width = r : r < 0 && (n.width -= r, n.x = t.x), i > n.height ? n.height = i : i < 0 && (n.height -= i, n.y = t.y), n
};
ge.intersect = function(e, t) {
    var n = e.x,
        r = e.y,
        i = t.x,
        a = t.y;
    return n > i + t.width || n + e.width < i || r + e.height < a || r > a + t.height ? nt.OUTSIDE : nt.INTERSECTING
};
ge.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
};
ge.prototype.clone = function(e) {
    return ge.clone(this, e)
};
ge.prototype.intersect = function(e) {
    return ge.intersect(this, e)
};
ge.prototype.equals = function(e) {
    return ge.equals(this, e)
};
var Qu = {
    CLOCKWISE: L.CW,
    COUNTER_CLOCKWISE: L.CCW
};
Qu.validate = function(e) {
    return e === Qu.CLOCKWISE || e === Qu.COUNTER_CLOCKWISE
};
const ll = Object.freeze(Qu);

function Ge(e) {
    var t = p(e, p.EMPTY_OBJECT),
        n = p(t.cull, p.EMPTY_OBJECT),
        r = p(t.polygonOffset, p.EMPTY_OBJECT),
        i = p(t.scissorTest, p.EMPTY_OBJECT),
        a = p(i.rectangle, p.EMPTY_OBJECT),
        o = p(t.depthRange, p.EMPTY_OBJECT),
        s = p(t.depthTest, p.EMPTY_OBJECT),
        c = p(t.colorMask, p.EMPTY_OBJECT),
        f = p(t.blending, p.EMPTY_OBJECT),
        h = p(f.color, p.EMPTY_OBJECT),
        d = p(t.stencilTest, p.EMPTY_OBJECT),
        _ = p(d.frontOperation, p.EMPTY_OBJECT),
        v = p(d.backOperation, p.EMPTY_OBJECT),
        m = p(t.sampleCoverage, p.EMPTY_OBJECT),
        g = t.viewport;
    this.frontFace = p(t.frontFace, ll.COUNTER_CLOCKWISE), this.cull = {
        enabled: p(n.enabled, !1),
        face: p(n.face, L.BACK)
    }, this.lineWidth = p(t.lineWidth, 1), this.polygonOffset = {
        enabled: p(r.enabled, !1),
        factor: p(r.factor, 0),
        units: p(r.units, 0)
    }, this.scissorTest = {
        enabled: p(i.enabled, !1),
        rectangle: ge.clone(a)
    }, this.depthRange = {
        near: p(o.near, 0),
        far: p(o.far, 1)
    }, this.depthTest = {
        enabled: p(s.enabled, !1),
        func: p(s.func, L.LESS)
    }, this.colorMask = {
        red: p(c.red, !0),
        green: p(c.green, !0),
        blue: p(c.blue, !0),
        alpha: p(c.alpha, !0)
    }, this.depthMask = p(t.depthMask, !0), this.stencilMask = p(t.stencilMask, -1), this.blending = {
        enabled: p(f.enabled, !1),
        color: new H(p(h.red, 0), p(h.green, 0), p(h.blue, 0), p(h.alpha, 0)),
        equationRgb: p(f.equationRgb, L.FUNC_ADD),
        equationAlpha: p(f.equationAlpha, L.FUNC_ADD),
        functionSourceRgb: p(f.functionSourceRgb, L.ONE),
        functionSourceAlpha: p(f.functionSourceAlpha, L.ONE),
        functionDestinationRgb: p(f.functionDestinationRgb, L.ZERO),
        functionDestinationAlpha: p(f.functionDestinationAlpha, L.ZERO)
    }, this.stencilTest = {
        enabled: p(d.enabled, !1),
        frontFunction: p(d.frontFunction, L.ALWAYS),
        backFunction: p(d.backFunction, L.ALWAYS),
        reference: p(d.reference, 0),
        mask: p(d.mask, -1),
        frontOperation: {
            fail: p(_.fail, L.KEEP),
            zFail: p(_.zFail, L.KEEP),
            zPass: p(_.zPass, L.KEEP)
        },
        backOperation: {
            fail: p(v.fail, L.KEEP),
            zFail: p(v.zFail, L.KEEP),
            zPass: p(v.zPass, L.KEEP)
        }
    }, this.sampleCoverage = {
        enabled: p(m.enabled, !1),
        value: p(m.value, 1),
        invert: p(m.invert, !1)
    }, this.viewport = l(g) ? new ge(g.x, g.y, g.width, g.height) : void 0, this.id = 0, this._applyFunctions = []
}
var wC = 0,
    Qr = {};
Ge.fromCache = function(e) {
    var t = JSON.stringify(e),
        n = Qr[t];
    if (l(n)) return ++n.referenceCount, n.state;
    var r = new Ge(e),
        i = JSON.stringify(r);
    return n = Qr[i], l(n) || (r.id = wC++, n = {
        referenceCount: 0,
        state: r
    }, Qr[i] = n), ++n.referenceCount, Qr[t] = {
        referenceCount: 1,
        state: n.state
    }, n.state
};
Ge.removeFromCache = function(e) {
    var t = new Ge(e),
        n = JSON.stringify(t),
        r = Qr[n],
        i = JSON.stringify(e),
        a = Qr[i];
    l(a) && (--a.referenceCount, a.referenceCount === 0 && (delete Qr[i], l(r) && --r.referenceCount)), l(r) && r.referenceCount === 0 && delete Qr[n]
};
Ge.getCache = function() {
    return Qr
};
Ge.clearCache = function() {
    Qr = {}
};

function Ba(e, t, n) {
    n ? e.enable(t) : e.disable(t)
}

function c0(e, t) {
    e.frontFace(t.frontFace)
}

function f0(e, t) {
    var n = t.cull,
        r = n.enabled;
    Ba(e, e.CULL_FACE, r), r && e.cullFace(n.face)
}

function h0(e, t) {
    e.lineWidth(t.lineWidth)
}

function l0(e, t) {
    var n = t.polygonOffset,
        r = n.enabled;
    Ba(e, e.POLYGON_OFFSET_FILL, r), r && e.polygonOffset(n.factor, n.units)
}

function d0(e, t, n) {
    var r = t.scissorTest,
        i = l(n.scissorTest) ? n.scissorTest.enabled : r.enabled;
    if (Ba(e, e.SCISSOR_TEST, i), i) {
        var a = l(n.scissorTest) ? n.scissorTest.rectangle : r.rectangle;
        e.scissor(a.x, a.y, a.width, a.height)
    }
}

function _0(e, t) {
    var n = t.depthRange;
    e.depthRange(n.near, n.far)
}

function v0(e, t) {
    var n = t.depthTest,
        r = n.enabled;
    Ba(e, e.DEPTH_TEST, r), r && e.depthFunc(n.func)
}

function m0(e, t) {
    var n = t.colorMask;
    e.colorMask(n.red, n.green, n.blue, n.alpha)
}

function p0(e, t) {
    e.depthMask(t.depthMask)
}

function g0(e, t) {
    e.stencilMask(t.stencilMask)
}

function xC(e, t) {
    e.blendColor(t.red, t.green, t.blue, t.alpha)
}

function y0(e, t, n) {
    var r = t.blending,
        i = l(n.blendingEnabled) ? n.blendingEnabled : r.enabled;
    Ba(e, e.BLEND, i), i && (xC(e, r.color), e.blendEquationSeparate(r.equationRgb, r.equationAlpha), e.blendFuncSeparate(r.functionSourceRgb, r.functionDestinationRgb, r.functionSourceAlpha, r.functionDestinationAlpha))
}

function T0(e, t) {
    var n = t.stencilTest,
        r = n.enabled;
    if (Ba(e, e.STENCIL_TEST, r), r) {
        var i = n.frontFunction,
            a = n.backFunction,
            o = n.reference,
            s = n.mask;
        e.stencilFunc(i, o, s), e.stencilFuncSeparate(e.BACK, a, o, s), e.stencilFuncSeparate(e.FRONT, i, o, s);
        var c = n.frontOperation,
            f = c.fail,
            h = c.zFail,
            d = c.zPass;
        e.stencilOpSeparate(e.FRONT, f, h, d);
        var _ = n.backOperation,
            v = _.fail,
            m = _.zFail,
            g = _.zPass;
        e.stencilOpSeparate(e.BACK, v, m, g)
    }
}

function E0(e, t) {
    var n = t.sampleCoverage,
        r = n.enabled;
    Ba(e, e.SAMPLE_COVERAGE, r), r && e.sampleCoverage(n.value, n.invert)
}
var SC = new ge;

function A0(e, t, n) {
    var r = p(t.viewport, n.viewport);
    l(r) || (r = SC, r.width = n.context.drawingBufferWidth, r.height = n.context.drawingBufferHeight), n.context.uniformState.viewport = r, e.viewport(r.x, r.y, r.width, r.height)
}
Ge.apply = function(e, t, n) {
    c0(e, t), f0(e, t), h0(e, t), l0(e, t), _0(e, t), v0(e, t), m0(e, t), p0(e, t), g0(e, t), T0(e, t), E0(e, t), d0(e, t, n), y0(e, t, n), A0(e, t, n)
};

function RC(e, t) {
    var n = [];
    return e.frontFace !== t.frontFace && n.push(c0), (e.cull.enabled !== t.cull.enabled || e.cull.face !== t.cull.face) && n.push(f0), e.lineWidth !== t.lineWidth && n.push(h0), (e.polygonOffset.enabled !== t.polygonOffset.enabled || e.polygonOffset.factor !== t.polygonOffset.factor || e.polygonOffset.units !== t.polygonOffset.units) && n.push(l0), (e.depthRange.near !== t.depthRange.near || e.depthRange.far !== t.depthRange.far) && n.push(_0), (e.depthTest.enabled !== t.depthTest.enabled || e.depthTest.func !== t.depthTest.func) && n.push(v0), (e.colorMask.red !== t.colorMask.red || e.colorMask.green !== t.colorMask.green || e.colorMask.blue !== t.colorMask.blue || e.colorMask.alpha !== t.colorMask.alpha) && n.push(m0), e.depthMask !== t.depthMask && n.push(p0), e.stencilMask !== t.stencilMask && n.push(g0), (e.stencilTest.enabled !== t.stencilTest.enabled || e.stencilTest.frontFunction !== t.stencilTest.frontFunction || e.stencilTest.backFunction !== t.stencilTest.backFunction || e.stencilTest.reference !== t.stencilTest.reference || e.stencilTest.mask !== t.stencilTest.mask || e.stencilTest.frontOperation.fail !== t.stencilTest.frontOperation.fail || e.stencilTest.frontOperation.zFail !== t.stencilTest.frontOperation.zFail || e.stencilTest.backOperation.fail !== t.stencilTest.backOperation.fail || e.stencilTest.backOperation.zFail !== t.stencilTest.backOperation.zFail || e.stencilTest.backOperation.zPass !== t.stencilTest.backOperation.zPass) && n.push(T0), (e.sampleCoverage.enabled !== t.sampleCoverage.enabled || e.sampleCoverage.value !== t.sampleCoverage.value || e.sampleCoverage.invert !== t.sampleCoverage.invert) && n.push(E0), n
}
Ge.partialApply = function(e, t, n, r, i, a) {
    if (t !== n) {
        var o = n._applyFunctions[t.id];
        l(o) || (o = RC(t, n), n._applyFunctions[t.id] = o);
        for (var s = o.length, c = 0; c < s; ++c) o[c](e, n)
    }
    var f = l(r.scissorTest) ? r.scissorTest : t.scissorTest,
        h = l(i.scissorTest) ? i.scissorTest : n.scissorTest;
    (f !== h || a) && d0(e, n, i);
    var d = l(r.blendingEnabled) ? r.blendingEnabled : t.blending.enabled,
        _ = l(i.blendingEnabled) ? i.blendingEnabled : n.blending.enabled;
    (d !== _ || _ && t.blending !== n.blending) && y0(e, n, i), (t !== n || r !== i || r.context !== i.context) && A0(e, n, i)
};
Ge.getState = function(e) {
    return {
        frontFace: e.frontFace,
        cull: {
            enabled: e.cull.enabled,
            face: e.cull.face
        },
        lineWidth: e.lineWidth,
        polygonOffset: {
            enabled: e.polygonOffset.enabled,
            factor: e.polygonOffset.factor,
            units: e.polygonOffset.units
        },
        scissorTest: {
            enabled: e.scissorTest.enabled,
            rectangle: ge.clone(e.scissorTest.rectangle)
        },
        depthRange: {
            near: e.depthRange.near,
            far: e.depthRange.far
        },
        depthTest: {
            enabled: e.depthTest.enabled,
            func: e.depthTest.func
        },
        colorMask: {
            red: e.colorMask.red,
            green: e.colorMask.green,
            blue: e.colorMask.blue,
            alpha: e.colorMask.alpha
        },
        depthMask: e.depthMask,
        stencilMask: e.stencilMask,
        blending: {
            enabled: e.blending.enabled,
            color: H.clone(e.blending.color),
            equationRgb: e.blending.equationRgb,
            equationAlpha: e.blending.equationAlpha,
            functionSourceRgb: e.blending.functionSourceRgb,
            functionSourceAlpha: e.blending.functionSourceAlpha,
            functionDestinationRgb: e.blending.functionDestinationRgb,
            functionDestinationAlpha: e.blending.functionDestinationAlpha
        },
        stencilTest: {
            enabled: e.stencilTest.enabled,
            frontFunction: e.stencilTest.frontFunction,
            backFunction: e.stencilTest.backFunction,
            reference: e.stencilTest.reference,
            mask: e.stencilTest.mask,
            frontOperation: {
                fail: e.stencilTest.frontOperation.fail,
                zFail: e.stencilTest.frontOperation.zFail,
                zPass: e.stencilTest.frontOperation.zPass
            },
            backOperation: {
                fail: e.stencilTest.backOperation.fail,
                zFail: e.stencilTest.backOperation.zFail,
                zPass: e.stencilTest.backOperation.zPass
            }
        },
        sampleCoverage: {
            enabled: e.sampleCoverage.enabled,
            value: e.sampleCoverage.value,
            invert: e.sampleCoverage.invert
        },
        viewport: l(e.viewport) ? ge.clone(e.viewport) : void 0
    }
};
var DC = new u;

function oe(e) {
    this._size = e.size, this._datatype = e.datatype, this.getValue = e.getValue
}
var tn = {};
tn[L.FLOAT] = "float";
tn[L.FLOAT_VEC2] = "vec2";
tn[L.FLOAT_VEC3] = "vec3";
tn[L.FLOAT_VEC4] = "vec4";
tn[L.INT] = "int";
tn[L.INT_VEC2] = "ivec2";
tn[L.INT_VEC3] = "ivec3";
tn[L.INT_VEC4] = "ivec4";
tn[L.BOOL] = "bool";
tn[L.BOOL_VEC2] = "bvec2";
tn[L.BOOL_VEC3] = "bvec3";
tn[L.BOOL_VEC4] = "bvec4";
tn[L.FLOAT_MAT2] = "mat2";
tn[L.FLOAT_MAT3] = "mat3";
tn[L.FLOAT_MAT4] = "mat4";
tn[L.SAMPLER_2D] = "sampler2D";
tn[L.SAMPLER_CUBE] = "samplerCube";
oe.prototype.getDeclaration = function(e) {
    var t = "uniform " + tn[this._datatype] + " " + e,
        n = this._size;
    return n === 1 ? t += ";" : t += "[" + n.toString() + "];", t
};
var ec = {
    czm_viewport: new oe({
        size: 1,
        datatype: L.FLOAT_VEC4,
        getValue: function(e) {
            return e.viewportCartesian4
        }
    }),
    czm_viewportOrthographic: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.viewportOrthographic
        }
    }),
    czm_viewportTransformation: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.viewportTransformation
        }
    }),
    czm_globeDepthTexture: new oe({
        size: 1,
        datatype: L.SAMPLER_2D,
        getValue: function(e) {
            return e.globeDepthTexture
        }
    }),
    czm_model: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.model
        }
    }),
    czm_inverseModel: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.inverseModel
        }
    }),
    czm_view: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.view
        }
    }),
    czm_view3D: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.view3D
        }
    }),
    czm_viewRotation: new oe({
        size: 1,
        datatype: L.FLOAT_MAT3,
        getValue: function(e) {
            return e.viewRotation
        }
    }),
    czm_viewRotation3D: new oe({
        size: 1,
        datatype: L.FLOAT_MAT3,
        getValue: function(e) {
            return e.viewRotation3D
        }
    }),
    czm_inverseView: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.inverseView
        }
    }),
    czm_inverseView3D: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.inverseView3D
        }
    }),
    czm_inverseViewRotation: new oe({
        size: 1,
        datatype: L.FLOAT_MAT3,
        getValue: function(e) {
            return e.inverseViewRotation
        }
    }),
    czm_inverseViewRotation3D: new oe({
        size: 1,
        datatype: L.FLOAT_MAT3,
        getValue: function(e) {
            return e.inverseViewRotation3D
        }
    }),
    czm_projection: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.projection
        }
    }),
    czm_inverseProjection: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.inverseProjection
        }
    }),
    czm_infiniteProjection: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.infiniteProjection
        }
    }),
    czm_modelView: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.modelView
        }
    }),
    czm_modelView3D: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.modelView3D
        }
    }),
    czm_modelViewRelativeToEye: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.modelViewRelativeToEye
        }
    }),
    czm_inverseModelView: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.inverseModelView
        }
    }),
    czm_inverseModelView3D: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.inverseModelView3D
        }
    }),
    czm_viewProjection: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.viewProjection
        }
    }),
    czm_inverseViewProjection: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.inverseViewProjection
        }
    }),
    czm_modelViewProjection: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.modelViewProjection
        }
    }),
    czm_inverseModelViewProjection: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.inverseModelViewProjection
        }
    }),
    czm_modelViewProjectionRelativeToEye: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.modelViewProjectionRelativeToEye
        }
    }),
    czm_modelViewInfiniteProjection: new oe({
        size: 1,
        datatype: L.FLOAT_MAT4,
        getValue: function(e) {
            return e.modelViewInfiniteProjection
        }
    }),
    czm_orthographicIn3D: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.orthographicIn3D ? 1 : 0
        }
    }),
    czm_normal: new oe({
        size: 1,
        datatype: L.FLOAT_MAT3,
        getValue: function(e) {
            return e.normal
        }
    }),
    czm_normal3D: new oe({
        size: 1,
        datatype: L.FLOAT_MAT3,
        getValue: function(e) {
            return e.normal3D
        }
    }),
    czm_inverseNormal: new oe({
        size: 1,
        datatype: L.FLOAT_MAT3,
        getValue: function(e) {
            return e.inverseNormal
        }
    }),
    czm_inverseNormal3D: new oe({
        size: 1,
        datatype: L.FLOAT_MAT3,
        getValue: function(e) {
            return e.inverseNormal3D
        }
    }),
    czm_eyeHeight: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.eyeHeight
        }
    }),
    czm_eyeHeight2D: new oe({
        size: 1,
        datatype: L.FLOAT_VEC2,
        getValue: function(e) {
            return e.eyeHeight2D
        }
    }),
    czm_entireFrustum: new oe({
        size: 1,
        datatype: L.FLOAT_VEC2,
        getValue: function(e) {
            return e.entireFrustum
        }
    }),
    czm_currentFrustum: new oe({
        size: 1,
        datatype: L.FLOAT_VEC2,
        getValue: function(e) {
            return e.currentFrustum
        }
    }),
    czm_frustumPlanes: new oe({
        size: 1,
        datatype: L.FLOAT_VEC4,
        getValue: function(e) {
            return e.frustumPlanes
        }
    }),
    czm_farDepthFromNearPlusOne: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.farDepthFromNearPlusOne
        }
    }),
    czm_log2FarDepthFromNearPlusOne: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.log2FarDepthFromNearPlusOne
        }
    }),
    czm_oneOverLog2FarDepthFromNearPlusOne: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.oneOverLog2FarDepthFromNearPlusOne
        }
    }),
    czm_sunPositionWC: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.sunPositionWC
        }
    }),
    czm_sunPositionColumbusView: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.sunPositionColumbusView
        }
    }),
    czm_sunDirectionEC: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.sunDirectionEC
        }
    }),
    czm_sunDirectionWC: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.sunDirectionWC
        }
    }),
    czm_moonDirectionEC: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.moonDirectionEC
        }
    }),
    czm_lightDirectionEC: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.lightDirectionEC
        }
    }),
    czm_lightDirectionWC: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.lightDirectionWC
        }
    }),
    czm_lightColor: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.lightColor
        }
    }),
    czm_lightColorHdr: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.lightColorHdr
        }
    }),
    czm_encodedCameraPositionMCHigh: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.encodedCameraPositionMCHigh
        }
    }),
    czm_encodedCameraPositionMCLow: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.encodedCameraPositionMCLow
        }
    }),
    czm_viewerPositionWC: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return S.getTranslation(e.inverseView, DC)
        }
    }),
    czm_frameNumber: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.frameState.frameNumber
        }
    }),
    czm_morphTime: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.frameState.morphTime
        }
    }),
    czm_sceneMode: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.frameState.mode
        }
    }),
    czm_pass: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.pass
        }
    }),
    czm_backgroundColor: new oe({
        size: 1,
        datatype: L.FLOAT_VEC4,
        getValue: function(e) {
            return e.backgroundColor
        }
    }),
    czm_brdfLut: new oe({
        size: 1,
        datatype: L.SAMPLER_2D,
        getValue: function(e) {
            return e.brdfLut
        }
    }),
    czm_environmentMap: new oe({
        size: 1,
        datatype: L.SAMPLER_CUBE,
        getValue: function(e) {
            return e.environmentMap
        }
    }),
    czm_specularEnvironmentMaps: new oe({
        size: 1,
        datatype: L.SAMPLER_2D,
        getValue: function(e) {
            return e.specularEnvironmentMaps
        }
    }),
    czm_specularEnvironmentMapSize: new oe({
        size: 1,
        datatype: L.FLOAT_VEC2,
        getValue: function(e) {
            return e.specularEnvironmentMapsDimensions
        }
    }),
    czm_specularEnvironmentMapsMaximumLOD: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.specularEnvironmentMapsMaximumLOD
        }
    }),
    czm_sphericalHarmonicCoefficients: new oe({
        size: 9,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.sphericalHarmonicCoefficients
        }
    }),
    czm_temeToPseudoFixed: new oe({
        size: 1,
        datatype: L.FLOAT_MAT3,
        getValue: function(e) {
            return e.temeToPseudoFixedMatrix
        }
    }),
    czm_pixelRatio: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.pixelRatio
        }
    }),
    czm_fogDensity: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.fogDensity
        }
    }),
    czm_imagerySplitPosition: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.imagerySplitPosition
        }
    }),
    czm_geometricToleranceOverMeter: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.geometricToleranceOverMeter
        }
    }),
    czm_minimumDisableDepthTestDistance: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.minimumDisableDepthTestDistance
        }
    }),
    czm_invertClassificationColor: new oe({
        size: 1,
        datatype: L.FLOAT_VEC4,
        getValue: function(e) {
            return e.invertClassificationColor
        }
    }),
    czm_gamma: new oe({
        size: 1,
        datatype: L.FLOAT,
        getValue: function(e) {
            return e.gamma
        }
    }),
    czm_ellipsoidRadii: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.ellipsoid.radii
        }
    }),
    czm_ellipsoidInverseRadii: new oe({
        size: 1,
        datatype: L.FLOAT_VEC3,
        getValue: function(e) {
            return e.ellipsoid.oneOverRadii
        }
    })
};

function fe(e, t, n, r) {
    this[0] = p(e, 0), this[1] = p(n, 0), this[2] = p(t, 0), this[3] = p(r, 0)
}
fe.packedLength = 4;
fe.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e[0], t[n++] = e[1], t[n++] = e[2], t[n++] = e[3], t
};
fe.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new fe), n[0] = e[t++], n[1] = e[t++], n[2] = e[t++], n[3] = e[t++], n
};
fe.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t) : new fe(e[0], e[2], e[1], e[3])
};
fe.fromArray = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new fe), n[0] = e[t], n[1] = e[t + 1], n[2] = e[t + 2], n[3] = e[t + 3], n
};
fe.fromColumnMajorArray = function(e, t) {
    return fe.clone(e, t)
};
fe.fromRowMajorArray = function(e, t) {
    return l(t) ? (t[0] = e[0], t[1] = e[2], t[2] = e[1], t[3] = e[3], t) : new fe(e[0], e[1], e[2], e[3])
};
fe.fromScale = function(e, t) {
    return l(t) ? (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = e.y, t) : new fe(e.x, 0, 0, e.y)
};
fe.fromUniformScale = function(e, t) {
    return l(t) ? (t[0] = e, t[1] = 0, t[2] = 0, t[3] = e, t) : new fe(e, 0, 0, e)
};
fe.fromRotation = function(e, t) {
    var n = Math.cos(e),
        r = Math.sin(e);
    return l(t) ? (t[0] = n, t[1] = r, t[2] = -r, t[3] = n, t) : new fe(n, -r, r, n)
};
fe.toArray = function(e, t) {
    return l(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t) : [e[0], e[1], e[2], e[3]]
};
fe.getElementIndex = function(e, t) {
    return e * 2 + t
};
fe.getColumn = function(e, t, n) {
    var r = t * 2,
        i = e[r],
        a = e[r + 1];
    return n.x = i, n.y = a, n
};
fe.setColumn = function(e, t, n, r) {
    r = fe.clone(e, r);
    var i = t * 2;
    return r[i] = n.x, r[i + 1] = n.y, r
};
fe.getRow = function(e, t, n) {
    var r = e[t],
        i = e[t + 2];
    return n.x = r, n.y = i, n
};
fe.setRow = function(e, t, n, r) {
    return r = fe.clone(e, r), r[t] = n.x, r[t + 2] = n.y, r
};
var V_ = new R;
fe.getScale = function(e, t) {
    return t.x = R.magnitude(R.fromElements(e[0], e[1], V_)), t.y = R.magnitude(R.fromElements(e[2], e[3], V_)), t
};
var G_ = new R;
fe.getMaximumScale = function(e) {
    return fe.getScale(e, G_), R.maximumComponent(G_)
};
fe.multiply = function(e, t, n) {
    var r = e[0] * t[0] + e[2] * t[1],
        i = e[0] * t[2] + e[2] * t[3],
        a = e[1] * t[0] + e[3] * t[1],
        o = e[1] * t[2] + e[3] * t[3];
    return n[0] = r, n[1] = a, n[2] = i, n[3] = o, n
};
fe.add = function(e, t, n) {
    return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n[2] = e[2] + t[2], n[3] = e[3] + t[3], n
};
fe.subtract = function(e, t, n) {
    return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[3] = e[3] - t[3], n
};
fe.multiplyByVector = function(e, t, n) {
    var r = e[0] * t.x + e[2] * t.y,
        i = e[1] * t.x + e[3] * t.y;
    return n.x = r, n.y = i, n
};
fe.multiplyByScalar = function(e, t, n) {
    return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n
};
fe.multiplyByScale = function(e, t, n) {
    return n[0] = e[0] * t.x, n[1] = e[1] * t.x, n[2] = e[2] * t.y, n[3] = e[3] * t.y, n
};
fe.negate = function(e, t) {
    return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t
};
fe.transpose = function(e, t) {
    var n = e[0],
        r = e[2],
        i = e[1],
        a = e[3];
    return t[0] = n, t[1] = r, t[2] = i, t[3] = a, t
};
fe.abs = function(e, t) {
    return t[0] = Math.abs(e[0]), t[1] = Math.abs(e[1]), t[2] = Math.abs(e[2]), t[3] = Math.abs(e[3]), t
};
fe.equals = function(e, t) {
    return e === t || l(e) && l(t) && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
};
fe.equalsArray = function(e, t, n) {
    return e[0] === t[n] && e[1] === t[n + 1] && e[2] === t[n + 2] && e[3] === t[n + 3]
};
fe.equalsEpsilon = function(e, t, n) {
    return n = p(n, 0), e === t || l(e) && l(t) && Math.abs(e[0] - t[0]) <= n && Math.abs(e[1] - t[1]) <= n && Math.abs(e[2] - t[2]) <= n && Math.abs(e[3] - t[3]) <= n
};
fe.IDENTITY = Object.freeze(new fe(1, 0, 0, 1));
fe.ZERO = Object.freeze(new fe(0, 0, 0, 0));
fe.COLUMN0ROW0 = 0;
fe.COLUMN0ROW1 = 1;
fe.COLUMN1ROW0 = 2;
fe.COLUMN1ROW1 = 3;
Object.defineProperties(fe.prototype, {
    length: {
        get: function() {
            return fe.packedLength
        }
    }
});
fe.prototype.clone = function(e) {
    return fe.clone(this, e)
};
fe.prototype.equals = function(e) {
    return fe.equals(this, e)
};
fe.prototype.equalsEpsilon = function(e, t) {
    return fe.equalsEpsilon(this, e, t)
};
fe.prototype.toString = function() {
    return "(" + this[0] + ", " + this[2] + `)
(` + this[1] + ", " + this[3] + ")"
};

function IC(e, t, n, r) {
    switch (t.type) {
        case e.FLOAT:
            return new C0(e, t, n, r);
        case e.FLOAT_VEC2:
            return new w0(e, t, n, r);
        case e.FLOAT_VEC3:
            return new x0(e, t, n, r);
        case e.FLOAT_VEC4:
            return new S0(e, t, n, r);
        case e.SAMPLER_2D:
        case e.SAMPLER_CUBE:
            return new yd(e, t, n, r);
        case e.INT:
        case e.BOOL:
            return new R0(e, t, n, r);
        case e.INT_VEC2:
        case e.BOOL_VEC2:
            return new D0(e, t, n, r);
        case e.INT_VEC3:
        case e.BOOL_VEC3:
            return new I0(e, t, n, r);
        case e.INT_VEC4:
        case e.BOOL_VEC4:
            return new P0(e, t, n, r);
        case e.FLOAT_MAT2:
            return new O0(e, t, n, r);
        case e.FLOAT_MAT3:
            return new M0(e, t, n, r);
        case e.FLOAT_MAT4:
            return new N0(e, t, n, r);
        default:
            throw new je("Unrecognized uniform type: " + t.type + ' for uniform "' + n + '".')
    }
}

function C0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = 0, this._gl = e, this._location = r
}
C0.prototype.set = function() {
    this.value !== this._value && (this._value = this.value, this._gl.uniform1f(this._location, this.value))
};

function w0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = new R, this._gl = e, this._location = r
}
w0.prototype.set = function() {
    var e = this.value;
    R.equals(e, this._value) || (R.clone(e, this._value), this._gl.uniform2f(this._location, e.x, e.y))
};

function x0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = void 0, this._gl = e, this._location = r
}
x0.prototype.set = function() {
    var e = this.value;
    l(e.red) ? H.equals(e, this._value) || (this._value = H.clone(e, this._value), this._gl.uniform3f(this._location, e.red, e.green, e.blue)) : l(e.x) && (u.equals(e, this._value) || (this._value = u.clone(e, this._value), this._gl.uniform3f(this._location, e.x, e.y, e.z)))
};

function S0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = void 0, this._gl = e, this._location = r
}
S0.prototype.set = function() {
    var e = this.value;
    l(e.red) ? H.equals(e, this._value) || (this._value = H.clone(e, this._value), this._gl.uniform4f(this._location, e.red, e.green, e.blue, e.alpha)) : l(e.x) && (U.equals(e, this._value) || (this._value = U.clone(e, this._value), this._gl.uniform4f(this._location, e.x, e.y, e.z, e.w)))
};

function yd(e, t, n, r) {
    this.name = n, this.value = void 0, this._gl = e, this._location = r, this.textureUnitIndex = void 0
}
yd.prototype.set = function() {
    var e = this._gl;
    e.activeTexture(e.TEXTURE0 + this.textureUnitIndex);
    var t = this.value;
    e.bindTexture(t._target, t._texture)
};
yd.prototype._setSampler = function(e) {
    return this.textureUnitIndex = e, this._gl.uniform1i(this._location, e), e + 1
};

function R0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = 0, this._gl = e, this._location = r
}
R0.prototype.set = function() {
    this.value !== this._value && (this._value = this.value, this._gl.uniform1i(this._location, this.value))
};

function D0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = new R, this._gl = e, this._location = r
}
D0.prototype.set = function() {
    var e = this.value;
    R.equals(e, this._value) || (R.clone(e, this._value), this._gl.uniform2i(this._location, e.x, e.y))
};

function I0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = new u, this._gl = e, this._location = r
}
I0.prototype.set = function() {
    var e = this.value;
    u.equals(e, this._value) || (u.clone(e, this._value), this._gl.uniform3i(this._location, e.x, e.y, e.z))
};

function P0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = new U, this._gl = e, this._location = r
}
P0.prototype.set = function() {
    var e = this.value;
    U.equals(e, this._value) || (U.clone(e, this._value), this._gl.uniform4i(this._location, e.x, e.y, e.z, e.w))
};
var PC = new Float32Array(4);

function O0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = new fe, this._gl = e, this._location = r
}
O0.prototype.set = function() {
    if (!fe.equalsArray(this.value, this._value, 0)) {
        fe.clone(this.value, this._value);
        var e = fe.toArray(this.value, PC);
        this._gl.uniformMatrix2fv(this._location, !1, e)
    }
};
var OC = new Float32Array(9);

function M0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = new N, this._gl = e, this._location = r
}
M0.prototype.set = function() {
    if (!N.equalsArray(this.value, this._value, 0)) {
        N.clone(this.value, this._value);
        var e = N.toArray(this.value, OC);
        this._gl.uniformMatrix3fv(this._location, !1, e)
    }
};
var MC = new Float32Array(16);

function N0(e, t, n, r) {
    this.name = n, this.value = void 0, this._value = new S, this._gl = e, this._location = r
}
N0.prototype.set = function() {
    if (!S.equalsArray(this.value, this._value, 0)) {
        S.clone(this.value, this._value);
        var e = S.toArray(this.value, MC);
        this._gl.uniformMatrix4fv(this._location, !1, e)
    }
};

function NC(e, t, n, r) {
    switch (t.type) {
        case e.FLOAT:
            return new b0(e, t, n, r);
        case e.FLOAT_VEC2:
            return new F0(e, t, n, r);
        case e.FLOAT_VEC3:
            return new L0(e, t, n, r);
        case e.FLOAT_VEC4:
            return new U0(e, t, n, r);
        case e.SAMPLER_2D:
        case e.SAMPLER_CUBE:
            return new Td(e, t, n, r);
        case e.INT:
        case e.BOOL:
            return new z0(e, t, n, r);
        case e.INT_VEC2:
        case e.BOOL_VEC2:
            return new B0(e, t, n, r);
        case e.INT_VEC3:
        case e.BOOL_VEC3:
            return new V0(e, t, n, r);
        case e.INT_VEC4:
        case e.BOOL_VEC4:
            return new G0(e, t, n, r);
        case e.FLOAT_MAT2:
            return new H0(e, t, n, r);
        case e.FLOAT_MAT3:
            return new k0(e, t, n, r);
        case e.FLOAT_MAT4:
            return new W0(e, t, n, r);
        default:
            throw new je("Unrecognized uniform type: " + t.type + ' for uniform "' + n + '".')
    }
}

function b0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Float32Array(i), this._gl = e, this._location = r[0]
}
b0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0; i < t; ++i) {
        var a = e[i];
        a !== n[i] && (n[i] = a, r = !0)
    }
    r && this._gl.uniform1fv(this._location, n)
};

function F0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Float32Array(i * 2), this._gl = e, this._location = r[0]
}
F0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0, a = 0; a < t; ++a) {
        var o = e[a];
        R.equalsArray(o, n, i) || (R.pack(o, n, i), r = !0), i += 2
    }
    r && this._gl.uniform2fv(this._location, n)
};

function L0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Float32Array(i * 3), this._gl = e, this._location = r[0]
}
L0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0, a = 0; a < t; ++a) {
        var o = e[a];
        l(o.red) ? (o.red !== n[i] || o.green !== n[i + 1] || o.blue !== n[i + 2]) && (n[i] = o.red, n[i + 1] = o.green, n[i + 2] = o.blue, r = !0) : l(o.x) && (u.equalsArray(o, n, i) || (u.pack(o, n, i), r = !0)), i += 3
    }
    r && this._gl.uniform3fv(this._location, n)
};

function U0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Float32Array(i * 4), this._gl = e, this._location = r[0]
}
U0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0, a = 0; a < t; ++a) {
        var o = e[a];
        l(o.red) ? H.equalsArray(o, n, i) || (H.pack(o, n, i), r = !0) : l(o.x) && (U.equalsArray(o, n, i) || (U.pack(o, n, i), r = !0)), i += 4
    }
    r && this._gl.uniform4fv(this._location, n)
};

function Td(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Float32Array(i), this._gl = e, this._locations = r, this.textureUnitIndex = void 0
}
Td.prototype.set = function() {
    for (var e = this._gl, t = e.TEXTURE0 + this.textureUnitIndex, n = this.value, r = n.length, i = 0; i < r; ++i) {
        var a = n[i];
        e.activeTexture(t + i), e.bindTexture(a._target, a._texture)
    }
};
Td.prototype._setSampler = function(e) {
    this.textureUnitIndex = e;
    for (var t = this._locations, n = t.length, r = 0; r < n; ++r) {
        var i = e + r;
        this._gl.uniform1i(t[r], i)
    }
    return e + n
};

function z0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Int32Array(i), this._gl = e, this._location = r[0]
}
z0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0; i < t; ++i) {
        var a = e[i];
        a !== n[i] && (n[i] = a, r = !0)
    }
    r && this._gl.uniform1iv(this._location, n)
};

function B0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Int32Array(i * 2), this._gl = e, this._location = r[0]
}
B0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0, a = 0; a < t; ++a) {
        var o = e[a];
        R.equalsArray(o, n, i) || (R.pack(o, n, i), r = !0), i += 2
    }
    r && this._gl.uniform2iv(this._location, n)
};

function V0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Int32Array(i * 3), this._gl = e, this._location = r[0]
}
V0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0, a = 0; a < t; ++a) {
        var o = e[a];
        u.equalsArray(o, n, i) || (u.pack(o, n, i), r = !0), i += 3
    }
    r && this._gl.uniform3iv(this._location, n)
};

function G0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Int32Array(i * 4), this._gl = e, this._location = r[0]
}
G0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0, a = 0; a < t; ++a) {
        var o = e[a];
        U.equalsArray(o, n, i) || (U.pack(o, n, i), r = !0), i += 4
    }
    r && this._gl.uniform4iv(this._location, n)
};

function H0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Float32Array(i * 4), this._gl = e, this._location = r[0]
}
H0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0, a = 0; a < t; ++a) {
        var o = e[a];
        fe.equalsArray(o, n, i) || (fe.pack(o, n, i), r = !0), i += 4
    }
    r && this._gl.uniformMatrix2fv(this._location, !1, n)
};

function k0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Float32Array(i * 9), this._gl = e, this._location = r[0]
}
k0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0, a = 0; a < t; ++a) {
        var o = e[a];
        N.equalsArray(o, n, i) || (N.pack(o, n, i), r = !0), i += 9
    }
    r && this._gl.uniformMatrix3fv(this._location, !1, n)
};

function W0(e, t, n, r) {
    var i = r.length;
    this.name = n, this.value = new Array(i), this._value = new Float32Array(i * 16), this._gl = e, this._location = r[0]
}
W0.prototype.set = function() {
    for (var e = this.value, t = e.length, n = this._value, r = !1, i = 0, a = 0; a < t; ++a) {
        var o = e[a];
        S.equalsArray(o, n, i) || (S.pack(o, n, i), r = !0), i += 16
    }
    r && this._gl.uniformMatrix4fv(this._location, !1, n)
};
var bC = 0;

function Mt(e) {
    var t = e.vertexShaderText,
        n = e.fragmentShaderText;
    typeof spector < "u" && (t = t.replace(/^#line/gm, "//#line"), n = n.replace(/^#line/gm, "//#line"));
    var r = FC(t, n);
    this._gl = e.gl, this._logShaderCompilation = e.logShaderCompilation, this._debugShaders = e.debugShaders, this._attributeLocations = e.attributeLocations, this._program = void 0, this._numberOfVertexAttributes = void 0, this._vertexAttributes = void 0, this._uniformsByName = void 0, this._uniforms = void 0, this._automaticUniforms = void 0, this._manualUniforms = void 0, this._duplicateUniformNames = r.duplicateUniformNames, this._cachedShader = void 0, this.maximumTextureUnitIndex = void 0, this._vertexShaderSource = e.vertexShaderSource, this._vertexShaderText = e.vertexShaderText, this._fragmentShaderSource = e.fragmentShaderSource, this._fragmentShaderText = r.fragmentShaderText, this.id = bC++
}
Mt.fromCache = function(e) {
    return e = p(e, p.EMPTY_OBJECT), e.context.shaderCache.getShaderProgram(e)
};
Mt.replaceCache = function(e) {
    return e = p(e, p.EMPTY_OBJECT), e.context.shaderCache.replaceShaderProgram(e)
};
Object.defineProperties(Mt.prototype, {
    vertexShaderSource: {
        get: function() {
            return this._vertexShaderSource
        }
    },
    fragmentShaderSource: {
        get: function() {
            return this._fragmentShaderSource
        }
    },
    vertexAttributes: {
        get: function() {
            return tc(this), this._vertexAttributes
        }
    },
    numberOfVertexAttributes: {
        get: function() {
            return tc(this), this._numberOfVertexAttributes
        }
    },
    allUniforms: {
        get: function() {
            return tc(this), this._uniformsByName
        }
    }
});

function H_(e) {
    var t = [],
        n = e.match(/uniform.*?(?![^{]*})(?=[=\[;])/g);
    if (l(n))
        for (var r = n.length, i = 0; i < r; i++) {
            var a = n[i].trim(),
                o = a.slice(a.lastIndexOf(" ") + 1);
            t.push(o)
        }
    return t
}

function FC(e, t) {
    var n = {};
    if (!pe.highpFloatSupported || !pe.highpIntSupported) {
        var r, i, a, o, s = H_(e),
            c = H_(t),
            f = s.length,
            h = c.length;
        for (r = 0; r < f; r++)
            for (i = 0; i < h; i++)
                if (s[r] === c[i]) {
                    a = s[r], o = "czm_mediump_" + a;
                    var d = new RegExp(a + "\\b", "g");
                    t = t.replace(d, o), n[o] = a
                }
    }
    return {
        fragmentShaderText: t,
        duplicateUniformNames: n
    }
}
var ur = "[Cesium WebGL] ";

function LC(e, t) {
    var n = t._vertexShaderText,
        r = t._fragmentShaderText,
        i = e.createShader(e.VERTEX_SHADER);
    e.shaderSource(i, n), e.compileShader(i);
    var a = e.createShader(e.FRAGMENT_SHADER);
    e.shaderSource(a, r), e.compileShader(a);
    var o = e.createProgram();
    e.attachShader(o, i), e.attachShader(o, a), e.deleteShader(i), e.deleteShader(a);
    var s = t._attributeLocations;
    if (l(s))
        for (var c in s) s.hasOwnProperty(c) && e.bindAttribLocation(o, s[c], c);
    e.linkProgram(o);
    var f;
    if (!e.getProgramParameter(o, e.LINK_STATUS)) {
        var h = t._debugShaders;
        if (!e.getShaderParameter(a, e.COMPILE_STATUS)) {
            if (f = e.getShaderInfoLog(a), console.error(ur + "Fragment shader compile log: " + f), l(h)) {
                var d = h.getTranslatedShaderSource(a);
                console.error(d !== "" ? ur + `Translated fragment shader source:
` + d : ur + "Fragment shader translation failed.")
            }
            throw e.deleteProgram(o), new je("Fragment shader failed to compile.  Compile log: " + f)
        }
        if (!e.getShaderParameter(i, e.COMPILE_STATUS)) {
            if (f = e.getShaderInfoLog(i), console.error(ur + "Vertex shader compile log: " + f), l(h)) {
                var _ = h.getTranslatedShaderSource(i);
                console.error(_ !== "" ? ur + `Translated vertex shader source:
` + _ : ur + "Vertex shader translation failed.")
            }
            throw e.deleteProgram(o), new je("Vertex shader failed to compile.  Compile log: " + f)
        }
        throw f = e.getProgramInfoLog(o), console.error(ur + "Shader program link log: " + f), l(h) && (console.error(ur + `Translated vertex shader source:
` + h.getTranslatedShaderSource(i)), console.error(ur + `Translated fragment shader source:
` + h.getTranslatedShaderSource(a))), e.deleteProgram(o), new je("Program failed to link.  Link log: " + f)
    }
    var v = t._logShaderCompilation;
    return v && (f = e.getShaderInfoLog(i), l(f) && f.length > 0 && console.log(ur + "Vertex shader compile log: " + f)), v && (f = e.getShaderInfoLog(a), l(f) && f.length > 0 && console.log(ur + "Fragment shader compile log: " + f)), v && (f = e.getProgramInfoLog(o), l(f) && f.length > 0 && console.log(ur + "Shader program link log: " + f)), o
}

function UC(e, t, n) {
    for (var r = {}, i = 0; i < n; ++i) {
        var a = e.getActiveAttrib(t, i),
            o = e.getAttribLocation(t, a.name);
        r[a.name] = {
            name: a.name,
            type: a.type,
            index: o
        }
    }
    return r
}

function zC(e, t) {
    for (var n = {}, r = [], i = [], a = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), o = 0; o < a; ++o) {
        var s = e.getActiveUniform(t, o),
            c = "[0]",
            f = s.name.indexOf(c, s.name.length - c.length) !== -1 ? s.name.slice(0, s.name.length - 3) : s.name;
        if (f.indexOf("gl_") !== 0)
            if (s.name.indexOf("[") < 0) {
                var h = e.getUniformLocation(t, f);
                if (h !== null) {
                    var d = IC(e, s, f, h);
                    n[f] = d, r.push(d), d._setSampler && i.push(d)
                }
            } else {
                var _, v, m, g, y = f.indexOf("[");
                if (y >= 0) {
                    if (_ = n[f.slice(0, y)], !l(_)) continue;
                    v = _._locations, v.length <= 1 && (m = _.value, g = e.getUniformLocation(t, f), g !== null && (v.push(g), m.push(e.getUniform(t, g))))
                } else {
                    v = [];
                    for (var E = 0; E < s.size; ++E) g = e.getUniformLocation(t, f + "[" + E + "]"), g !== null && v.push(g);
                    _ = NC(e, s, f, v), n[f] = _, r.push(_), _._setSampler && i.push(_)
                }
            }
    }
    return {
        uniformsByName: n,
        uniforms: r,
        samplerUniforms: i
    }
}

function BC(e, t) {
    var n = [],
        r = [];
    for (var i in t)
        if (t.hasOwnProperty(i)) {
            var a = t[i],
                o = i,
                s = e._duplicateUniformNames[o];
            l(s) && (a.name = s, o = s);
            var c = ec[o];
            l(c) ? n.push({
                uniform: a,
                automaticUniform: c
            }) : r.push(a)
        }
    return {
        automaticUniforms: n,
        manualUniforms: r
    }
}

function VC(e, t, n) {
    e.useProgram(t);
    for (var r = 0, i = n.length, a = 0; a < i; ++a) r = n[a]._setSampler(r);
    return e.useProgram(null), r
}

function tc(e) {
    l(e._program) || q0(e)
}

function q0(e) {
    var t = e._program,
        n = e._gl,
        r = LC(n, e, e._debugShaders),
        i = n.getProgramParameter(r, n.ACTIVE_ATTRIBUTES),
        a = zC(n, r),
        o = BC(e, a.uniformsByName);
    e._program = r, e._numberOfVertexAttributes = i, e._vertexAttributes = UC(n, r, i), e._uniformsByName = a.uniformsByName, e._uniforms = a.uniforms, e._automaticUniforms = o.automaticUniforms, e._manualUniforms = o.manualUniforms, e.maximumTextureUnitIndex = VC(n, r, a.samplerUniforms), t && e._gl.deleteProgram(t), typeof spector < "u" && (e._program.__SPECTOR_rebuildProgram = function(s, c, f, h) {
        var d = e._vertexShaderText,
            _ = e._fragmentShaderText,
            v = / ! = /g;
        e._vertexShaderText = s.replace(v, " != "), e._fragmentShaderText = c.replace(v, " != ");
        try {
            q0(e), f(e._program)
        } catch (y) {
            e._vertexShaderText = d, e._fragmentShaderText = _;
            var m = /(?:Compile|Link) error: ([^]*)/,
                g = m.exec(y.message);
            h(g ? g[1] : y.message)
        }
    })
}
Mt.prototype._bind = function() {
    tc(this), this._gl.useProgram(this._program)
};
Mt.prototype._setUniforms = function(e, t, n) {
    var r, i;
    if (l(e)) {
        var a = this._manualUniforms;
        for (r = a.length, i = 0; i < r; ++i) {
            var o = a[i];
            o.value = e[o.name]()
        }
    }
    var s = this._automaticUniforms;
    for (r = s.length, i = 0; i < r; ++i) {
        var c = s[i];
        c.uniform.value = c.automaticUniform.getValue(t)
    }
    var f = this._uniforms;
    for (r = f.length, i = 0; i < r; ++i) f[i].set();
    if (n) {
        var h = this._gl,
            d = this._program;
        h.validateProgram(d)
    }
};
Mt.prototype.isDestroyed = function() {
    return !1
};
Mt.prototype.destroy = function() {
    this._cachedShader.cache.releaseShaderProgram(this)
};
Mt.prototype.finalDestroy = function() {
    return this._gl.deleteProgram(this._program), Pe(this)
};

function GC(e, t) {
    var n = /#define OUTPUT_DECLARATION/,
        r = e.split(`
`);
    if (/#version 300 es/g.test(e)) return e;
    var i = -1,
        a, o;
    for (a = 0; a < r.length; ++a)
        if (o = r[a], n.test(o)) {
            i = a;
            break
        }
    if (i === -1) throw new we("Could not find a #define OUTPUT_DECLARATION!");
    var s = [];
    for (a = 0; a < 10; a++) {
        var c = "gl_FragData\\[" + a + "\\]",
            f = "czm_out" + a,
            h = new RegExp(c, "g");
        h.test(e) && (k_(f, s), Kr(c, f, r), r.splice(i, 0, "layout(location = " + a + ") out vec4 " + f + ";"), i += 1)
    }
    var d = "czm_fragColor";
    kC("gl_FragColor", r) && (k_(d, s), Kr("gl_FragColor", d, r), r.splice(i, 0, "layout(location = 0) out vec4 czm_fragColor;"), i += 1);
    var _ = qC(s, r),
        v = {};
    for (a = 0; a < r.length; a++) {
        o = r[a];
        for (var m in _)
            if (_.hasOwnProperty(m)) {
                var g = new RegExp("(layout)[^]+(out)[^]+(" + m + ")[^]+", "g");
                g.test(o) && (v[o] = m)
            }
    }
    for (var y in v)
        if (v.hasOwnProperty(y)) {
            var E = v[y],
                w = r.indexOf(y),
                C = _[E],
                A = C.length,
                x;
            for (x = 0; x < A; x++) r.splice(w, 0, C[x]);
            for (w += A + 1, x = A - 1; x >= 0; x--) r.splice(w, 0, "#endif //" + C[x])
        }
    var P = "WEBGL_2",
        I = "#define " + P,
        D = "#version 300 es",
        O = !1;
    for (a = 0; a < r.length; a++)
        if (/#version/.test(r[a])) {
            r[a] = D, O = !0;
            break
        }
    return O || r.splice(0, 0, D), r.splice(1, 0, I), $f("EXT_draw_buffers", P, r), $f("EXT_frag_depth", P, r), $f("OES_standard_derivatives", P, r), Kr("texture2D", "texture", r), Kr("texture3D", "texture", r), Kr("textureCube", "texture", r), Kr("gl_FragDepthEXT", "gl_FragDepth", r), t ? Kr("varying", "in", r) : (Kr("attribute", "in", r), Kr("varying", "out", r)), WC(r)
}

function Kr(e, t, n) {
    for (var r = "(^|[^\\w])(" + e + ")($|[^\\w])", i = new RegExp(r, "g"), a = n.length, o = 0; o < a; ++o) {
        var s = n[o];
        n[o] = s.replace(i, "$1" + t + "$3")
    }
}

function HC(e, t, n) {
    for (var r = n.length, i = 0; i < r; ++i) {
        var a = n[i];
        n[i] = a.replace(e, t)
    }
}

function kC(e, t) {
    for (var n = "(^|[^\\w])(" + e + ")($|[^\\w])", r = new RegExp(n, "g"), i = t.length, a = 0; a < i; ++a) {
        var o = t[a];
        if (r.test(o)) return !0
    }
    return !1
}

function WC(e) {
    for (var t = "", n = e.length, r = 0; r < n; ++r) t += e[r] + `
`;
    return t
}

function k_(e, t) {
    t.indexOf(e) === -1 && t.push(e)
}

function qC(e, t) {
    for (var n = {}, r = e.length, i = [], a = 0; a < t.length; ++a) {
        var o = t[a],
            s = /(#ifdef|#if)/g.test(o),
            c = /#else/g.test(o),
            f = /#endif/g.test(o);
        if (s) i.push(o);
        else if (c) {
            var h = i[i.length - 1],
                d = h.replace("ifdef", "ifndef");
            /if/g.test(d) && (d = d.replace(/(#if\s+)(\S*)([^]*)/, "$1!($2)$3")), i.pop(), i.push(d)
        } else if (f) i.pop();
        else if (!/layout/g.test(o))
            for (var _ = 0; _ < r; ++_) {
                var v = e[_];
                o.indexOf(v) !== -1 && (l(n[v]) ? n[v] = n[v].filter(function(m) {
                    return i.indexOf(m) >= 0
                }) : n[v] = i.slice())
            }
    }
    return n
}

function $f(e, t, n) {
    var r = "#extension\\s+GL_" + e + "\\s+:\\s+[a-zA-Z0-9]+\\s*$";
    HC(new RegExp(r, "g"), "", n), Kr("GL_" + e, t, n)
}
const YC = `const float czm_degreesPerRadian = 57.29577951308232;
`,
    XC = `const czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);
`,
    jC = `const float czm_epsilon1 = 0.1;
`,
    ZC = `const float czm_epsilon2 = 0.01;
`,
    KC = `const float czm_epsilon3 = 0.001;
`,
    $C = `const float czm_epsilon4 = 0.0001;
`,
    JC = `const float czm_epsilon5 = 0.00001;
`,
    QC = `const float czm_epsilon6 = 0.000001;
`,
    ew = `const float czm_epsilon7 = 0.0000001;
`,
    tw = `const float czm_infinity = 5906376272000.0;
`,
    nw = `const float czm_oneOverPi = 0.3183098861837907;
`,
    rw = `const float czm_oneOverTwoPi = 0.15915494309189535;
`,
    iw = `const float czm_passCesium3DTile = 4.0;
`,
    aw = `const float czm_passCesium3DTileClassification = 5.0;
`,
    ow = `const float czm_passCesium3DTileClassificationIgnoreShow = 6.0;
`,
    sw = `const float czm_passClassification = 7.0;
`,
    uw = `const float czm_passCompute = 1.0;
`,
    cw = `const float czm_passEnvironment = 0.0;
`,
    fw = `const float czm_passGlobe = 2.0;
`,
    hw = `const float czm_passOpaque = 7.0;
`,
    lw = `const float czm_passOverlay = 9.0;
`,
    dw = `const float czm_passTerrainClassification = 3.0;
`,
    _w = `const float czm_passTranslucent = 8.0;
`,
    vw = `const float czm_pi = 3.141592653589793;
`,
    mw = `const float czm_piOverFour = 0.7853981633974483;
`,
    pw = `const float czm_piOverSix = 0.5235987755982988;
`,
    gw = `const float czm_piOverThree = 1.0471975511965976;
`,
    yw = `const float czm_piOverTwo = 1.5707963267948966;
`,
    Tw = `const float czm_radiansPerDegree = 0.017453292519943295;
`,
    Ew = `const float czm_sceneMode2D = 2.0;
`,
    Aw = `const float czm_sceneMode3D = 3.0;
`,
    Cw = `const float czm_sceneModeColumbusView = 1.0;
`,
    ww = `const float czm_sceneModeMorphing = 0.0;
`,
    xw = `const float czm_solarRadius = 695500000.0;
`,
    Sw = `const float czm_threePiOver2 = 4.71238898038469;
`,
    Rw = `const float czm_twoPi = 6.283185307179586;
`,
    Dw = `const float czm_webMercatorMaxLatitude = 1.4844222297453324;
`,
    Iw = `struct czm_depthRangeStruct
{
float near;
float far;
};
`,
    Pw = `struct czm_material
{
vec3 diffuse;
float specular;
float shininess;
vec3 normal;
vec3 emission;
float alpha;
};
`,
    Ow = `struct czm_materialInput
{
float s;
vec2 st;
vec3 str;
vec3 normalEC;
mat3 tangentToEyeMatrix;
vec3 positionToEyeEC;
float height;
float slope;
float aspect;
};
`,
    Mw = `struct czm_ray
{
vec3 origin;
vec3 direction;
};
`,
    Nw = `struct czm_raySegment
{
float start;
float stop;
};
const czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);
const czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);
`,
    bw = `struct czm_shadowParameters
{
#ifdef USE_CUBE_MAP_SHADOW
vec3 texCoords;
#else
vec2 texCoords;
#endif
float depthBias;
float depth;
float nDotL;
vec2 texelStepSize;
float normalShadingSmooth;
float darkness;
};
`,
    Fw = `const vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 czm_HSBToRGB(vec3 hsb)
{
vec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www);
return hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y);
}
`,
    Lw = `vec3 hueToRGB(float hue)
{
float r = abs(hue * 6.0 - 3.0) - 1.0;
float g = 2.0 - abs(hue * 6.0 - 2.0);
float b = 2.0 - abs(hue * 6.0 - 4.0);
return clamp(vec3(r, g, b), 0.0, 1.0);
}
vec3 czm_HSLToRGB(vec3 hsl)
{
vec3 rgb = hueToRGB(hsl.x);
float c = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y;
return (rgb - 0.5) * c + hsl.z;
}
`,
    Uw = `const vec4 K_RGB2HSB = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec3 czm_RGBToHSB(vec3 rgb)
{
vec4 p = mix(vec4(rgb.bg, K_RGB2HSB.wz), vec4(rgb.gb, K_RGB2HSB.xy), step(rgb.b, rgb.g));
vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));
float d = q.x - min(q.w, q.y);
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + czm_epsilon7)), d / (q.x + czm_epsilon7), q.x);
}
`,
    zw = `vec3 RGBtoHCV(vec3 rgb)
{
vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0 / 3.0) : vec4(rgb.gb, 0.0, -1.0 / 3.0);
vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);
float c = q.x - min(q.w, q.y);
float h = abs((q.w - q.y) / (6.0 * c + czm_epsilon7) + q.z);
return vec3(h, c, q.x);
}
vec3 czm_RGBToHSL(vec3 rgb)
{
vec3 hcv = RGBtoHCV(rgb);
float l = hcv.z - hcv.y * 0.5;
float s = hcv.y / (1.0 - abs(l * 2.0 - 1.0) + czm_epsilon7);
return vec3(hcv.x, s, l);
}
`,
    Bw = `vec3 czm_RGBToXYZ(vec3 rgb)
{
const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,
0.3576, 0.7152, 0.1192,
0.1805, 0.0722, 0.9505);
vec3 xyz = RGB2XYZ * rgb;
vec3 Yxy;
Yxy.r = xyz.g;
float temp = dot(vec3(1.0), xyz);
Yxy.gb = xyz.rg / temp;
return Yxy;
}
`,
    Vw = `vec3 czm_XYZToRGB(vec3 Yxy)
{
const mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,
-1.5371,  1.8760, -0.2040,
-0.4985,  0.0416,  1.0572);
vec3 xyz;
xyz.r = Yxy.r * Yxy.g / Yxy.b;
xyz.g = Yxy.r;
xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;
return XYZ2RGB * xyz;
}
`,
    Gw = `vec3 czm_acesTonemapping(vec3 color) {
float g = 0.985;
float a = 0.065;
float b = 0.0001;
float c = 0.433;
float d = 0.238;
color = (color * (color + a) - b) / (color * (g * color + c) + d);
color = clamp(color, 0.0, 1.0);
return color;
}
`,
    Hw = `float czm_alphaWeight(float a)
{
float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];
return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 0.003 / (1e-5 + pow(abs(z) / 200.0, 4.0))));
}
`,
    kw = `vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)
{
float val1 = clamp(dist / fuzzFactor, 0.0, 1.0);
float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);
val1 = val1 * (1.0 - val2);
val1 = val1 * val1 * (3.0 - (2.0 * val1));
val1 = pow(val1, 0.5);
vec4 midColor = (color1 + color2) * 0.5;
return mix(midColor, currentColor, val1);
}
vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)
{
return czm_antialias(color1, color2, currentColor, dist, 0.1);
}
`,
    Ww = `vec2 czm_approximateSphericalCoordinates(vec3 normal) {
float latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z);
float longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y);
return vec2(latitudeApproximation, longitudeApproximation);
}
`,
    qw = `bool czm_backFacing()
{
return gl_FrontFacing == false;
}
`,
    Yw = `float czm_branchFreeTernary(bool comparison, float a, float b) {
float useA = float(comparison);
return a * useA + b * (1.0 - useA);
}
vec2 czm_branchFreeTernary(bool comparison, vec2 a, vec2 b) {
float useA = float(comparison);
return a * useA + b * (1.0 - useA);
}
vec3 czm_branchFreeTernary(bool comparison, vec3 a, vec3 b) {
float useA = float(comparison);
return a * useA + b * (1.0 - useA);
}
vec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) {
float useA = float(comparison);
return a * useA + b * (1.0 - useA);
}
`,
    Xw = `vec4 czm_cascadeColor(vec4 weights)
{
return vec4(1.0, 0.0, 0.0, 1.0) * weights.x +
vec4(0.0, 1.0, 0.0, 1.0) * weights.y +
vec4(0.0, 0.0, 1.0, 1.0) * weights.z +
vec4(1.0, 0.0, 1.0, 1.0) * weights.w;
}
`,
    jw = `uniform vec4 shadowMap_cascadeDistances;
float czm_cascadeDistance(vec4 weights)
{
return dot(shadowMap_cascadeDistances, weights);
}
`,
    Zw = `uniform mat4 shadowMap_cascadeMatrices[4];
mat4 czm_cascadeMatrix(vec4 weights)
{
return shadowMap_cascadeMatrices[0] * weights.x +
shadowMap_cascadeMatrices[1] * weights.y +
shadowMap_cascadeMatrices[2] * weights.z +
shadowMap_cascadeMatrices[3] * weights.w;
}
`,
    Kw = `uniform vec4 shadowMap_cascadeSplits[2];
vec4 czm_cascadeWeights(float depthEye)
{
vec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye));
vec4 far = step(depthEye, shadowMap_cascadeSplits[1]);
return near * far;
}
`,
    $w = `vec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)
{
vec3 p = mix(position2D.xyz, position3D.xyz, time);
return vec4(p, 1.0);
}
`,
    Jw = `vec4 czm_computePosition();
`,
    Qw = `vec2 cordic(float angle)
{
vec2 vector = vec2(6.0725293500888267e-1, 0.0);
float sense = (angle < 0.0) ? -1.0 : 1.0;
mat2 rotation = mat2(1.0, sense, -sense, 1.0);
vector = rotation * vector;
angle -= sense * 7.8539816339744828e-1;
sense = (angle < 0.0) ? -1.0 : 1.0;
float factor = sense * 5.0e-1;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 4.6364760900080609e-1;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 2.5e-1;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 2.4497866312686414e-1;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.25e-1;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.2435499454676144e-1;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 6.25e-2;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 6.2418809995957350e-2;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 3.125e-2;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 3.1239833430268277e-2;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.5625e-2;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.5623728620476831e-2;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 7.8125e-3;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 7.8123410601011111e-3;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 3.90625e-3;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 3.9062301319669718e-3;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.953125e-3;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.9531225164788188e-3;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 9.765625e-4;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 9.7656218955931946e-4;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 4.8828125e-4;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 4.8828121119489829e-4;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 2.44140625e-4;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 2.4414062014936177e-4;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.220703125e-4;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.2207031189367021e-4;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 6.103515625e-5;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 6.1035156174208773e-5;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 3.0517578125e-5;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 3.0517578115526096e-5;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.52587890625e-5;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.5258789061315762e-5;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 7.62939453125e-6;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 7.6293945311019700e-6;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 3.814697265625e-6;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 3.8146972656064961e-6;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.9073486328125e-6;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 1.9073486328101870e-6;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 9.5367431640625e-7;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 9.5367431640596084e-7;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 4.76837158203125e-7;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 4.7683715820308884e-7;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 2.384185791015625e-7;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
angle -= sense * 2.3841857910155797e-7;
sense = (angle < 0.0) ? -1.0 : 1.0;
factor = sense * 1.1920928955078125e-7;
rotation[0][1] = factor;
rotation[1][0] = -factor;
vector = rotation * vector;
return vector;
}
vec2 czm_cosineAndSine(float angle)
{
if (angle < -czm_piOverTwo || angle > czm_piOverTwo)
{
if (angle < 0.0)
{
return -cordic(angle + czm_pi);
}
else
{
return -cordic(angle - czm_pi);
}
}
else
{
return cordic(angle);
}
}
`,
    ex = `vec2 czm_decompressTextureCoordinates(float encoded)
{
float temp = encoded / 4096.0;
float xZeroTo4095 = floor(temp);
float stx = xZeroTo4095 / 4095.0;
float sty = (encoded - xZeroTo4095 * 4096.0) / 4095.0;
return vec2(stx, sty);
}
`,
    tx = `#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)
varying float v_WindowZ;
#endif
vec4 czm_depthClamp(vec4 coords)
{
#ifndef LOG_DEPTH
#ifdef GL_EXT_frag_depth
v_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;
coords.z = 0.0;
#else
coords.z = min(coords.z, coords.w);
#endif
#endif
return coords;
}
`,
    nx = `mat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)
{
vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));
vec3 tangentEC = normalize(czm_normal3D * tangentMC);
vec3 bitangentEC = normalize(cross(normalEC, tangentEC));
return mat3(
tangentEC.x,   tangentEC.y,   tangentEC.z,
bitangentEC.x, bitangentEC.y, bitangentEC.z,
normalEC.x,    normalEC.y,    normalEC.z);
}
`,
    rx = `bool czm_ellipsoidContainsPoint(vec3 ellipsoid_inverseRadii, vec3 point)
{
vec3 scaled = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;
return (dot(scaled, scaled) <= 1.0);
}
`,
    ix = `vec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)
{
return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);
}
`,
    ax = `bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {
return all(lessThanEqual(abs(left - right), vec4(epsilon)));
}
bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {
return all(lessThanEqual(abs(left - right), vec3(epsilon)));
}
bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {
return all(lessThanEqual(abs(left - right), vec2(epsilon)));
}
bool czm_equalsEpsilon(float left, float right, float epsilon) {
return (abs(left - right) <= epsilon);
}
`,
    ox = `vec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)
{
vec4 p = positionEC;
vec4 zEyeOffset = normalize(p) * eyeOffset.z;
p.xy += eyeOffset.xy + zEyeOffset.xy;
p.z += zEyeOffset.z;
return p;
}
`,
    sx = `vec4 czm_eyeToWindowCoordinates(vec4 positionEC)
{
vec4 q = czm_projection * positionEC;
q.xyz /= q.w;
q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz;
return q;
}
`,
    ux = `float czm_fastApproximateAtan(float x) {
return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);
}
float czm_fastApproximateAtan(float x, float y) {
float t = abs(x);
float opposite = abs(y);
float adjacent = max(t, opposite);
opposite = min(t, opposite);
t = czm_fastApproximateAtan(opposite / adjacent);
t = czm_branchFreeTernary(abs(y) > abs(x), czm_piOverTwo - t, t);
t = czm_branchFreeTernary(x < 0.0, czm_pi - t, t);
t = czm_branchFreeTernary(y < 0.0, -t, t);
return t;
}
`,
    cx = `vec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor)
{
float scalar = distanceToCamera * czm_fogDensity;
float fog = 1.0 - exp(-(scalar * scalar));
return mix(color, fogColor, fog);
}
vec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant)
{
float scalar = distanceToCamera * czm_fogDensity;
float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));
return mix(color, fogColor, fog);
}
`,
    fx = `vec3 czm_gammaCorrect(vec3 color) {
#ifdef HDR
color = pow(color, vec3(czm_gamma));
#endif
return color;
}
vec4 czm_gammaCorrect(vec4 color) {
#ifdef HDR
color.rgb = pow(color.rgb, vec3(czm_gamma));
#endif
return color;
}
`,
    hx = `vec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)
{
return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);
}
`,
    lx = `czm_material czm_getDefaultMaterial(czm_materialInput materialInput)
{
czm_material material;
material.diffuse = vec3(0.0);
material.specular = 0.0;
material.shininess = 1.0;
material.normal = materialInput.normalEC;
material.emission = vec3(0.0);
material.alpha = 1.0;
return material;
}
`,
    dx = `float czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)
{
return max(dot(lightDirectionEC, normalEC), 0.0);
}
`,
    _x = `float czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)
{
vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);
float specular = max(dot(toReflectedLight, toEyeEC), 0.0);
return pow(specular, max(shininess, czm_epsilon2));
}
`,
    vx = `vec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)
{
float cosAngle = cos(angleInRadians);
float sinAngle = sin(angleInRadians);
vec2 s0 = vec2(1.0/17.0, 0.0);
vec2 s1 = vec2(-1.0/29.0, 0.0);
vec2 s2 = vec2(1.0/101.0, 1.0/59.0);
vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);
s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));
s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));
s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));
s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));
vec2 uv0 = (uv/103.0) + (time * s0);
vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);
vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);
vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);
uv0 = fract(uv0);
uv1 = fract(uv1);
uv2 = fract(uv2);
uv3 = fract(uv3);
vec4 noise = (texture2D(normalMap, uv0)) +
(texture2D(normalMap, uv1)) +
(texture2D(normalMap, uv2)) +
(texture2D(normalMap, uv3));
return ((noise / 4.0) - 0.5) * 2.0;
}
`,
    mx = `vec3 czm_hue(vec3 rgb, float adjustment)
{
const mat3 toYIQ = mat3(0.299,     0.587,     0.114,
0.595716, -0.274453, -0.321263,
0.211456, -0.522591,  0.311135);
const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,
1.0, -0.2721, -0.6474,
1.0, -1.107,   1.7046);
vec3 yiq = toYIQ * rgb;
float hue = atan(yiq.z, yiq.y) + adjustment;
float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);
vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));
return toRGB * color;
}
`,
    px = `vec3 czm_inverseGamma(vec3 color) {
return pow(color, vec3(1.0 / czm_gamma));
}
`,
    gx = `bool czm_isEmpty(czm_raySegment interval)
{
return (interval.stop < 0.0);
}
`,
    yx = `bool czm_isFull(czm_raySegment interval)
{
return (interval.start == 0.0 && interval.stop == czm_infinity);
}
`,
    Tx = `float czm_latitudeToWebMercatorFraction(float latitude, float southMercatorY, float oneOverMercatorHeight)
{
float sinLatitude = sin(latitude);
float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));
return (mercatorY - southMercatorY) * oneOverMercatorHeight;
}
`,
    Ex = `float czm_lineDistance(vec2 point1, vec2 point2, vec2 point) {
return abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / distance(point2, point1);
}
`,
    Ax = `float czm_luminance(vec3 rgb)
{
const vec3 W = vec3(0.2125, 0.7154, 0.0721);
return dot(rgb, W);
}
`,
    Cx = `float czm_metersPerPixel(vec4 positionEC, float pixelRatio)
{
float width = czm_viewport.z;
float height = czm_viewport.w;
float pixelWidth;
float pixelHeight;
float top = czm_frustumPlanes.x;
float bottom = czm_frustumPlanes.y;
float left = czm_frustumPlanes.z;
float right = czm_frustumPlanes.w;
if (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0)
{
float frustumWidth = right - left;
float frustumHeight = top - bottom;
pixelWidth = frustumWidth / width;
pixelHeight = frustumHeight / height;
}
else
{
float distanceToPixel = -positionEC.z;
float inverseNear = 1.0 / czm_currentFrustum.x;
float tanTheta = top * inverseNear;
pixelHeight = 2.0 * distanceToPixel * tanTheta / height;
tanTheta = right * inverseNear;
pixelWidth = 2.0 * distanceToPixel * tanTheta / width;
}
return max(pixelWidth, pixelHeight) * pixelRatio;
}
float czm_metersPerPixel(vec4 positionEC)
{
return czm_metersPerPixel(positionEC, czm_pixelRatio);
}
`,
    wx = `vec4 czm_modelToWindowCoordinates(vec4 position)
{
vec4 q = czm_modelViewProjection * position;
q.xyz /= q.w;
q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz;
return q;
}
`,
    xx = `vec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)
{
const vec3 W = vec3(0.2125, 0.7154, 0.0721);
vec3 target = left * right;
float leftLuminance = dot(left, W);
float rightLuminance = dot(right, W);
float targetLuminance = dot(target, W);
return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;
}
`,
    Sx = `float czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq)
{
float valueAtMin = nearFarScalar.y;
float valueAtMax = nearFarScalar.w;
float nearDistanceSq = nearFarScalar.x * nearFarScalar.x;
float farDistanceSq = nearFarScalar.z * nearFarScalar.z;
float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);
t = pow(clamp(t, 0.0, 1.0), 0.2);
return mix(valueAtMin, valueAtMax, t);
}
`,
    Rx = `vec3 czm_octDecode(vec2 encoded, float range)
{
if (encoded.x == 0.0 && encoded.y == 0.0) {
return vec3(0.0, 0.0, 0.0);
}
encoded = encoded / range * 2.0 - 1.0;
vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));
if (v.z < 0.0)
{
v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);
}
return normalize(v);
}
vec3 czm_octDecode(vec2 encoded)
{
return czm_octDecode(encoded, 255.0);
}
vec3 czm_octDecode(float encoded)
{
float temp = encoded / 256.0;
float x = floor(temp);
float y = (temp - x) * 256.0;
return czm_octDecode(vec2(x, y));
}
void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)
{
float temp = encoded.x / 65536.0;
float x = floor(temp);
float encodedFloat1 = (temp - x) * 65536.0;
temp = encoded.y / 65536.0;
float y = floor(temp);
float encodedFloat2 = (temp - y) * 65536.0;
vector1 = czm_octDecode(encodedFloat1);
vector2 = czm_octDecode(encodedFloat2);
vector3 = czm_octDecode(vec2(x, y));
}
`,
    Dx = `vec4 czm_packDepth(float depth)
{
vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;
enc = fract(enc);
enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);
return enc;
}
`,
    Ix = `float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)
{
return czm_getLambertDiffuse(lightDirectionEC, material.normal);
}
float czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)
{
return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);
}
vec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)
{
float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material);
if (czm_sceneMode == czm_sceneMode3D) {
diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);
}
float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);
vec3 materialDiffuse = material.diffuse * 0.5;
vec3 ambient = materialDiffuse;
vec3 color = ambient + material.emission;
color += materialDiffuse * diffuse * czm_lightColor;
color += material.specular * specular * czm_lightColor;
return vec4(color, material.alpha);
}
vec4 czm_private_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)
{
float diffuse = czm_private_getLambertDiffuseOfMaterial(lightDirectionEC, material);
float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);
vec3 ambient = vec3(0.0);
vec3 color = ambient + material.emission;
color += material.diffuse * diffuse * czm_lightColor;
color += material.specular * specular * czm_lightColor;
return vec4(color, material.alpha);
}
`,
    Px = `float czm_planeDistance(vec4 plane, vec3 point) {
return (dot(plane.xyz, point) + plane.w);
}
float czm_planeDistance(vec3 planeNormal, float planeDistance, vec3 point) {
return (dot(planeNormal, point) + planeDistance);
}
`,
    Ox = `vec3 czm_pointAlongRay(czm_ray ray, float time)
{
return ray.origin + (time * ray.direction);
}
`,
    Mx = `czm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, vec3 ellipsoid_center, vec3 ellipsoid_inverseRadii)
{
vec3 q = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;
vec3 w = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;
q = q - ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ellipsoid_center, 1.0)).xyz;
float q2 = dot(q, q);
float qw = dot(q, w);
if (q2 > 1.0)
{
if (qw >= 0.0)
{
return czm_emptyRaySegment;
}
else
{
float qw2 = qw * qw;
float difference = q2 - 1.0;
float w2 = dot(w, w);
float product = w2 * difference;
if (qw2 < product)
{
return czm_emptyRaySegment;
}
else if (qw2 > product)
{
float discriminant = qw * qw - product;
float temp = -qw + sqrt(discriminant);
float root0 = temp / w2;
float root1 = difference / temp;
if (root0 < root1)
{
czm_raySegment i = czm_raySegment(root0, root1);
return i;
}
else
{
czm_raySegment i = czm_raySegment(root1, root0);
return i;
}
}
else
{
float root = sqrt(difference / w2);
czm_raySegment i = czm_raySegment(root, root);
return i;
}
}
}
else if (q2 < 1.0)
{
float difference = q2 - 1.0;
float w2 = dot(w, w);
float product = w2 * difference;
float discriminant = qw * qw - product;
float temp = -qw + sqrt(discriminant);
czm_raySegment i = czm_raySegment(0.0, temp / w2);
return i;
}
else
{
if (qw < 0.0)
{
float w2 = dot(w, w);
czm_raySegment i = czm_raySegment(0.0, -qw / w2);
return i;
}
else
{
return czm_emptyRaySegment;
}
}
}
`,
    Nx = `float czm_readDepth(sampler2D depthTexture, vec2 texCoords)
{
return czm_reverseLogDepth(texture2D(depthTexture, texCoords).r);
}
`,
    bx = `float czm_readNonPerspective(float value, float oneOverW) {
return value * oneOverW;
}
vec2 czm_readNonPerspective(vec2 value, float oneOverW) {
return value * oneOverW;
}
vec3 czm_readNonPerspective(vec3 value, float oneOverW) {
return value * oneOverW;
}
vec4 czm_readNonPerspective(vec4 value, float oneOverW) {
return value * oneOverW;
}
`,
    Fx = `float czm_reverseLogDepth(float logZ)
{
#ifdef LOG_DEPTH
float near = czm_currentFrustum.x;
float far = czm_currentFrustum.y;
float log2Depth = logZ * czm_log2FarDepthFromNearPlusOne;
float depthFromNear = pow(2.0, log2Depth) - 1.0;
return far * (1.0 - near / (depthFromNear + near)) / (far - near);
#endif
return logZ;
}
`,
    Lx = `vec3 czm_sampleOctahedralProjectionWithFiltering(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod)
{
direction /= dot(vec3(1.0), abs(direction));
vec2 rev = abs(direction.zx) - vec2(1.0);
vec2 neg = vec2(direction.x < 0.0 ? rev.x : -rev.x,
direction.z < 0.0 ? rev.y : -rev.y);
vec2 uv = direction.y < 0.0 ? neg : direction.xz;
vec2 coord = 0.5 * uv + vec2(0.5);
vec2 pixel = 1.0 / textureSize;
if (lod > 0.0)
{
float scale = 1.0 / pow(2.0, lod);
float offset = ((textureSize.y + 1.0) / textureSize.x);
coord.x *= offset;
coord *= scale;
coord.x += offset + pixel.x;
coord.y += (1.0 - (1.0 / pow(2.0, lod - 1.0))) + pixel.y * (lod - 1.0) * 2.0;
}
else
{
coord.x *= (textureSize.y / textureSize.x);
}
#ifndef OES_texture_float_linear
vec3 color1 = texture2D(projectedMap, coord + vec2(0.0, pixel.y)).rgb;
vec3 color2 = texture2D(projectedMap, coord + vec2(pixel.x, 0.0)).rgb;
vec3 color3 = texture2D(projectedMap, coord + pixel).rgb;
vec3 color4 = texture2D(projectedMap, coord).rgb;
vec2 texturePosition = coord * textureSize;
float fu = fract(texturePosition.x);
float fv = fract(texturePosition.y);
vec3 average1 = mix(color4, color2, fu);
vec3 average2 = mix(color1, color3, fu);
vec3 color = mix(average1, average2, fv);
#else
vec3 color = texture2D(projectedMap, coord).rgb;
#endif
return color;
}
vec3 czm_sampleOctahedralProjection(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod, float maxLod) {
float currentLod = floor(lod + 0.5);
float nextLod = min(currentLod + 1.0, maxLod);
vec3 colorCurrentLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, currentLod);
vec3 colorNextLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, nextLod);
return mix(colorNextLod, colorCurrentLod, nextLod - lod);
}
`,
    Ux = `vec3 czm_saturation(vec3 rgb, float adjustment)
{
const vec3 W = vec3(0.2125, 0.7154, 0.0721);
vec3 intensity = vec3(dot(rgb, W));
return mix(intensity, rgb, adjustment);
}
`,
    zx = `float czm_sampleShadowMap(highp samplerCube shadowMap, vec3 d)
{
return czm_unpackDepth(textureCube(shadowMap, d));
}
float czm_sampleShadowMap(highp sampler2D shadowMap, vec2 uv)
{
#ifdef USE_SHADOW_DEPTH_TEXTURE
return texture2D(shadowMap, uv).r;
#else
return czm_unpackDepth(texture2D(shadowMap, uv));
#endif
}
float czm_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth)
{
return step(depth, czm_sampleShadowMap(shadowMap, uv));
}
float czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth)
{
return step(depth, czm_sampleShadowMap(shadowMap, uv));
}
`,
    Bx = `float czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness)
{
#ifdef USE_NORMAL_SHADING
#ifdef USE_NORMAL_SHADING_SMOOTH
float strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0);
#else
float strength = step(0.0, nDotL);
#endif
visibility *= strength;
#endif
visibility = max(visibility, darkness);
return visibility;
}
#ifdef USE_CUBE_MAP_SHADOW
float czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters)
{
float depthBias = shadowParameters.depthBias;
float depth = shadowParameters.depth;
float nDotL = shadowParameters.nDotL;
float normalShadingSmooth = shadowParameters.normalShadingSmooth;
float darkness = shadowParameters.darkness;
vec3 uvw = shadowParameters.texCoords;
depth -= depthBias;
float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);
return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);
}
#else
float czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters)
{
float depthBias = shadowParameters.depthBias;
float depth = shadowParameters.depth;
float nDotL = shadowParameters.nDotL;
float normalShadingSmooth = shadowParameters.normalShadingSmooth;
float darkness = shadowParameters.darkness;
vec2 uv = shadowParameters.texCoords;
depth -= depthBias;
#ifdef USE_SOFT_SHADOWS
vec2 texelStepSize = shadowParameters.texelStepSize;
float radius = 1.0;
float dx0 = -texelStepSize.x * radius;
float dy0 = -texelStepSize.y * radius;
float dx1 = texelStepSize.x * radius;
float dy1 = texelStepSize.y * radius;
float visibility = (
czm_shadowDepthCompare(shadowMap, uv, depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +
czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)
) * (1.0 / 9.0);
#else
float visibility = czm_shadowDepthCompare(shadowMap, uv, depth);
#endif
return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);
}
#endif
`,
    Vx = `float czm_signNotZero(float value)
{
return value >= 0.0 ? 1.0 : -1.0;
}
vec2 czm_signNotZero(vec2 value)
{
return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));
}
vec3 czm_signNotZero(vec3 value)
{
return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));
}
vec4 czm_signNotZero(vec4 value)
{
return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));
}
`,
    Gx = `vec3 czm_sphericalHarmonics(vec3 normal, vec3 coefficients[9])
{
const float c1 = 0.429043;
const float c2 = 0.511664;
const float c3 = 0.743125;
const float c4 = 0.886227;
const float c5 = 0.247708;
vec3 L00 = coefficients[0];
vec3 L1_1 = coefficients[1];
vec3 L10 = coefficients[2];
vec3 L11 = coefficients[3];
vec3 L2_2 = coefficients[4];
vec3 L2_1 = coefficients[5];
vec3 L20 = coefficients[6];
vec3 L21 = coefficients[7];
vec3 L22 = coefficients[8];
float x = normal.x;
float y = normal.y;
float z = normal.z;
return c1 * L22 * (x * x - y * y) + c3 * L20 * z * z + c4 * L00 - c5 * L20 +
2.0 * c1 * (L2_2 * x * y + L21 * x * z + L2_1 * y * z) +
2.0 * c2 * (L11 * x + L1_1 * y + L10 * z);
}
`,
    Hx = `mat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC)
{
vec3 normal = normalize(normalEC);
vec3 tangent = normalize(tangentEC);
vec3 bitangent = normalize(bitangentEC);
return mat3(tangent.x  , tangent.y  , tangent.z,
bitangent.x, bitangent.y, bitangent.z,
normal.x   , normal.y   , normal.z);
}
`,
    kx = `vec4 czm_transformPlane(vec4 plane, mat4 transform) {
vec4 transformedPlane = transform * plane;
float normalMagnitude = length(transformedPlane.xyz);
return transformedPlane / normalMagnitude;
}
`,
    Wx = `vec4 czm_translateRelativeToEye(vec3 high, vec3 low)
{
vec3 highDifference = high - czm_encodedCameraPositionMCHigh;
vec3 lowDifference = low - czm_encodedCameraPositionMCLow;
return vec4(highDifference + lowDifference, 1.0);
}
`,
    qx = `vec4 czm_translucentPhong(vec3 toEye, czm_material material, vec3 lightDirectionEC)
{
float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);
if (czm_sceneMode == czm_sceneMode3D) {
diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);
}
diffuse = clamp(diffuse, 0.0, 1.0);
float specular = czm_getSpecular(lightDirectionEC, toEye, material.normal, material.shininess);
vec3 materialDiffuse = material.diffuse * 0.5;
vec3 ambient = materialDiffuse;
vec3 color = ambient + material.emission;
color += materialDiffuse * diffuse * czm_lightColor;
color += material.specular * specular * czm_lightColor;
return vec4(color, material.alpha);
}
`,
    Yx = `mat2 czm_transpose(mat2 matrix)
{
return mat2(
matrix[0][0], matrix[1][0],
matrix[0][1], matrix[1][1]);
}
mat3 czm_transpose(mat3 matrix)
{
return mat3(
matrix[0][0], matrix[1][0], matrix[2][0],
matrix[0][1], matrix[1][1], matrix[2][1],
matrix[0][2], matrix[1][2], matrix[2][2]);
}
mat4 czm_transpose(mat4 matrix)
{
return mat4(
matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],
matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],
matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],
matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);
}
`,
    Xx = `float czm_unpackDepth(vec4 packedDepth)
{
return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
}
`,
    jx = `float czm_unpackFloat(vec4 packedFloat)
{
packedFloat = floor(packedFloat * 255.0 + 0.5);
float sign = 1.0 - step(128.0, packedFloat[3]) * 2.0;
float exponent = 2.0 * mod(packedFloat[3], 128.0) + step(128.0, packedFloat[2]) - 127.0;
if (exponent == -127.0)
{
return 0.0;
}
float mantissa = mod(packedFloat[2], 128.0) * 65536.0 + packedFloat[1] * 256.0 + packedFloat[0] + float(0x800000);
float result = sign * exp2(exponent - 23.0) * mantissa;
return result;
}
`,
    Zx = `#ifdef LOG_DEPTH
varying float v_depthFromNearPlusOne;
#ifdef SHADOW_MAP
varying vec3 v_logPositionEC;
#endif
#endif
vec4 czm_updatePositionDepth(vec4 coords) {
#if defined(LOG_DEPTH)
#ifdef SHADOW_MAP
vec3 logPositionEC = (czm_inverseProjection * coords).xyz;
v_logPositionEC = logPositionEC;
#endif
coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;
#endif
return coords;
}
void czm_vertexLogDepth()
{
#ifdef LOG_DEPTH
v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0;
gl_Position = czm_updatePositionDepth(gl_Position);
#endif
}
void czm_vertexLogDepth(vec4 clipCoords)
{
#ifdef LOG_DEPTH
v_depthFromNearPlusOne = (clipCoords.w - czm_currentFrustum.x) + 1.0;
czm_updatePositionDepth(clipCoords);
#endif
}
`,
    Kx = `vec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)
{
float x = 2.0 * (fragmentCoordinate.x - czm_viewport.x) / czm_viewport.z - 1.0;
float y = 2.0 * (fragmentCoordinate.y - czm_viewport.y) / czm_viewport.w - 1.0;
float z = (fragmentCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];
vec4 q = vec4(x, y, z, 1.0);
q /= fragmentCoordinate.w;
if (!(czm_inverseProjection == mat4(0.0)))
{
q = czm_inverseProjection * q;
}
else
{
float top = czm_frustumPlanes.x;
float bottom = czm_frustumPlanes.y;
float left = czm_frustumPlanes.z;
float right = czm_frustumPlanes.w;
float near = czm_currentFrustum.x;
float far = czm_currentFrustum.y;
q.x = (q.x * (right - left) + left + right) * 0.5;
q.y = (q.y * (top - bottom) + bottom + top) * 0.5;
q.z = (q.z * (near - far) - near - far) * 0.5;
q.w = 1.0;
}
return q;
}
vec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)
{
#ifdef LOG_DEPTH
float near = czm_currentFrustum.x;
float far = czm_currentFrustum.y;
float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;
float depthFromNear = pow(2.0, log2Depth) - 1.0;
float depthFromCamera = depthFromNear + near;
vec4 windowCoord = vec4(fragmentCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);
vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);
eyeCoordinate.w = 1.0 / depthFromCamera;
return eyeCoordinate;
#else
vec4 windowCoord = vec4(fragmentCoordinateXY, depthOrLogDepth, 1.0);
vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);
#endif
return eyeCoordinate;
}
`,
    $x = `#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)
varying float v_WindowZ;
#endif
void czm_writeDepthClamp()
{
#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)
gl_FragDepthEXT = clamp(v_WindowZ * gl_FragCoord.w, 0.0, 1.0);
#endif
}
`,
    Jx = `#ifdef LOG_DEPTH
varying float v_depthFromNearPlusOne;
#ifdef POLYGON_OFFSET
uniform vec2 u_polygonOffset;
#endif
#endif
void czm_writeLogDepth(float depth)
{
#if defined(GL_EXT_frag_depth) && defined(LOG_DEPTH)
if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {
discard;
}
#ifdef POLYGON_OFFSET
float factor = u_polygonOffset[0];
float units = u_polygonOffset[1];
#ifdef GL_OES_standard_derivatives
float x = dFdx(depth);
float y = dFdy(depth);
float m = sqrt(x * x + y * y);
depth += m * factor;
#endif
#endif
gl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;
#ifdef POLYGON_OFFSET
gl_FragDepthEXT += czm_epsilon7 * units;
#endif
#endif
}
void czm_writeLogDepth() {
#ifdef LOG_DEPTH
czm_writeLogDepth(v_depthFromNearPlusOne);
#endif
}
`,
    Qx = `float czm_writeNonPerspective(float value, float w) {
return value * w;
}
vec2 czm_writeNonPerspective(vec2 value, float w) {
return value * w;
}
vec3 czm_writeNonPerspective(vec3 value, float w) {
return value * w;
}
vec4 czm_writeNonPerspective(vec4 value, float w) {
return value * w;
}
`,
    Jf = {
        czm_degreesPerRadian: YC,
        czm_depthRange: XC,
        czm_epsilon1: jC,
        czm_epsilon2: ZC,
        czm_epsilon3: KC,
        czm_epsilon4: $C,
        czm_epsilon5: JC,
        czm_epsilon6: QC,
        czm_epsilon7: ew,
        czm_infinity: tw,
        czm_oneOverPi: nw,
        czm_oneOverTwoPi: rw,
        czm_passCesium3DTile: iw,
        czm_passCesium3DTileClassification: aw,
        czm_passCesium3DTileClassificationIgnoreShow: ow,
        czm_passClassification: sw,
        czm_passCompute: uw,
        czm_passEnvironment: cw,
        czm_passGlobe: fw,
        czm_passOpaque: hw,
        czm_passOverlay: lw,
        czm_passTerrainClassification: dw,
        czm_passTranslucent: _w,
        czm_pi: vw,
        czm_piOverFour: mw,
        czm_piOverSix: pw,
        czm_piOverThree: gw,
        czm_piOverTwo: yw,
        czm_radiansPerDegree: Tw,
        czm_sceneMode2D: Ew,
        czm_sceneMode3D: Aw,
        czm_sceneModeColumbusView: Cw,
        czm_sceneModeMorphing: ww,
        czm_solarRadius: xw,
        czm_threePiOver2: Sw,
        czm_twoPi: Rw,
        czm_webMercatorMaxLatitude: Dw,
        czm_depthRangeStruct: Iw,
        czm_material: Pw,
        czm_materialInput: Ow,
        czm_ray: Mw,
        czm_raySegment: Nw,
        czm_shadowParameters: bw,
        czm_HSBToRGB: Fw,
        czm_HSLToRGB: Lw,
        czm_RGBToHSB: Uw,
        czm_RGBToHSL: zw,
        czm_RGBToXYZ: Bw,
        czm_XYZToRGB: Vw,
        czm_acesTonemapping: Gw,
        czm_alphaWeight: Hw,
        czm_antialias: kw,
        czm_approximateSphericalCoordinates: Ww,
        czm_backFacing: qw,
        czm_branchFreeTernary: Yw,
        czm_cascadeColor: Xw,
        czm_cascadeDistance: jw,
        czm_cascadeMatrix: Zw,
        czm_cascadeWeights: Kw,
        czm_columbusViewMorph: $w,
        czm_computePosition: Jw,
        czm_cosineAndSine: Qw,
        czm_decompressTextureCoordinates: ex,
        czm_depthClamp: tx,
        czm_eastNorthUpToEyeCoordinates: nx,
        czm_ellipsoidContainsPoint: rx,
        czm_ellipsoidWgs84TextureCoordinates: ix,
        czm_equalsEpsilon: ax,
        czm_eyeOffset: ox,
        czm_eyeToWindowCoordinates: sx,
        czm_fastApproximateAtan: ux,
        czm_fog: cx,
        czm_gammaCorrect: fx,
        czm_geodeticSurfaceNormal: hx,
        czm_getDefaultMaterial: lx,
        czm_getLambertDiffuse: dx,
        czm_getSpecular: _x,
        czm_getWaterNoise: vx,
        czm_hue: mx,
        czm_inverseGamma: px,
        czm_isEmpty: gx,
        czm_isFull: yx,
        czm_latitudeToWebMercatorFraction: Tx,
        czm_lineDistance: Ex,
        czm_luminance: Ax,
        czm_metersPerPixel: Cx,
        czm_modelToWindowCoordinates: wx,
        czm_multiplyWithColorBalance: xx,
        czm_nearFarScalar: Sx,
        czm_octDecode: Rx,
        czm_packDepth: Dx,
        czm_phong: Ix,
        czm_planeDistance: Px,
        czm_pointAlongRay: Ox,
        czm_rayEllipsoidIntersectionInterval: Mx,
        czm_readDepth: Nx,
        czm_readNonPerspective: bx,
        czm_reverseLogDepth: Fx,
        czm_sampleOctahedralProjection: Lx,
        czm_saturation: Ux,
        czm_shadowDepthCompare: zx,
        czm_shadowVisibility: Bx,
        czm_signNotZero: Vx,
        czm_sphericalHarmonics: Gx,
        czm_tangentToEyeSpaceMatrix: Hx,
        czm_transformPlane: kx,
        czm_translateRelativeToEye: Wx,
        czm_translucentPhong: qx,
        czm_transpose: Yx,
        czm_unpackDepth: Xx,
        czm_unpackFloat: jx,
        czm_vertexLogDepth: Zx,
        czm_windowToEyeCoordinates: Kx,
        czm_writeDepthClamp: $x,
        czm_writeLogDepth: Jx,
        czm_writeNonPerspective: Qx
    };

function Y0(e) {
    return e = e.replace(/\/\/.*/g, ""), e.replace(/\/\*\*[\s\S]*?\*\//gm, function(t) {
        for (var n = t.match(/\n/gm).length, r = "", i = 0; i < n; ++i) r += `
`;
        return r
    })
}

function X0(e, t, n) {
    for (var r, i = 0; i < n.length; ++i) n[i].name === e && (r = n[i]);
    return l(r) || (t = Y0(t), r = {
        name: e,
        glslSource: t,
        dependsOn: [],
        requiredBy: [],
        evaluated: !1
    }, n.push(r)), r
}

function j0(e, t) {
    if (!e.evaluated) {
        e.evaluated = !0;
        var n = e.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);
        l(n) && n !== null && (n = n.filter(function(r, i) {
            return n.indexOf(r) === i
        }), n.forEach(function(r) {
            if (r !== e.name && Re._czmBuiltinsAndUniforms.hasOwnProperty(r)) {
                var i = X0(r, Re._czmBuiltinsAndUniforms[r], t);
                e.dependsOn.push(i), i.requiredBy.push(e), j0(i, t)
            }
        }))
    }
}

function eS(e) {
    for (var t = [], n = []; e.length > 0;) {
        var r = e.pop();
        n.push(r), r.requiredBy.length === 0 && t.push(r)
    }
    for (; t.length > 0;) {
        var i = t.shift();
        e.push(i);
        for (var a = 0; a < i.dependsOn.length; ++a) {
            var o = i.dependsOn[a],
                s = o.requiredBy.indexOf(i);
            o.requiredBy.splice(s, 1), o.requiredBy.length === 0 && t.push(o)
        }
    }
    for (var c = 0; c < n.length; ++c) n[c].requiredBy.length
}

function tS(e) {
    var t = [],
        n = X0("main", e, t);
    j0(n, t), eS(t);
    for (var r = "", i = t.length - 1; i >= 0; --i) r = r + t[i].glslSource + `
`;
    return r.replace(n.glslSource, "")
}

function Z0(e, t, n) {
    var r, i, a = "",
        o = e.sources;
    if (l(o))
        for (r = 0, i = o.length; r < i; ++r) a += `
#line 0
` + o[r];
    a = Y0(a);
    var s;
    a = a.replace(/#version\s+(.*?)\n/gm, function(m, g) {
        return s = g, `
`
    });
    var c = [];
    a = a.replace(/#extension.*\n/gm, function(m) {
        return c.push(m), `
`
    }), a = a.replace(/precision\s(lowp|mediump|highp)\s(float|int);/, "");
    var f = e.pickColorQualifier;
    l(f) && (a = Re.createPickFragmentShaderSource(a, f));
    var h = "";
    l(s) && (h = "#version " + s + `
`);
    var d = c.length;
    for (r = 0; r < d; r++) h += c[r];
    t && (h += `#ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
#else
    precision mediump float;
    #define highp mediump
#endif

`);
    var _ = e.defines;
    if (l(_))
        for (r = 0, i = _.length; r < i; ++r) {
            var v = _[r];
            v.length !== 0 && (h += "#define " + v + `
`)
        }
    return n.webgl2 && (h += `#define OUTPUT_DECLARATION

`), n.textureFloatLinear && (h += `#define OES_texture_float_linear

`), n.floatingPointTexture && (h += `#define OES_texture_float

`), e.includeBuiltIns && (h += tS(a)), h += `
#line 0
`, h += a, n.webgl2 && (h = GC(h, t)), h
}

function Re(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.pickColorQualifier;
    this.defines = l(e.defines) ? e.defines.slice(0) : [], this.sources = l(e.sources) ? e.sources.slice(0) : [], this.pickColorQualifier = t, this.includeBuiltIns = p(e.includeBuiltIns, !0)
}
Re.prototype.clone = function() {
    return new Re({
        sources: this.sources,
        defines: this.defines,
        pickColorQualifier: this.pickColorQualifier,
        includeBuiltIns: this.includeBuiltIns
    })
};
Re.replaceMain = function(e, t) {
    return t = "void " + t + "()", e.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, t)
};
Re.prototype.createCombinedVertexShader = function(e) {
    return Z0(this, !1, e)
};
Re.prototype.createCombinedFragmentShader = function(e) {
    return Z0(this, !0, e)
};
Re._czmBuiltinsAndUniforms = {};
for (var Qf in Jf) Jf.hasOwnProperty(Qf) && (Re._czmBuiltinsAndUniforms[Qf] = Jf[Qf]);
for (var hu in ec)
    if (ec.hasOwnProperty(hu)) {
        var W_ = ec[hu];
        typeof W_.getDeclaration == "function" && (Re._czmBuiltinsAndUniforms[hu] = W_.getDeclaration(hu))
    }
Re.createPickVertexShaderSource = function(e) {
    var t = Re.replaceMain(e, "czm_old_main"),
        n = `attribute vec4 pickColor; 
varying vec4 czm_pickColor; 
void main() 
{ 
    czm_old_main(); 
    czm_pickColor = pickColor; 
}`;
    return t + `
` + n
};
Re.createPickFragmentShaderSource = function(e, t) {
    var n = Re.replaceMain(e, "czm_old_main"),
        r = t + ` vec4 czm_pickColor; 
void main() 
{ 
    czm_old_main(); 
    if (gl_FragColor.a == 0.0) { 
       discard; 
    } 
    gl_FragColor = czm_pickColor; 
}`;
    return n + `
` + r
};
Re.findVarying = function(e, t) {
    for (var n = e.sources, r = t.length, i = 0; i < r; ++i)
        for (var a = t[i], o = n.length, s = 0; s < o; ++s)
            if (n[s].indexOf(a) !== -1) return a
};
var nS = ["v_normalEC", "v_normal"];
Re.findNormalVarying = function(e) {
    return Re.findVarying(e, nS)
};
var rS = ["v_positionEC"];
Re.findPositionVarying = function(e) {
    return Re.findVarying(e, rS)
};
var iS = {
    NONE: 0,
    TRIANGLES: 1,
    LINES: 2,
    POLYLINES: 3
};
const hs = Object.freeze(iS);

function rt(e) {
    e = p(e, p.EMPTY_OBJECT), this.attributes = e.attributes, this.indices = e.indices, this.primitiveType = p(e.primitiveType, Ve.TRIANGLES), this.boundingSphere = e.boundingSphere, this.geometryType = p(e.geometryType, hs.NONE), this.boundingSphereCV = e.boundingSphereCV, this.offsetAttribute = e.offsetAttribute
}
rt.computeNumberOfVertices = function(e) {
    var t = -1;
    for (var n in e.attributes)
        if (e.attributes.hasOwnProperty(n) && l(e.attributes[n]) && l(e.attributes[n].values)) {
            var r = e.attributes[n],
                i = r.values.length / r.componentsPerAttribute;
            t = i
        }
    return t
};
var aS = new K,
    oS = new u,
    q_ = new S,
    sS = [new K, new K, new K],
    uS = [new R, new R, new R],
    cS = [new R, new R, new R],
    fS = new u,
    hS = new X,
    lS = new S,
    dS = new fe;
rt._textureCoordinateRotationPoints = function(e, t, n, r) {
    var i, a = W.center(r, aS),
        o = K.toCartesian(a, n, oS),
        s = xe.eastNorthUpToFixedFrame(o, n, q_),
        c = S.inverse(s, q_),
        f = uS,
        h = sS;
    h[0].longitude = r.west, h[0].latitude = r.south, h[1].longitude = r.west, h[1].latitude = r.north, h[2].longitude = r.east, h[2].latitude = r.south;
    var d = fS;
    for (i = 0; i < 3; i++) K.toCartesian(h[i], n, d), d = S.multiplyByPointAsVector(c, d, d), f[i].x = d.x, f[i].y = d.y;
    var _ = X.fromAxisAngle(u.UNIT_Z, -t, hS),
        v = N.fromQuaternion(_, lS),
        m = e.length,
        g = Number.POSITIVE_INFINITY,
        y = Number.POSITIVE_INFINITY,
        E = Number.NEGATIVE_INFINITY,
        w = Number.NEGATIVE_INFINITY;
    for (i = 0; i < m; i++) d = S.multiplyByPointAsVector(c, e[i], d), d = N.multiplyByVector(v, d, d), g = Math.min(g, d.x), y = Math.min(y, d.y), E = Math.max(E, d.x), w = Math.max(w, d.y);
    var C = fe.fromRotation(t, dS),
        A = cS;
    A[0].x = g, A[0].y = y, A[1].x = g, A[1].y = w, A[2].x = E, A[2].y = y;
    var x = f[0],
        P = f[2].x - x.x,
        I = f[1].y - x.y;
    for (i = 0; i < 3; i++) {
        var D = A[i];
        fe.multiplyByVector(C, D, D), D.x = (D.x - x.x) / P, D.y = (D.y - x.y) / I
    }
    var O = A[0],
        F = A[1],
        z = A[2],
        b = new Array(6);
    return R.pack(O, b), R.pack(F, b, 2), R.pack(z, b, 4), b
};

function _S(e, t, n, r) {
    var i = l(t.vertexBuffer),
        a = l(t.value),
        o = t.value ? t.value.length : t.componentsPerAttribute,
        s = {
            index: p(t.index, n),
            enabled: p(t.enabled, !0),
            vertexBuffer: t.vertexBuffer,
            value: a ? t.value.slice(0) : void 0,
            componentsPerAttribute: o,
            componentDatatype: p(t.componentDatatype, ee.FLOAT),
            normalize: p(t.normalize, !1),
            offsetInBytes: p(t.offsetInBytes, 0),
            strideInBytes: p(t.strideInBytes, 0),
            instanceDivisor: p(t.instanceDivisor, 0)
        };
    if (i) s.vertexAttrib = function(c) {
        var f = this.index;
        c.bindBuffer(c.ARRAY_BUFFER, this.vertexBuffer._getBuffer()), c.vertexAttribPointer(f, this.componentsPerAttribute, this.componentDatatype, this.normalize, this.strideInBytes, this.offsetInBytes), c.enableVertexAttribArray(f), this.instanceDivisor > 0 && (r.glVertexAttribDivisor(f, this.instanceDivisor), r._vertexAttribDivisors[f] = this.instanceDivisor, r._previousDrawInstanced = !0)
    }, s.disableVertexAttribArray = function(c) {
        c.disableVertexAttribArray(this.index), this.instanceDivisor > 0 && r.glVertexAttribDivisor(n, 0)
    };
    else {
        switch (s.componentsPerAttribute) {
            case 1:
                s.vertexAttrib = function(c) {
                    c.vertexAttrib1fv(this.index, this.value)
                };
                break;
            case 2:
                s.vertexAttrib = function(c) {
                    c.vertexAttrib2fv(this.index, this.value)
                };
                break;
            case 3:
                s.vertexAttrib = function(c) {
                    c.vertexAttrib3fv(this.index, this.value)
                };
                break;
            case 4:
                s.vertexAttrib = function(c) {
                    c.vertexAttrib4fv(this.index, this.value)
                };
                break
        }
        s.disableVertexAttribArray = function(c) {}
    }
    e.push(s)
}

function K0(e, t, n) {
    for (var r = 0; r < t.length; ++r) {
        var i = t[r];
        i.enabled && i.vertexAttrib(e)
    }
    l(n) && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n._getBuffer())
}

function Cn(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.context,
        n = t._gl,
        r = e.attributes,
        i = e.indexBuffer,
        a, o = [],
        s = 1,
        c = !1,
        f = !1,
        h = r.length;
    for (a = 0; a < h; ++a) _S(o, r[a], a, t);
    for (h = o.length, a = 0; a < h; ++a) {
        var d = o[a];
        if (l(d.vertexBuffer) && d.instanceDivisor === 0) {
            var _ = d.strideInBytes || d.componentsPerAttribute * ee.getSizeInBytes(d.componentDatatype);
            s = d.vertexBuffer.sizeInBytes / _;
            break
        }
    }
    for (a = 0; a < h; ++a) o[a].instanceDivisor > 0 && (c = !0), l(o[a].value) && (f = !0);
    var v;
    t.vertexArrayObject && (v = t.glCreateVertexArray(), t.glBindVertexArray(v), K0(n, o, i), t.glBindVertexArray(null)), this._numberOfVertices = s, this._hasInstancedAttributes = c, this._hasConstantAttributes = f, this._context = t, this._gl = n, this._vao = v, this._attributes = o, this._indexBuffer = i
}

function Y_(e) {
    return e.values.length / e.componentsPerAttribute
}

function vS(e) {
    return ee.getSizeInBytes(e.componentDatatype) * e.componentsPerAttribute
}

function mS(e) {
    var t, n, r, i = [];
    for (n in e) e.hasOwnProperty(n) && l(e[n]) && l(e[n].values) && (i.push(n), e[n].componentDatatype === ee.DOUBLE && (e[n].componentDatatype = ee.FLOAT, e[n].values = ee.createTypedArray(ee.FLOAT, e[n].values)));
    var a, o = i.length;
    if (o > 0)
        for (a = Y_(e[i[0]]), t = 1; t < o; ++t) {
            var s = Y_(e[i[t]]);
            if (s !== a) throw new je("Each attribute list must have the same number of vertices.  Attribute " + i[t] + " has a different number of vertices (" + s.toString() + ") than attribute " + i[0] + " (" + a.toString() + ").")
        }
    i.sort(function(P, I) {
        return ee.getSizeInBytes(e[I].componentDatatype) - ee.getSizeInBytes(e[P].componentDatatype)
    });
    var c = 0,
        f = {};
    for (t = 0; t < o; ++t) n = i[t], r = e[n], f[n] = c, c += vS(r);
    if (c > 0) {
        var h = ee.getSizeInBytes(e[i[0]].componentDatatype),
            d = c % h;
        d !== 0 && (c += h - d);
        var _ = a * c,
            v = new ArrayBuffer(_),
            m = {};
        for (t = 0; t < o; ++t) {
            n = i[t];
            var g = ee.getSizeInBytes(e[n].componentDatatype);
            m[n] = {
                pointer: ee.createTypedArray(e[n].componentDatatype, v),
                index: f[n] / g,
                strideInComponentType: c / g
            }
        }
        for (t = 0; t < a; ++t)
            for (var y = 0; y < o; ++y) {
                n = i[y], r = e[n];
                for (var E = r.values, w = m[n], C = w.pointer, A = r.componentsPerAttribute, x = 0; x < A; ++x) C[w.index + x] = E[t * A + x];
                w.index += w.strideInComponentType
            }
        return {
            buffer: v,
            offsetsInBytes: f,
            vertexSizeInBytes: c
        }
    }
}
Cn.fromGeometry = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.context,
        n = p(e.geometry, p.EMPTY_OBJECT),
        r = p(e.bufferUsage, Ye.DYNAMIC_DRAW),
        i = p(e.attributeLocations, p.EMPTY_OBJECT),
        a = p(e.interleave, !1),
        o = e.vertexArrayAttributes,
        s, c, f, h = l(o) ? o : [],
        d = n.attributes;
    if (a) {
        var _ = mS(d);
        if (l(_)) {
            f = _t.createVertexBuffer({
                context: t,
                typedArray: _.buffer,
                usage: r
            });
            var v = _.offsetsInBytes,
                m = _.vertexSizeInBytes;
            for (s in d) d.hasOwnProperty(s) && l(d[s]) && (c = d[s], l(c.values) ? h.push({
                index: i[s],
                vertexBuffer: f,
                componentDatatype: c.componentDatatype,
                componentsPerAttribute: c.componentsPerAttribute,
                normalize: c.normalize,
                offsetInBytes: v[s],
                strideInBytes: m
            }) : h.push({
                index: i[s],
                value: c.value,
                componentDatatype: c.componentDatatype,
                normalize: c.normalize
            }))
        }
    } else
        for (s in d)
            if (d.hasOwnProperty(s) && l(d[s])) {
                c = d[s];
                var g = c.componentDatatype;
                g === ee.DOUBLE && (g = ee.FLOAT), f = void 0, l(c.values) && (f = _t.createVertexBuffer({
                    context: t,
                    typedArray: ee.createTypedArray(g, c.values),
                    usage: r
                })), h.push({
                    index: i[s],
                    vertexBuffer: f,
                    value: c.value,
                    componentDatatype: g,
                    componentsPerAttribute: c.componentsPerAttribute,
                    normalize: c.normalize
                })
            } var y, E = n.indices;
    return l(E) && (rt.computeNumberOfVertices(n) >= T.SIXTY_FOUR_KILOBYTES && t.elementIndexUint ? y = _t.createIndexBuffer({
        context: t,
        typedArray: new Uint32Array(E),
        usage: r,
        indexDatatype: yt.UNSIGNED_INT
    }) : y = _t.createIndexBuffer({
        context: t,
        typedArray: new Uint16Array(E),
        usage: r,
        indexDatatype: yt.UNSIGNED_SHORT
    })), new Cn({
        context: t,
        attributes: h,
        indexBuffer: y
    })
};
Object.defineProperties(Cn.prototype, {
    numberOfAttributes: {
        get: function() {
            return this._attributes.length
        }
    },
    numberOfVertices: {
        get: function() {
            return this._numberOfVertices
        }
    },
    indexBuffer: {
        get: function() {
            return this._indexBuffer
        }
    }
});
Cn.prototype.getAttribute = function(e) {
    return this._attributes[e]
};

function pS(e) {
    var t = e._context,
        n = e._hasInstancedAttributes;
    if (!(!n && !t._previousDrawInstanced)) {
        t._previousDrawInstanced = n;
        var r = t._vertexAttribDivisors,
            i = e._attributes,
            a = pe.maximumVertexAttributes,
            o;
        if (n) {
            var s = i.length;
            for (o = 0; o < s; ++o) {
                var c = i[o];
                if (c.enabled) {
                    var f = c.instanceDivisor,
                        h = c.index;
                    f !== r[h] && (t.glVertexAttribDivisor(h, f), r[h] = f)
                }
            }
        } else
            for (o = 0; o < a; ++o) r[o] > 0 && (t.glVertexAttribDivisor(o, 0), r[o] = 0)
    }
}

function gS(e, t) {
    for (var n = e._attributes, r = n.length, i = 0; i < r; ++i) {
        var a = n[i];
        a.enabled && l(a.value) && a.vertexAttrib(t)
    }
}
Cn.prototype._bind = function() {
    l(this._vao) ? (this._context.glBindVertexArray(this._vao), this._context.instancedArrays && pS(this), this._hasConstantAttributes && gS(this, this._gl)) : K0(this._gl, this._attributes, this._indexBuffer)
};
Cn.prototype._unBind = function() {
    if (l(this._vao)) this._context.glBindVertexArray(null);
    else {
        for (var e = this._attributes, t = this._gl, n = 0; n < e.length; ++n) {
            var r = e[n];
            r.enabled && r.disableVertexAttribArray(t)
        }
        this._indexBuffer && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null)
    }
};
Cn.prototype.isDestroyed = function() {
    return !1
};
Cn.prototype.destroy = function() {
    for (var e = this._attributes, t = 0; t < e.length; ++t) {
        var n = e[t].vertexBuffer;
        l(n) && !n.isDestroyed() && n.vertexArrayDestroyable && n.destroy()
    }
    var r = this._indexBuffer;
    return l(r) && !r.isDestroyed() && r.vertexArrayDestroyable && r.destroy(), l(this._vao) && this._context.glDeleteVertexArray(this._vao), Pe(this)
};

function Yt(e, t, n, r) {
    var i = Yt._verifyAttributes(t);
    n = p(n, 0);
    for (var a = [], o = {}, s, c, f = i.length, h = 0; h < f; ++h) {
        var d = i[h];
        if (d.vertexBuffer) {
            a.push(d);
            continue
        }
        c = d.usage, s = o[c], l(s) || (s = o[c] = []), s.push(d)
    }

    function _(y, E) {
        return ee.getSizeInBytes(E.componentDatatype) - ee.getSizeInBytes(y.componentDatatype)
    }
    this._allBuffers = [];
    for (c in o)
        if (o.hasOwnProperty(c)) {
            s = o[c], s.sort(_);
            var v = Yt._vertexSizeInBytes(s),
                m = s[0].usage,
                g = {
                    vertexSizeInBytes: v,
                    vertexBuffer: void 0,
                    usage: m,
                    needsCommit: !1,
                    arrayBuffer: void 0,
                    arrayViews: Yt._createArrayViews(s, v)
                };
            this._allBuffers.push(g)
        }
    this._size = 0, this._instanced = p(r, !1), this._precreated = a, this._context = e, this.writers = void 0, this.va = void 0, this.resize(n)
}
Yt._verifyAttributes = function(e) {
    for (var t = [], n = 0; n < e.length; ++n) {
        var r = e[n],
            i = {
                index: p(r.index, n),
                enabled: p(r.enabled, !0),
                componentsPerAttribute: r.componentsPerAttribute,
                componentDatatype: p(r.componentDatatype, ee.FLOAT),
                normalize: p(r.normalize, !1),
                vertexBuffer: r.vertexBuffer,
                usage: p(r.usage, Ye.STATIC_DRAW)
            };
        t.push(i)
    }
    for (var a = new Array(t.length), o = 0; o < t.length; ++o) {
        var s = t[o],
            c = s.index;
        a[c] = !0
    }
    return t
};
Yt._vertexSizeInBytes = function(e) {
    for (var t = 0, n = e.length, r = 0; r < n; ++r) {
        var i = e[r];
        t += i.componentsPerAttribute * ee.getSizeInBytes(i.componentDatatype)
    }
    var a = n > 0 ? ee.getSizeInBytes(e[0].componentDatatype) : 0,
        o = a > 0 ? t % a : 0,
        s = o === 0 ? 0 : a - o;
    return t += s, t
};
Yt._createArrayViews = function(e, t) {
    for (var n = [], r = 0, i = e.length, a = 0; a < i; ++a) {
        var o = e[a],
            s = o.componentDatatype;
        n.push({
            index: o.index,
            enabled: o.enabled,
            componentsPerAttribute: o.componentsPerAttribute,
            componentDatatype: s,
            normalize: o.normalize,
            offsetInBytes: r,
            vertexSizeInComponentType: t / ee.getSizeInBytes(s),
            view: void 0
        }), r += o.componentsPerAttribute * ee.getSizeInBytes(s)
    }
    return n
};
Yt.prototype.resize = function(e) {
    this._size = e;
    var t = this._allBuffers;
    this.writers = [];
    for (var n = 0, r = t.length; n < r; ++n) {
        var i = t[n];
        Yt._resize(i, this._size), Yt._appendWriters(this.writers, i)
    }
    Ed(this)
};
Yt._resize = function(e, t) {
    if (e.vertexSizeInBytes > 0) {
        var n = new ArrayBuffer(t * e.vertexSizeInBytes);
        if (l(e.arrayBuffer))
            for (var r = new Uint8Array(n), i = new Uint8Array(e.arrayBuffer), a = i.length, o = 0; o < a; ++o) r[o] = i[o];
        for (var s = e.arrayViews, c = s.length, f = 0; f < c; ++f) {
            var h = s[f];
            h.view = ee.createArrayBufferView(h.componentDatatype, n, h.offsetInBytes)
        }
        e.arrayBuffer = n
    }
};
var yS = [function(e, t, n) {
    return function(r, i) {
        t[r * n] = i, e.needsCommit = !0
    }
}, function(e, t, n) {
    return function(r, i, a) {
        var o = r * n;
        t[o] = i, t[o + 1] = a, e.needsCommit = !0
    }
}, function(e, t, n) {
    return function(r, i, a, o) {
        var s = r * n;
        t[s] = i, t[s + 1] = a, t[s + 2] = o, e.needsCommit = !0
    }
}, function(e, t, n) {
    return function(r, i, a, o, s) {
        var c = r * n;
        t[c] = i, t[c + 1] = a, t[c + 2] = o, t[c + 3] = s, e.needsCommit = !0
    }
}];
Yt._appendWriters = function(e, t) {
    for (var n = t.arrayViews, r = n.length, i = 0; i < r; ++i) {
        var a = n[i];
        e[a.index] = yS[a.componentsPerAttribute - 1](t, a.view, a.vertexSizeInComponentType)
    }
};
Yt.prototype.commit = function(e) {
    var t = !1,
        n = this._allBuffers,
        r, i, a;
    for (i = 0, a = n.length; i < a; ++i) r = n[i], t = TS(this, r) || t;
    if (t || !l(this.va)) {
        Ed(this);
        for (var o = this.va = [], s = T.SIXTY_FOUR_KILOBYTES - 4, c = l(e) && !this._instanced ? Math.ceil(this._size / s) : 1, f = 0; f < c; ++f) {
            var h = [];
            for (i = 0, a = n.length; i < a; ++i) {
                r = n[i];
                var d = f * (r.vertexSizeInBytes * s);
                Yt._appendAttributes(h, r, d, this._instanced)
            }
            h = h.concat(this._precreated), o.push({
                va: new Cn({
                    context: this._context,
                    attributes: h,
                    indexBuffer: e
                }),
                indicesCount: 1.5 * (f !== c - 1 ? s : this._size % s)
            })
        }
    }
};

function TS(e, t) {
    if (t.needsCommit && t.vertexSizeInBytes > 0) {
        t.needsCommit = !1;
        var n = t.vertexBuffer,
            r = e._size * t.vertexSizeInBytes,
            i = l(n);
        if (!i || n.sizeInBytes < r) return i && n.destroy(), t.vertexBuffer = _t.createVertexBuffer({
            context: e._context,
            typedArray: t.arrayBuffer,
            usage: t.usage
        }), t.vertexBuffer.vertexArrayDestroyable = !1, !0;
        t.vertexBuffer.copyFromArrayView(t.arrayBuffer)
    }
    return !1
}
Yt._appendAttributes = function(e, t, n, r) {
    for (var i = t.arrayViews, a = i.length, o = 0; o < a; ++o) {
        var s = i[o];
        e.push({
            index: s.index,
            enabled: s.enabled,
            componentsPerAttribute: s.componentsPerAttribute,
            componentDatatype: s.componentDatatype,
            normalize: s.normalize,
            vertexBuffer: t.vertexBuffer,
            offsetInBytes: n + s.offsetInBytes,
            strideInBytes: t.vertexSizeInBytes,
            instanceDivisor: r ? 1 : 0
        })
    }
};
Yt.prototype.subCommit = function(e, t) {
    for (var n = this._allBuffers, r = 0, i = n.length; r < i; ++r) ES(n[r], e, t)
};

function ES(e, t, n) {
    if (e.needsCommit && e.vertexSizeInBytes > 0) {
        var r = e.vertexSizeInBytes * t,
            i = e.vertexSizeInBytes * n;
        e.vertexBuffer.copyFromArrayView(new Uint8Array(e.arrayBuffer, r, i), r)
    }
}
Yt.prototype.endSubCommits = function() {
    for (var e = this._allBuffers, t = 0, n = e.length; t < n; ++t) e[t].needsCommit = !1
};

function Ed(e) {
    var t = e.va;
    if (!!l(t)) {
        for (var n = t.length, r = 0; r < n; ++r) t[r].va.destroy();
        e.va = void 0
    }
}
Yt.prototype.isDestroyed = function() {
    return !1
};
Yt.prototype.destroy = function() {
    for (var e = this._allBuffers, t = 0, n = e.length; t < n; ++t) {
        var r = e[t];
        r.vertexBuffer = r.vertexBuffer && r.vertexBuffer.destroy()
    }
    return Ed(this), Pe(this)
};

function Oi() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
        var t = Math.random() * 16 | 0,
            n = e === "x" ? t : t & 3 | 8;
        return n.toString(16)
    })
}

function wn(e, t) {
    e = p(e, 0), this._near = e, t = p(t, Number.MAX_VALUE), this._far = t
}
Object.defineProperties(wn.prototype, {
    near: {
        get: function() {
            return this._near
        },
        set: function(e) {
            this._near = e
        }
    },
    far: {
        get: function() {
            return this._far
        },
        set: function(e) {
            this._far = e
        }
    }
});
wn.packedLength = 2;
wn.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.near, t[n] = e.far, t
};
wn.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new wn), n.near = e[t++], n.far = e[t], n
};
wn.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.near === t.near && e.far === t.far
};
wn.clone = function(e, t) {
    if (!!l(e)) return l(t) || (t = new wn), t.near = e.near, t.far = e.far, t
};
wn.prototype.clone = function(e) {
    return wn.clone(this, e)
};
wn.prototype.equals = function(e) {
    return wn.equals(this, e)
};
var AS = {
    NONE: 0,
    CLAMP_TO_GROUND: 1,
    RELATIVE_TO_GROUND: 2
};
const Ra = Object.freeze(AS);
var CS = {
    CENTER: 0,
    LEFT: 1,
    RIGHT: -1
};
const Oc = Object.freeze(CS);
var nc = {
    MORPHING: 0,
    COLUMBUS_VIEW: 1,
    SCENE2D: 2,
    SCENE3D: 3
};
nc.getMorphTime = function(e) {
    return e === nc.SCENE3D ? 1 : e === nc.MORPHING ? void 0 : 0
};
const k = Object.freeze(nc);
var Ht = {},
    wS = new U(0, 0, 0, 1),
    ln = new U,
    xS = new ge,
    eh = new R,
    th = new R;
Ht.wgs84ToWindowCoordinates = function(e, t, n) {
    return Ht.wgs84WithEyeOffsetToWindowCoordinates(e, t, u.ZERO, n)
};
var X_ = new U,
    j_ = new u;

function Qo(e, t, n, r) {
    var i = n.viewMatrix,
        a = S.multiplyByVector(i, U.fromElements(e.x, e.y, e.z, 1, X_), X_),
        o = u.multiplyComponents(t, u.normalize(a, j_), j_);
    return a.x += t.x + o.x, a.y += t.y + o.y, a.z += o.z, S.multiplyByVector(n.frustum.projectionMatrix, a, r)
}
var SS = new K(Math.PI, T.PI_OVER_TWO),
    RS = new u,
    DS = new u;
Ht.wgs84WithEyeOffsetToWindowCoordinates = function(e, t, n, r) {
    var i = e.frameState,
        a = Ht.computeActualWgs84Position(i, t, wS);
    if (!!l(a)) {
        var o = e.canvas,
            s = xS;
        s.x = 0, s.y = 0, s.width = o.clientWidth, s.height = o.clientHeight;
        var c = e.camera,
            f = !1;
        if (i.mode === k.SCENE2D) {
            var h = e.mapProjection,
                d = SS,
                _ = h.project(d, RS),
                v = u.clone(c.position, DS),
                m = c.frustum.clone(),
                g = S.computeViewportTransformation(s, 0, 1, new S),
                y = c.frustum.projectionMatrix,
                E = c.positionWC.y,
                w = u.fromElements(T.sign(E) * _.x - E, 0, -c.positionWC.x),
                C = xe.pointToGLWindowCoordinates(y, g, w);
            if (E === 0 || C.x <= 0 || C.x >= o.clientWidth) f = !0;
            else {
                if (C.x > o.clientWidth * .5) {
                    s.width = C.x, c.frustum.right = _.x - E, ln = Qo(a, n, c, ln), Ht.clipToGLWindowCoordinates(s, ln, eh), s.x += C.x, c.position.x = -c.position.x;
                    var A = c.frustum.right;
                    c.frustum.right = -c.frustum.left, c.frustum.left = -A, ln = Qo(a, n, c, ln), Ht.clipToGLWindowCoordinates(s, ln, th)
                } else {
                    s.x += C.x, s.width -= C.x, c.frustum.left = -_.x - E, ln = Qo(a, n, c, ln), Ht.clipToGLWindowCoordinates(s, ln, eh), s.x = s.x - s.width, c.position.x = -c.position.x;
                    var x = c.frustum.left;
                    c.frustum.left = -c.frustum.right, c.frustum.right = -x, ln = Qo(a, n, c, ln), Ht.clipToGLWindowCoordinates(s, ln, th)
                }
                u.clone(v, c.position), c.frustum = m.clone(), r = R.clone(eh, r), (r.x < 0 || r.x > o.clientWidth) && (r.x = th.x)
            }
        }
        if (i.mode !== k.SCENE2D || f) {
            if (ln = Qo(a, n, c, ln), ln.z < 0 && !(c.frustum instanceof lt) && !(c.frustum instanceof Wn)) return;
            r = Ht.clipToGLWindowCoordinates(s, ln, r)
        }
        return r.y = o.clientHeight - r.y, r
    }
};
Ht.wgs84ToDrawingBufferCoordinates = function(e, t, n) {
    if (n = Ht.wgs84ToWindowCoordinates(e, t, n), !!l(n)) return Ht.transformWindowToDrawingBuffer(e, n, n)
};
var yi = new u,
    IS = new K;
Ht.computeActualWgs84Position = function(e, t, n) {
    var r = e.mode;
    if (r === k.SCENE3D) return u.clone(t, n);
    var i = e.mapProjection,
        a = i.ellipsoid.cartesianToCartographic(t, IS);
    if (!!l(a)) {
        if (i.project(a, yi), r === k.COLUMBUS_VIEW) return u.fromElements(yi.z, yi.x, yi.y, n);
        if (r === k.SCENE2D) return u.fromElements(0, yi.x, yi.y, n);
        var o = e.morphTime;
        return u.fromElements(T.lerp(yi.z, t.x, o), T.lerp(yi.x, t.y, o), T.lerp(yi.y, t.z, o), n)
    }
};
var Z_ = new u,
    K_ = new u,
    $_ = new S;
Ht.clipToGLWindowCoordinates = function(e, t, n) {
    return u.divideByScalar(t, t.w, Z_), S.computeViewportTransformation(e, 0, 1, $_), S.multiplyByPoint($_, Z_, K_), R.fromCartesian3(K_, n)
};
Ht.transformWindowToDrawingBuffer = function(e, t, n) {
    var r = e.canvas,
        i = e.drawingBufferWidth / r.clientWidth,
        a = e.drawingBufferHeight / r.clientHeight;
    return R.fromElements(t.x * i, t.y * a, n)
};
var PS = new U,
    J_ = new U;
Ht.drawingBufferToWgs84Coordinates = function(e, t, n, r) {
    var i = e.context,
        a = i.uniformState,
        o = a.currentFrustum,
        s = o.x,
        c = o.y;
    if (e.frameState.useLogDepth) {
        var f = n * a.log2FarDepthFromNearPlusOne,
            h = Math.pow(2, f) - 1;
        n = c * (1 - s / (h + s)) / (c - s)
    }
    var d = e.view.passState.viewport,
        _ = U.clone(U.UNIT_W, PS);
    _.x = (t.x - d.x) / d.width * 2 - 1, _.y = (t.y - d.y) / d.height * 2 - 1, _.z = n * 2 - 1, _.w = 1;
    var v, m = e.camera.frustum;
    if (!l(m.fovy)) l(m._offCenterFrustum) && (m = m._offCenterFrustum), v = J_, v.x = (_.x * (m.right - m.left) + m.left + m.right) * .5, v.y = (_.y * (m.top - m.bottom) + m.bottom + m.top) * .5, v.z = (_.z * (s - c) - s - c) * .5, v.w = 1, v = S.multiplyByVector(a.inverseView, v, v);
    else {
        v = S.multiplyByVector(a.inverseViewProjection, _, J_);
        var g = 1 / v.w;
        u.multiplyByScalar(v, g, v)
    }
    return u.fromCartesian4(v, r)
};
var OS = {
    CENTER: 0,
    BOTTOM: 1,
    BASELINE: 2,
    TOP: -1
};
const Da = Object.freeze(OS);

function ye(e, t) {
    e = p(e, p.EMPTY_OBJECT);
    var n = e.translucencyByDistance,
        r = e.pixelOffsetScaleByDistance,
        i = e.scaleByDistance,
        a = e.distanceDisplayCondition;
    l(n) && (n = at.clone(n)), l(r) && (r = at.clone(r)), l(i) && (i = at.clone(i)), l(a) && (a = wn.clone(a)), this._show = p(e.show, !0), this._position = u.clone(p(e.position, u.ZERO)), this._actualPosition = u.clone(this._position), this._pixelOffset = R.clone(p(e.pixelOffset, R.ZERO)), this._translate = new R(0, 0), this._eyeOffset = u.clone(p(e.eyeOffset, u.ZERO)), this._heightReference = p(e.heightReference, Ra.NONE), this._verticalOrigin = p(e.verticalOrigin, Da.CENTER), this._horizontalOrigin = p(e.horizontalOrigin, Oc.CENTER), this._scale = p(e.scale, 1), this._color = H.clone(p(e.color, H.WHITE)), this._rotation = p(e.rotation, 0), this._alignedAxis = u.clone(p(e.alignedAxis, u.ZERO)), this._width = e.width, this._height = e.height, this._scaleByDistance = i, this._translucencyByDistance = n, this._pixelOffsetScaleByDistance = r, this._sizeInMeters = p(e.sizeInMeters, !1), this._distanceDisplayCondition = a, this._disableDepthTestDistance = e.disableDepthTestDistance, this._id = e.id, this._collection = p(e.collection, t), this._pickId = void 0, this._pickPrimitive = p(e._pickPrimitive, this), this._billboardCollection = t, this._dirty = !1, this._index = -1, this._batchIndex = void 0, this._imageIndex = -1, this._imageIndexPromise = void 0, this._imageId = void 0, this._image = void 0, this._imageSubRegion = void 0, this._imageWidth = void 0, this._imageHeight = void 0, this._labelDimensions = void 0, this._labelHorizontalOrigin = void 0, this._labelTranslate = void 0;
    var o = e.image,
        s = e.imageId;
    l(o) && (l(s) || (typeof o == "string" ? s = o : l(o.src) ? s = o.src : s = Oi()), this._imageId = s, this._image = o), l(e.imageSubRegion) && (this._imageId = s, this._imageSubRegion = e.imageSubRegion), l(this._billboardCollection._textureAtlas) && this._loadImage(), this._actualClampedPosition = void 0, this._removeCallbackFunc = void 0, this._mode = k.SCENE3D, this._clusterShow = !0, this._outlineColor = H.clone(p(e.outlineColor, H.BLACK)), this._outlineWidth = p(e.outlineWidth, 0), this._updateClamping()
}
var Q_ = ye.SHOW_INDEX = 0,
    rc = ye.POSITION_INDEX = 1,
    $0 = ye.PIXEL_OFFSET_INDEX = 2,
    MS = ye.EYE_OFFSET_INDEX = 3,
    NS = ye.HORIZONTAL_ORIGIN_INDEX = 4,
    bS = ye.VERTICAL_ORIGIN_INDEX = 5,
    FS = ye.SCALE_INDEX = 6,
    ic = ye.IMAGE_INDEX_INDEX = 7,
    ev = ye.COLOR_INDEX = 8,
    LS = ye.ROTATION_INDEX = 9,
    US = ye.ALIGNED_AXIS_INDEX = 10,
    zS = ye.SCALE_BY_DISTANCE_INDEX = 11,
    BS = ye.TRANSLUCENCY_BY_DISTANCE_INDEX = 12,
    VS = ye.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = 13,
    GS = ye.DISTANCE_DISPLAY_CONDITION = 14,
    HS = ye.DISABLE_DEPTH_DISTANCE = 15;
ye.TEXTURE_COORDINATE_BOUNDS = 16;
var tv = ye.SDF_INDEX = 17;
ye.NUMBER_OF_PROPERTIES = 18;

function vt(e, t) {
    var n = e._billboardCollection;
    l(n) && (n._updateBillboard(e, t), e._dirty = !0)
}
Object.defineProperties(ye.prototype, {
    show: {
        get: function() {
            return this._show
        },
        set: function(e) {
            this._show !== e && (this._show = e, vt(this, Q_))
        }
    },
    position: {
        get: function() {
            return this._position
        },
        set: function(e) {
            var t = this._position;
            u.equals(t, e) || (u.clone(e, t), u.clone(e, this._actualPosition), this._updateClamping(), vt(this, rc))
        }
    },
    heightReference: {
        get: function() {
            return this._heightReference
        },
        set: function(e) {
            var t = this._heightReference;
            e !== t && (this._heightReference = e, this._updateClamping(), vt(this, rc))
        }
    },
    pixelOffset: {
        get: function() {
            return this._pixelOffset
        },
        set: function(e) {
            var t = this._pixelOffset;
            R.equals(t, e) || (R.clone(e, t), vt(this, $0))
        }
    },
    scaleByDistance: {
        get: function() {
            return this._scaleByDistance
        },
        set: function(e) {
            var t = this._scaleByDistance;
            at.equals(t, e) || (this._scaleByDistance = at.clone(e, t), vt(this, zS))
        }
    },
    translucencyByDistance: {
        get: function() {
            return this._translucencyByDistance
        },
        set: function(e) {
            var t = this._translucencyByDistance;
            at.equals(t, e) || (this._translucencyByDistance = at.clone(e, t), vt(this, BS))
        }
    },
    pixelOffsetScaleByDistance: {
        get: function() {
            return this._pixelOffsetScaleByDistance
        },
        set: function(e) {
            var t = this._pixelOffsetScaleByDistance;
            at.equals(t, e) || (this._pixelOffsetScaleByDistance = at.clone(e, t), vt(this, VS))
        }
    },
    eyeOffset: {
        get: function() {
            return this._eyeOffset
        },
        set: function(e) {
            var t = this._eyeOffset;
            u.equals(t, e) || (u.clone(e, t), vt(this, MS))
        }
    },
    horizontalOrigin: {
        get: function() {
            return this._horizontalOrigin
        },
        set: function(e) {
            this._horizontalOrigin !== e && (this._horizontalOrigin = e, vt(this, NS))
        }
    },
    verticalOrigin: {
        get: function() {
            return this._verticalOrigin
        },
        set: function(e) {
            this._verticalOrigin !== e && (this._verticalOrigin = e, vt(this, bS))
        }
    },
    scale: {
        get: function() {
            return this._scale
        },
        set: function(e) {
            this._scale !== e && (this._scale = e, vt(this, FS))
        }
    },
    color: {
        get: function() {
            return this._color
        },
        set: function(e) {
            var t = this._color;
            H.equals(t, e) || (H.clone(e, t), vt(this, ev))
        }
    },
    rotation: {
        get: function() {
            return this._rotation
        },
        set: function(e) {
            this._rotation !== e && (this._rotation = e, vt(this, LS))
        }
    },
    alignedAxis: {
        get: function() {
            return this._alignedAxis
        },
        set: function(e) {
            var t = this._alignedAxis;
            u.equals(t, e) || (u.clone(e, t), vt(this, US))
        }
    },
    width: {
        get: function() {
            return p(this._width, this._imageWidth)
        },
        set: function(e) {
            this._width !== e && (this._width = e, vt(this, ic))
        }
    },
    height: {
        get: function() {
            return p(this._height, this._imageHeight)
        },
        set: function(e) {
            this._height !== e && (this._height = e, vt(this, ic))
        }
    },
    sizeInMeters: {
        get: function() {
            return this._sizeInMeters
        },
        set: function(e) {
            this._sizeInMeters !== e && (this._sizeInMeters = e, vt(this, ev))
        }
    },
    distanceDisplayCondition: {
        get: function() {
            return this._distanceDisplayCondition
        },
        set: function(e) {
            wn.equals(e, this._distanceDisplayCondition) || (this._distanceDisplayCondition = wn.clone(e, this._distanceDisplayCondition), vt(this, GS))
        }
    },
    disableDepthTestDistance: {
        get: function() {
            return this._disableDepthTestDistance
        },
        set: function(e) {
            this._disableDepthTestDistance !== e && (this._disableDepthTestDistance = e, vt(this, HS))
        }
    },
    id: {
        get: function() {
            return this._id
        },
        set: function(e) {
            this._id = e, l(this._pickId) && (this._pickId.object.id = e)
        }
    },
    pickPrimitive: {
        get: function() {
            return this._pickPrimitive
        },
        set: function(e) {
            this._pickPrimitive = e, l(this._pickId) && (this._pickId.object.primitive = e)
        }
    },
    pickId: {
        get: function() {
            return this._pickId
        }
    },
    image: {
        get: function() {
            return this._imageId
        },
        set: function(e) {
            l(e) ? typeof e == "string" ? this.setImage(e, e) : e instanceof J ? this.setImage(e.url, e) : l(e.src) ? this.setImage(e.src, e) : this.setImage(Oi(), e) : (this._imageIndex = -1, this._imageSubRegion = void 0, this._imageId = void 0, this._image = void 0, this._imageIndexPromise = void 0, vt(this, ic))
        }
    },
    ready: {
        get: function() {
            return this._imageIndex !== -1
        }
    },
    _clampedPosition: {
        get: function() {
            return this._actualClampedPosition
        },
        set: function(e) {
            this._actualClampedPosition = u.clone(e, this._actualClampedPosition), vt(this, rc)
        }
    },
    clusterShow: {
        get: function() {
            return this._clusterShow
        },
        set: function(e) {
            this._clusterShow !== e && (this._clusterShow = e, vt(this, Q_))
        }
    },
    outlineColor: {
        get: function() {
            return this._outlineColor
        },
        set: function(e) {
            var t = this._outlineColor;
            H.equals(t, e) || (H.clone(e, t), vt(this, tv))
        }
    },
    outlineWidth: {
        get: function() {
            return this._outlineWidth
        },
        set: function(e) {
            this._outlineWidth !== e && (this._outlineWidth = e, vt(this, tv))
        }
    }
});
ye.prototype.getPickId = function(e) {
    return l(this._pickId) || (this._pickId = e.createPickId({
        primitive: this._pickPrimitive,
        collection: this._collection,
        id: this._id
    })), this._pickId
};
ye.prototype._updateClamping = function() {
    ye._updateClamping(this._billboardCollection, this)
};
var ls = new K,
    nv = new u;
ye._updateClamping = function(e, t) {
    var n = e._scene;
    if (!l(n) || !l(n.globe)) return;
    var r = n.globe,
        i = r.ellipsoid,
        a = r._surface,
        o = n.frameState.mode,
        s = o !== t._mode;
    if (t._mode = o, (t._heightReference === Ra.NONE || s) && l(t._removeCallbackFunc) && (t._removeCallbackFunc(), t._removeCallbackFunc = void 0, t._clampedPosition = void 0), t._heightReference === Ra.NONE || !l(t._position)) return;
    var c = i.cartesianToCartographic(t._position);
    if (!l(c)) {
        t._actualClampedPosition = void 0;
        return
    }
    l(t._removeCallbackFunc) && t._removeCallbackFunc();

    function f(d) {
        if (t._heightReference === Ra.RELATIVE_TO_GROUND)
            if (t._mode === k.SCENE3D) {
                var _ = i.cartesianToCartographic(d, ls);
                _.height += c.height, i.cartographicToCartesian(_, d)
            } else d.x += c.height;
        t._clampedPosition = u.clone(d, t._clampedPosition)
    }
    t._removeCallbackFunc = a.updateHeight(c, f), K.clone(c, ls);
    var h = r.getHeight(c);
    l(h) && (ls.height = h), i.cartographicToCartesian(ls, nv), f(nv)
};
ye.prototype._loadImage = function() {
    var e = this._billboardCollection._textureAtlas,
        t = this._imageId,
        n = this._image,
        r = this._imageSubRegion,
        i;
    if (l(n) && (i = e.addImage(t, n)), l(r) && (i = e.addSubRegion(t, r)), this._imageIndexPromise = i, !!l(i)) {
        var a = this;
        i.then(function(o) {
            if (!(a._imageId !== t || a._image !== n || !ge.equals(a._imageSubRegion, r))) {
                var s = e.textureCoordinates[o];
                a._imageWidth = e.texture.width * s.width, a._imageHeight = e.texture.height * s.height, a._imageIndex = o, a._ready = !0, a._image = void 0, a._imageIndexPromise = void 0, vt(a, ic)
            }
        }).otherwise(function(o) {
            console.error("Error loading image for billboard: " + o), a._imageIndexPromise = void 0
        })
    }
};
ye.prototype.setImage = function(e, t) {
    this._imageId !== e && (this._imageIndex = -1, this._imageSubRegion = void 0, this._imageId = e, this._image = t, l(this._billboardCollection._textureAtlas) && this._loadImage())
};
ye.prototype.setImageSubRegion = function(e, t) {
    this._imageId === e && ge.equals(this._imageSubRegion, t) || (this._imageIndex = -1, this._imageId = e, this._imageSubRegion = ge.clone(t), l(this._billboardCollection._textureAtlas) && this._loadImage())
};
ye.prototype._setTranslate = function(e) {
    var t = this._translate;
    R.equals(t, e) || (R.clone(e, t), vt(this, $0))
};
ye.prototype._getActualPosition = function() {
    return l(this._clampedPosition) ? this._clampedPosition : this._actualPosition
};
ye.prototype._setActualPosition = function(e) {
    l(this._clampedPosition) || u.clone(e, this._actualPosition), vt(this, rc)
};
var rv = new U;
ye._computeActualPosition = function(e, t, n, r) {
    return l(e._clampedPosition) ? (n.mode !== e._mode && e._updateClamping(), e._clampedPosition) : n.mode === k.SCENE3D ? t : (S.multiplyByPoint(r, t, rv), Ht.computeActualWgs84Position(n, rv))
};
var J0 = new u;
ye._computeScreenSpacePosition = function(e, t, n, r, i, a) {
    var o = S.multiplyByPoint(e, t, J0),
        s = Ht.wgs84WithEyeOffsetToWindowCoordinates(i, o, n, a);
    if (!!l(s)) return R.add(s, r, s), s
};
var lu = new R(0, 0);
ye.prototype.computeScreenSpacePosition = function(e, t) {
    var n = this._billboardCollection;
    l(t) || (t = new R), R.clone(this._pixelOffset, lu), R.add(lu, this._translate, lu);
    var r = n.modelMatrix,
        i = this._position;
    if (l(this._clampedPosition) && (i = this._clampedPosition, e.mode !== k.SCENE3D)) {
        var a = e.mapProjection,
            o = a.ellipsoid,
            s = a.unproject(i, ls);
        i = o.cartographicToCartesian(s, J0), r = S.IDENTITY
    }
    var c = ye._computeScreenSpacePosition(r, i, this._eyeOffset, lu, e, t);
    return c
};
ye.getScreenSpaceBoundingBox = function(e, t, n) {
    var r = e.width,
        i = e.height,
        a = e.scale;
    r *= a, i *= a;
    var o = t.x;
    e.horizontalOrigin === Oc.RIGHT ? o -= r : e.horizontalOrigin === Oc.CENTER && (o -= r * .5);
    var s = t.y;
    return e.verticalOrigin === Da.BOTTOM || e.verticalOrigin === Da.BASELINE ? s -= i : e.verticalOrigin === Da.CENTER && (s -= i * .5), l(n) || (n = new ge), n.x = o, n.y = s, n.width = r, n.height = i, n
};
ye.prototype.equals = function(e) {
    return this === e || l(e) && this._id === e._id && u.equals(this._position, e._position) && this._imageId === e._imageId && this._show === e._show && this._scale === e._scale && this._verticalOrigin === e._verticalOrigin && this._horizontalOrigin === e._horizontalOrigin && this._heightReference === e._heightReference && ge.equals(this._imageSubRegion, e._imageSubRegion) && H.equals(this._color, e._color) && R.equals(this._pixelOffset, e._pixelOffset) && R.equals(this._translate, e._translate) && u.equals(this._eyeOffset, e._eyeOffset) && at.equals(this._scaleByDistance, e._scaleByDistance) && at.equals(this._translucencyByDistance, e._translucencyByDistance) && at.equals(this._pixelOffsetScaleByDistance, e._pixelOffsetScaleByDistance) && wn.equals(this._distanceDisplayCondition, e._distanceDisplayCondition) && this._disableDepthTestDistance === e._disableDepthTestDistance
};
ye.prototype._destroy = function() {
    l(this._customData) && (this._billboardCollection._scene.globe._surface.removeTileCustomData(this._customData), this._customData = void 0), l(this._removeCallbackFunc) && (this._removeCallbackFunc(), this._removeCallbackFunc = void 0), this.image = void 0, this._pickId = this._pickId && this._pickId.destroy(), this._billboardCollection = void 0
};
const kS = `#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
uniform sampler2D u_atlas;
#ifdef VECTOR_TILE
uniform vec4 u_highlightColor;
#endif
varying vec2 v_textureCoordinates;
varying vec4 v_pickColor;
varying vec4 v_color;
#ifdef SDF
varying vec4 v_outlineColor;
varying float v_outlineWidth;
#endif
#ifdef FRAGMENT_DEPTH_CHECK
varying vec4 v_textureCoordinateBounds;
varying vec4 v_originTextureCoordinateAndTranslate;
varying vec4 v_compressed;
varying mat2 v_rotationMatrix;
const float SHIFT_LEFT12 = 4096.0;
const float SHIFT_LEFT1 = 2.0;
const float SHIFT_RIGHT12 = 1.0 / 4096.0;
const float SHIFT_RIGHT1 = 1.0 / 2.0;
float getGlobeDepth(vec2 adjustedST, vec2 depthLookupST, bool applyTranslate, vec2 dimensions, vec2 imageSize)
{
vec2 lookupVector = imageSize * (depthLookupST - adjustedST);
lookupVector = v_rotationMatrix * lookupVector;
vec2 labelOffset = (dimensions - imageSize) * (depthLookupST - vec2(0.0, v_originTextureCoordinateAndTranslate.y));
vec2 translation = v_originTextureCoordinateAndTranslate.zw;
if (applyTranslate)
{
translation += (dimensions * v_originTextureCoordinateAndTranslate.xy * vec2(1.0, 0.0));
}
vec2 st = ((lookupVector - translation + labelOffset) + gl_FragCoord.xy) / czm_viewport.zw;
float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st));
if (logDepthOrDepth == 0.0)
{
return 0.0;
}
vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);
return eyeCoordinate.z / eyeCoordinate.w;
}
#endif
#ifdef SDF
float getDistance(vec2 position)
{
return texture2D(u_atlas, position).r;
}
vec4 getSDFColor(vec2 position, float outlineWidth, vec4 outlineColor, float smoothing)
{
float distance = getDistance(position);
if (outlineWidth > 0.0)
{
float outlineEdge = clamp(SDF_EDGE - outlineWidth, 0.0, SDF_EDGE);
float outlineFactor = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);
vec4 sdfColor = mix(outlineColor, v_color, outlineFactor);
float alpha = smoothstep(outlineEdge - smoothing, outlineEdge + smoothing, distance);
return vec4(sdfColor.rgb, sdfColor.a * alpha);
}
else
{
float alpha = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);
return vec4(v_color.rgb, v_color.a * alpha);
}
}
#endif
void main()
{
vec4 color = texture2D(u_atlas, v_textureCoordinates);
#ifdef SDF
float outlineWidth = v_outlineWidth;
vec4 outlineColor = v_outlineColor;
float distance = getDistance(v_textureCoordinates);
#ifdef GL_OES_standard_derivatives
float smoothing = fwidth(distance);
vec2 sampleOffset = 0.354 * vec2(dFdx(v_textureCoordinates) + dFdy(v_textureCoordinates));
vec4 center = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);
vec4 color1 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);
vec4 color2 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);
vec4 color3 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);
vec4 color4 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);
color = (center + color1 + color2 + color3 + color4)/5.0;
#else
float smoothing = 1.0/32.0;
color = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);
#endif
color = czm_gammaCorrect(color);
#else
color = czm_gammaCorrect(color);
color *= czm_gammaCorrect(v_color);
#endif
#if !defined(OPAQUE) && !defined(TRANSLUCENT)
if (color.a < 0.005)
{
discard;
}
#else
#ifdef OPAQUE
if (color.a < 0.995)
{
discard;
}
#else
if (color.a >= 0.995)
{
discard;
}
#endif
#endif
#ifdef VECTOR_TILE
color *= u_highlightColor;
#endif
gl_FragColor = color;
#ifdef LOG_DEPTH
czm_writeLogDepth();
#endif
#ifdef FRAGMENT_DEPTH_CHECK
float temp = v_compressed.y;
temp = temp * SHIFT_RIGHT1;
float temp2 = (temp - floor(temp)) * SHIFT_LEFT1;
bool enableDepthTest = temp2 != 0.0;
bool applyTranslate = floor(temp) != 0.0;
if (enableDepthTest) {
temp = v_compressed.z;
temp = temp * SHIFT_RIGHT12;
vec2 dimensions;
dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;
dimensions.x = floor(temp);
temp = v_compressed.w;
temp = temp * SHIFT_RIGHT12;
vec2 imageSize;
imageSize.y = (temp - floor(temp)) * SHIFT_LEFT12;
imageSize.x = floor(temp);
vec2 adjustedST = v_textureCoordinates - v_textureCoordinateBounds.xy;
adjustedST = adjustedST / vec2(v_textureCoordinateBounds.z - v_textureCoordinateBounds.x, v_textureCoordinateBounds.w - v_textureCoordinateBounds.y);
float epsilonEyeDepth = v_compressed.x + czm_epsilon1;
float globeDepth1 = getGlobeDepth(adjustedST, v_originTextureCoordinateAndTranslate.xy, applyTranslate, dimensions, imageSize);
if (globeDepth1 != 0.0 && globeDepth1 > epsilonEyeDepth)
{
float globeDepth2 = getGlobeDepth(adjustedST, vec2(0.0, 1.0), applyTranslate, dimensions, imageSize);
if (globeDepth2 != 0.0 && globeDepth2 > epsilonEyeDepth)
{
float globeDepth3 = getGlobeDepth(adjustedST, vec2(1.0, 1.0), applyTranslate, dimensions, imageSize);
if (globeDepth3 != 0.0 && globeDepth3 > epsilonEyeDepth)
{
discard;
}
}
}
}
#endif
}
`,
    WS = `#ifdef INSTANCED
attribute vec2 direction;
#endif
attribute vec4 positionHighAndScale;
attribute vec4 positionLowAndRotation;
attribute vec4 compressedAttribute0;
attribute vec4 compressedAttribute1;
attribute vec4 compressedAttribute2;
attribute vec4 eyeOffset;
attribute vec4 scaleByDistance;
attribute vec4 pixelOffsetScaleByDistance;
attribute vec4 compressedAttribute3;
attribute vec2 sdf;
#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)
attribute vec4 textureCoordinateBoundsOrLabelTranslate;
#endif
#ifdef VECTOR_TILE
attribute float a_batchId;
#endif
varying vec2 v_textureCoordinates;
#ifdef FRAGMENT_DEPTH_CHECK
varying vec4 v_textureCoordinateBounds;
varying vec4 v_originTextureCoordinateAndTranslate;
varying vec4 v_compressed;
varying mat2 v_rotationMatrix;
#endif
varying vec4 v_pickColor;
varying vec4 v_color;
#ifdef SDF
varying vec4 v_outlineColor;
varying float v_outlineWidth;
#endif
const float UPPER_BOUND = 32768.0;
const float SHIFT_LEFT16 = 65536.0;
const float SHIFT_LEFT12 = 4096.0;
const float SHIFT_LEFT8 = 256.0;
const float SHIFT_LEFT7 = 128.0;
const float SHIFT_LEFT5 = 32.0;
const float SHIFT_LEFT3 = 8.0;
const float SHIFT_LEFT2 = 4.0;
const float SHIFT_LEFT1 = 2.0;
const float SHIFT_RIGHT12 = 1.0 / 4096.0;
const float SHIFT_RIGHT8 = 1.0 / 256.0;
const float SHIFT_RIGHT7 = 1.0 / 128.0;
const float SHIFT_RIGHT5 = 1.0 / 32.0;
const float SHIFT_RIGHT3 = 1.0 / 8.0;
const float SHIFT_RIGHT2 = 1.0 / 4.0;
const float SHIFT_RIGHT1 = 1.0 / 2.0;
vec4 addScreenSpaceOffset(vec4 positionEC, vec2 imageSize, float scale, vec2 direction, vec2 origin, vec2 translate, vec2 pixelOffset, vec3 alignedAxis, bool validAlignedAxis, float rotation, bool sizeInMeters, out mat2 rotationMatrix, out float mpp)
{
vec2 halfSize = imageSize * scale * 0.5;
halfSize *= ((direction * 2.0) - 1.0);
vec2 originTranslate = origin * abs(halfSize);
#if defined(ROTATION) || defined(ALIGNED_AXIS)
if (validAlignedAxis || rotation != 0.0)
{
float angle = rotation;
if (validAlignedAxis)
{
vec4 projectedAlignedAxis = czm_modelViewProjection * vec4(alignedAxis, 0.0);
angle += sign(-projectedAlignedAxis.x) * acos(sign(projectedAlignedAxis.y) * (projectedAlignedAxis.y * projectedAlignedAxis.y) /
(projectedAlignedAxis.x * projectedAlignedAxis.x + projectedAlignedAxis.y * projectedAlignedAxis.y));
}
float cosTheta = cos(angle);
float sinTheta = sin(angle);
rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);
halfSize = rotationMatrix * halfSize;
}
else
{
rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);
}
#endif
mpp = czm_metersPerPixel(positionEC);
positionEC.xy += (originTranslate + halfSize) * czm_branchFreeTernary(sizeInMeters, 1.0, mpp);
positionEC.xy += (translate + pixelOffset) * mpp;
return positionEC;
}
#ifdef VERTEX_DEPTH_CHECK
float getGlobeDepth(vec4 positionEC)
{
vec4 posWC = czm_eyeToWindowCoordinates(positionEC);
float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, posWC.xy / czm_viewport.zw));
if (globeDepth == 0.0)
{
return 0.0;
}
vec4 eyeCoordinate = czm_windowToEyeCoordinates(posWC.xy, globeDepth);
return eyeCoordinate.z / eyeCoordinate.w;
}
#endif
void main()
{
vec3 positionHigh = positionHighAndScale.xyz;
vec3 positionLow = positionLowAndRotation.xyz;
float scale = positionHighAndScale.w;
#if defined(ROTATION) || defined(ALIGNED_AXIS)
float rotation = positionLowAndRotation.w;
#else
float rotation = 0.0;
#endif
float compressed = compressedAttribute0.x;
vec2 pixelOffset;
pixelOffset.x = floor(compressed * SHIFT_RIGHT7);
compressed -= pixelOffset.x * SHIFT_LEFT7;
pixelOffset.x -= UPPER_BOUND;
vec2 origin;
origin.x = floor(compressed * SHIFT_RIGHT5);
compressed -= origin.x * SHIFT_LEFT5;
origin.y = floor(compressed * SHIFT_RIGHT3);
compressed -= origin.y * SHIFT_LEFT3;
#ifdef FRAGMENT_DEPTH_CHECK
vec2 depthOrigin = origin.xy;
#endif
origin -= vec2(1.0);
float show = floor(compressed * SHIFT_RIGHT2);
compressed -= show * SHIFT_LEFT2;
#ifdef INSTANCED
vec2 textureCoordinatesBottomLeft = czm_decompressTextureCoordinates(compressedAttribute0.w);
vec2 textureCoordinatesRange = czm_decompressTextureCoordinates(eyeOffset.w);
vec2 textureCoordinates = textureCoordinatesBottomLeft + direction * textureCoordinatesRange;
#else
vec2 direction;
direction.x = floor(compressed * SHIFT_RIGHT1);
direction.y = compressed - direction.x * SHIFT_LEFT1;
vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);
#endif
float temp = compressedAttribute0.y  * SHIFT_RIGHT8;
pixelOffset.y = -(floor(temp) - UPPER_BOUND);
vec2 translate;
translate.y = (temp - floor(temp)) * SHIFT_LEFT16;
temp = compressedAttribute0.z * SHIFT_RIGHT8;
translate.x = floor(temp) - UPPER_BOUND;
translate.y += (temp - floor(temp)) * SHIFT_LEFT8;
translate.y -= UPPER_BOUND;
temp = compressedAttribute1.x * SHIFT_RIGHT8;
float temp2 = floor(compressedAttribute2.w * SHIFT_RIGHT2);
vec2 imageSize = vec2(floor(temp), temp2);
#ifdef FRAGMENT_DEPTH_CHECK
float labelHorizontalOrigin = floor(compressedAttribute2.w - (temp2 * SHIFT_LEFT2));
float applyTranslate = 0.0;
if (labelHorizontalOrigin != 0.0)
{
applyTranslate = 1.0;
labelHorizontalOrigin -= 2.0;
depthOrigin.x = labelHorizontalOrigin + 1.0;
}
depthOrigin = vec2(1.0) - (depthOrigin * 0.5);
#endif
#ifdef EYE_DISTANCE_TRANSLUCENCY
vec4 translucencyByDistance;
translucencyByDistance.x = compressedAttribute1.z;
translucencyByDistance.z = compressedAttribute1.w;
translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
temp = compressedAttribute1.y * SHIFT_RIGHT8;
translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
#endif
#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)
temp = compressedAttribute3.w;
temp = temp * SHIFT_RIGHT12;
vec2 dimensions;
dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;
dimensions.x = floor(temp);
#endif
#ifdef ALIGNED_AXIS
vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));
temp = compressedAttribute2.z * SHIFT_RIGHT5;
bool validAlignedAxis = (temp - floor(temp)) * SHIFT_LEFT1 > 0.0;
#else
vec3 alignedAxis = vec3(0.0);
bool validAlignedAxis = false;
#endif
vec4 pickColor;
vec4 color;
temp = compressedAttribute2.y;
temp = temp * SHIFT_RIGHT8;
pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
pickColor.r = floor(temp);
temp = compressedAttribute2.x;
temp = temp * SHIFT_RIGHT8;
color.b = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
color.g = (temp - floor(temp)) * SHIFT_LEFT8;
color.r = floor(temp);
temp = compressedAttribute2.z * SHIFT_RIGHT8;
bool sizeInMeters = floor((temp - floor(temp)) * SHIFT_LEFT7) > 0.0;
temp = floor(temp) * SHIFT_RIGHT8;
pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
pickColor /= 255.0;
color.a = floor(temp);
color /= 255.0;
vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
vec4 positionEC = czm_modelViewRelativeToEye * p;
#if defined(FRAGMENT_DEPTH_CHECK) || defined(VERTEX_DEPTH_CHECK)
float eyeDepth = positionEC.z;
#endif
positionEC = czm_eyeOffset(positionEC, eyeOffset.xyz);
positionEC.xyz *= show;
#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)
float lengthSq;
if (czm_sceneMode == czm_sceneMode2D)
{
lengthSq = czm_eyeHeight2D.y;
}
else
{
lengthSq = dot(positionEC.xyz, positionEC.xyz);
}
#endif
#ifdef EYE_DISTANCE_SCALING
float distanceScale = czm_nearFarScalar(scaleByDistance, lengthSq);
scale *= distanceScale;
translate *= distanceScale;
if (scale == 0.0)
{
positionEC.xyz = vec3(0.0);
}
#endif
float translucency = 1.0;
#ifdef EYE_DISTANCE_TRANSLUCENCY
translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);
if (translucency == 0.0)
{
positionEC.xyz = vec3(0.0);
}
#endif
#ifdef EYE_DISTANCE_PIXEL_OFFSET
float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq);
pixelOffset *= pixelOffsetScale;
#endif
#ifdef DISTANCE_DISPLAY_CONDITION
float nearSq = compressedAttribute3.x;
float farSq = compressedAttribute3.y;
if (lengthSq < nearSq || lengthSq > farSq)
{
positionEC.xyz = vec3(0.0);
}
#endif
mat2 rotationMatrix;
float mpp;
#ifdef DISABLE_DEPTH_DISTANCE
float disableDepthTestDistance = compressedAttribute3.z;
#endif
#ifdef VERTEX_DEPTH_CHECK
if (lengthSq < disableDepthTestDistance) {
float depthsilon = 10.0;
vec2 labelTranslate = textureCoordinateBoundsOrLabelTranslate.xy;
vec4 pEC1 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
float globeDepth1 = getGlobeDepth(pEC1);
if (globeDepth1 != 0.0 && pEC1.z + depthsilon < globeDepth1)
{
vec4 pEC2 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0, 1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
float globeDepth2 = getGlobeDepth(pEC2);
if (globeDepth2 != 0.0 && pEC2.z + depthsilon < globeDepth2)
{
vec4 pEC3 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
float globeDepth3 = getGlobeDepth(pEC3);
if (globeDepth3 != 0.0 && pEC3.z + depthsilon < globeDepth3)
{
positionEC.xyz = vec3(0.0);
}
}
}
}
#endif
positionEC = addScreenSpaceOffset(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);
gl_Position = czm_projection * positionEC;
v_textureCoordinates = textureCoordinates;
#ifdef LOG_DEPTH
czm_vertexLogDepth();
#endif
#ifdef DISABLE_DEPTH_DISTANCE
if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)
{
disableDepthTestDistance = czm_minimumDisableDepthTestDistance;
}
if (disableDepthTestDistance != 0.0)
{
float zclip = gl_Position.z / gl_Position.w;
bool clipped = (zclip < -1.0 || zclip > 1.0);
if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))
{
gl_Position.z = -gl_Position.w;
#ifdef LOG_DEPTH
v_depthFromNearPlusOne = 1.0;
#endif
}
}
#endif
#ifdef FRAGMENT_DEPTH_CHECK
if (sizeInMeters) {
translate /= mpp;
dimensions /= mpp;
imageSize /= mpp;
}
#if defined(ROTATION) || defined(ALIGNED_AXIS)
v_rotationMatrix = rotationMatrix;
#else
v_rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);
#endif
float enableDepthCheck = 0.0;
if (lengthSq < disableDepthTestDistance)
{
enableDepthCheck = 1.0;
}
float dw = floor(clamp(dimensions.x, 0.0, SHIFT_LEFT12));
float dh = floor(clamp(dimensions.y, 0.0, SHIFT_LEFT12));
float iw = floor(clamp(imageSize.x, 0.0, SHIFT_LEFT12));
float ih = floor(clamp(imageSize.y, 0.0, SHIFT_LEFT12));
v_compressed.x = eyeDepth;
v_compressed.y = applyTranslate * SHIFT_LEFT1 + enableDepthCheck;
v_compressed.z = dw * SHIFT_LEFT12 + dh;
v_compressed.w = iw * SHIFT_LEFT12 + ih;
v_originTextureCoordinateAndTranslate.xy = depthOrigin;
v_originTextureCoordinateAndTranslate.zw = translate;
v_textureCoordinateBounds = textureCoordinateBoundsOrLabelTranslate;
#endif
#ifdef SDF
vec4 outlineColor;
float outlineWidth;
temp = sdf.x;
temp = temp * SHIFT_RIGHT8;
outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
outlineColor.r = floor(temp);
temp = sdf.y;
temp = temp * SHIFT_RIGHT8;
float temp3 = (temp - floor(temp)) * SHIFT_LEFT8;
temp = floor(temp) * SHIFT_RIGHT8;
outlineWidth = (temp - floor(temp)) * SHIFT_LEFT8;
outlineColor.a = floor(temp);
outlineColor /= 255.0;
v_outlineWidth = outlineWidth / 255.0;
v_outlineColor = outlineColor;
v_outlineColor.a *= translucency;
#endif
v_pickColor = pickColor;
v_color = color;
v_color.a *= translucency;
}
`;
var qS = {
    ADD: L.FUNC_ADD,
    SUBTRACT: L.FUNC_SUBTRACT,
    REVERSE_SUBTRACT: L.FUNC_REVERSE_SUBTRACT,
    MIN: L.MIN,
    MAX: L.MAX
};
const no = Object.freeze(qS);
var YS = {
    ZERO: L.ZERO,
    ONE: L.ONE,
    SOURCE_COLOR: L.SRC_COLOR,
    ONE_MINUS_SOURCE_COLOR: L.ONE_MINUS_SRC_COLOR,
    DESTINATION_COLOR: L.DST_COLOR,
    ONE_MINUS_DESTINATION_COLOR: L.ONE_MINUS_DST_COLOR,
    SOURCE_ALPHA: L.SRC_ALPHA,
    ONE_MINUS_SOURCE_ALPHA: L.ONE_MINUS_SRC_ALPHA,
    DESTINATION_ALPHA: L.DST_ALPHA,
    ONE_MINUS_DESTINATION_ALPHA: L.ONE_MINUS_DST_ALPHA,
    CONSTANT_COLOR: L.CONSTANT_COLOR,
    ONE_MINUS_CONSTANT_COLOR: L.ONE_MINUS_CONSTANT_COLOR,
    CONSTANT_ALPHA: L.CONSTANT_ALPHA,
    ONE_MINUS_CONSTANT_ALPHA: L.ONE_MINUS_CONSTANT_ALPHA,
    SOURCE_ALPHA_SATURATE: L.SRC_ALPHA_SATURATE
};
const cr = Object.freeze(YS);
var XS = {
    DISABLED: Object.freeze({
        enabled: !1
    }),
    ALPHA_BLEND: Object.freeze({
        enabled: !0,
        equationRgb: no.ADD,
        equationAlpha: no.ADD,
        functionSourceRgb: cr.SOURCE_ALPHA,
        functionSourceAlpha: cr.ONE,
        functionDestinationRgb: cr.ONE_MINUS_SOURCE_ALPHA,
        functionDestinationAlpha: cr.ONE_MINUS_SOURCE_ALPHA
    }),
    PRE_MULTIPLIED_ALPHA_BLEND: Object.freeze({
        enabled: !0,
        equationRgb: no.ADD,
        equationAlpha: no.ADD,
        functionSourceRgb: cr.ONE,
        functionSourceAlpha: cr.ONE,
        functionDestinationRgb: cr.ONE_MINUS_SOURCE_ALPHA,
        functionDestinationAlpha: cr.ONE_MINUS_SOURCE_ALPHA
    }),
    ADDITIVE_BLEND: Object.freeze({
        enabled: !0,
        equationRgb: no.ADD,
        equationAlpha: no.ADD,
        functionSourceRgb: cr.SOURCE_ALPHA,
        functionSourceAlpha: cr.ONE,
        functionDestinationRgb: cr.ONE,
        functionDestinationAlpha: cr.ONE
    })
};
const fi = Object.freeze(XS);
var jS = {
    OPAQUE: 0,
    TRANSLUCENT: 1,
    OPAQUE_AND_TRANSLUCENT: 2
};
const Mr = Object.freeze(jS);
var ZS = {
    FONT_SIZE: 48,
    PADDING: 10,
    RADIUS: 8,
    CUTOFF: .25
};
const Q0 = Object.freeze(ZS);
var We = {
    UNSIGNED_BYTE: L.UNSIGNED_BYTE,
    UNSIGNED_SHORT: L.UNSIGNED_SHORT,
    UNSIGNED_INT: L.UNSIGNED_INT,
    FLOAT: L.FLOAT,
    HALF_FLOAT: L.HALF_FLOAT_OES,
    UNSIGNED_INT_24_8: L.UNSIGNED_INT_24_8,
    UNSIGNED_SHORT_4_4_4_4: L.UNSIGNED_SHORT_4_4_4_4,
    UNSIGNED_SHORT_5_5_5_1: L.UNSIGNED_SHORT_5_5_5_1,
    UNSIGNED_SHORT_5_6_5: L.UNSIGNED_SHORT_5_6_5
};
We.toWebGLConstant = function(e, t) {
    switch (e) {
        case We.UNSIGNED_BYTE:
            return L.UNSIGNED_BYTE;
        case We.UNSIGNED_SHORT:
            return L.UNSIGNED_SHORT;
        case We.UNSIGNED_INT:
            return L.UNSIGNED_INT;
        case We.FLOAT:
            return L.FLOAT;
        case We.HALF_FLOAT:
            return t.webgl2 ? L.HALF_FLOAT : L.HALF_FLOAT_OES;
        case We.UNSIGNED_INT_24_8:
            return L.UNSIGNED_INT_24_8;
        case We.UNSIGNED_SHORT_4_4_4_4:
            return L.UNSIGNED_SHORT_4_4_4_4;
        case We.UNSIGNED_SHORT_5_5_5_1:
            return L.UNSIGNED_SHORT_5_5_5_1;
        case We.UNSIGNED_SHORT_5_6_5:
            return We.UNSIGNED_SHORT_5_6_5
    }
};
We.isPacked = function(e) {
    return e === We.UNSIGNED_INT_24_8 || e === We.UNSIGNED_SHORT_4_4_4_4 || e === We.UNSIGNED_SHORT_5_5_5_1 || e === We.UNSIGNED_SHORT_5_6_5
};
We.sizeInBytes = function(e) {
    switch (e) {
        case We.UNSIGNED_BYTE:
            return 1;
        case We.UNSIGNED_SHORT:
        case We.UNSIGNED_SHORT_4_4_4_4:
        case We.UNSIGNED_SHORT_5_5_5_1:
        case We.UNSIGNED_SHORT_5_6_5:
        case We.HALF_FLOAT:
            return 2;
        case We.UNSIGNED_INT:
        case We.FLOAT:
        case We.UNSIGNED_INT_24_8:
            return 4
    }
};
We.validate = function(e) {
    return e === We.UNSIGNED_BYTE || e === We.UNSIGNED_SHORT || e === We.UNSIGNED_INT || e === We.FLOAT || e === We.HALF_FLOAT || e === We.UNSIGNED_INT_24_8 || e === We.UNSIGNED_SHORT_4_4_4_4 || e === We.UNSIGNED_SHORT_5_5_5_1 || e === We.UNSIGNED_SHORT_5_6_5
};
const ae = Object.freeze(We);
var te = {
    DEPTH_COMPONENT: L.DEPTH_COMPONENT,
    DEPTH_STENCIL: L.DEPTH_STENCIL,
    ALPHA: L.ALPHA,
    RGB: L.RGB,
    RGBA: L.RGBA,
    LUMINANCE: L.LUMINANCE,
    LUMINANCE_ALPHA: L.LUMINANCE_ALPHA,
    RGB_DXT1: L.COMPRESSED_RGB_S3TC_DXT1_EXT,
    RGBA_DXT1: L.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    RGBA_DXT3: L.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    RGBA_DXT5: L.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    RGB_PVRTC_4BPPV1: L.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
    RGB_PVRTC_2BPPV1: L.COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
    RGBA_PVRTC_4BPPV1: L.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
    RGBA_PVRTC_2BPPV1: L.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
    RGB_ETC1: L.COMPRESSED_RGB_ETC1_WEBGL
};
te.componentsLength = function(e) {
    switch (e) {
        case te.RGB:
            return 3;
        case te.RGBA:
            return 4;
        case te.LUMINANCE_ALPHA:
            return 2;
        case te.ALPHA:
        case te.LUMINANCE:
            return 1;
        default:
            return 1
    }
};
te.validate = function(e) {
    return e === te.DEPTH_COMPONENT || e === te.DEPTH_STENCIL || e === te.ALPHA || e === te.RGB || e === te.RGBA || e === te.LUMINANCE || e === te.LUMINANCE_ALPHA || e === te.RGB_DXT1 || e === te.RGBA_DXT1 || e === te.RGBA_DXT3 || e === te.RGBA_DXT5 || e === te.RGB_PVRTC_4BPPV1 || e === te.RGB_PVRTC_2BPPV1 || e === te.RGBA_PVRTC_4BPPV1 || e === te.RGBA_PVRTC_2BPPV1 || e === te.RGB_ETC1
};
te.isColorFormat = function(e) {
    return e === te.ALPHA || e === te.RGB || e === te.RGBA || e === te.LUMINANCE || e === te.LUMINANCE_ALPHA
};
te.isDepthFormat = function(e) {
    return e === te.DEPTH_COMPONENT || e === te.DEPTH_STENCIL
};
te.isCompressedFormat = function(e) {
    return e === te.RGB_DXT1 || e === te.RGBA_DXT1 || e === te.RGBA_DXT3 || e === te.RGBA_DXT5 || e === te.RGB_PVRTC_4BPPV1 || e === te.RGB_PVRTC_2BPPV1 || e === te.RGBA_PVRTC_4BPPV1 || e === te.RGBA_PVRTC_2BPPV1 || e === te.RGB_ETC1
};
te.isDXTFormat = function(e) {
    return e === te.RGB_DXT1 || e === te.RGBA_DXT1 || e === te.RGBA_DXT3 || e === te.RGBA_DXT5
};
te.isPVRTCFormat = function(e) {
    return e === te.RGB_PVRTC_4BPPV1 || e === te.RGB_PVRTC_2BPPV1 || e === te.RGBA_PVRTC_4BPPV1 || e === te.RGBA_PVRTC_2BPPV1
};
te.isETC1Format = function(e) {
    return e === te.RGB_ETC1
};
te.compressedTextureSizeInBytes = function(e, t, n) {
    switch (e) {
        case te.RGB_DXT1:
        case te.RGBA_DXT1:
        case te.RGB_ETC1:
            return Math.floor((t + 3) / 4) * Math.floor((n + 3) / 4) * 8;
        case te.RGBA_DXT3:
        case te.RGBA_DXT5:
            return Math.floor((t + 3) / 4) * Math.floor((n + 3) / 4) * 16;
        case te.RGB_PVRTC_4BPPV1:
        case te.RGBA_PVRTC_4BPPV1:
            return Math.floor((Math.max(t, 8) * Math.max(n, 8) * 4 + 7) / 8);
        case te.RGB_PVRTC_2BPPV1:
        case te.RGBA_PVRTC_2BPPV1:
            return Math.floor((Math.max(t, 16) * Math.max(n, 8) * 2 + 7) / 8);
        default:
            return 0
    }
};
te.textureSizeInBytes = function(e, t, n, r) {
    var i = te.componentsLength(e);
    return ae.isPacked(t) && (i = 1), i * ae.sizeInBytes(t) * n * r
};
te.alignmentInBytes = function(e, t, n) {
    var r = te.textureSizeInBytes(e, t, n, 1) % 4;
    return r === 0 ? 4 : r === 2 ? 2 : 1
};
te.createTypedArray = function(e, t, n, r) {
    var i, a = ae.sizeInBytes(t);
    a === Uint8Array.BYTES_PER_ELEMENT ? i = Uint8Array : a === Uint16Array.BYTES_PER_ELEMENT ? i = Uint16Array : a === Float32Array.BYTES_PER_ELEMENT && t === ae.FLOAT ? i = Float32Array : i = Uint32Array;
    var o = te.componentsLength(e) * n * r;
    return new i(o)
};
te.flipY = function(e, t, n, r, i) {
    if (i === 1) return e;
    for (var a = te.createTypedArray(t, n, r, i), o = te.componentsLength(t), s = r * o, c = 0; c < i; ++c)
        for (var f = c * r * o, h = (i - c - 1) * r * o, d = 0; d < s; ++d) a[h + d] = e[f + d];
    return a
};
te.toInternalFormat = function(e, t, n) {
    if (!n.webgl2) return e;
    if (e === te.DEPTH_STENCIL) return L.DEPTH24_STENCIL8;
    if (e === te.DEPTH_COMPONENT) {
        if (t === ae.UNSIGNED_SHORT) return L.DEPTH_COMPONENT16;
        if (t === ae.UNSIGNED_INT) return L.DEPTH_COMPONENT24
    }
    if (t === ae.FLOAT) switch (e) {
        case te.RGBA:
            return L.RGBA32F;
        case te.RGB:
            return L.RGB32F;
        case te.RG:
            return L.RG32F;
        case te.R:
            return L.R32F
    }
    if (t === ae.HALF_FLOAT) switch (e) {
        case te.RGBA:
            return L.RGBA16F;
        case te.RGB:
            return L.RGB16F;
        case te.RG:
            return L.RG16F;
        case te.R:
            return L.R16F
    }
    return e
};
const de = Object.freeze(te);

function nh(e, t, n) {
    var r = e._gl;
    r.framebufferTexture2D(r.FRAMEBUFFER, t, n._target, n._texture, 0)
}

function du(e, t, n) {
    var r = e._gl;
    r.framebufferRenderbuffer(r.FRAMEBUFFER, t, r.RENDERBUFFER, n._getRenderbuffer())
}

function xt(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.context,
        n = t._gl;
    pe.maximumColorAttachments, this._gl = n, this._framebuffer = n.createFramebuffer(), this._colorTextures = [], this._colorRenderbuffers = [], this._activeColorAttachments = [], this._depthTexture = void 0, this._depthRenderbuffer = void 0, this._stencilRenderbuffer = void 0, this._depthStencilTexture = void 0, this._depthStencilRenderbuffer = void 0, this.destroyAttachments = p(e.destroyAttachments, !0), l(e.depthTexture) || l(e.depthRenderbuffer), l(e.depthStencilTexture) || l(e.depthStencilRenderbuffer), this._bind();
    var r, i, a, o, s;
    if (l(e.colorTextures)) {
        var c = e.colorTextures;
        for (o = this._colorTextures.length = this._activeColorAttachments.length = c.length, a = 0; a < o; ++a) r = c[a], s = this._gl.COLOR_ATTACHMENT0 + a, nh(this, s, r), this._activeColorAttachments[a] = s, this._colorTextures[a] = r
    }
    if (l(e.colorRenderbuffers)) {
        var f = e.colorRenderbuffers;
        for (o = this._colorRenderbuffers.length = this._activeColorAttachments.length = f.length, a = 0; a < o; ++a) i = f[a], s = this._gl.COLOR_ATTACHMENT0 + a, du(this, s, i), this._activeColorAttachments[a] = s, this._colorRenderbuffers[a] = i
    }
    l(e.depthTexture) && (r = e.depthTexture, nh(this, this._gl.DEPTH_ATTACHMENT, r), this._depthTexture = r), l(e.depthRenderbuffer) && (i = e.depthRenderbuffer, du(this, this._gl.DEPTH_ATTACHMENT, i), this._depthRenderbuffer = i), l(e.stencilRenderbuffer) && (i = e.stencilRenderbuffer, du(this, this._gl.STENCIL_ATTACHMENT, i), this._stencilRenderbuffer = i), l(e.depthStencilTexture) && (r = e.depthStencilTexture, nh(this, this._gl.DEPTH_STENCIL_ATTACHMENT, r), this._depthStencilTexture = r), l(e.depthStencilRenderbuffer) && (i = e.depthStencilRenderbuffer, du(this, this._gl.DEPTH_STENCIL_ATTACHMENT, i), this._depthStencilRenderbuffer = i), this._unBind()
}
Object.defineProperties(xt.prototype, {
    status: {
        get: function() {
            this._bind();
            var e = this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER);
            return this._unBind(), e
        }
    },
    numberOfColorAttachments: {
        get: function() {
            return this._activeColorAttachments.length
        }
    },
    depthTexture: {
        get: function() {
            return this._depthTexture
        }
    },
    depthRenderbuffer: {
        get: function() {
            return this._depthRenderbuffer
        }
    },
    stencilRenderbuffer: {
        get: function() {
            return this._stencilRenderbuffer
        }
    },
    depthStencilTexture: {
        get: function() {
            return this._depthStencilTexture
        }
    },
    depthStencilRenderbuffer: {
        get: function() {
            return this._depthStencilRenderbuffer
        }
    },
    hasDepthAttachment: {
        get: function() {
            return !!(this.depthTexture || this.depthRenderbuffer || this.depthStencilTexture || this.depthStencilRenderbuffer)
        }
    }
});
xt.prototype._bind = function() {
    var e = this._gl;
    e.bindFramebuffer(e.FRAMEBUFFER, this._framebuffer)
};
xt.prototype._unBind = function() {
    var e = this._gl;
    e.bindFramebuffer(e.FRAMEBUFFER, null)
};
xt.prototype._getActiveColorAttachments = function() {
    return this._activeColorAttachments
};
xt.prototype.getColorTexture = function(e) {
    return this._colorTextures[e]
};
xt.prototype.getColorRenderbuffer = function(e) {
    return this._colorRenderbuffers[e]
};
xt.prototype.isDestroyed = function() {
    return !1
};
xt.prototype.destroy = function() {
    if (this.destroyAttachments) {
        for (var e = 0, t = this._colorTextures, n = t.length; e < n; ++e) {
            var r = t[e];
            l(r) && r.destroy()
        }
        var i = this._colorRenderbuffers;
        for (n = i.length, e = 0; e < n; ++e) {
            var a = i[e];
            l(a) && a.destroy()
        }
        this._depthTexture = this._depthTexture && this._depthTexture.destroy(), this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy(), this._stencilRenderbuffer = this._stencilRenderbuffer && this._stencilRenderbuffer.destroy(), this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy(), this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy()
    }
    return this._gl.deleteFramebuffer(this._framebuffer), Pe(this)
};
var ac = {
    DONT_CARE: L.DONT_CARE,
    FASTEST: L.FASTEST,
    NICEST: L.NICEST,
    validate: function(e) {
        return e === ac.DONT_CARE || e === ac.FASTEST || e === ac.NICEST
    }
};
const Kc = Object.freeze(ac);
var oc = {
    NEAREST: L.NEAREST,
    LINEAR: L.LINEAR
};
oc.validate = function(e) {
    return e === oc.NEAREST || e === oc.LINEAR
};
const zr = Object.freeze(oc);
var ki = {
    NEAREST: L.NEAREST,
    LINEAR: L.LINEAR,
    NEAREST_MIPMAP_NEAREST: L.NEAREST_MIPMAP_NEAREST,
    LINEAR_MIPMAP_NEAREST: L.LINEAR_MIPMAP_NEAREST,
    NEAREST_MIPMAP_LINEAR: L.NEAREST_MIPMAP_LINEAR,
    LINEAR_MIPMAP_LINEAR: L.LINEAR_MIPMAP_LINEAR
};
ki.validate = function(e) {
    return e === ki.NEAREST || e === ki.LINEAR || e === ki.NEAREST_MIPMAP_NEAREST || e === ki.LINEAR_MIPMAP_NEAREST || e === ki.NEAREST_MIPMAP_LINEAR || e === ki.LINEAR_MIPMAP_LINEAR
};
const Ot = Object.freeze(ki);
var sc = {
    CLAMP_TO_EDGE: L.CLAMP_TO_EDGE,
    REPEAT: L.REPEAT,
    MIRRORED_REPEAT: L.MIRRORED_REPEAT,
    validate: function(e) {
        return e === sc.CLAMP_TO_EDGE || e === sc.REPEAT || e === sc.MIRRORED_REPEAT
    }
};
const gn = Object.freeze(sc);

function gt(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = p(e.wrapS, gn.CLAMP_TO_EDGE),
        n = p(e.wrapT, gn.CLAMP_TO_EDGE),
        r = p(e.minificationFilter, Ot.LINEAR),
        i = p(e.magnificationFilter, zr.LINEAR),
        a = l(e.maximumAnisotropy) ? e.maximumAnisotropy : 1;
    this._wrapS = t, this._wrapT = n, this._minificationFilter = r, this._magnificationFilter = i, this._maximumAnisotropy = a
}
Object.defineProperties(gt.prototype, {
    wrapS: {
        get: function() {
            return this._wrapS
        }
    },
    wrapT: {
        get: function() {
            return this._wrapT
        }
    },
    minificationFilter: {
        get: function() {
            return this._minificationFilter
        }
    },
    magnificationFilter: {
        get: function() {
            return this._magnificationFilter
        }
    },
    maximumAnisotropy: {
        get: function() {
            return this._maximumAnisotropy
        }
    }
});
gt.equals = function(e, t) {
    return e === t || l(e) && l(t) && e._wrapS === t._wrapS && e._wrapT === t._wrapT && e._minificationFilter === t._minificationFilter && e._magnificationFilter === t._magnificationFilter && e._maximumAnisotropy === t._maximumAnisotropy
};
gt.NEAREST = Object.freeze(new gt({
    wrapS: gn.CLAMP_TO_EDGE,
    wrapT: gn.CLAMP_TO_EDGE,
    minificationFilter: Ot.NEAREST,
    magnificationFilter: zr.NEAREST
}));

function be(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.context,
        n = e.width,
        r = e.height,
        i = e.source;
    l(i) && (l(n) || (n = p(i.videoWidth, i.width)), l(r) || (r = p(i.videoHeight, i.height)));
    var a = p(e.pixelFormat, de.RGBA),
        o = p(e.pixelDatatype, ae.UNSIGNED_BYTE),
        s = de.toInternalFormat(a, o, t),
        c = de.isCompressedFormat(s),
        f = e.preMultiplyAlpha || a === de.RGB || a === de.LUMINANCE,
        h = p(e.flipY, !0),
        d = !0,
        _ = t._gl,
        v = _.TEXTURE_2D,
        m = _.createTexture();
    _.activeTexture(_.TEXTURE0), _.bindTexture(v, m);
    var g = 4;
    if (l(i) && l(i.arrayBufferView) && !c && (g = de.alignmentInBytes(a, o, n)), _.pixelStorei(_.UNPACK_ALIGNMENT, g), l(i))
        if (l(i.arrayBufferView)) {
            _.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), _.pixelStorei(_.UNPACK_FLIP_Y_WEBGL, !1);
            var y = i.arrayBufferView;
            if (c) _.compressedTexImage2D(v, 0, s, n, r, 0, y);
            else if (h && (y = de.flipY(y, a, o, n, r)), _.texImage2D(v, 0, s, n, r, 0, a, ae.toWebGLConstant(o, t), y), l(i.mipLevels))
                for (var E = n, w = r, C = 0; C < i.mipLevels.length; ++C) E = Math.floor(E / 2) | 0, E < 1 && (E = 1), w = Math.floor(w / 2) | 0, w < 1 && (w = 1), _.texImage2D(v, C + 1, s, E, w, 0, a, ae.toWebGLConstant(o, t), i.mipLevels[C])
        } else l(i.framebuffer) ? (_.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), _.pixelStorei(_.UNPACK_FLIP_Y_WEBGL, !1), i.framebuffer !== t.defaultFramebuffer && i.framebuffer._bind(), _.copyTexImage2D(v, 0, s, i.xOffset, i.yOffset, n, r, 0), i.framebuffer !== t.defaultFramebuffer && i.framebuffer._unBind()) : (_.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, f), _.pixelStorei(_.UNPACK_FLIP_Y_WEBGL, h), _.texImage2D(v, 0, s, a, ae.toWebGLConstant(o, t), i));
    else _.texImage2D(v, 0, s, n, r, 0, a, ae.toWebGLConstant(o, t), null), d = !1;
    _.bindTexture(v, null);
    var A;
    c ? A = de.compressedTextureSizeInBytes(a, n, r) : A = de.textureSizeInBytes(a, o, n, r), this._id = Oi(), this._context = t, this._textureFilterAnisotropic = t._textureFilterAnisotropic, this._textureTarget = v, this._texture = m, this._internalFormat = s, this._pixelFormat = a, this._pixelDatatype = o, this._width = n, this._height = r, this._dimensions = new R(n, r), this._hasMipmap = !1, this._sizeInBytes = A, this._preMultiplyAlpha = f, this._flipY = h, this._initialized = d, this._sampler = void 0, this.sampler = l(e.sampler) ? e.sampler : new gt
}
be.create = function(e) {
    return new be(e)
};
be.fromFramebuffer = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.context,
        n = t._gl,
        r = p(e.pixelFormat, de.RGB),
        i = p(e.framebufferXOffset, 0),
        a = p(e.framebufferYOffset, 0),
        o = p(e.width, n.drawingBufferWidth),
        s = p(e.height, n.drawingBufferHeight),
        c = e.framebuffer,
        f = new be({
            context: t,
            width: o,
            height: s,
            pixelFormat: r,
            source: {
                framebuffer: l(c) ? c : t.defaultFramebuffer,
                xOffset: i,
                yOffset: a,
                width: o,
                height: s
            }
        });
    return f
};
Object.defineProperties(be.prototype, {
    id: {
        get: function() {
            return this._id
        }
    },
    sampler: {
        get: function() {
            return this._sampler
        },
        set: function(e) {
            var t = e.minificationFilter,
                n = e.magnificationFilter,
                r = this._context,
                i = this._pixelFormat,
                a = this._pixelDatatype,
                o = t === Ot.NEAREST_MIPMAP_NEAREST || t === Ot.NEAREST_MIPMAP_LINEAR || t === Ot.LINEAR_MIPMAP_NEAREST || t === Ot.LINEAR_MIPMAP_LINEAR;
            (a === ae.FLOAT && !r.textureFloatLinear || a === ae.HALF_FLOAT && !r.textureHalfFloatLinear) && (t = o ? Ot.NEAREST_MIPMAP_NEAREST : Ot.NEAREST, n = zr.NEAREST), r.webgl2 && de.isDepthFormat(i) && (t = Ot.NEAREST, n = zr.NEAREST);
            var s = r._gl,
                c = this._textureTarget;
            s.activeTexture(s.TEXTURE0), s.bindTexture(c, this._texture), s.texParameteri(c, s.TEXTURE_MIN_FILTER, t), s.texParameteri(c, s.TEXTURE_MAG_FILTER, n), s.texParameteri(c, s.TEXTURE_WRAP_S, e.wrapS), s.texParameteri(c, s.TEXTURE_WRAP_T, e.wrapT), l(this._textureFilterAnisotropic) && s.texParameteri(c, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.maximumAnisotropy), s.bindTexture(c, null), this._sampler = e
        }
    },
    pixelFormat: {
        get: function() {
            return this._pixelFormat
        }
    },
    pixelDatatype: {
        get: function() {
            return this._pixelDatatype
        }
    },
    dimensions: {
        get: function() {
            return this._dimensions
        }
    },
    preMultiplyAlpha: {
        get: function() {
            return this._preMultiplyAlpha
        }
    },
    flipY: {
        get: function() {
            return this._flipY
        }
    },
    width: {
        get: function() {
            return this._width
        }
    },
    height: {
        get: function() {
            return this._height
        }
    },
    sizeInBytes: {
        get: function() {
            return this._hasMipmap ? Math.floor(this._sizeInBytes * 4 / 3) : this._sizeInBytes
        }
    },
    _target: {
        get: function() {
            return this._textureTarget
        }
    }
});
be.prototype.copyFrom = function(e, t, n) {
    t = p(t, 0), n = p(n, 0);
    var r = this._context,
        i = r._gl,
        a = this._textureTarget;
    i.activeTexture(i.TEXTURE0), i.bindTexture(a, this._texture);
    var o = e.width,
        s = e.height,
        c = e.arrayBufferView,
        f = this._width,
        h = this._height,
        d = this._internalFormat,
        _ = this._pixelFormat,
        v = this._pixelDatatype,
        m = this._preMultiplyAlpha,
        g = this._flipY,
        y = 4;
    l(c) && (y = de.alignmentInBytes(_, v, o)), i.pixelStorei(i.UNPACK_ALIGNMENT, y);
    var E = !1;
    if (!this._initialized) {
        if (t === 0 && n === 0 && o === f && s === h) l(c) ? (i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, !1), g && (c = de.flipY(c, _, v, f, h)), i.texImage2D(a, 0, d, f, h, 0, _, ae.toWebGLConstant(v, r), c)) : (i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, m), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, g), i.texImage2D(a, 0, d, _, ae.toWebGLConstant(v, r), e)), E = !0;
        else {
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, !1);
            var w = de.createTypedArray(_, v, f, h);
            i.texImage2D(a, 0, d, f, h, 0, _, ae.toWebGLConstant(v, r), w)
        }
        this._initialized = !0
    }
    E || (l(c) ? (i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, !1), g && (c = de.flipY(c, _, v, o, s)), i.texSubImage2D(a, 0, t, n, o, s, _, ae.toWebGLConstant(v, r), c)) : (i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, m), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, g), i.texSubImage2D(a, 0, t, n, _, ae.toWebGLConstant(v, r), e))), i.bindTexture(a, null)
};
be.prototype.copyFromFramebuffer = function(e, t, n, r, i, a) {
    e = p(e, 0), t = p(t, 0), n = p(n, 0), r = p(r, 0), i = p(i, this._width), a = p(a, this._height);
    var o = this._context._gl,
        s = this._textureTarget;
    o.activeTexture(o.TEXTURE0), o.bindTexture(s, this._texture), o.copyTexSubImage2D(s, 0, e, t, n, r, i, a), o.bindTexture(s, null), this._initialized = !0
};
be.prototype.generateMipmap = function(e) {
    e = p(e, Kc.DONT_CARE), this._hasMipmap = !0;
    var t = this._context._gl,
        n = this._textureTarget;
    t.hint(t.GENERATE_MIPMAP_HINT, e), t.activeTexture(t.TEXTURE0), t.bindTexture(n, this._texture), t.generateMipmap(n), t.bindTexture(n, null)
};
be.prototype.isDestroyed = function() {
    return !1
};
be.prototype.destroy = function() {
    return this._context._gl.deleteTexture(this._texture), Pe(this)
};

function xi(e, t, n, r, i) {
    this.bottomLeft = p(e, R.ZERO), this.topRight = p(t, R.ZERO), this.childNode1 = n, this.childNode2 = r, this.imageIndex = i
}
var KS = new R(16, 16);

function Mo(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = p(e.borderWidthInPixels, 1),
        n = p(e.initialSize, KS);
    this._context = e.context, this._pixelFormat = p(e.pixelFormat, de.RGBA), this._borderWidthInPixels = t, this._textureCoordinates = [], this._guid = Oi(), this._idHash = {}, this._initialSize = n, this._root = void 0
}
Object.defineProperties(Mo.prototype, {
    borderWidthInPixels: {
        get: function() {
            return this._borderWidthInPixels
        }
    },
    textureCoordinates: {
        get: function() {
            return this._textureCoordinates
        }
    },
    texture: {
        get: function() {
            return l(this._texture) || (this._texture = new be({
                context: this._context,
                width: this._initialSize.x,
                height: this._initialSize.y,
                pixelFormat: this._pixelFormat
            })), this._texture
        }
    },
    numberOfImages: {
        get: function() {
            return this._textureCoordinates.length
        }
    },
    guid: {
        get: function() {
            return this._guid
        }
    }
});

function $S(e, t) {
    var n = e._context,
        r = e.numberOfImages,
        i = 2,
        a = e._borderWidthInPixels;
    if (r > 0) {
        for (var o = e._texture.width, s = e._texture.height, c = i * (o + t.width + a), f = i * (s + t.height + a), h = o / c, d = s / f, _ = new xi(new R(o + a, a), new R(c, s)), v = new xi(new R, new R(c, s), e._root, _), m = new xi(new R(a, s + a), new R(c, f)), g = new xi(new R, new R(c, f), v, m), y = 0; y < e._textureCoordinates.length; y++) {
            var E = e._textureCoordinates[y];
            l(E) && (E.x *= h, E.y *= d, E.width *= h, E.height *= d)
        }
        var w = new be({
                context: e._context,
                width: c,
                height: f,
                pixelFormat: e._pixelFormat
            }),
            C = new xt({
                context: n,
                colorTextures: [e._texture],
                destroyAttachments: !1
            });
        C._bind(), w.copyFromFramebuffer(0, 0, 0, 0, c, f), C._unBind(), C.destroy(), e._texture = e._texture && e._texture.destroy(), e._texture = w, e._root = g
    } else {
        var A = i * (t.width + 2 * a),
            x = i * (t.height + 2 * a);
        A < e._initialSize.x && (A = e._initialSize.x), x < e._initialSize.y && (x = e._initialSize.y), e._texture = e._texture && e._texture.destroy(), e._texture = new be({
            context: e._context,
            width: A,
            height: x,
            pixelFormat: e._pixelFormat
        }), e._root = new xi(new R(a, a), new R(A, x))
    }
}

function uc(e, t, n) {
    if (!!l(t)) {
        if (!l(t.childNode1) && !l(t.childNode2)) {
            if (l(t.imageIndex)) return;
            var r = t.topRight.x - t.bottomLeft.x,
                i = t.topRight.y - t.bottomLeft.y,
                a = r - n.width,
                o = i - n.height;
            if (a < 0 || o < 0) return;
            if (a === 0 && o === 0) return t;
            if (a > o) {
                t.childNode1 = new xi(new R(t.bottomLeft.x, t.bottomLeft.y), new R(t.bottomLeft.x + n.width, t.topRight.y));
                var s = t.bottomLeft.x + n.width + e._borderWidthInPixels;
                s < t.topRight.x && (t.childNode2 = new xi(new R(s, t.bottomLeft.y), new R(t.topRight.x, t.topRight.y)))
            } else {
                t.childNode1 = new xi(new R(t.bottomLeft.x, t.bottomLeft.y), new R(t.topRight.x, t.bottomLeft.y + n.height));
                var c = t.bottomLeft.y + n.height + e._borderWidthInPixels;
                c < t.topRight.y && (t.childNode2 = new xi(new R(t.bottomLeft.x, c), new R(t.topRight.x, t.topRight.y)))
            }
            return uc(e, t.childNode1, n)
        }
        return uc(e, t.childNode1, n) || uc(e, t.childNode2, n)
    }
}

function eg(e, t, n) {
    var r = uc(e, e._root, t);
    if (l(r)) {
        r.imageIndex = n;
        var i = e._texture.width,
            a = e._texture.height,
            o = r.topRight.x - r.bottomLeft.x,
            s = r.topRight.y - r.bottomLeft.y,
            c = r.bottomLeft.x / i,
            f = r.bottomLeft.y / a,
            h = o / i,
            d = s / a;
        e._textureCoordinates[n] = new ge(c, f, h, d), e._texture.copyFrom(t, r.bottomLeft.x, r.bottomLeft.y)
    } else $S(e, t), eg(e, t, n);
    e._guid = Oi()
}
Mo.prototype.addImage = function(e, t) {
    var n = this._idHash[e];
    if (l(n)) return n;
    if (typeof t == "function") t = t(e);
    else if (typeof t == "string" || t instanceof J) {
        var r = J.createIfNeeded(t);
        t = r.fetchImage()
    }
    var i = this;
    return n = he(t, function(a) {
        if (i.isDestroyed()) return -1;
        var o = i.numberOfImages;
        return eg(i, a, o), o
    }), this._idHash[e] = n, n
};
Mo.prototype.addSubRegion = function(e, t) {
    var n = this._idHash[e];
    if (!l(n)) throw new je('image with id "' + e + '" not found in the atlas.');
    var r = this;
    return he(n, function(i) {
        if (i === -1) return -1;
        var a = r._texture.width,
            o = r._texture.height,
            s = r.numberOfImages,
            c = r._textureCoordinates[i],
            f = c.x + t.x / a,
            h = c.y + t.y / o,
            d = t.width / a,
            _ = t.height / o;
        return r._textureCoordinates.push(new ge(f, h, d, _)), r._guid = Oi(), s
    })
};
Mo.prototype.isDestroyed = function() {
    return !1
};
Mo.prototype.destroy = function() {
    return this._texture = this._texture && this._texture.destroy(), Pe(this)
};
var JS = ye.SHOW_INDEX,
    gs = ye.POSITION_INDEX,
    tg = ye.PIXEL_OFFSET_INDEX,
    ng = ye.EYE_OFFSET_INDEX,
    QS = ye.HORIZONTAL_ORIGIN_INDEX,
    eR = ye.VERTICAL_ORIGIN_INDEX,
    tR = ye.SCALE_INDEX,
    es = ye.IMAGE_INDEX_INDEX,
    rg = ye.COLOR_INDEX,
    nR = ye.ROTATION_INDEX,
    rR = ye.ALIGNED_AXIS_INDEX,
    ig = ye.SCALE_BY_DISTANCE_INDEX,
    ag = ye.TRANSLUCENCY_BY_DISTANCE_INDEX,
    og = ye.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX,
    sg = ye.DISTANCE_DISPLAY_CONDITION,
    iR = ye.DISABLE_DEPTH_DISTANCE,
    aR = ye.TEXTURE_COORDINATE_BOUNDS,
    ug = ye.SDF_INDEX,
    Ad = ye.NUMBER_OF_PROPERTIES,
    ct, oR = {
        positionHighAndScale: 0,
        positionLowAndRotation: 1,
        compressedAttribute0: 2,
        compressedAttribute1: 3,
        compressedAttribute2: 4,
        eyeOffset: 5,
        scaleByDistance: 6,
        pixelOffsetScaleByDistance: 7,
        compressedAttribute3: 8,
        textureCoordinateBoundsOrLabelTranslate: 9,
        a_batchId: 10,
        sdf: 11
    },
    sR = {
        direction: 0,
        positionHighAndScale: 1,
        positionLowAndRotation: 2,
        compressedAttribute0: 3,
        compressedAttribute1: 4,
        compressedAttribute2: 5,
        eyeOffset: 6,
        scaleByDistance: 7,
        pixelOffsetScaleByDistance: 8,
        compressedAttribute3: 9,
        textureCoordinateBoundsOrLabelTranslate: 10,
        a_batchId: 11,
        sdf: 12
    };

function Gr(e) {
    e = p(e, p.EMPTY_OBJECT), this._scene = e.scene, this._batchTable = e.batchTable, this._textureAtlas = void 0, this._textureAtlasGUID = void 0, this._destroyTextureAtlas = !0, this._sp = void 0, this._spTranslucent = void 0, this._rsOpaque = void 0, this._rsTranslucent = void 0, this._vaf = void 0, this._billboards = [], this._billboardsToUpdate = [], this._billboardsToUpdateIndex = 0, this._billboardsRemoved = !1, this._createVertexArray = !1, this._shaderRotation = !1, this._compiledShaderRotation = !1, this._shaderAlignedAxis = !1, this._compiledShaderAlignedAxis = !1, this._shaderScaleByDistance = !1, this._compiledShaderScaleByDistance = !1, this._shaderTranslucencyByDistance = !1, this._compiledShaderTranslucencyByDistance = !1, this._shaderPixelOffsetScaleByDistance = !1, this._compiledShaderPixelOffsetScaleByDistance = !1, this._shaderDistanceDisplayCondition = !1, this._compiledShaderDistanceDisplayCondition = !1, this._shaderDisableDepthDistance = !1, this._compiledShaderDisableDepthDistance = !1, this._shaderClampToGround = !1, this._compiledShaderClampToGround = !1, this._propertiesChanged = new Uint32Array(Ad), this._maxSize = 0, this._maxEyeOffset = 0, this._maxScale = 1, this._maxPixelOffset = 0, this._allHorizontalCenter = !0, this._allVerticalCenter = !0, this._allSizedInMeters = !0, this._baseVolume = new q, this._baseVolumeWC = new q, this._baseVolume2D = new q, this._boundingVolume = new q, this._boundingVolumeDirty = !1, this._colorCommands = [], this.modelMatrix = S.clone(p(e.modelMatrix, S.IDENTITY)), this._modelMatrix = S.clone(S.IDENTITY), this.debugShowBoundingVolume = p(e.debugShowBoundingVolume, !1), this.debugShowTextureAtlas = p(e.debugShowTextureAtlas, !1), this.blendOption = p(e.blendOption, Mr.OPAQUE_AND_TRANSLUCENT), this._blendOption = void 0, this._mode = k.SCENE3D, this._buffersUsage = [Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW, Ye.STATIC_DRAW], this._highlightColor = H.clone(H.WHITE);
    var t = this;
    this._uniforms = {
        u_atlas: function() {
            return t._textureAtlas.texture
        },
        u_highlightColor: function() {
            return t._highlightColor
        }
    };
    var n = this._scene;
    l(n) && l(n.terrainProviderChanged) && (this._removeCallbackFunc = n.terrainProviderChanged.addEventListener(function() {
        for (var r = this._billboards, i = r.length, a = 0; a < i; ++a) l(r[a]) && r[a]._updateClamping()
    }, this))
}
Object.defineProperties(Gr.prototype, {
    length: {
        get: function() {
            return Cd(this), this._billboards.length
        }
    },
    textureAtlas: {
        get: function() {
            return this._textureAtlas
        },
        set: function(e) {
            this._textureAtlas !== e && (this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy(), this._textureAtlas = e, this._createVertexArray = !0)
        }
    },
    destroyTextureAtlas: {
        get: function() {
            return this._destroyTextureAtlas
        },
        set: function(e) {
            this._destroyTextureAtlas = e
        }
    }
});

function cg(e) {
    for (var t = e.length, n = 0; n < t; ++n) e[n] && e[n]._destroy()
}
Gr.prototype.add = function(e) {
    var t = new ye(e, this);
    return t._index = this._billboards.length, this._billboards.push(t), this._createVertexArray = !0, t
};
Gr.prototype.remove = function(e) {
    return this.contains(e) ? (this._billboards[e._index] = null, this._billboardsRemoved = !0, this._createVertexArray = !0, e._destroy(), !0) : !1
};
Gr.prototype.removeAll = function() {
    cg(this._billboards), this._billboards = [], this._billboardsToUpdate = [], this._billboardsToUpdateIndex = 0, this._billboardsRemoved = !1, this._createVertexArray = !0
};

function Cd(e) {
    if (e._billboardsRemoved) {
        e._billboardsRemoved = !1;
        for (var t = [], n = e._billboards, r = n.length, i = 0, a = 0; i < r; ++i) {
            var o = n[i];
            o && (o._index = a++, t.push(o))
        }
        e._billboards = t
    }
}
Gr.prototype._updateBillboard = function(e, t) {
    e._dirty || (this._billboardsToUpdate[this._billboardsToUpdateIndex++] = e), ++this._propertiesChanged[t]
};
Gr.prototype.contains = function(e) {
    return l(e) && e._billboardCollection === this
};
Gr.prototype.get = function(e) {
    return Cd(this), this._billboards[e]
};
var rh;

function uR(e) {
    var t = 16384,
        n = e.cache.billboardCollection_indexBufferBatched;
    if (l(n)) return n;
    for (var r = t * 6 - 6, i = new Uint16Array(r), a = 0, o = 0; a < r; a += 6, o += 4) i[a] = o, i[a + 1] = o + 1, i[a + 2] = o + 2, i[a + 3] = o + 0, i[a + 4] = o + 2, i[a + 5] = o + 3;
    return n = _t.createIndexBuffer({
        context: e,
        typedArray: i,
        usage: Ye.STATIC_DRAW,
        indexDatatype: yt.UNSIGNED_SHORT
    }), n.vertexArrayDestroyable = !1, e.cache.billboardCollection_indexBufferBatched = n, n
}

function cR(e) {
    var t = e.cache.billboardCollection_indexBufferInstanced;
    return l(t) || (t = _t.createIndexBuffer({
        context: e,
        typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),
        usage: Ye.STATIC_DRAW,
        indexDatatype: yt.UNSIGNED_SHORT
    }), t.vertexArrayDestroyable = !1, e.cache.billboardCollection_indexBufferInstanced = t), t
}

function fR(e) {
    var t = e.cache.billboardCollection_vertexBufferInstanced;
    return l(t) || (t = _t.createVertexBuffer({
        context: e,
        typedArray: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        usage: Ye.STATIC_DRAW
    }), t.vertexArrayDestroyable = !1, e.cache.billboardCollection_vertexBufferInstanced = t), t
}
Gr.prototype.computeNewBuffersUsage = function() {
    for (var e = this._buffersUsage, t = !1, n = this._propertiesChanged, r = 0; r < Ad; ++r) {
        var i = n[r] === 0 ? Ye.STATIC_DRAW : Ye.STREAM_DRAW;
        t = t || e[r] !== i, e[r] = i
    }
    return t
};

function hR(e, t, n, r, i, a) {
    var o = [{
        index: ct.positionHighAndScale,
        componentsPerAttribute: 4,
        componentDatatype: ee.FLOAT,
        usage: n[gs]
    }, {
        index: ct.positionLowAndRotation,
        componentsPerAttribute: 4,
        componentDatatype: ee.FLOAT,
        usage: n[gs]
    }, {
        index: ct.compressedAttribute0,
        componentsPerAttribute: 4,
        componentDatatype: ee.FLOAT,
        usage: n[tg]
    }, {
        index: ct.compressedAttribute1,
        componentsPerAttribute: 4,
        componentDatatype: ee.FLOAT,
        usage: n[ag]
    }, {
        index: ct.compressedAttribute2,
        componentsPerAttribute: 4,
        componentDatatype: ee.FLOAT,
        usage: n[rg]
    }, {
        index: ct.eyeOffset,
        componentsPerAttribute: 4,
        componentDatatype: ee.FLOAT,
        usage: n[ng]
    }, {
        index: ct.scaleByDistance,
        componentsPerAttribute: 4,
        componentDatatype: ee.FLOAT,
        usage: n[ig]
    }, {
        index: ct.pixelOffsetScaleByDistance,
        componentsPerAttribute: 4,
        componentDatatype: ee.FLOAT,
        usage: n[og]
    }, {
        index: ct.compressedAttribute3,
        componentsPerAttribute: 4,
        componentDatatype: ee.FLOAT,
        usage: n[sg]
    }, {
        index: ct.textureCoordinateBoundsOrLabelTranslate,
        componentsPerAttribute: 4,
        componentDatatype: ee.FLOAT,
        usage: n[aR]
    }];
    r && o.push({
        index: ct.direction,
        componentsPerAttribute: 2,
        componentDatatype: ee.FLOAT,
        vertexBuffer: fR(e)
    }), l(i) && o.push({
        index: ct.a_batchId,
        componentsPerAttribute: 1,
        componentDatatype: ee.FLOAT,
        bufferUsage: Ye.STATIC_DRAW
    }), a && o.push({
        index: ct.sdf,
        componentsPerAttribute: 2,
        componentDatatype: ee.FLOAT,
        usage: n[ug]
    });
    var s = r ? t : 4 * t;
    return new Yt(e, o, s, r)
}
var ih = new rn;

function fg(e, t, n, r, i) {
    var a, o = r[ct.positionHighAndScale],
        s = r[ct.positionLowAndRotation],
        c = i._getActualPosition();
    e._mode === k.SCENE3D && (q.expand(e._baseVolume, c, e._baseVolume), e._boundingVolumeDirty = !0), rn.fromCartesian(c, ih);
    var f = i.scale,
        h = i.rotation;
    h !== 0 && (e._shaderRotation = !0), e._maxScale = Math.max(e._maxScale, f);
    var d = ih.high,
        _ = ih.low;
    e._instanced ? (a = i._index, o(a, d.x, d.y, d.z, f), s(a, _.x, _.y, _.z, h)) : (a = i._index * 4, o(a + 0, d.x, d.y, d.z, f), o(a + 1, d.x, d.y, d.z, f), o(a + 2, d.x, d.y, d.z, f), o(a + 3, d.x, d.y, d.z, f), s(a + 0, _.x, _.y, _.z, h), s(a + 1, _.x, _.y, _.z, h), s(a + 2, _.x, _.y, _.z, h), s(a + 3, _.x, _.y, _.z, h))
}
var vr = new R,
    fr = 32768,
    vo = 65536,
    ah = 4096,
    ni = 256,
    lR = 128,
    dR = 32,
    _R = 8,
    hg = 4,
    vR = 1 / 256,
    lg = 0,
    dg = 2,
    _g = 3,
    vg = 1;

function mg(e, t, n, r, i) {
    var a, o = r[ct.compressedAttribute0],
        s = i.pixelOffset,
        c = s.x,
        f = s.y,
        h = i._translate,
        d = h.x,
        _ = h.y;
    e._maxPixelOffset = Math.max(e._maxPixelOffset, Math.abs(c + d), Math.abs(-f + _));
    var v = i.horizontalOrigin,
        m = i._verticalOrigin,
        g = i.show && i.clusterShow;
    i.color.alpha === 0 && (g = !1), m === Da.BASELINE && (m = Da.BOTTOM), e._allHorizontalCenter = e._allHorizontalCenter && v === Oc.CENTER, e._allVerticalCenter = e._allVerticalCenter && m === Da.CENTER;
    var y = 0,
        E = 0,
        w = 0,
        C = 0,
        A = i._imageIndex;
    if (A !== -1) {
        var x = n[A];
        y = x.x, E = x.y, w = x.width, C = x.height
    }
    var P = y + w,
        I = E + C,
        D = Math.floor(T.clamp(c, -fr, fr) + fr) * lR;
    D += (v + 1) * dR, D += (m + 1) * _R, D += (g ? 1 : 0) * hg;
    var O = Math.floor(T.clamp(f, -fr, fr) + fr) * ni,
        F = Math.floor(T.clamp(d, -fr, fr) + fr) * ni,
        z = (T.clamp(_, -fr, fr) + fr) * vR,
        b = Math.floor(z),
        M = Math.floor((z - b) * ni);
    O += b, F += M, vr.x = y, vr.y = E;
    var G = Ee.compressTextureCoordinates(vr);
    vr.x = P;
    var V = Ee.compressTextureCoordinates(vr);
    vr.y = I;
    var B = Ee.compressTextureCoordinates(vr);
    vr.x = y;
    var Y = Ee.compressTextureCoordinates(vr);
    e._instanced ? (a = i._index, o(a, D, O, F, G)) : (a = i._index * 4, o(a + 0, D + lg, O, F, G), o(a + 1, D + dg, O, F, V), o(a + 2, D + _g, O, F, B), o(a + 3, D + vg, O, F, Y))
}

function pg(e, t, n, r, i) {
    var a, o = r[ct.compressedAttribute1],
        s = i.alignedAxis;
    u.equals(s, u.ZERO) || (e._shaderAlignedAxis = !0);
    var c = 0,
        f = 1,
        h = 1,
        d = 1,
        _ = i.translucencyByDistance;
    l(_) && (c = _.near, f = _.nearValue, h = _.far, d = _.farValue, (f !== 1 || d !== 1) && (e._shaderTranslucencyByDistance = !0));
    var v = 0,
        m = i._imageIndex;
    if (m !== -1) {
        var g = n[m];
        v = g.width
    }
    var y = e._textureAtlas.texture.width,
        E = Math.round(p(i.width, y * v));
    e._maxSize = Math.max(e._maxSize, E);
    var w = T.clamp(E, 0, vo),
        C = 0;
    Math.abs(u.magnitudeSquared(s) - 1) < T.EPSILON6 && (C = Ee.octEncodeFloat(s)), f = T.clamp(f, 0, 1), f = f === 1 ? 255 : f * 255 | 0, w = w * ni + f, d = T.clamp(d, 0, 1), d = d === 1 ? 255 : d * 255 | 0, C = C * ni + d, e._instanced ? (a = i._index, o(a, w, C, c, h)) : (a = i._index * 4, o(a + 0, w, C, c, h), o(a + 1, w, C, c, h), o(a + 2, w, C, c, h), o(a + 3, w, C, c, h))
}

function dl(e, t, n, r, i) {
    var a, o = r[ct.compressedAttribute2],
        s = i.color,
        c = l(e._batchTable) ? H.WHITE : i.getPickId(t.context).color,
        f = i.sizeInMeters ? 1 : 0,
        h = Math.abs(u.magnitudeSquared(i.alignedAxis) - 1) < T.EPSILON6 ? 1 : 0;
    e._allSizedInMeters = e._allSizedInMeters && f === 1;
    var d = 0,
        _ = i._imageIndex;
    if (_ !== -1) {
        var v = n[_];
        d = v.height
    }
    var m = e._textureAtlas.texture.dimensions,
        g = Math.round(p(i.height, m.y * d));
    e._maxSize = Math.max(e._maxSize, g);
    var y = p(i._labelHorizontalOrigin, -2);
    y += 2;
    var E = g * hg + y,
        w = H.floatToByte(s.red),
        C = H.floatToByte(s.green),
        A = H.floatToByte(s.blue),
        x = w * vo + C * ni + A;
    w = H.floatToByte(c.red), C = H.floatToByte(c.green), A = H.floatToByte(c.blue);
    var P = w * vo + C * ni + A,
        I = H.floatToByte(s.alpha) * vo + H.floatToByte(c.alpha) * ni;
    I += f * 2 + h, e._instanced ? (a = i._index, o(a, x, P, I, E)) : (a = i._index * 4, o(a + 0, x, P, I, E), o(a + 1, x, P, I, E), o(a + 2, x, P, I, E), o(a + 3, x, P, I, E))
}

function _l(e, t, n, r, i) {
    var a, o = r[ct.eyeOffset],
        s = i.eyeOffset,
        c = s.z;
    if (i._heightReference !== Ra.NONE && (c *= 1.005), e._maxEyeOffset = Math.max(e._maxEyeOffset, Math.abs(s.x), Math.abs(s.y), Math.abs(c)), e._instanced) {
        var f = 0,
            h = 0,
            d = i._imageIndex;
        if (d !== -1) {
            var _ = n[d];
            f = _.width, h = _.height
        }
        vr.x = f, vr.y = h;
        var v = Ee.compressTextureCoordinates(vr);
        a = i._index, o(a, s.x, s.y, c, v)
    } else a = i._index * 4, o(a + 0, s.x, s.y, c, 0), o(a + 1, s.x, s.y, c, 0), o(a + 2, s.x, s.y, c, 0), o(a + 3, s.x, s.y, c, 0)
}

function gg(e, t, n, r, i) {
    var a, o = r[ct.scaleByDistance],
        s = 0,
        c = 1,
        f = 1,
        h = 1,
        d = i.scaleByDistance;
    l(d) && (s = d.near, c = d.nearValue, f = d.far, h = d.farValue, (c !== 1 || h !== 1) && (e._shaderScaleByDistance = !0)), e._instanced ? (a = i._index, o(a, s, c, f, h)) : (a = i._index * 4, o(a + 0, s, c, f, h), o(a + 1, s, c, f, h), o(a + 2, s, c, f, h), o(a + 3, s, c, f, h))
}

function yg(e, t, n, r, i) {
    var a, o = r[ct.pixelOffsetScaleByDistance],
        s = 0,
        c = 1,
        f = 1,
        h = 1,
        d = i.pixelOffsetScaleByDistance;
    l(d) && (s = d.near, c = d.nearValue, f = d.far, h = d.farValue, (c !== 1 || h !== 1) && (e._shaderPixelOffsetScaleByDistance = !0)), e._instanced ? (a = i._index, o(a, s, c, f, h)) : (a = i._index * 4, o(a + 0, s, c, f, h), o(a + 1, s, c, f, h), o(a + 2, s, c, f, h), o(a + 3, s, c, f, h))
}

function Tg(e, t, n, r, i) {
    var a, o = r[ct.compressedAttribute3],
        s = 0,
        c = Number.MAX_VALUE,
        f = i.distanceDisplayCondition;
    l(f) && (s = f.near, c = f.far, s *= s, c *= c, e._shaderDistanceDisplayCondition = !0);
    var h = i.disableDepthTestDistance,
        d = i.heightReference === Ra.CLAMP_TO_GROUND && t.context.depthTexture;
    l(h) || (h = d ? 5e3 : 0), h *= h, (d || h > 0) && (e._shaderDisableDepthDistance = !0, h === Number.POSITIVE_INFINITY && (h = -1));
    var _, v;
    if (l(i._labelDimensions)) v = i._labelDimensions.x, _ = i._labelDimensions.y;
    else {
        var m = 0,
            g = 0,
            y = i._imageIndex;
        if (y !== -1) {
            var E = n[y];
            m = E.height, g = E.width
        }
        _ = Math.round(p(i.height, e._textureAtlas.texture.dimensions.y * m));
        var w = e._textureAtlas.texture.width;
        v = Math.round(p(i.width, w * g))
    }
    var C = Math.floor(T.clamp(v, 0, ah)),
        A = Math.floor(T.clamp(_, 0, ah)),
        x = C * ah + A;
    e._instanced ? (a = i._index, o(a, s, c, h, x)) : (a = i._index * 4, o(a + 0, s, c, h, x), o(a + 1, s, c, h, x), o(a + 2, s, c, h, x), o(a + 3, s, c, h, x))
}

function Eg(e, t, n, r, i) {
    if (i.heightReference === Ra.CLAMP_TO_GROUND) {
        var a = e._scene,
            o = t.context,
            s = t.globeTranslucencyState.translucent,
            c = l(a.globe) && a.globe.depthTestAgainstTerrain;
        e._shaderClampToGround = o.depthTexture && !s && c
    }
    var f, h = r[ct.textureCoordinateBoundsOrLabelTranslate];
    if (pe.maximumVertexTextureImageUnits > 0) {
        var d = 0,
            _ = 0;
        l(i._labelTranslate) && (d = i._labelTranslate.x, _ = i._labelTranslate.y), e._instanced ? (f = i._index, h(f, d, _, 0, 0)) : (f = i._index * 4, h(f + 0, d, _, 0, 0), h(f + 1, d, _, 0, 0), h(f + 2, d, _, 0, 0), h(f + 3, d, _, 0, 0));
        return
    }
    var v = 0,
        m = 0,
        g = 0,
        y = 0,
        E = i._imageIndex;
    if (E !== -1) {
        var w = n[E];
        v = w.x, m = w.y, g = w.width, y = w.height
    }
    var C = v + g,
        A = m + y;
    e._instanced ? (f = i._index, h(f, v, m, C, A)) : (f = i._index * 4, h(f + 0, v, m, C, A), h(f + 1, v, m, C, A), h(f + 2, v, m, C, A), h(f + 3, v, m, C, A))
}

function mR(e, t, n, r, i) {
    if (!!l(e._batchTable)) {
        var a = r[ct.a_batchId],
            o = i._batchIndex,
            s;
        e._instanced ? (s = i._index, a(s, o)) : (s = i._index * 4, a(s + 0, o), a(s + 1, o), a(s + 2, o), a(s + 3, o))
    }
}

function Ag(e, t, n, r, i) {
    if (!!e._sdf) {
        var a, o = r[ct.sdf],
            s = i.outlineColor,
            c = i.outlineWidth,
            f = H.floatToByte(s.red),
            h = H.floatToByte(s.green),
            d = H.floatToByte(s.blue),
            _ = f * vo + h * ni + d,
            v = c / Q0.RADIUS,
            m = H.floatToByte(s.alpha) * vo + H.floatToByte(v) * ni;
        e._instanced ? (a = i._index, o(a, _, m)) : (a = i._index * 4, o(a + 0, _ + lg, m), o(a + 1, _ + dg, m), o(a + 2, _ + _g, m), o(a + 3, _ + vg, m))
    }
}

function pR(e, t, n, r, i) {
    fg(e, t, n, r, i), mg(e, t, n, r, i), pg(e, t, n, r, i), dl(e, t, n, r, i), _l(e, t, n, r, i), gg(e, t, n, r, i), yg(e, t, n, r, i), Tg(e, t, n, r, i), Eg(e, t, n, r, i), mR(e, t, n, r, i), Ag(e, t, n, r, i)
}

function oh(e, t, n, r, i, a) {
    var o;
    r.mode === k.SCENE3D ? (o = e._baseVolume, e._boundingVolumeDirty = !0) : o = e._baseVolume2D;
    for (var s = [], c = 0; c < n; ++c) {
        var f = t[c],
            h = f.position,
            d = ye._computeActualPosition(f, h, r, i);
        l(d) && (f._setActualPosition(d), a ? s.push(d) : q.expand(o, d, o))
    }
    a && q.fromPoints(s, o)
}

function gR(e, t) {
    var n = t.mode,
        r = e._billboards,
        i = e._billboardsToUpdate,
        a = e._modelMatrix;
    e._createVertexArray || e._mode !== n || n !== k.SCENE3D && !S.equals(a, e.modelMatrix) ? (e._mode = n, S.clone(e.modelMatrix, a), e._createVertexArray = !0, (n === k.SCENE3D || n === k.SCENE2D || n === k.COLUMBUS_VIEW) && oh(e, r, r.length, t, a, !0)) : n === k.MORPHING ? oh(e, r, r.length, t, a, !0) : (n === k.SCENE2D || n === k.COLUMBUS_VIEW) && oh(e, i, e._billboardsToUpdateIndex, t, a, !1)
}

function yR(e, t, n) {
    var r = 1;
    (!e._allSizedInMeters || e._maxPixelOffset !== 0) && (r = t.camera.getPixelSize(n, t.context.drawingBufferWidth, t.context.drawingBufferHeight));
    var i = r * e._maxScale * e._maxSize * 2;
    e._allHorizontalCenter && e._allVerticalCenter && (i *= .5);
    var a = r * e._maxPixelOffset + e._maxEyeOffset;
    n.radius += i + a
}

function TR(e, t) {
    var n;
    n = `uniform sampler2D billboard_texture; 
varying vec2 v_textureCoordinates; 
void main() 
{ 
    gl_FragColor = texture2D(billboard_texture, v_textureCoordinates); 
} 
`;
    var r = t.createViewportQuadCommand(n, {
        uniformMap: {
            billboard_texture: function() {
                return e._textureAtlas.texture
            }
        }
    });
    return r.pass = ue.OVERLAY, r
}
var ER = [];
Gr.prototype.update = function(e) {
    Cd(this);
    var t = this._billboards,
        n = t.length,
        r = e.context;
    this._instanced = r.instancedArrays, ct = this._instanced ? sR : oR, rh = this._instanced ? cR : uR;
    var i = this._textureAtlas;
    if (!l(i)) {
        i = this._textureAtlas = new Mo({
            context: r
        });
        for (var a = 0; a < n; ++a) t[a]._loadImage()
    }
    var o = i.textureCoordinates;
    if (o.length !== 0) {
        gR(this, e), t = this._billboards, n = t.length;
        var s = this._billboardsToUpdate,
            c = this._billboardsToUpdateIndex,
            f = this._propertiesChanged,
            h = i.guid,
            d = this._createVertexArray || this._textureAtlasGUID !== h;
        this._textureAtlasGUID = h;
        var _, v = e.passes,
            m = v.pick;
        if (d || !m && this.computeNewBuffersUsage()) {
            this._createVertexArray = !1;
            for (var g = 0; g < Ad; ++g) f[g] = 0;
            if (this._vaf = this._vaf && this._vaf.destroy(), n > 0) {
                this._vaf = hR(r, n, this._buffersUsage, this._instanced, this._batchTable, this._sdf), _ = this._vaf.writers;
                for (var y = 0; y < n; ++y) {
                    var E = this._billboards[y];
                    E._dirty = !1, pR(this, e, o, _, E)
                }
                this._vaf.commit(rh(r))
            }
            this._billboardsToUpdateIndex = 0
        } else if (c > 0) {
            var w = ER;
            w.length = 0, (f[gs] || f[nR] || f[tR]) && w.push(fg), (f[es] || f[tg] || f[QS] || f[eR] || f[JS]) && (w.push(mg), this._instanced && w.push(_l)), (f[es] || f[rR] || f[ag]) && (w.push(pg), w.push(dl)), (f[es] || f[rg]) && w.push(dl), f[ng] && w.push(_l), f[ig] && w.push(gg), f[og] && w.push(yg), (f[sg] || f[iR] || f[es] || f[gs]) && w.push(Tg), (f[es] || f[gs]) && w.push(Eg), f[ug] && w.push(Ag);
            var C = w.length;
            if (_ = this._vaf.writers, c / n > .1) {
                for (var A = 0; A < c; ++A) {
                    var x = s[A];
                    x._dirty = !1;
                    for (var P = 0; P < C; ++P) w[P](this, e, o, _, x)
                }
                this._vaf.commit(rh(r))
            } else {
                for (var I = 0; I < c; ++I) {
                    var D = s[I];
                    D._dirty = !1;
                    for (var O = 0; O < C; ++O) w[O](this, e, o, _, D);
                    this._instanced ? this._vaf.subCommit(D._index, 1) : this._vaf.subCommit(D._index * 4, 4)
                }
                this._vaf.endSubCommits()
            }
            this._billboardsToUpdateIndex = 0
        }
        if (c > n * 1.5 && (s.length = n), !(!l(this._vaf) || !l(this._vaf.va))) {
            this._boundingVolumeDirty && (this._boundingVolumeDirty = !1, q.transform(this._baseVolume, this.modelMatrix, this._baseVolumeWC));
            var F, z = S.IDENTITY;
            e.mode === k.SCENE3D ? (z = this.modelMatrix, F = q.clone(this._baseVolumeWC, this._boundingVolume)) : F = q.clone(this._baseVolume2D, this._boundingVolume), yR(this, e, F);
            var b = this._blendOption !== this.blendOption;
            if (this._blendOption = this.blendOption, b) {
                this._blendOption === Mr.OPAQUE || this._blendOption === Mr.OPAQUE_AND_TRANSLUCENT ? this._rsOpaque = Ge.fromCache({
                    depthTest: {
                        enabled: !0,
                        func: L.LESS
                    },
                    depthMask: !0
                }) : this._rsOpaque = void 0;
                var M = this._blendOption === Mr.TRANSLUCENT;
                this._blendOption === Mr.TRANSLUCENT || this._blendOption === Mr.OPAQUE_AND_TRANSLUCENT ? this._rsTranslucent = Ge.fromCache({
                    depthTest: {
                        enabled: !0,
                        func: M ? L.LEQUAL : L.LESS
                    },
                    depthMask: M,
                    blending: fi.ALPHA_BLEND
                }) : this._rsTranslucent = void 0
            }
            this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || e.minimumDisableDepthTestDistance !== 0;
            var G, V, B, Y, j, Z = pe.maximumVertexTextureImageUnits > 0;
            if (b || this._shaderRotation !== this._compiledShaderRotation || this._shaderAlignedAxis !== this._compiledShaderAlignedAxis || this._shaderScaleByDistance !== this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance !== this._compiledShaderTranslucencyByDistance || this._shaderPixelOffsetScaleByDistance !== this._compiledShaderPixelOffsetScaleByDistance || this._shaderDistanceDisplayCondition !== this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance || this._shaderClampToGround !== this._compiledShaderClampToGround || this._sdf !== this._compiledSDF) {
                G = WS, V = kS, j = [], l(this._batchTable) && (j.push("VECTOR_TILE"), G = this._batchTable.getVertexShaderCallback(!1, "a_batchId", void 0)(G), V = this._batchTable.getFragmentShaderCallback(!1, void 0)(V)), B = new Re({
                    defines: j,
                    sources: [G]
                }), this._instanced && B.defines.push("INSTANCED"), this._shaderRotation && B.defines.push("ROTATION"), this._shaderAlignedAxis && B.defines.push("ALIGNED_AXIS"), this._shaderScaleByDistance && B.defines.push("EYE_DISTANCE_SCALING"), this._shaderTranslucencyByDistance && B.defines.push("EYE_DISTANCE_TRANSLUCENCY"), this._shaderPixelOffsetScaleByDistance && B.defines.push("EYE_DISTANCE_PIXEL_OFFSET"), this._shaderDistanceDisplayCondition && B.defines.push("DISTANCE_DISPLAY_CONDITION"), this._shaderDisableDepthDistance && B.defines.push("DISABLE_DEPTH_DISTANCE"), this._shaderClampToGround && (Z ? B.defines.push("VERTEX_DEPTH_CHECK") : B.defines.push("FRAGMENT_DEPTH_CHECK"));
                var Q = 1 - Q0.CUTOFF;
                this._sdf && B.defines.push("SDF");
                var ie = l(this._batchTable) ? "VECTOR_TILE" : "";
                this._blendOption === Mr.OPAQUE_AND_TRANSLUCENT && (Y = new Re({
                    defines: ["OPAQUE", ie],
                    sources: [V]
                }), this._shaderClampToGround && (Z ? Y.defines.push("VERTEX_DEPTH_CHECK") : Y.defines.push("FRAGMENT_DEPTH_CHECK")), this._sdf && (Y.defines.push("SDF"), Y.defines.push("SDF_EDGE " + Q)), this._sp = Mt.replaceCache({
                    context: r,
                    shaderProgram: this._sp,
                    vertexShaderSource: B,
                    fragmentShaderSource: Y,
                    attributeLocations: ct
                }), Y = new Re({
                    defines: ["TRANSLUCENT", ie],
                    sources: [V]
                }), this._shaderClampToGround && (Z ? Y.defines.push("VERTEX_DEPTH_CHECK") : Y.defines.push("FRAGMENT_DEPTH_CHECK")), this._sdf && (Y.defines.push("SDF"), Y.defines.push("SDF_EDGE " + Q)), this._spTranslucent = Mt.replaceCache({
                    context: r,
                    shaderProgram: this._spTranslucent,
                    vertexShaderSource: B,
                    fragmentShaderSource: Y,
                    attributeLocations: ct
                })), this._blendOption === Mr.OPAQUE && (Y = new Re({
                    defines: [ie],
                    sources: [V]
                }), this._shaderClampToGround && (Z ? Y.defines.push("VERTEX_DEPTH_CHECK") : Y.defines.push("FRAGMENT_DEPTH_CHECK")), this._sdf && (Y.defines.push("SDF"), Y.defines.push("SDF_EDGE " + Q)), this._sp = Mt.replaceCache({
                    context: r,
                    shaderProgram: this._sp,
                    vertexShaderSource: B,
                    fragmentShaderSource: Y,
                    attributeLocations: ct
                })), this._blendOption === Mr.TRANSLUCENT && (Y = new Re({
                    defines: [ie],
                    sources: [V]
                }), this._shaderClampToGround && (Z ? Y.defines.push("VERTEX_DEPTH_CHECK") : Y.defines.push("FRAGMENT_DEPTH_CHECK")), this._sdf && (Y.defines.push("SDF"), Y.defines.push("SDF_EDGE " + Q)), this._spTranslucent = Mt.replaceCache({
                    context: r,
                    shaderProgram: this._spTranslucent,
                    vertexShaderSource: B,
                    fragmentShaderSource: Y,
                    attributeLocations: ct
                })), this._compiledShaderRotation = this._shaderRotation, this._compiledShaderAlignedAxis = this._shaderAlignedAxis, this._compiledShaderScaleByDistance = this._shaderScaleByDistance, this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance, this._compiledShaderPixelOffsetScaleByDistance = this._shaderPixelOffsetScaleByDistance, this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition, this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance, this._compiledShaderClampToGround = this._shaderClampToGround, this._compiledSDF = this._sdf
            }
            var Ae = e.commandList;
            if (v.render || v.pick) {
                var re = this._colorCommands,
                    ve = this._blendOption === Mr.OPAQUE,
                    qe = this._blendOption === Mr.OPAQUE_AND_TRANSLUCENT,
                    De = this._vaf.va,
                    _e = De.length,
                    Oe = this._uniforms,
                    Fe;
                l(this._batchTable) ? (Oe = this._batchTable.getUniformMapCallback()(Oe), Fe = this._batchTable.getPickId()) : Fe = "v_pickColor", re.length = _e;
                for (var ce = qe ? _e * 2 : _e, He = 0; He < ce; ++He) {
                    var le = re[He];
                    l(le) || (le = re[He] = new an);
                    var ft = ve || qe && He % 2 === 0;
                    le.pass = ft || !qe ? ue.OPAQUE : ue.TRANSLUCENT, le.owner = this;
                    var Pt = qe ? Math.floor(He / 2) : He;
                    le.boundingVolume = F, le.modelMatrix = z, le.count = De[Pt].indicesCount, le.shaderProgram = ft ? this._sp : this._spTranslucent, le.uniformMap = Oe, le.vertexArray = De[Pt].va, le.renderState = ft ? this._rsOpaque : this._rsTranslucent, le.debugShowBoundingVolume = this.debugShowBoundingVolume, le.pickId = Fe, this._instanced && (le.count = 6, le.instanceCount = n), Ae.push(le)
                }
                this.debugShowTextureAtlas && (l(this.debugCommand) || (this.debugCommand = TR(this, e.context)), Ae.push(this.debugCommand))
            }
        }
    }
};
Gr.prototype.isDestroyed = function() {
    return !1
};
Gr.prototype.destroy = function() {
    return l(this._removeCallbackFunc) && (this._removeCallbackFunc(), this._removeCallbackFunc = void 0), this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy(), this._sp = this._sp && this._sp.destroy(), this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy(), this._vaf = this._vaf && this._vaf.destroy(), cg(this._billboards), Pe(this)
};
var AR = {
    LEFT_DRAG: 0,
    RIGHT_DRAG: 1,
    MIDDLE_DRAG: 2,
    WHEEL: 3,
    PINCH: 4
};
const tt = Object.freeze(AR);

function yn(e, t) {
    var n = e;
    return l(t) && (n += "+" + t), n
}

function CR(e, t) {
    R.clone(e.distance.startPosition, t.distance.startPosition), R.clone(e.distance.endPosition, t.distance.endPosition), R.clone(e.angleAndHeight.startPosition, t.angleAndHeight.startPosition), R.clone(e.angleAndHeight.endPosition, t.angleAndHeight.endPosition)
}

function iv(e, t, n) {
    var r = yn(tt.PINCH, t),
        i = e._update,
        a = e._isDown,
        o = e._eventStartPosition,
        s = e._pressTime,
        c = e._releaseTime;
    i[r] = !0, a[r] = !1, o[r] = new R;
    var f = e._movement[r];
    l(f) || (f = e._movement[r] = {}), f.distance = {
        startPosition: new R,
        endPosition: new R
    }, f.angleAndHeight = {
        startPosition: new R,
        endPosition: new R
    }, f.prevAngle = 0, e._eventHandler.setInputAction(function(h) {
        e._buttonsDown++, a[r] = !0, s[r] = new Date, R.lerp(h.position1, h.position2, .5, o[r])
    }, ot.PINCH_START, t), e._eventHandler.setInputAction(function() {
        e._buttonsDown = Math.max(e._buttonsDown - 1, 0), a[r] = !1, c[r] = new Date
    }, ot.PINCH_END, t), e._eventHandler.setInputAction(function(h) {
        if (a[r]) {
            i[r] ? (CR(h, f), i[r] = !1, f.prevAngle = f.angleAndHeight.startPosition.x) : (R.clone(h.distance.endPosition, f.distance.endPosition), R.clone(h.angleAndHeight.endPosition, f.angleAndHeight.endPosition));
            for (var d = f.angleAndHeight.endPosition.x, _ = f.prevAngle, v = Math.PI * 2; d >= _ + Math.PI;) d -= v;
            for (; d < _ - Math.PI;) d += v;
            f.angleAndHeight.endPosition.x = -d * n.clientWidth / 12, f.angleAndHeight.startPosition.x = -_ * n.clientWidth / 12
        }
    }, ot.PINCH_MOVE, t)
}

function av(e, t) {
    var n = yn(tt.WHEEL, t),
        r = e._update;
    r[n] = !0;
    var i = e._movement[n];
    l(i) || (i = e._movement[n] = {}), i.startPosition = new R, i.endPosition = new R, e._eventHandler.setInputAction(function(a) {
        var o = 15 * T.toRadians(a);
        r[n] ? (R.clone(R.ZERO, i.startPosition), i.endPosition.x = 0, i.endPosition.y = o, r[n] = !1) : i.endPosition.y = i.endPosition.y + o
    }, ot.WHEEL, t)
}

function ro(e, t, n) {
    var r = yn(n, t),
        i = e._isDown,
        a = e._eventStartPosition,
        o = e._pressTime,
        s = e._releaseTime;
    i[r] = !1, a[r] = new R;
    var c = e._lastMovement[r];
    l(c) || (c = e._lastMovement[r] = {
        startPosition: new R,
        endPosition: new R,
        valid: !1
    });
    var f, h;
    n === tt.LEFT_DRAG ? (f = ot.LEFT_DOWN, h = ot.LEFT_UP) : n === tt.RIGHT_DRAG ? (f = ot.RIGHT_DOWN, h = ot.RIGHT_UP) : n === tt.MIDDLE_DRAG && (f = ot.MIDDLE_DOWN, h = ot.MIDDLE_UP), e._eventHandler.setInputAction(function(d) {
        e._buttonsDown++, c.valid = !1, i[r] = !0, o[r] = new Date, R.clone(d.position, a[r])
    }, f, t), e._eventHandler.setInputAction(function() {
        e._buttonsDown = Math.max(e._buttonsDown - 1, 0), i[r] = !1, s[r] = new Date
    }, h, t)
}

function ov(e, t) {
    R.clone(e.startPosition, t.startPosition), R.clone(e.endPosition, t.endPosition)
}

function sv(e, t) {
    var n = e._update,
        r = e._movement,
        i = e._lastMovement,
        a = e._isDown;
    for (var o in tt)
        if (tt.hasOwnProperty(o)) {
            var s = tt[o];
            if (l(s)) {
                var c = yn(s, t);
                n[c] = !0, l(e._lastMovement[c]) || (e._lastMovement[c] = {
                    startPosition: new R,
                    endPosition: new R,
                    valid: !1
                }), l(e._movement[c]) || (e._movement[c] = {
                    startPosition: new R,
                    endPosition: new R
                })
            }
        }
    e._eventHandler.setInputAction(function(f) {
        for (var h in tt)
            if (tt.hasOwnProperty(h)) {
                var d = tt[h];
                if (l(d)) {
                    var _ = yn(d, t);
                    a[_] && (n[_] ? (ov(r[_], i[_]), i[_].valid = !0, ov(f, r[_]), n[_] = !1) : R.clone(f.endPosition, r[_].endPosition))
                }
            }
        R.clone(f.endPosition, e._currentMousePosition)
    }, ot.MOUSE_MOVE, t)
}

function Ar(e) {
    this._eventHandler = new Vr(e), this._update = {}, this._movement = {}, this._lastMovement = {}, this._isDown = {}, this._eventStartPosition = {}, this._pressTime = {}, this._releaseTime = {}, this._buttonsDown = 0, this._currentMousePosition = new R, av(this, void 0), iv(this, void 0, e), ro(this, void 0, tt.LEFT_DRAG), ro(this, void 0, tt.RIGHT_DRAG), ro(this, void 0, tt.MIDDLE_DRAG), sv(this, void 0);
    for (var t in gr)
        if (gr.hasOwnProperty(t)) {
            var n = gr[t];
            l(n) && (av(this, n), iv(this, n, e), ro(this, n, tt.LEFT_DRAG), ro(this, n, tt.RIGHT_DRAG), ro(this, n, tt.MIDDLE_DRAG), sv(this, n))
        }
}
Object.defineProperties(Ar.prototype, {
    currentMousePosition: {
        get: function() {
            return this._currentMousePosition
        }
    },
    anyButtonDown: {
        get: function() {
            var e = !this._update[yn(tt.WHEEL)] || !this._update[yn(tt.WHEEL, gr.SHIFT)] || !this._update[yn(tt.WHEEL, gr.CTRL)] || !this._update[yn(tt.WHEEL, gr.ALT)];
            return this._buttonsDown > 0 || e
        }
    }
});
Ar.prototype.isMoving = function(e, t) {
    var n = yn(e, t);
    return !this._update[n]
};
Ar.prototype.getMovement = function(e, t) {
    var n = yn(e, t),
        r = this._movement[n];
    return r
};
Ar.prototype.getLastMovement = function(e, t) {
    var n = yn(e, t),
        r = this._lastMovement[n];
    if (r.valid) return r
};
Ar.prototype.isButtonDown = function(e, t) {
    var n = yn(e, t);
    return this._isDown[n]
};
Ar.prototype.getStartMousePosition = function(e, t) {
    if (e === tt.WHEEL) return this._currentMousePosition;
    var n = yn(e, t);
    return this._eventStartPosition[n]
};
Ar.prototype.getButtonPressTime = function(e, t) {
    var n = yn(e, t);
    return this._pressTime[n]
};
Ar.prototype.getButtonReleaseTime = function(e, t) {
    var n = yn(e, t);
    return this._releaseTime[n]
};
Ar.prototype.reset = function() {
    for (var e in this._update) this._update.hasOwnProperty(e) && (this._update[e] = !0)
};
Ar.prototype.isDestroyed = function() {
    return !1
};
Ar.prototype.destroy = function() {
    return this._eventHandler = this._eventHandler && this._eventHandler.destroy(), Pe(this)
};

function ra(e) {
    e = p(e, p.EMPTY_OBJECT), this._ellipsoid = p(e.ellipsoid, ne.WGS84), this._rectangle = p(e.rectangle, W.MAX_VALUE), this._projection = new un(this._ellipsoid), this._numberOfLevelZeroTilesX = p(e.numberOfLevelZeroTilesX, 2), this._numberOfLevelZeroTilesY = p(e.numberOfLevelZeroTilesY, 1)
}
Object.defineProperties(ra.prototype, {
    ellipsoid: {
        get: function() {
            return this._ellipsoid
        }
    },
    rectangle: {
        get: function() {
            return this._rectangle
        }
    },
    projection: {
        get: function() {
            return this._projection
        }
    }
});
ra.prototype.getNumberOfXTilesAtLevel = function(e) {
    return this._numberOfLevelZeroTilesX << e
};
ra.prototype.getNumberOfYTilesAtLevel = function(e) {
    return this._numberOfLevelZeroTilesY << e
};
ra.prototype.rectangleToNativeRectangle = function(e, t) {
    var n = T.toDegrees(e.west),
        r = T.toDegrees(e.south),
        i = T.toDegrees(e.east),
        a = T.toDegrees(e.north);
    return l(t) ? (t.west = n, t.south = r, t.east = i, t.north = a, t) : new W(n, r, i, a)
};
ra.prototype.tileXYToNativeRectangle = function(e, t, n, r) {
    var i = this.tileXYToRectangle(e, t, n, r);
    return i.west = T.toDegrees(i.west), i.south = T.toDegrees(i.south), i.east = T.toDegrees(i.east), i.north = T.toDegrees(i.north), i
};
ra.prototype.tileXYToRectangle = function(e, t, n, r) {
    var i = this._rectangle,
        a = this.getNumberOfXTilesAtLevel(n),
        o = this.getNumberOfYTilesAtLevel(n),
        s = i.width / a,
        c = e * s + i.west,
        f = (e + 1) * s + i.west,
        h = i.height / o,
        d = i.north - t * h,
        _ = i.north - (t + 1) * h;
    return l(r) || (r = new W(c, _, f, d)), r.west = c, r.south = _, r.east = f, r.north = d, r
};
ra.prototype.positionToTileXY = function(e, t, n) {
    var r = this._rectangle;
    if (!!W.contains(r, e)) {
        var i = this.getNumberOfXTilesAtLevel(t),
            a = this.getNumberOfYTilesAtLevel(t),
            o = r.width / i,
            s = r.height / a,
            c = e.longitude;
        r.east < r.west && (c += T.TWO_PI);
        var f = (c - r.west) / o | 0;
        f >= i && (f = i - 1);
        var h = (r.north - e.latitude) / s | 0;
        return h >= a && (h = a - 1), l(n) ? (n.x = f, n.y = h, n) : new R(f, h)
    }
};
var wR = {
    NONE: 0,
    LERC: 1
};
const uv = Object.freeze(wR);

function Fn(e, t, n) {
    this.minimum = u.clone(p(e, u.ZERO)), this.maximum = u.clone(p(t, u.ZERO)), l(n) ? n = u.clone(n) : n = u.midpoint(this.minimum, this.maximum, new u), this.center = n
}
Fn.fromPoints = function(e, t) {
    if (l(t) || (t = new Fn), !l(e) || e.length === 0) return t.minimum = u.clone(u.ZERO, t.minimum), t.maximum = u.clone(u.ZERO, t.maximum), t.center = u.clone(u.ZERO, t.center), t;
    for (var n = e[0].x, r = e[0].y, i = e[0].z, a = e[0].x, o = e[0].y, s = e[0].z, c = e.length, f = 1; f < c; f++) {
        var h = e[f],
            d = h.x,
            _ = h.y,
            v = h.z;
        n = Math.min(d, n), a = Math.max(d, a), r = Math.min(_, r), o = Math.max(_, o), i = Math.min(v, i), s = Math.max(v, s)
    }
    var m = t.minimum;
    m.x = n, m.y = r, m.z = i;
    var g = t.maximum;
    return g.x = a, g.y = o, g.z = s, t.center = u.midpoint(m, g, t.center), t
};
Fn.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (t.minimum = u.clone(e.minimum, t.minimum), t.maximum = u.clone(e.maximum, t.maximum), t.center = u.clone(e.center, t.center), t) : new Fn(e.minimum, e.maximum, e.center)
};
Fn.equals = function(e, t) {
    return e === t || l(e) && l(t) && u.equals(e.center, t.center) && u.equals(e.minimum, t.minimum) && u.equals(e.maximum, t.maximum)
};
var _u = new u;
Fn.intersectPlane = function(e, t) {
    _u = u.subtract(e.maximum, e.minimum, _u);
    var n = u.multiplyByScalar(_u, .5, _u),
        r = t.normal,
        i = n.x * Math.abs(r.x) + n.y * Math.abs(r.y) + n.z * Math.abs(r.z),
        a = u.dot(e.center, r) + t.distance;
    return a - i > 0 ? nt.INSIDE : a + i < 0 ? nt.OUTSIDE : nt.INTERSECTING
};
Fn.prototype.clone = function(e) {
    return Fn.clone(this, e)
};
Fn.prototype.intersectPlane = function(e) {
    return Fn.intersectPlane(this, e)
};
Fn.prototype.equals = function(e) {
    return Fn.equals(this, e)
};

function Hr(e, t) {
    this._ellipsoid = e, this._cameraPosition = new u, this._cameraPositionInScaledSpace = new u, this._distanceToLimbInScaledSpaceSquared = 0, l(t) && (this.cameraPosition = t)
}
Object.defineProperties(Hr.prototype, {
    ellipsoid: {
        get: function() {
            return this._ellipsoid
        }
    },
    cameraPosition: {
        get: function() {
            return this._cameraPosition
        },
        set: function(e) {
            var t = this._ellipsoid,
                n = t.transformPositionToScaledSpace(e, this._cameraPositionInScaledSpace),
                r = u.magnitudeSquared(n) - 1;
            u.clone(e, this._cameraPosition), this._cameraPositionInScaledSpace = n, this._distanceToLimbInScaledSpaceSquared = r
        }
    }
});
var Cg = new u;
Hr.prototype.isPointVisible = function(e) {
    var t = this._ellipsoid,
        n = t.transformPositionToScaledSpace(e, Cg);
    return wd(n, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared)
};
Hr.prototype.isScaledSpacePointVisible = function(e) {
    return wd(e, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared)
};
var xR = new u;
Hr.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function(e, t) {
    var n = this._ellipsoid,
        r, i;
    return l(t) && t < 0 && n.minimumRadius > -t ? (i = xR, i.x = this._cameraPosition.x / (n.radii.x + t), i.y = this._cameraPosition.y / (n.radii.y + t), i.z = this._cameraPosition.z / (n.radii.z + t), r = i.x * i.x + i.y * i.y + i.z * i.z - 1) : (i = this._cameraPositionInScaledSpace, r = this._distanceToLimbInScaledSpaceSquared), wd(e, i, r)
};
Hr.prototype.computeHorizonCullingPoint = function(e, t, n) {
    return Sg(this._ellipsoid, e, t, n)
};
var wg = ne.clone(ne.UNIT_SPHERE);
Hr.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function(e, t, n, r) {
    var i = xg(this._ellipsoid, n, wg);
    return Sg(i, e, t, r)
};
Hr.prototype.computeHorizonCullingPointFromVertices = function(e, t, n, r, i) {
    return Rg(this._ellipsoid, e, t, n, r, i)
};
Hr.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function(e, t, n, r, i, a) {
    var o = xg(this._ellipsoid, i, wg);
    return Rg(o, e, t, n, r, a)
};
var SR = [];
Hr.prototype.computeHorizonCullingPointFromRectangle = function(e, t, n) {
    var r = W.subsample(e, t, 0, SR),
        i = q.fromPoints(r);
    if (!(u.magnitude(i.center) < .1 * t.minimumRadius)) return this.computeHorizonCullingPoint(i.center, r, n)
};
var RR = new u;

function xg(e, t, n) {
    if (l(t) && t < 0 && e.minimumRadius > -t) {
        var r = u.fromElements(e.radii.x + t, e.radii.y + t, e.radii.z + t, RR);
        e = ne.fromCartesian3(r, n)
    }
    return e
}

function Sg(e, t, n, r) {
    l(r) || (r = new u);
    for (var i = Pg(e, t), a = 0, o = 0, s = n.length; o < s; ++o) {
        var c = n[o],
            f = Dg(e, c, i);
        if (f < 0) return;
        a = Math.max(a, f)
    }
    return Ig(i, a, r)
}
var vu = new u;

function Rg(e, t, n, r, i, a) {
    l(a) || (a = new u), r = p(r, 3), i = p(i, u.ZERO);
    for (var o = Pg(e, t), s = 0, c = 0, f = n.length; c < f; c += r) {
        vu.x = n[c] + i.x, vu.y = n[c + 1] + i.y, vu.z = n[c + 2] + i.z;
        var h = Dg(e, vu, o);
        if (h < 0) return;
        s = Math.max(s, h)
    }
    return Ig(o, s, a)
}

function wd(e, t, n) {
    var r = t,
        i = n,
        a = u.subtract(e, r, Cg),
        o = -u.dot(a, r),
        s = i < 0 ? o > 0 : o > i && o * o / u.magnitudeSquared(a) > i;
    return !s
}
var DR = new u,
    IR = new u;

function Dg(e, t, n) {
    var r = e.transformPositionToScaledSpace(t, DR),
        i = u.magnitudeSquared(r),
        a = Math.sqrt(i),
        o = u.divideByScalar(r, a, IR);
    i = Math.max(1, i), a = Math.max(1, a);
    var s = u.dot(o, n),
        c = u.magnitude(u.cross(o, n, o)),
        f = 1 / a,
        h = Math.sqrt(i - 1) * f;
    return 1 / (s * f - c * h)
}

function Ig(e, t, n) {
    if (!(t <= 0 || t === 1 / 0 || t !== t)) return u.multiplyByScalar(e, t, n)
}
var sh = new u;

function Pg(e, t) {
    return u.equals(t, u.ZERO) ? t : (e.transformPositionToScaledSpace(t, sh), u.normalize(sh, sh))
}
var uh = new U;

function ai(e, t) {
    t = p(t, ne.WGS84), e = t.scaleToGeodeticSurface(e);
    var n = xe.eastNorthUpToFixedFrame(e, t);
    this._ellipsoid = t, this._origin = e, this._xAxis = u.fromCartesian4(S.getColumn(n, 0, uh)), this._yAxis = u.fromCartesian4(S.getColumn(n, 1, uh));
    var r = u.fromCartesian4(S.getColumn(n, 2, uh));
    this._plane = Ne.fromPointNormal(e, r)
}
Object.defineProperties(ai.prototype, {
    ellipsoid: {
        get: function() {
            return this._ellipsoid
        }
    },
    origin: {
        get: function() {
            return this._origin
        }
    },
    plane: {
        get: function() {
            return this._plane
        }
    },
    xAxis: {
        get: function() {
            return this._xAxis
        }
    },
    yAxis: {
        get: function() {
            return this._yAxis
        }
    },
    zAxis: {
        get: function() {
            return this._plane.normal
        }
    }
});
var PR = new Fn;
ai.fromPoints = function(e, t) {
    var n = Fn.fromPoints(e, PR);
    return new ai(n.center, t)
};
var Og = new Ke,
    Mc = new u;
ai.prototype.projectPointOntoPlane = function(e, t) {
    var n = Og;
    n.origin = e, u.normalize(e, n.direction);
    var r = Me.rayPlane(n, this._plane, Mc);
    if (l(r) || (u.negate(n.direction, n.direction), r = Me.rayPlane(n, this._plane, Mc)), l(r)) {
        var i = u.subtract(r, this._origin, r),
            a = u.dot(this._xAxis, i),
            o = u.dot(this._yAxis, i);
        return l(t) ? (t.x = a, t.y = o, t) : new R(a, o)
    }
};
ai.prototype.projectPointsOntoPlane = function(e, t) {
    l(t) || (t = []);
    for (var n = 0, r = e.length, i = 0; i < r; i++) {
        var a = this.projectPointOntoPlane(e[i], t[n]);
        l(a) && (t[n] = a, n++)
    }
    return t.length = n, t
};
ai.prototype.projectPointToNearestOnPlane = function(e, t) {
    l(t) || (t = new R);
    var n = Og;
    n.origin = e, u.clone(this._plane.normal, n.direction);
    var r = Me.rayPlane(n, this._plane, Mc);
    l(r) || (u.negate(n.direction, n.direction), r = Me.rayPlane(n, this._plane, Mc));
    var i = u.subtract(r, this._origin, r),
        a = u.dot(this._xAxis, i),
        o = u.dot(this._yAxis, i);
    return t.x = a, t.y = o, t
};
ai.prototype.projectPointsToNearestOnPlane = function(e, t) {
    l(t) || (t = []);
    var n = e.length;
    t.length = n;
    for (var r = 0; r < n; r++) t[r] = this.projectPointToNearestOnPlane(e[r], t[r]);
    return t
};
var OR = new u;
ai.prototype.projectPointOntoEllipsoid = function(e, t) {
    l(t) || (t = new u);
    var n = this._ellipsoid,
        r = this._origin,
        i = this._xAxis,
        a = this._yAxis,
        o = OR;
    return u.multiplyByScalar(i, e.x, o), t = u.add(r, o, t), u.multiplyByScalar(a, e.y, o), u.add(t, o, t), n.scaleToGeocentricSurface(t, t), t
};
ai.prototype.projectPointsOntoEllipsoid = function(e, t) {
    var n = e.length;
    l(t) ? t.length = n : t = new Array(n);
    for (var r = 0; r < n; ++r) t[r] = this.projectPointOntoEllipsoid(e[r], t[r]);
    return t
};

function $e(e, t) {
    this.center = u.clone(p(e, u.ZERO)), this.halfAxes = N.clone(p(t, N.ZERO))
}
$e.packedLength = u.packedLength + N.packedLength;
$e.pack = function(e, t, n) {
    return n = p(n, 0), u.pack(e.center, t, n), N.pack(e.halfAxes, t, n + u.packedLength), t
};
$e.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new $e), u.unpack(e, t, n.center), N.unpack(e, t + u.packedLength, n.halfAxes), n
};
var MR = new u,
    NR = new u,
    bR = new u,
    FR = new u,
    LR = new u,
    UR = new u,
    zR = new N,
    BR = {
        unitary: new N,
        diagonal: new N
    };
$e.fromPoints = function(e, t) {
    if (l(t) || (t = new $e), !l(e) || e.length === 0) return t.halfAxes = N.ZERO, t.center = u.ZERO, t;
    var n, r = e.length,
        i = u.clone(e[0], MR);
    for (n = 1; n < r; n++) u.add(i, e[n], i);
    var a = 1 / r;
    u.multiplyByScalar(i, a, i);
    var o = 0,
        s = 0,
        c = 0,
        f = 0,
        h = 0,
        d = 0,
        _;
    for (n = 0; n < r; n++) _ = u.subtract(e[n], i, NR), o += _.x * _.x, s += _.x * _.y, c += _.x * _.z, f += _.y * _.y, h += _.y * _.z, d += _.z * _.z;
    o *= a, s *= a, c *= a, f *= a, h *= a, d *= a;
    var v = zR;
    v[0] = o, v[1] = s, v[2] = c, v[3] = s, v[4] = f, v[5] = h, v[6] = c, v[7] = h, v[8] = d;
    var m = N.computeEigenDecomposition(v, BR),
        g = N.clone(m.unitary, t.halfAxes),
        y = N.getColumn(g, 0, FR),
        E = N.getColumn(g, 1, LR),
        w = N.getColumn(g, 2, UR),
        C = -Number.MAX_VALUE,
        A = -Number.MAX_VALUE,
        x = -Number.MAX_VALUE,
        P = Number.MAX_VALUE,
        I = Number.MAX_VALUE,
        D = Number.MAX_VALUE;
    for (n = 0; n < r; n++) _ = e[n], C = Math.max(u.dot(y, _), C), A = Math.max(u.dot(E, _), A), x = Math.max(u.dot(w, _), x), P = Math.min(u.dot(y, _), P), I = Math.min(u.dot(E, _), I), D = Math.min(u.dot(w, _), D);
    y = u.multiplyByScalar(y, .5 * (P + C), y), E = u.multiplyByScalar(E, .5 * (I + A), E), w = u.multiplyByScalar(w, .5 * (D + x), w);
    var O = u.add(y, E, t.center);
    u.add(O, w, O);
    var F = bR;
    return F.x = C - P, F.y = A - I, F.z = x - D, u.multiplyByScalar(F, .5, F), N.multiplyByScale(t.halfAxes, F, t.halfAxes), t
};
var Mg = new u,
    VR = new u;

function cv(e, t, n, r, i, a, o, s, c, f, h) {
    l(h) || (h = new $e);
    var d = h.halfAxes;
    N.setColumn(d, 0, t, d), N.setColumn(d, 1, n, d), N.setColumn(d, 2, r, d);
    var _ = Mg;
    _.x = (i + a) / 2, _.y = (o + s) / 2, _.z = (c + f) / 2;
    var v = VR;
    v.x = (a - i) / 2, v.y = (s - o) / 2, v.z = (f - c) / 2;
    var m = h.center;
    return _ = N.multiplyByVector(d, _, _), u.add(e, _, m), N.multiplyByScale(d, v, d), h
}
var fv = new K,
    GR = new u,
    HR = new K,
    kR = new K,
    WR = new K,
    qR = new K,
    YR = new K,
    XR = new u,
    hv = new u,
    jR = new u,
    lv = new u,
    ZR = new u,
    KR = new R,
    $R = new R,
    JR = new R,
    QR = new R,
    eD = new R,
    tD = new u,
    nD = new u,
    rD = new u,
    iD = new u,
    aD = new R,
    oD = new u,
    sD = new u,
    uD = new u,
    cD = new Ne(u.UNIT_X, 0);
$e.fromRectangle = function(e, t, n, r, i) {
    t = p(t, 0), n = p(n, 0), r = p(r, ne.WGS84);
    var a, o, s, c, f, h, d;
    if (e.width <= T.PI) {
        var _ = W.center(e, fv),
            v = r.cartographicToCartesian(_, GR),
            m = new ai(v, r);
        d = m.plane;
        var g = _.longitude,
            y = e.south < 0 && e.north > 0 ? 0 : _.latitude,
            E = K.fromRadians(g, e.north, n, HR),
            w = K.fromRadians(e.west, e.north, n, kR),
            C = K.fromRadians(e.west, y, n, WR),
            A = K.fromRadians(e.west, e.south, n, qR),
            x = K.fromRadians(g, e.south, n, YR),
            P = r.cartographicToCartesian(E, XR),
            I = r.cartographicToCartesian(w, hv),
            D = r.cartographicToCartesian(C, jR),
            O = r.cartographicToCartesian(A, lv),
            F = r.cartographicToCartesian(x, ZR),
            z = m.projectPointToNearestOnPlane(P, KR),
            b = m.projectPointToNearestOnPlane(I, $R),
            M = m.projectPointToNearestOnPlane(D, JR),
            G = m.projectPointToNearestOnPlane(O, QR),
            V = m.projectPointToNearestOnPlane(F, eD);
        return a = Math.min(b.x, M.x, G.x), o = -a, c = Math.max(b.y, z.y), s = Math.min(G.y, V.y), w.height = A.height = t, I = r.cartographicToCartesian(w, hv), O = r.cartographicToCartesian(A, lv), f = Math.min(Ne.getPointDistance(d, I), Ne.getPointDistance(d, O)), h = n, cv(m.origin, m.xAxis, m.yAxis, m.zAxis, a, o, s, c, f, h, i)
    }
    var B = e.south > 0,
        Y = e.north < 0,
        j = B ? e.south : Y ? e.north : 0,
        Z = W.center(e, fv).longitude,
        Q = u.fromRadians(Z, j, n, r, tD);
    Q.z = 0;
    var ie = Math.abs(Q.x) < T.EPSILON10 && Math.abs(Q.y) < T.EPSILON10,
        Ae = ie ? u.UNIT_X : u.normalize(Q, nD),
        re = u.UNIT_Z,
        ve = u.cross(Ae, re, rD);
    d = Ne.fromPointNormal(Q, Ae, cD);
    var qe = u.fromRadians(Z + T.PI_OVER_TWO, j, n, r, iD);
    o = u.dot(Ne.projectPointOntoPlane(d, qe, aD), ve), a = -o, c = u.fromRadians(0, e.north, Y ? t : n, r, oD).z, s = u.fromRadians(0, e.south, B ? t : n, r, sD).z;
    var De = u.fromRadians(e.east, j, n, r, uD);
    return f = Ne.getPointDistance(d, De), h = 0, cv(Q, ve, re, Ae, a, o, s, c, f, h, i)
};
$e.clone = function(e, t) {
    if (!!l(e)) return l(t) ? (u.clone(e.center, t.center), N.clone(e.halfAxes, t.halfAxes), t) : new $e(e.center, e.halfAxes)
};
$e.intersectPlane = function(e, t) {
    var n = e.center,
        r = t.normal,
        i = e.halfAxes,
        a = r.x,
        o = r.y,
        s = r.z,
        c = Math.abs(a * i[N.COLUMN0ROW0] + o * i[N.COLUMN0ROW1] + s * i[N.COLUMN0ROW2]) + Math.abs(a * i[N.COLUMN1ROW0] + o * i[N.COLUMN1ROW1] + s * i[N.COLUMN1ROW2]) + Math.abs(a * i[N.COLUMN2ROW0] + o * i[N.COLUMN2ROW1] + s * i[N.COLUMN2ROW2]),
        f = u.dot(r, n) + t.distance;
    return f <= -c ? nt.OUTSIDE : f >= c ? nt.INSIDE : nt.INTERSECTING
};
var Ng = new u,
    bg = new u,
    Fg = new u,
    fD = new u;
$e.distanceSquaredTo = function(e, t) {
    var n = u.subtract(t, e.center, Mg),
        r = e.halfAxes,
        i = N.getColumn(r, 0, Ng),
        a = N.getColumn(r, 1, bg),
        o = N.getColumn(r, 2, Fg),
        s = u.magnitude(i),
        c = u.magnitude(a),
        f = u.magnitude(o);
    u.normalize(i, i), u.normalize(a, a), u.normalize(o, o);
    var h = fD;
    h.x = u.dot(n, i), h.y = u.dot(n, a), h.z = u.dot(n, o);
    var d = 0,
        _;
    return h.x < -s ? (_ = h.x + s, d += _ * _) : h.x > s && (_ = h.x - s, d += _ * _), h.y < -c ? (_ = h.y + c, d += _ * _) : h.y > c && (_ = h.y - c, d += _ * _), h.z < -f ? (_ = h.z + f, d += _ * _) : h.z > f && (_ = h.z - f, d += _ * _), d
};
var hD = new u,
    lD = new u;
$e.computePlaneDistances = function(e, t, n, r) {
    l(r) || (r = new Yi);
    var i = Number.POSITIVE_INFINITY,
        a = Number.NEGATIVE_INFINITY,
        o = e.center,
        s = e.halfAxes,
        c = N.getColumn(s, 0, Ng),
        f = N.getColumn(s, 1, bg),
        h = N.getColumn(s, 2, Fg),
        d = u.add(c, f, hD);
    u.add(d, h, d), u.add(d, o, d);
    var _ = u.subtract(d, t, lD),
        v = u.dot(n, _);
    return i = Math.min(v, i), a = Math.max(v, a), u.add(o, c, d), u.add(d, f, d), u.subtract(d, h, d), u.subtract(d, t, _), v = u.dot(n, _), i = Math.min(v, i), a = Math.max(v, a), u.add(o, c, d), u.subtract(d, f, d), u.add(d, h, d), u.subtract(d, t, _), v = u.dot(n, _), i = Math.min(v, i), a = Math.max(v, a), u.add(o, c, d), u.subtract(d, f, d), u.subtract(d, h, d), u.subtract(d, t, _), v = u.dot(n, _), i = Math.min(v, i), a = Math.max(v, a), u.subtract(o, c, d), u.add(d, f, d), u.add(d, h, d), u.subtract(d, t, _), v = u.dot(n, _), i = Math.min(v, i), a = Math.max(v, a), u.subtract(o, c, d), u.add(d, f, d), u.subtract(d, h, d), u.subtract(d, t, _), v = u.dot(n, _), i = Math.min(v, i), a = Math.max(v, a), u.subtract(o, c, d), u.subtract(d, f, d), u.add(d, h, d), u.subtract(d, t, _), v = u.dot(n, _), i = Math.min(v, i), a = Math.max(v, a), u.subtract(o, c, d), u.subtract(d, f, d), u.subtract(d, h, d), u.subtract(d, t, _), v = u.dot(n, _), i = Math.min(v, i), a = Math.max(v, a), r.start = i, r.stop = a, r
};
var dD = new q;
$e.isOccluded = function(e, t) {
    var n = q.fromOrientedBoundingBox(e, dD);
    return !t.isBoundingSphereVisible(n)
};
$e.prototype.intersectPlane = function(e) {
    return $e.intersectPlane(this, e)
};
$e.prototype.distanceSquaredTo = function(e) {
    return $e.distanceSquaredTo(this, e)
};
$e.prototype.computePlaneDistances = function(e, t, n) {
    return $e.computePlaneDistances(this, e, t, n)
};
$e.prototype.isOccluded = function(e) {
    return $e.isOccluded(this, e)
};
$e.equals = function(e, t) {
    return e === t || l(e) && l(t) && u.equals(e.center, t.center) && N.equals(e.halfAxes, t.halfAxes)
};
$e.prototype.clone = function(e) {
    return $e.clone(this, e)
};
$e.prototype.equals = function(e) {
    return $e.equals(this, e)
};
var _D = {
    NONE: 0,
    BITS12: 1
};
const er = Object.freeze(_D);
var Ca = new u,
    vD = new u,
    mr = new R,
    mu = new S,
    mD = new S,
    pD = Math.pow(2, 12);

function qn(e, t, n, r, i, a) {
    var o = er.NONE,
        s, c, f;
    if (l(e) && l(t) && l(n) && l(r)) {
        var h = e.minimum,
            d = e.maximum,
            _ = u.subtract(d, h, vD),
            v = n - t,
            m = Math.max(u.maximumComponent(_), v);
        m < pD - 1 ? o = er.BITS12 : o = er.NONE, s = e.center, c = S.inverseTransformation(r, new S);
        var g = u.negate(h, Ca);
        S.multiply(S.fromTranslation(g, mu), c, c);
        var y = Ca;
        y.x = 1 / _.x, y.y = 1 / _.y, y.z = 1 / _.z, S.multiply(S.fromScale(y, mu), c, c), f = S.clone(r), S.setTranslation(f, u.ZERO, f), r = S.clone(r, new S);
        var E = S.fromTranslation(h, mu),
            w = S.fromScale(_, mD),
            C = S.multiply(E, w, mu);
        S.multiply(r, C, r), S.multiply(f, C, f)
    }
    this.quantization = o, this.minimumHeight = t, this.maximumHeight = n, this.center = s, this.toScaledENU = c, this.fromScaledENU = r, this.matrix = f, this.hasVertexNormals = i, this.hasWebMercatorT = p(a, !1)
}
qn.prototype.encode = function(e, t, n, r, i, a, o) {
    var s = r.x,
        c = r.y;
    if (this.quantization === er.BITS12) {
        n = S.multiplyByPoint(this.toScaledENU, n, Ca), n.x = T.clamp(n.x, 0, 1), n.y = T.clamp(n.y, 0, 1), n.z = T.clamp(n.z, 0, 1);
        var f = this.maximumHeight - this.minimumHeight,
            h = T.clamp((i - this.minimumHeight) / f, 0, 1);
        R.fromElements(n.x, n.y, mr);
        var d = Ee.compressTextureCoordinates(mr);
        R.fromElements(n.z, h, mr);
        var _ = Ee.compressTextureCoordinates(mr);
        R.fromElements(s, c, mr);
        var v = Ee.compressTextureCoordinates(mr);
        if (e[t++] = d, e[t++] = _, e[t++] = v, this.hasWebMercatorT) {
            R.fromElements(o, 0, mr);
            var m = Ee.compressTextureCoordinates(mr);
            e[t++] = m
        }
    } else u.subtract(n, this.center, Ca), e[t++] = Ca.x, e[t++] = Ca.y, e[t++] = Ca.z, e[t++] = i, e[t++] = s, e[t++] = c, this.hasWebMercatorT && (e[t++] = o);
    return this.hasVertexNormals && (e[t++] = Ee.octPackFloat(a)), t
};
qn.prototype.decodePosition = function(e, t, n) {
    if (l(n) || (n = new u), t *= this.getStride(), this.quantization === er.BITS12) {
        var r = Ee.decompressTextureCoordinates(e[t], mr);
        n.x = r.x, n.y = r.y;
        var i = Ee.decompressTextureCoordinates(e[t + 1], mr);
        return n.z = i.x, S.multiplyByPoint(this.fromScaledENU, n, n)
    }
    return n.x = e[t], n.y = e[t + 1], n.z = e[t + 2], u.add(n, this.center, n)
};
qn.prototype.decodeTextureCoordinates = function(e, t, n) {
    return l(n) || (n = new R), t *= this.getStride(), this.quantization === er.BITS12 ? Ee.decompressTextureCoordinates(e[t + 2], n) : R.fromElements(e[t + 4], e[t + 5], n)
};
qn.prototype.decodeHeight = function(e, t) {
    if (t *= this.getStride(), this.quantization === er.BITS12) {
        var n = Ee.decompressTextureCoordinates(e[t + 1], mr);
        return n.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight
    }
    return e[t + 3]
};
qn.prototype.decodeWebMercatorT = function(e, t) {
    return t *= this.getStride(), this.quantization === er.BITS12 ? Ee.decompressTextureCoordinates(e[t + 3], mr).x : e[t + 6]
};
qn.prototype.getOctEncodedNormal = function(e, t, n) {
    var r = this.getStride();
    t = (t + 1) * r - 1;
    var i = e[t] / 256,
        a = Math.floor(i),
        o = (i - a) * 256;
    return R.fromElements(a, o, n)
};
qn.prototype.getStride = function() {
    var e;
    switch (this.quantization) {
        case er.BITS12:
            e = 3;
            break;
        default:
            e = 6
    }
    return this.hasWebMercatorT && ++e, this.hasVertexNormals && ++e, e
};
var vl = {
        position3DAndHeight: 0,
        textureCoordAndEncodedNormals: 1
    },
    cc = {
        compressed0: 0,
        compressed1: 1
    };
qn.prototype.getAttributes = function(e) {
    var t = ee.FLOAT,
        n = ee.getSizeInBytes(t),
        r;
    if (this.quantization === er.NONE) {
        var i = 4,
            a = 2;
        return this.hasWebMercatorT && ++a, this.hasVertexNormals && ++a, r = (i + a) * n, [{
            index: vl.position3DAndHeight,
            vertexBuffer: e,
            componentDatatype: t,
            componentsPerAttribute: i,
            offsetInBytes: 0,
            strideInBytes: r
        }, {
            index: vl.textureCoordAndEncodedNormals,
            vertexBuffer: e,
            componentDatatype: t,
            componentsPerAttribute: a,
            offsetInBytes: i * n,
            strideInBytes: r
        }]
    }
    var o = 3,
        s = 0;
    return (this.hasWebMercatorT || this.hasVertexNormals) && ++o, this.hasWebMercatorT && this.hasVertexNormals ? (++s, r = (o + s) * n, [{
        index: cc.compressed0,
        vertexBuffer: e,
        componentDatatype: t,
        componentsPerAttribute: o,
        offsetInBytes: 0,
        strideInBytes: r
    }, {
        index: cc.compressed1,
        vertexBuffer: e,
        componentDatatype: t,
        componentsPerAttribute: s,
        offsetInBytes: o * n,
        strideInBytes: r
    }]) : [{
        index: cc.compressed0,
        vertexBuffer: e,
        componentDatatype: t,
        componentsPerAttribute: o
    }]
};
qn.prototype.getAttributeLocations = function() {
    return this.quantization === er.NONE ? vl : cc
};
qn.clone = function(e, t) {
    return l(t) || (t = new qn), t.quantization = e.quantization, t.minimumHeight = e.minimumHeight, t.maximumHeight = e.maximumHeight, t.center = u.clone(e.center), t.toScaledENU = S.clone(e.toScaledENU), t.fromScaledENU = S.clone(e.fromScaledENU), t.matrix = S.clone(e.matrix), t.hasVertexNormals = e.hasVertexNormals, t.hasWebMercatorT = e.hasWebMercatorT, t
};

function st(e) {
    this._ellipsoid = p(e, ne.WGS84), this._semimajorAxis = this._ellipsoid.maximumRadius, this._oneOverSemimajorAxis = 1 / this._semimajorAxis
}
Object.defineProperties(st.prototype, {
    ellipsoid: {
        get: function() {
            return this._ellipsoid
        }
    }
});
st.mercatorAngleToGeodeticLatitude = function(e) {
    return T.PI_OVER_TWO - 2 * Math.atan(Math.exp(-e))
};
st.geodeticLatitudeToMercatorAngle = function(e) {
    e > st.MaximumLatitude ? e = st.MaximumLatitude : e < -st.MaximumLatitude && (e = -st.MaximumLatitude);
    var t = Math.sin(e);
    return .5 * Math.log((1 + t) / (1 - t))
};
st.MaximumLatitude = st.mercatorAngleToGeodeticLatitude(Math.PI);
st.prototype.project = function(e, t) {
    var n = this._semimajorAxis,
        r = e.longitude * n,
        i = st.geodeticLatitudeToMercatorAngle(e.latitude) * n,
        a = e.height;
    return l(t) ? (t.x = r, t.y = i, t.z = a, t) : new u(r, i, a)
};
st.prototype.unproject = function(e, t) {
    var n = this._oneOverSemimajorAxis,
        r = e.x * n,
        i = st.mercatorAngleToGeodeticLatitude(e.y * n),
        a = e.z;
    return l(t) ? (t.longitude = r, t.latitude = i, t.height = a, t) : new K(r, i, a)
};
var br = {};
br.DEFAULT_STRUCTURE = Object.freeze({
    heightScale: 1,
    heightOffset: 0,
    elementsPerHeight: 1,
    stride: 1,
    elementMultiplier: 256,
    isBigEndian: !1
});
var ch = new u,
    gD = new S,
    yD = new u,
    TD = new u;
br.computeVertices = function(e) {
    var t = Math.cos,
        n = Math.sin,
        r = Math.sqrt,
        i = Math.atan,
        a = Math.exp,
        o = T.PI_OVER_TWO,
        s = T.toRadians,
        c = e.heightmap,
        f = e.width,
        h = e.height,
        d = e.skirtHeight,
        _ = p(e.isGeographic, !0),
        v = p(e.ellipsoid, ne.WGS84),
        m = 1 / v.maximumRadius,
        g = e.nativeRectangle,
        y, E, w, C, A = e.rectangle;
    l(A) ? (y = A.west, E = A.south, w = A.east, C = A.north) : _ ? (y = s(g.west), E = s(g.south), w = s(g.east), C = s(g.north)) : (y = g.west * m, E = o - 2 * i(a(-g.south * m)), w = g.east * m, C = o - 2 * i(a(-g.north * m)));
    var x = e.relativeToCenter,
        P = l(x);
    x = P ? x : u.ZERO;
    var I = p(e.exaggeration, 1),
        D = p(e.includeWebMercatorT, !1),
        O = p(e.structure, br.DEFAULT_STRUCTURE),
        F = p(O.heightScale, br.DEFAULT_STRUCTURE.heightScale),
        z = p(O.heightOffset, br.DEFAULT_STRUCTURE.heightOffset),
        b = p(O.elementsPerHeight, br.DEFAULT_STRUCTURE.elementsPerHeight),
        M = p(O.stride, br.DEFAULT_STRUCTURE.stride),
        G = p(O.elementMultiplier, br.DEFAULT_STRUCTURE.elementMultiplier),
        V = p(O.isBigEndian, br.DEFAULT_STRUCTURE.isBigEndian),
        B = W.computeWidth(g),
        Y = W.computeHeight(g),
        j = B / (f - 1),
        Z = Y / (h - 1);
    _ || (B *= m, Y *= m);
    var Q = v.radiiSquared,
        ie = Q.x,
        Ae = Q.y,
        re = Q.z,
        ve = 65536,
        qe = -65536,
        De = xe.eastNorthUpToFixedFrame(x, v),
        _e = S.inverseTransformation(De, gD),
        Oe, Fe;
    D && (Oe = st.geodeticLatitudeToMercatorAngle(E), Fe = 1 / (st.geodeticLatitudeToMercatorAngle(C) - Oe));
    var ce = yD;
    ce.x = Number.POSITIVE_INFINITY, ce.y = Number.POSITIVE_INFINITY, ce.z = Number.POSITIVE_INFINITY;
    var He = TD;
    He.x = Number.NEGATIVE_INFINITY, He.y = Number.NEGATIVE_INFINITY, He.z = Number.NEGATIVE_INFINITY;
    var le = Number.POSITIVE_INFINITY,
        ft = f * h,
        Pt = d > 0 ? f * 2 + h * 2 : 0,
        Ie = ft + Pt,
        xn = new Array(Ie),
        Sn = new Array(Ie),
        St = new Array(Ie),
        rr = D ? new Array(Ie) : [],
        bt = 0,
        cn = h,
        Rr = 0,
        fn = f;
    d > 0 && (--bt, ++cn, --Rr, ++fn);
    for (var ir = 1e-5, hn = bt; hn < cn; ++hn) {
        var Yn = hn;
        Yn < 0 && (Yn = 0), Yn >= h && (Yn = h - 1);
        var ar = g.north - Z * Yn;
        _ ? ar = s(ar) : ar = o - 2 * i(a(-ar * m));
        var sa = (ar - E) / (C - E);
        sa = T.clamp(sa, 0, 1);
        var Xe = hn === bt,
            et = hn === cn - 1;
        d > 0 && (Xe ? ar += ir * Y : et && (ar -= ir * Y));
        var bi = t(ar),
            qa = n(ar),
            me = re * qa,
            Fi;
        D && (Fi = (st.geodeticLatitudeToMercatorAngle(ar) - Oe) * Fe);
        for (var qr = Rr; qr < fn; ++qr) {
            var or = qr;
            or < 0 && (or = 0), or >= f && (or = f - 1);
            var di = Yn * (f * M) + or * M,
                Ft;
            if (b === 1) Ft = c[di];
            else {
                Ft = 0;
                var Ln;
                if (V)
                    for (Ln = 0; Ln < b; ++Ln) Ft = Ft * G + c[di + Ln];
                else
                    for (Ln = b - 1; Ln >= 0; --Ln) Ft = Ft * G + c[di + Ln]
            }
            Ft = (Ft * F + z) * I, qe = Math.max(qe, Ft), ve = Math.min(ve, Ft);
            var Un = g.west + j * or;
            _ ? Un = s(Un) : Un = Un * m;
            var Ut = (Un - y) / (w - y);
            Ut = T.clamp(Ut, 0, 1);
            var Rn = Yn * f + or;
            if (d > 0) {
                var Yr = qr === Rr,
                    Ya = qr === fn - 1,
                    Bo = Xe || et || Yr || Ya,
                    Vo = (Xe || et) && (Yr || Ya);
                if (Vo) continue;
                Bo && (Ft -= d, Yr ? (Rn = ft + (h - Yn - 1), Un -= ir * B) : et ? Rn = ft + h + (f - or - 1) : Ya ? (Rn = ft + h + f + Yn, Un += ir * B) : Xe && (Rn = ft + h + f + h + or))
            }
            var ua = bi * t(Un),
                ca = bi * n(Un),
                Xa = ie * ua,
                ja = Ae * ca,
                fa = r(Xa * ua + ja * ca + me * qa),
                ha = 1 / fa,
                Go = Xa * ha,
                Ho = ja * ha,
                Xr = me * ha,
                Xn = new u;
            Xn.x = Go + ua * Ft, Xn.y = Ho + ca * Ft, Xn.z = Xr + qa * Ft, xn[Rn] = Xn, Sn[Rn] = Ft, St[Rn] = new R(Ut, sa), D && (rr[Rn] = Fi), S.multiplyByPoint(_e, Xn, ch), u.minimumByComponent(ch, ce, ce), u.maximumByComponent(ch, He, He), le = Math.min(le, Ft)
        }
    }
    var df = q.fromPoints(xn),
        kt;
    l(A) && (kt = $e.fromRectangle(A, ve, qe, v));
    var jr;
    if (P) {
        var la = new Hr(v);
        jr = la.computeHorizonCullingPointPossiblyUnderEllipsoid(x, xn, ve)
    }
    for (var _f = new Fn(ce, He, x), Dr = new qn(_f, le, qe, De, !1, D), ko = new Float32Array(Ie * Dr.getStride()), Za = 0, _i = 0; _i < Ie; ++_i) Za = Dr.encode(ko, Za, xn[_i], St[_i], Sn[_i], void 0, rr[_i]);
    return {
        vertices: ko,
        maximumHeight: qe,
        minimumHeight: ve,
        encoding: Dr,
        boundingSphere3D: df,
        orientedBoundingBox: kt,
        occludeePointInScaledSpace: jr
    }
};

function Lg() {
    if (!l(Lt._canTransferArrayBuffer)) {
        var e = new Worker(ED("Workers/transferTypedArrayTest.js"));
        e.postMessage = p(e.webkitPostMessage, e.postMessage);
        var t = 99,
            n = new Int8Array([t]);
        try {
            e.postMessage({
                array: n
            }, [n.buffer])
        } catch {
            return Lt._canTransferArrayBuffer = !1, Lt._canTransferArrayBuffer
        }
        var r = he.defer();
        e.onmessage = function(i) {
            var a = i.data.array,
                o = l(a) && a[0] === t;
            r.resolve(o), e.terminate(), Lt._canTransferArrayBuffer = o
        }, Lt._canTransferArrayBuffer = r.promise
    }
    return Lt._canTransferArrayBuffer
}
var ml = new ht;

function Ug(e, t) {
    --e._activeTasks;
    var n = t.id;
    if (!!l(n)) {
        var r = e._deferreds,
            i = r[n];
        if (l(t.error)) {
            var a = t.error;
            a.name === "RuntimeError" ? (a = new je(t.error.message), a.stack = t.error.stack) : a.name === "DeveloperError" && (a = new we(t.error.message), a.stack = t.error.stack), ml.raiseEvent(a), i.reject(a)
        } else ml.raiseEvent(), i.resolve(t.result);
        delete r[n]
    }
}

function ED(e) {
    var t = Hn(e);
    if (Xp(t)) {
        var n = 'importScripts("' + t + '");',
            r;
        try {
            r = new Blob([n], {
                type: "application/javascript"
            })
        } catch {
            var i = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,
                a = new i;
            a.append(n), r = a.getBlob("application/javascript")
        }
        var o = window.URL || window.webkitURL;
        t = o.createObjectURL(r)
    }
    return t
}

function zg(e) {
    var t = function() {
        let r, i = `
  function Ue(e){return null!=e}function s(e){var t;this.name="DeveloperError",this.message=e;try{throw new Error}catch(e){t=e.stack}this.stack=t}self.module=self.module||{},Ue(Object.create)&&(s.prototype=Object.create(Error.prototype),s.prototype.constructor=s),s.prototype.toString=function(){var e=this.name+": "+this.message;return Ue(this.stack)&&(e+="\\n"+this.stack.toString()),e},s.throwInstantiationError=function(){throw new s("This function defines an interface and should not be called directly.")};var i={};function n(e){return e+" is required, actual value was undefined"}function r(e,t,n){return"Expected "+n+" to be typeof "+t+", actual typeof was "+e}function Pe(e,t){return null!=e?e:t}function t(e){null==e&&(e=(new Date).getTime()),this.N=624,this.M=397,this.MATRIX_A=2567483615,this.UPPER_MASK=2147483648,this.LOWER_MASK=2147483647,this.mt=new Array(this.N),this.mti=this.N+1,this.init_genrand(e)}i.typeOf={},i.defined=function(e,t){if(!Ue(t))throw new s(n(e))},i.typeOf.func=function(e,t){if("function"!=typeof t)throw new s(r(typeof t,"function",e))},i.typeOf.string=function(e,t){if("string"!=typeof t)throw new s(r(typeof t,"string",e))},i.typeOf.number=function(e,t){if("number"!=typeof t)throw new s(r(typeof t,"number",e))},i.typeOf.number.lessThan=function(e,t,n){if(i.typeOf.number(e,t),n<=t)throw new s("Expected "+e+" to be less than "+n+", actual value was "+t)},i.typeOf.number.lessThanOrEquals=function(e,t,n){if(i.typeOf.number(e,t),n<t)throw new s("Expected "+e+" to be less than or equal to "+n+", actual value was "+t)},i.typeOf.number.greaterThan=function(e,t,n){if(i.typeOf.number(e,t),t<=n)throw new s("Expected "+e+" to be greater than "+n+", actual value was "+t)},i.typeOf.number.greaterThanOrEquals=function(e,t,n){if(i.typeOf.number(e,t),t<n)throw new s("Expected "+e+" to be greater than or equal to"+n+", actual value was "+t)},i.typeOf.object=function(e,t){if("object"!=typeof t)throw new s(r(typeof t,"object",e))},i.typeOf.bool=function(e,t){if("boolean"!=typeof t)throw new s(r(typeof t,"boolean",e))},i.typeOf.number.equals=function(e,t,n,r){if(i.typeOf.number(e,n),i.typeOf.number(t,r),n!==r)throw new s(e+" must be equal to "+t+", the actual values are "+n+" and "+r)},Pe.EMPTY_OBJECT=Object.freeze({}),t.prototype.init_genrand=function(e){for(this.mt[0]=e>>>0,this.mti=1;this.mti<this.N;this.mti++){e=this.mt[this.mti-1]^this.mt[this.mti-1]>>>30;this.mt[this.mti]=(1812433253*((4294901760&e)>>>16)<<16)+1812433253*(65535&e)+this.mti,this.mt[this.mti]>>>=0}},t.prototype.genrand_int32=function(){var e,t,n=new Array(0,this.MATRIX_A);if(this.mti>=this.N){for(this.mti==this.N+1&&this.init_genrand(5489),t=0;t<this.N-this.M;t++)e=this.mt[t]&this.UPPER_MASK|this.mt[t+1]&this.LOWER_MASK,this.mt[t]=this.mt[t+this.M]^e>>>1^n[1&e];for(;t<this.N-1;t++)e=this.mt[t]&this.UPPER_MASK|this.mt[t+1]&this.LOWER_MASK,this.mt[t]=this.mt[t+(this.M-this.N)]^e>>>1^n[1&e];e=this.mt[this.N-1]&this.UPPER_MASK|this.mt[0]&this.LOWER_MASK,this.mt[this.N-1]=this.mt[this.M-1]^e>>>1^n[1&e],this.mti=0}return e=this.mt[this.mti++],e^=e>>>11,e^=e<<7&2636928640,e^=e<<15&4022730752,(e^=e>>>18)>>>0},t.prototype.random=function(){return this.genrand_int32()*(1/4294967296)};var Ce={EPSILON1:.1,EPSILON2:.01,EPSILON3:.001,EPSILON4:1e-4,EPSILON5:1e-5,EPSILON6:1e-6,EPSILON7:1e-7,EPSILON8:1e-8,EPSILON9:1e-9,EPSILON10:1e-10,EPSILON11:1e-11,EPSILON12:1e-12,EPSILON13:1e-13,EPSILON14:1e-14,EPSILON15:1e-15,EPSILON16:1e-16,EPSILON17:1e-17,EPSILON18:1e-18,EPSILON19:1e-19,EPSILON20:1e-20,EPSILON21:1e-21,GRAVITATIONALPARAMETER:3986004418e5,SOLAR_RADIUS:6955e5,LUNAR_RADIUS:1737400,SIXTY_FOUR_KILOBYTES:65536,FOUR_GIGABYTES:4294967296};Ce.sign=Pe(Math.sign,function(e){return 0===(e=+e)||e!=e?e:0<e?1:-1}),Ce.signNotZero=function(e){return e<0?-1:1},Ce.toSNorm=function(e,t){return t=Pe(t,255),Math.round((.5*Ce.clamp(e,-1,1)+.5)*t)},Ce.fromSNorm=function(e,t){return t=Pe(t,255),Ce.clamp(e,0,t)/t*2-1},Ce.normalize=function(e,t,n){return 0===(n=Math.max(n-t,0))?0:Ce.clamp((e-t)/n,0,1)},Ce.sinh=Pe(Math.sinh,function(e){return(Math.exp(e)-Math.exp(-e))/2}),Ce.cosh=Pe(Math.cosh,function(e){return(Math.exp(e)+Math.exp(-e))/2}),Ce.lerp=function(e,t,n){return(1-n)*e+n*t},Ce.PI=Math.PI,Ce.ONE_OVER_PI=1/Math.PI,Ce.PI_OVER_TWO=Math.PI/2,Ce.PI_OVER_THREE=Math.PI/3,Ce.PI_OVER_FOUR=Math.PI/4,Ce.PI_OVER_SIX=Math.PI/6,Ce.THREE_PI_OVER_TWO=3*Math.PI/2,Ce.TWO_PI=2*Math.PI,Ce.ONE_OVER_TWO_PI=1/(2*Math.PI),Ce.RADIANS_PER_DEGREE=Math.PI/180,Ce.DEGREES_PER_RADIAN=180/Math.PI,Ce.RADIANS_PER_ARCSECOND=Ce.RADIANS_PER_DEGREE/3600,Ce.toRadians=function(e){return e*Ce.RADIANS_PER_DEGREE},Ce.toDegrees=function(e){return e*Ce.DEGREES_PER_RADIAN},Ce.convertLongitudeRange=function(e){var t=Ce.TWO_PI,e=e-Math.floor(e/t)*t;return e<-Math.PI?e+t:e>=Math.PI?e-t:e},Ce.clampToLatitudeRange=function(e){return Ce.clamp(e,-1*Ce.PI_OVER_TWO,Ce.PI_OVER_TWO)},Ce.negativePiToPi=function(e){return Ce.zeroToTwoPi(e+Ce.PI)-Ce.PI},Ce.zeroToTwoPi=function(e){var t=Ce.mod(e,Ce.TWO_PI);return Math.abs(t)<Ce.EPSILON14&&Math.abs(e)>Ce.EPSILON14?Ce.TWO_PI:t},Ce.mod=function(e,t){return(e%t+t)%t},Ce.equalsEpsilon=function(e,t,n,r){n=Pe(n,0),r=Pe(r,n);var i=Math.abs(e-t);return i<=r||i<=n*Math.max(Math.abs(e),Math.abs(t))},Ce.lessThan=function(e,t,n){return e-t<-n},Ce.lessThanOrEquals=function(e,t,n){return e-t<n},Ce.greaterThan=function(e,t,n){return n<e-t},Ce.greaterThanOrEquals=function(e,t,n){return-n<e-t};var a=[1];Ce.factorial=function(e){var t=a.length;if(t<=e)for(var n=a[t-1],r=t;r<=e;r++){var i=n*r;a.push(i),n=i}return a[e]},Ce.incrementWrap=function(e,t,n){return n=Pe(n,0),e=t<++e?n:e},Ce.isPowerOfTwo=function(e){return 0!==e&&0==(e&e-1)},Ce.nextPowerOfTwo=function(e){return--e,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,++e},Ce.clamp=function(e,t,n){return e<t?t:n<e?n:e};var o=new t;function De(e,t,n){this.x=Pe(e,0),this.y=Pe(t,0),this.z=Pe(n,0)}Ce.setRandomNumberSeed=function(e){o=new t(e)},Ce.nextRandomNumber=function(){return o.random()},Ce.randomBetween=function(e,t){return Ce.nextRandomNumber()*(t-e)+e},Ce.acosClamped=function(e){return Math.acos(Ce.clamp(e,-1,1))},Ce.asinClamped=function(e){return Math.asin(Ce.clamp(e,-1,1))},Ce.chordLength=function(e,t){return 2*t*Math.sin(.5*e)},Ce.logBase=function(e,t){return Math.log(e)/Math.log(t)},Ce.cbrt=Pe(Math.cbrt,function(e){var t=Math.pow(Math.abs(e),1/3);return e<0?-t:t}),Ce.log2=Pe(Math.log2,function(e){return Math.log(e)*Math.LOG2E}),Ce.fog=function(e,t){t*=e;return 1-Math.exp(-t*t)},Ce.fastApproximateAtan=function(e){return e*(-.1784*Math.abs(e)-.0663*e*e+1.0301)},Ce.fastApproximateAtan2=function(e,t){var n=Math.abs(e),r=Math.abs(t),i=Math.max(n,r),i=Math.min(n,r)/i,n=Ce.fastApproximateAtan(i);return n=Math.abs(t)>Math.abs(e)?Ce.PI_OVER_TWO-n:n,n=e<0?Ce.PI-n:n,n=t<0?-n:n},De.fromSpherical=function(e,t){Ue(t)||(t=new De);var n=e.clock,r=e.cone,i=Pe(e.magnitude,1),e=i*Math.sin(r);return t.x=e*Math.cos(n),t.y=e*Math.sin(n),t.z=i*Math.cos(r),t},De.fromElements=function(e,t,n,r){return Ue(r)?(r.x=e,r.y=t,r.z=n,r):new De(e,t,n)},De.clone=function(e,t){if(Ue(e))return Ue(t)?(t.x=e.x,t.y=e.y,t.z=e.z,t):new De(e.x,e.y,e.z)},De.fromCartesian4=De.clone,De.packedLength=3,De.pack=function(e,t,n){return n=Pe(n,0),t[n++]=e.x,t[n++]=e.y,t[n]=e.z,t},De.unpack=function(e,t,n){return t=Pe(t,0),(n=!Ue(n)?new De:n).x=e[t++],n.y=e[t++],n.z=e[t],n},De.packArray=function(e,t){var n=e.length,r=3*n;if(Ue(t)){if(!Array.isArray(t)&&t.length!==r)throw new s("If result is a typed array, it must have exactly array.length * 3 elements");t.length!==r&&(t.length=r)}else t=new Array(r);for(var i=0;i<n;++i)De.pack(e[i],t,3*i);return t},De.unpackArray=function(e,t){var n=e.length;Ue(t)?t.length=n/3:t=new Array(n/3);for(var r=0;r<n;r+=3){var i=r/3;t[i]=De.unpack(e,r,t[i])}return t},De.fromArray=De.unpack,De.maximumComponent=function(e){return Math.max(e.x,e.y,e.z)},De.minimumComponent=function(e){return Math.min(e.x,e.y,e.z)},De.minimumByComponent=function(e,t,n){return n.x=Math.min(e.x,t.x),n.y=Math.min(e.y,t.y),n.z=Math.min(e.z,t.z),n},De.maximumByComponent=function(e,t,n){return n.x=Math.max(e.x,t.x),n.y=Math.max(e.y,t.y),n.z=Math.max(e.z,t.z),n},De.magnitudeSquared=function(e){return e.x*e.x+e.y*e.y+e.z*e.z},De.magnitude=function(e){return Math.sqrt(De.magnitudeSquared(e))};var u=new De;De.distance=function(e,t){return De.subtract(e,t,u),De.magnitude(u)},De.distanceSquared=function(e,t){return De.subtract(e,t,u),De.magnitudeSquared(u)},De.normalize=function(e,t){var n=De.magnitude(e);return t.x=e.x/n,t.y=e.y/n,t.z=e.z/n,t},De.dot=function(e,t){return e.x*t.x+e.y*t.y+e.z*t.z},De.multiplyComponents=function(e,t,n){return n.x=e.x*t.x,n.y=e.y*t.y,n.z=e.z*t.z,n},De.divideComponents=function(e,t,n){return n.x=e.x/t.x,n.y=e.y/t.y,n.z=e.z/t.z,n},De.add=function(e,t,n){return n.x=e.x+t.x,n.y=e.y+t.y,n.z=e.z+t.z,n},De.subtract=function(e,t,n){return n.x=e.x-t.x,n.y=e.y-t.y,n.z=e.z-t.z,n},De.multiplyByScalar=function(e,t,n){return n.x=e.x*t,n.y=e.y*t,n.z=e.z*t,n},De.divideByScalar=function(e,t,n){return n.x=e.x/t,n.y=e.y/t,n.z=e.z/t,n},De.negate=function(e,t){return t.x=-e.x,t.y=-e.y,t.z=-e.z,t},De.abs=function(e,t){return t.x=Math.abs(e.x),t.y=Math.abs(e.y),t.z=Math.abs(e.z),t};var c=new De;De.lerp=function(e,t,n,r){return De.multiplyByScalar(t,n,c),r=De.multiplyByScalar(e,1-n,r),De.add(c,r,r)};var l=new De,f=new De;De.angleBetween=function(e,t){De.normalize(e,l),De.normalize(t,f);e=De.dot(l,f),t=De.magnitude(De.cross(l,f,l));return Math.atan2(t,e)};var h=new De;De.mostOrthogonalAxis=function(e,t){e=De.normalize(e,h);return De.abs(e,e),t=e.x<=e.y?e.x<=e.z?De.clone(De.UNIT_X,t):De.clone(De.UNIT_Z,t):e.y<=e.z?De.clone(De.UNIT_Y,t):De.clone(De.UNIT_Z,t)},De.projectVector=function(e,t,n){e=De.dot(e,t)/De.dot(t,t);return De.multiplyByScalar(t,e,n)},De.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&e.x===t.x&&e.y===t.y&&e.z===t.z},De.equalsArray=function(e,t,n){return e.x===t[n]&&e.y===t[n+1]&&e.z===t[n+2]},De.equalsEpsilon=function(e,t,n,r){return e===t||Ue(e)&&Ue(t)&&Ce.equalsEpsilon(e.x,t.x,n,r)&&Ce.equalsEpsilon(e.y,t.y,n,r)&&Ce.equalsEpsilon(e.z,t.z,n,r)},De.cross=function(e,t,n){var r=e.x,i=e.y,a=e.z,o=t.x,s=t.y,e=t.z,t=i*e-a*s,e=a*o-r*e,o=r*s-i*o;return n.x=t,n.y=e,n.z=o,n},De.midpoint=function(e,t,n){return n.x=.5*(e.x+t.x),n.y=.5*(e.y+t.y),n.z=.5*(e.z+t.z),n},De.fromDegrees=function(e,t,n,r,i){return e=Ce.toRadians(e),t=Ce.toRadians(t),De.fromRadians(e,t,n,r,i)};var d=new De,m=new De,p=new De(40680631590769,40680631590769,40408299984661.445);De.fromRadians=function(e,t,n,r,i){n=Pe(n,0);var a=Ue(r)?r.radiiSquared:p,r=Math.cos(t);d.x=r*Math.cos(e),d.y=r*Math.sin(e),d.z=Math.sin(t),d=De.normalize(d,d),De.multiplyComponents(a,d,m);a=Math.sqrt(De.dot(d,m));return m=De.divideByScalar(m,a,m),d=De.multiplyByScalar(d,n,d),Ue(i)||(i=new De),De.add(m,d,i)},De.fromDegreesArray=function(e,t,n){var r=e.length;Ue(n)?n.length=r/2:n=new Array(r/2);for(var i=0;i<r;i+=2){var a=e[i],o=e[i+1],s=i/2;n[s]=De.fromDegrees(a,o,0,t,n[s])}return n},De.fromRadiansArray=function(e,t,n){var r=e.length;Ue(n)?n.length=r/2:n=new Array(r/2);for(var i=0;i<r;i+=2){var a=e[i],o=e[i+1],s=i/2;n[s]=De.fromRadians(a,o,0,t,n[s])}return n},De.fromDegreesArrayHeights=function(e,t,n){var r=e.length;Ue(n)?n.length=r/3:n=new Array(r/3);for(var i=0;i<r;i+=3){var a=e[i],o=e[i+1],s=e[i+2],u=i/3;n[u]=De.fromDegrees(a,o,s,t,n[u])}return n},De.fromRadiansArrayHeights=function(e,t,n){var r=e.length;Ue(n)?n.length=r/3:n=new Array(r/3);for(var i=0;i<r;i+=3){var a=e[i],o=e[i+1],s=e[i+2],u=i/3;n[u]=De.fromRadians(a,o,s,t,n[u])}return n},De.ZERO=Object.freeze(new De(0,0,0)),De.UNIT_X=Object.freeze(new De(1,0,0)),De.UNIT_Y=Object.freeze(new De(0,1,0)),De.UNIT_Z=Object.freeze(new De(0,0,1)),De.prototype.clone=function(e){return De.clone(this,e)},De.prototype.equals=function(e){return De.equals(this,e)},De.prototype.equalsEpsilon=function(e,t,n){return De.equalsEpsilon(this,e,t,n)},De.prototype.toString=function(){return"("+this.x+", "+this.y+", "+this.z+")"};var I=new De,M=new De;function E(e,t,n,r,i){var a=e.x,o=e.y,s=e.z,u=t.x,c=t.y,t=t.z,l=a*a*u*u,f=o*o*c*c,h=s*s*t*t,u=l+f+h,c=Math.sqrt(1/u),t=De.multiplyByScalar(e,c,I);if(u<r)return isFinite(c)?De.clone(t,i):void 0;var d=n.x,m=n.y,p=n.z,n=M;n.x=t.x*d*2,n.y=t.y*m*2,n.z=t.z*p*2;var E,y,_,T,R,A,g,S=(1-c)*De.magnitude(e)/(.5*De.magnitude(n)),w=0;do{w=(E=l*(R=(y=1/(1+(S-=w)*d))*y)+f*(A=(_=1/(1+S*m))*_)+h*(g=(T=1/(1+S*p))*T)-1)/(-2*(l*(R*y)*d+f*(A*_)*m+h*(g*T)*p))}while(Math.abs(E)>Ce.EPSILON12);return Ue(i)?(i.x=a*y,i.y=o*_,i.z=s*T,i):new De(a*y,o*_,s*T)}function R(e,t,n){this.longitude=Pe(e,0),this.latitude=Pe(t,0),this.height=Pe(n,0)}R.fromRadians=function(e,t,n,r){return n=Pe(n,0),Ue(r)?(r.longitude=e,r.latitude=t,r.height=n,r):new R(e,t,n)},R.fromDegrees=function(e,t,n,r){return e=Ce.toRadians(e),t=Ce.toRadians(t),R.fromRadians(e,t,n,r)};var y=new De,_=new De,T=new De,A=new De(1/6378137,1/6378137,1/6356752.314245179),g=new De(1/40680631590769,1/40680631590769,1/40408299984661.445),S=Ce.EPSILON1;function w(e,t,n,r){t=Pe(t,0),n=Pe(n,0),r=Pe(r,0),e._radii=new De(t,n,r),e._radiiSquared=new De(t*t,n*n,r*r),e._radiiToTheFourth=new De(t*t*t*t,n*n*n*n,r*r*r*r),e._oneOverRadii=new De(0===t?0:1/t,0===n?0:1/n,0===r?0:1/r),e._oneOverRadiiSquared=new De(0===t?0:1/(t*t),0===n?0:1/(n*n),0===r?0:1/(r*r)),e._minimumRadius=Math.min(t,n,r),e._maximumRadius=Math.max(t,n,r),e._centerToleranceSquared=Ce.EPSILON1,0!==e._radiiSquared.z&&(e._squaredXOverSquaredZ=e._radiiSquared.x/e._radiiSquared.z)}function be(e,t,n){this._radii=void 0,this._radiiSquared=void 0,this._radiiToTheFourth=void 0,this._oneOverRadii=void 0,this._oneOverRadiiSquared=void 0,this._minimumRadius=void 0,this._maximumRadius=void 0,this._centerToleranceSquared=void 0,this._squaredXOverSquaredZ=void 0,w(this,e,t,n)}R.fromCartesian=function(e,t,n){var r=Ue(t)?t.oneOverRadii:A,i=Ue(t)?t.oneOverRadiiSquared:g,r=E(e,r,i,Ue(t)?t._centerToleranceSquared:S,_);if(Ue(r)){t=De.multiplyComponents(r,i,y),t=De.normalize(t,t),i=De.subtract(e,r,T),r=Math.atan2(t.y,t.x),t=Math.asin(t.z),i=Ce.sign(De.dot(i,e))*De.magnitude(i);return Ue(n)?(n.longitude=r,n.latitude=t,n.height=i,n):new R(r,t,i)}},R.toCartesian=function(e,t,n){return De.fromRadians(e.longitude,e.latitude,e.height,t,n)},R.clone=function(e,t){if(Ue(e))return Ue(t)?(t.longitude=e.longitude,t.latitude=e.latitude,t.height=e.height,t):new R(e.longitude,e.latitude,e.height)},R.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&e.longitude===t.longitude&&e.latitude===t.latitude&&e.height===t.height},R.equalsEpsilon=function(e,t,n){return n=Pe(n,0),e===t||Ue(e)&&Ue(t)&&Math.abs(e.longitude-t.longitude)<=n&&Math.abs(e.latitude-t.latitude)<=n&&Math.abs(e.height-t.height)<=n},R.ZERO=Object.freeze(new R(0,0,0)),R.prototype.clone=function(e){return R.clone(this,e)},R.prototype.equals=function(e){return R.equals(this,e)},R.prototype.equalsEpsilon=function(e,t){return R.equalsEpsilon(this,e,t)},R.prototype.toString=function(){return"("+this.longitude+", "+this.latitude+", "+this.height+")"},Object.defineProperties(be.prototype,{radii:{get:function(){return this._radii}},radiiSquared:{get:function(){return this._radiiSquared}},radiiToTheFourth:{get:function(){return this._radiiToTheFourth}},oneOverRadii:{get:function(){return this._oneOverRadii}},oneOverRadiiSquared:{get:function(){return this._oneOverRadiiSquared}},minimumRadius:{get:function(){return this._minimumRadius}},maximumRadius:{get:function(){return this._maximumRadius}}}),be.clone=function(e,t){if(Ue(e)){var n=e._radii;return Ue(t)?(De.clone(n,t._radii),De.clone(e._radiiSquared,t._radiiSquared),De.clone(e._radiiToTheFourth,t._radiiToTheFourth),De.clone(e._oneOverRadii,t._oneOverRadii),De.clone(e._oneOverRadiiSquared,t._oneOverRadiiSquared),t._minimumRadius=e._minimumRadius,t._maximumRadius=e._maximumRadius,t._centerToleranceSquared=e._centerToleranceSquared,t):new be(n.x,n.y,n.z)}},be.fromCartesian3=function(e,t){return Ue(t)||(t=new be),Ue(e)&&w(t,e.x,e.y,e.z),t},be.WGS84=Object.freeze(new be(6378137,6378137,6356752.314245179)),be.UNIT_SPHERE=Object.freeze(new be(1,1,1)),be.MOON=Object.freeze(new be(Ce.LUNAR_RADIUS,Ce.LUNAR_RADIUS,Ce.LUNAR_RADIUS)),be.prototype.clone=function(e){return be.clone(this,e)},be.packedLength=De.packedLength,be.pack=function(e,t,n){return n=Pe(n,0),De.pack(e._radii,t,n),t},be.unpack=function(e,t,n){t=Pe(t,0);t=De.unpack(e,t);return be.fromCartesian3(t,n)},be.prototype.geocentricSurfaceNormal=De.normalize,be.prototype.geodeticSurfaceNormalCartographic=function(e,t){var n=e.longitude,r=e.latitude,i=Math.cos(r),e=i*Math.cos(n),n=i*Math.sin(n),r=Math.sin(r);return(t=!Ue(t)?new De:t).x=e,t.y=n,t.z=r,De.normalize(t,t)},be.prototype.geodeticSurfaceNormal=function(e,t){if(!De.equalsEpsilon(e,De.ZERO,Ce.EPSILON14))return Ue(t)||(t=new De),t=De.multiplyComponents(e,this._oneOverRadiiSquared,t),De.normalize(t,t)};var O=new De,N=new De;be.prototype.cartographicToCartesian=function(e,t){var n=O,r=N;this.geodeticSurfaceNormalCartographic(e,n),De.multiplyComponents(this._radiiSquared,n,r);var i=Math.sqrt(De.dot(n,r));return De.divideByScalar(r,i,r),De.multiplyByScalar(n,e.height,n),Ue(t)||(t=new De),De.add(r,n,t)},be.prototype.cartographicArrayToCartesianArray=function(e,t){var n=e.length;Ue(t)?t.length=n:t=new Array(n);for(var r=0;r<n;r++)t[r]=this.cartographicToCartesian(e[r],t[r]);return t};var x=new De,v=new De,U=new De;be.prototype.cartesianToCartographic=function(e,t){var n=this.scaleToGeodeticSurface(e,v);if(Ue(n)){var r=this.geodeticSurfaceNormal(n,x),i=De.subtract(e,n,U),n=Math.atan2(r.y,r.x),r=Math.asin(r.z),i=Ce.sign(De.dot(i,e))*De.magnitude(i);return Ue(t)?(t.longitude=n,t.latitude=r,t.height=i,t):new R(n,r,i)}},be.prototype.cartesianArrayToCartographicArray=function(e,t){var n=e.length;Ue(t)?t.length=n:t=new Array(n);for(var r=0;r<n;++r)t[r]=this.cartesianToCartographic(e[r],t[r]);return t},be.prototype.scaleToGeodeticSurface=function(e,t){return E(e,this._oneOverRadii,this._oneOverRadiiSquared,this._centerToleranceSquared,t)},be.prototype.scaleToGeocentricSurface=function(e,t){Ue(t)||(t=new De);var n=e.x,r=e.y,i=e.z,a=this._oneOverRadiiSquared,a=1/Math.sqrt(n*n*a.x+r*r*a.y+i*i*a.z);return De.multiplyByScalar(e,a,t)},be.prototype.transformPositionToScaledSpace=function(e,t){return Ue(t)||(t=new De),De.multiplyComponents(e,this._oneOverRadii,t)},be.prototype.transformPositionFromScaledSpace=function(e,t){return Ue(t)||(t=new De),De.multiplyComponents(e,this._radii,t)},be.prototype.equals=function(e){return this===e||Ue(e)&&De.equals(this._radii,e._radii)},be.prototype.toString=function(){return this._radii.toString()},be.prototype.getSurfaceNormalIntersectionWithZAxis=function(e,t,n){t=Pe(t,0);var r=this._squaredXOverSquaredZ;if((n=!Ue(n)?new De:n).x=0,n.y=0,n.z=e.z*(1-r),!(Math.abs(n.z)>=this._radii.z-t))return n};var P=[.14887433898163,.43339539412925,.67940956829902,.86506336668898,.97390652851717,0],C=[.29552422471475,.26926671930999,.21908636251598,.14945134915058,.066671344308684,0];function D(e,t,n){for(var r=.5*(t+e),i=.5*(t-e),a=0,o=0;o<5;o++){var s=i*P[o];a+=C[o]*(n(r+s)+n(r-s))}return a*=i}be.prototype.surfaceArea=function(e){for(var t=e.west,i=e.east,n=e.south,r=e.north;i<t;)i+=Ce.TWO_PI;var e=this._radiiSquared,a=e.x,o=e.y,s=e.z,u=a*o;return D(n,r,function(e){var n=Math.cos(e),r=Math.sin(e);return Math.cos(e)*D(t,i,function(e){var t=Math.cos(e),e=Math.sin(e);return Math.sqrt(u*r*r+s*(o*t*t+a*e*e)*n*n)})})};var e={NONE:0,LERC:1},b=Object.freeze(e),L={OUTSIDE:-1,INTERSECTING:0,INSIDE:1},F=Object.freeze(L);function Le(e,t,n){this.minimum=De.clone(Pe(e,De.ZERO)),this.maximum=De.clone(Pe(t,De.ZERO)),n=Ue(n)?De.clone(n):De.midpoint(this.minimum,this.maximum,new De),this.center=n}Le.fromPoints=function(e,t){if(Ue(t)||(t=new Le),!Ue(e)||0===e.length)return t.minimum=De.clone(De.ZERO,t.minimum),t.maximum=De.clone(De.ZERO,t.maximum),t.center=De.clone(De.ZERO,t.center),t;for(var n=e[0].x,r=e[0].y,i=e[0].z,a=e[0].x,o=e[0].y,s=e[0].z,u=e.length,c=1;c<u;c++)var l=e[c],f=l.x,h=l.y,l=l.z,n=Math.min(f,n),a=Math.max(f,a),r=Math.min(h,r),o=Math.max(h,o),i=Math.min(l,i),s=Math.max(l,s);var d=t.minimum;d.x=n,d.y=r,d.z=i;var m=t.maximum;return m.x=a,m.y=o,m.z=s,t.center=De.midpoint(d,m,t.center),t},Le.clone=function(e,t){if(Ue(e))return Ue(t)?(t.minimum=De.clone(e.minimum,t.minimum),t.maximum=De.clone(e.maximum,t.maximum),t.center=De.clone(e.center,t.center),t):new Le(e.minimum,e.maximum,e.center)},Le.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&De.equals(e.center,t.center)&&De.equals(e.minimum,t.minimum)&&De.equals(e.maximum,t.maximum)};var B=new De;function z(e){this._ellipsoid=Pe(e,be.WGS84),this._semimajorAxis=this._ellipsoid.maximumRadius,this._oneOverSemimajorAxis=1/this._semimajorAxis}function q(e,t){this.start=Pe(e,0),this.stop=Pe(t,0)}function V(e,t,n,r,i,a,o,s,u){this[0]=Pe(e,0),this[1]=Pe(r,0),this[2]=Pe(o,0),this[3]=Pe(t,0),this[4]=Pe(i,0),this[5]=Pe(s,0),this[6]=Pe(n,0),this[7]=Pe(a,0),this[8]=Pe(u,0)}Le.intersectPlane=function(e,t){B=De.subtract(e.maximum,e.minimum,B);var n=De.multiplyByScalar(B,.5,B),r=t.normal,n=n.x*Math.abs(r.x)+n.y*Math.abs(r.y)+n.z*Math.abs(r.z),t=De.dot(e.center,r)+t.distance;return 0<t-n?F.INSIDE:t+n<0?F.OUTSIDE:F.INTERSECTING},Le.prototype.clone=function(e){return Le.clone(this,e)},Le.prototype.intersectPlane=function(e){return Le.intersectPlane(this,e)},Le.prototype.equals=function(e){return Le.equals(this,e)},Object.defineProperties(z.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}}),z.prototype.project=function(e,t){var n=this._semimajorAxis,r=e.longitude*n,n=e.latitude*n,e=e.height;return Ue(t)?(t.x=r,t.y=n,t.z=e,t):new De(r,n,e)},z.prototype.unproject=function(e,t){var n=this._oneOverSemimajorAxis,r=e.x*n,n=e.y*n,e=e.z;return Ue(t)?(t.longitude=r,t.latitude=n,t.height=e,t):new R(r,n,e)},V.packedLength=9,V.pack=function(e,t,n){return n=Pe(n,0),t[n++]=e[0],t[n++]=e[1],t[n++]=e[2],t[n++]=e[3],t[n++]=e[4],t[n++]=e[5],t[n++]=e[6],t[n++]=e[7],t[n++]=e[8],t},V.unpack=function(e,t,n){return t=Pe(t,0),(n=!Ue(n)?new V:n)[0]=e[t++],n[1]=e[t++],n[2]=e[t++],n[3]=e[t++],n[4]=e[t++],n[5]=e[t++],n[6]=e[t++],n[7]=e[t++],n[8]=e[t++],n},V.clone=function(e,t){if(Ue(e))return Ue(t)?(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t):new V(e[0],e[3],e[6],e[1],e[4],e[7],e[2],e[5],e[8])},V.fromArray=function(e,t,n){return t=Pe(t,0),(n=!Ue(n)?new V:n)[0]=e[t],n[1]=e[t+1],n[2]=e[t+2],n[3]=e[t+3],n[4]=e[t+4],n[5]=e[t+5],n[6]=e[t+6],n[7]=e[t+7],n[8]=e[t+8],n},V.fromColumnMajorArray=function(e,t){return V.clone(e,t)},V.fromRowMajorArray=function(e,t){return Ue(t)?(t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],t):new V(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])},V.fromQuaternion=function(e,t){var n=e.x*e.x,r=e.x*e.y,i=e.x*e.z,a=e.x*e.w,o=e.y*e.y,s=e.y*e.z,u=e.y*e.w,c=e.z*e.z,l=e.z*e.w,f=e.w*e.w,h=n-o-c+f,d=2*(r-l),m=2*(i+u),e=2*(r+l),r=o-n-c+f,l=2*(s-a),u=2*(i-u),a=2*(s+a),f=-n-o+c+f;return Ue(t)?(t[0]=h,t[1]=e,t[2]=u,t[3]=d,t[4]=r,t[5]=a,t[6]=m,t[7]=l,t[8]=f,t):new V(h,d,m,e,r,l,u,a,f)},V.fromHeadingPitchRoll=function(e,t){var n=Math.cos(-e.pitch),r=Math.cos(-e.heading),i=Math.cos(e.roll),a=Math.sin(-e.pitch),o=Math.sin(-e.heading),s=Math.sin(e.roll),u=n*r,c=-i*o+s*a*r,l=s*o+i*a*r,f=n*o,e=i*r+s*a*o,o=-s*r+i*a*o,a=-a,s=s*n,n=i*n;return Ue(t)?(t[0]=u,t[1]=f,t[2]=a,t[3]=c,t[4]=e,t[5]=s,t[6]=l,t[7]=o,t[8]=n,t):new V(u,c,l,f,e,o,a,s,n)},V.fromScale=function(e,t){return Ue(t)?(t[0]=e.x,t[1]=0,t[2]=0,t[3]=0,t[4]=e.y,t[5]=0,t[6]=0,t[7]=0,t[8]=e.z,t):new V(e.x,0,0,0,e.y,0,0,0,e.z)},V.fromUniformScale=function(e,t){return Ue(t)?(t[0]=e,t[1]=0,t[2]=0,t[3]=0,t[4]=e,t[5]=0,t[6]=0,t[7]=0,t[8]=e,t):new V(e,0,0,0,e,0,0,0,e)},V.fromCrossProduct=function(e,t){return Ue(t)?(t[0]=0,t[1]=e.z,t[2]=-e.y,t[3]=-e.z,t[4]=0,t[5]=e.x,t[6]=e.y,t[7]=-e.x,t[8]=0,t):new V(0,-e.z,e.y,e.z,0,-e.x,-e.y,e.x,0)},V.fromRotationX=function(e,t){var n=Math.cos(e),e=Math.sin(e);return Ue(t)?(t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=n,t[5]=e,t[6]=0,t[7]=-e,t[8]=n,t):new V(1,0,0,0,n,-e,0,e,n)},V.fromRotationY=function(e,t){var n=Math.cos(e),e=Math.sin(e);return Ue(t)?(t[0]=n,t[1]=0,t[2]=-e,t[3]=0,t[4]=1,t[5]=0,t[6]=e,t[7]=0,t[8]=n,t):new V(n,0,e,0,1,0,-e,0,n)},V.fromRotationZ=function(e,t){var n=Math.cos(e),e=Math.sin(e);return Ue(t)?(t[0]=n,t[1]=e,t[2]=0,t[3]=-e,t[4]=n,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t):new V(n,-e,0,e,n,0,0,0,1)},V.toArray=function(e,t){return Ue(t)?(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t):[e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8]]},V.getElementIndex=function(e,t){return 3*e+t},V.getColumn=function(e,t,n){var r=3*t,i=e[r],t=e[1+r],r=e[2+r];return n.x=i,n.y=t,n.z=r,n},V.setColumn=function(e,t,n,r){t*=3;return(r=V.clone(e,r))[t]=n.x,r[1+t]=n.y,r[2+t]=n.z,r},V.getRow=function(e,t,n){var r=e[t],i=e[t+3],t=e[t+6];return n.x=r,n.y=i,n.z=t,n},V.setRow=function(e,t,n,r){return(r=V.clone(e,r))[t]=n.x,r[t+3]=n.y,r[t+6]=n.z,r};var k=new De;V.getScale=function(e,t){return t.x=De.magnitude(De.fromElements(e[0],e[1],e[2],k)),t.y=De.magnitude(De.fromElements(e[3],e[4],e[5],k)),t.z=De.magnitude(De.fromElements(e[6],e[7],e[8],k)),t};var G=new De;V.getMaximumScale=function(e){return V.getScale(e,G),De.maximumComponent(G)},V.multiply=function(e,t,n){var r=e[0]*t[0]+e[3]*t[1]+e[6]*t[2],i=e[1]*t[0]+e[4]*t[1]+e[7]*t[2],a=e[2]*t[0]+e[5]*t[1]+e[8]*t[2],o=e[0]*t[3]+e[3]*t[4]+e[6]*t[5],s=e[1]*t[3]+e[4]*t[4]+e[7]*t[5],u=e[2]*t[3]+e[5]*t[4]+e[8]*t[5],c=e[0]*t[6]+e[3]*t[7]+e[6]*t[8],l=e[1]*t[6]+e[4]*t[7]+e[7]*t[8],t=e[2]*t[6]+e[5]*t[7]+e[8]*t[8];return n[0]=r,n[1]=i,n[2]=a,n[3]=o,n[4]=s,n[5]=u,n[6]=c,n[7]=l,n[8]=t,n},V.add=function(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n[3]=e[3]+t[3],n[4]=e[4]+t[4],n[5]=e[5]+t[5],n[6]=e[6]+t[6],n[7]=e[7]+t[7],n[8]=e[8]+t[8],n},V.subtract=function(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n[3]=e[3]-t[3],n[4]=e[4]-t[4],n[5]=e[5]-t[5],n[6]=e[6]-t[6],n[7]=e[7]-t[7],n[8]=e[8]-t[8],n},V.multiplyByVector=function(e,t,n){var r=t.x,i=t.y,a=t.z,o=e[0]*r+e[3]*i+e[6]*a,t=e[1]*r+e[4]*i+e[7]*a,a=e[2]*r+e[5]*i+e[8]*a;return n.x=o,n.y=t,n.z=a,n},V.multiplyByScalar=function(e,t,n){return n[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n[3]=e[3]*t,n[4]=e[4]*t,n[5]=e[5]*t,n[6]=e[6]*t,n[7]=e[7]*t,n[8]=e[8]*t,n},V.multiplyByScale=function(e,t,n){return n[0]=e[0]*t.x,n[1]=e[1]*t.x,n[2]=e[2]*t.x,n[3]=e[3]*t.y,n[4]=e[4]*t.y,n[5]=e[5]*t.y,n[6]=e[6]*t.z,n[7]=e[7]*t.z,n[8]=e[8]*t.z,n},V.negate=function(e,t){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t[4]=-e[4],t[5]=-e[5],t[6]=-e[6],t[7]=-e[7],t[8]=-e[8],t},V.transpose=function(e,t){var n=e[0],r=e[3],i=e[6],a=e[1],o=e[4],s=e[7],u=e[2],c=e[5],e=e[8];return t[0]=n,t[1]=r,t[2]=i,t[3]=a,t[4]=o,t[5]=s,t[6]=u,t[7]=c,t[8]=e,t};var X=new De(1,1,1);function W(e){for(var t=0,n=0;n<9;++n){var r=e[n];t+=r*r}return Math.sqrt(t)}V.getRotation=function(e,t){var n=De.divideComponents(X,V.getScale(e,G),G);return t=V.multiplyByScale(e,n,t)};var H=[1,0,0],Y=[2,2,1];function j(e){for(var t=0,n=0;n<3;++n){var r=e[V.getElementIndex(Y[n],H[n])];t+=2*r*r}return Math.sqrt(t)}function Z(e,t){for(var n=Ce.EPSILON15,r=0,i=1,a=0;a<3;++a){var o=Math.abs(e[V.getElementIndex(Y[a],H[a])]);r<o&&(i=a,r=o)}var s=1,u=0,c=H[i],l=Y[i];return Math.abs(e[V.getElementIndex(l,c)])>n&&(u=(n=(n=(e[V.getElementIndex(l,l)]-e[V.getElementIndex(c,c)])/2/e[V.getElementIndex(l,c)])<0?-1/(-n+Math.sqrt(1+n*n)):1/(n+Math.sqrt(1+n*n)))*(s=1/Math.sqrt(1+n*n))),(t=V.clone(V.IDENTITY,t))[V.getElementIndex(c,c)]=t[V.getElementIndex(l,l)]=s,t[V.getElementIndex(l,c)]=u,t[V.getElementIndex(c,l)]=-u,t}var K=new V,J=new V;V.computeEigenDecomposition=function(e,t){for(var n=Ce.EPSILON20,r=0,i=0,a=(t=!Ue(t)?{}:t).unitary=V.clone(V.IDENTITY,t.unitary),o=t.diagonal=V.clone(e,t.diagonal),s=n*W(o);i<10&&j(o)>s;)Z(o,K),V.transpose(K,J),V.multiply(o,K,o),V.multiply(J,o,o),V.multiply(a,K,a),2<++r&&(++i,r=0);return t},V.abs=function(e,t){return t[0]=Math.abs(e[0]),t[1]=Math.abs(e[1]),t[2]=Math.abs(e[2]),t[3]=Math.abs(e[3]),t[4]=Math.abs(e[4]),t[5]=Math.abs(e[5]),t[6]=Math.abs(e[6]),t[7]=Math.abs(e[7]),t[8]=Math.abs(e[8]),t},V.determinant=function(e){var t=e[0],n=e[3],r=e[6],i=e[1],a=e[4],o=e[7],s=e[2],u=e[5],e=e[8];return t*(a*e-u*o)+i*(u*r-n*e)+s*(n*o-a*r)},V.inverse=function(e,t){var n=e[0],r=e[1],i=e[2],a=e[3],o=e[4],s=e[5],u=e[6],c=e[7],l=e[8],e=V.determinant(e);t[0]=o*l-c*s,t[1]=c*i-r*l,t[2]=r*s-o*i,t[3]=u*s-a*l,t[4]=n*l-u*i,t[5]=a*i-n*s,t[6]=a*c-u*o,t[7]=u*r-n*c,t[8]=n*o-a*r;e=1/e;return V.multiplyByScalar(t,e,t)};var Q=new V;function $(e,t,n,r){this.x=Pe(e,0),this.y=Pe(t,0),this.z=Pe(n,0),this.w=Pe(r,0)}V.inverseTranspose=function(e,t){return V.inverse(V.transpose(e,Q),t)},V.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]},V.equalsEpsilon=function(e,t,n){return n=Pe(n,0),e===t||Ue(e)&&Ue(t)&&Math.abs(e[0]-t[0])<=n&&Math.abs(e[1]-t[1])<=n&&Math.abs(e[2]-t[2])<=n&&Math.abs(e[3]-t[3])<=n&&Math.abs(e[4]-t[4])<=n&&Math.abs(e[5]-t[5])<=n&&Math.abs(e[6]-t[6])<=n&&Math.abs(e[7]-t[7])<=n&&Math.abs(e[8]-t[8])<=n},V.IDENTITY=Object.freeze(new V(1,0,0,0,1,0,0,0,1)),V.ZERO=Object.freeze(new V(0,0,0,0,0,0,0,0,0)),V.COLUMN0ROW0=0,V.COLUMN0ROW1=1,V.COLUMN0ROW2=2,V.COLUMN1ROW0=3,V.COLUMN1ROW1=4,V.COLUMN1ROW2=5,V.COLUMN2ROW0=6,V.COLUMN2ROW1=7,V.COLUMN2ROW2=8,Object.defineProperties(V.prototype,{length:{get:function(){return V.packedLength}}}),V.prototype.clone=function(e){return V.clone(this,e)},V.prototype.equals=function(e){return V.equals(this,e)},V.equalsArray=function(e,t,n){return e[0]===t[n]&&e[1]===t[n+1]&&e[2]===t[n+2]&&e[3]===t[n+3]&&e[4]===t[n+4]&&e[5]===t[n+5]&&e[6]===t[n+6]&&e[7]===t[n+7]&&e[8]===t[n+8]},V.prototype.equalsEpsilon=function(e,t){return V.equalsEpsilon(this,e,t)},V.prototype.toString=function(){return"("+this[0]+", "+this[3]+", "+this[6]+")\\n("+this[1]+", "+this[4]+", "+this[7]+")\\n("+this[2]+", "+this[5]+", "+this[8]+")"},$.fromElements=function(e,t,n,r,i){return Ue(i)?(i.x=e,i.y=t,i.z=n,i.w=r,i):new $(e,t,n,r)},$.fromColor=function(e,t){return Ue(t)?(t.x=e.red,t.y=e.green,t.z=e.blue,t.w=e.alpha,t):new $(e.red,e.green,e.blue,e.alpha)},$.clone=function(e,t){if(Ue(e))return Ue(t)?(t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t):new $(e.x,e.y,e.z,e.w)},$.packedLength=4,$.pack=function(e,t,n){return n=Pe(n,0),t[n++]=e.x,t[n++]=e.y,t[n++]=e.z,t[n]=e.w,t},$.unpack=function(e,t,n){return t=Pe(t,0),(n=!Ue(n)?new $:n).x=e[t++],n.y=e[t++],n.z=e[t++],n.w=e[t],n},$.packArray=function(e,t){var n=e.length,r=4*n;if(Ue(t)){if(!Array.isArray(t)&&t.length!==r)throw new s("If result is a typed array, it must have exactly array.length * 4 elements");t.length!==r&&(t.length=r)}else t=new Array(r);for(var i=0;i<n;++i)$.pack(e[i],t,4*i);return t},$.unpackArray=function(e,t){var n=e.length;Ue(t)?t.length=n/4:t=new Array(n/4);for(var r=0;r<n;r+=4){var i=r/4;t[i]=$.unpack(e,r,t[i])}return t},$.fromArray=$.unpack,$.maximumComponent=function(e){return Math.max(e.x,e.y,e.z,e.w)},$.minimumComponent=function(e){return Math.min(e.x,e.y,e.z,e.w)},$.minimumByComponent=function(e,t,n){return n.x=Math.min(e.x,t.x),n.y=Math.min(e.y,t.y),n.z=Math.min(e.z,t.z),n.w=Math.min(e.w,t.w),n},$.maximumByComponent=function(e,t,n){return n.x=Math.max(e.x,t.x),n.y=Math.max(e.y,t.y),n.z=Math.max(e.z,t.z),n.w=Math.max(e.w,t.w),n},$.magnitudeSquared=function(e){return e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w},$.magnitude=function(e){return Math.sqrt($.magnitudeSquared(e))};var ee=new $;$.distance=function(e,t){return $.subtract(e,t,ee),$.magnitude(ee)},$.distanceSquared=function(e,t){return $.subtract(e,t,ee),$.magnitudeSquared(ee)},$.normalize=function(e,t){var n=$.magnitude(e);return t.x=e.x/n,t.y=e.y/n,t.z=e.z/n,t.w=e.w/n,t},$.dot=function(e,t){return e.x*t.x+e.y*t.y+e.z*t.z+e.w*t.w},$.multiplyComponents=function(e,t,n){return n.x=e.x*t.x,n.y=e.y*t.y,n.z=e.z*t.z,n.w=e.w*t.w,n},$.divideComponents=function(e,t,n){return n.x=e.x/t.x,n.y=e.y/t.y,n.z=e.z/t.z,n.w=e.w/t.w,n},$.add=function(e,t,n){return n.x=e.x+t.x,n.y=e.y+t.y,n.z=e.z+t.z,n.w=e.w+t.w,n},$.subtract=function(e,t,n){return n.x=e.x-t.x,n.y=e.y-t.y,n.z=e.z-t.z,n.w=e.w-t.w,n},$.multiplyByScalar=function(e,t,n){return n.x=e.x*t,n.y=e.y*t,n.z=e.z*t,n.w=e.w*t,n},$.divideByScalar=function(e,t,n){return n.x=e.x/t,n.y=e.y/t,n.z=e.z/t,n.w=e.w/t,n},$.negate=function(e,t){return t.x=-e.x,t.y=-e.y,t.z=-e.z,t.w=-e.w,t},$.abs=function(e,t){return t.x=Math.abs(e.x),t.y=Math.abs(e.y),t.z=Math.abs(e.z),t.w=Math.abs(e.w),t};var te=new $;$.lerp=function(e,t,n,r){return $.multiplyByScalar(t,n,te),r=$.multiplyByScalar(e,1-n,r),$.add(te,r,r)};var ne=new $;$.mostOrthogonalAxis=function(e,t){e=$.normalize(e,ne);return $.abs(e,e),t=e.x<=e.y?e.x<=e.z?e.x<=e.w?$.clone($.UNIT_X,t):$.clone($.UNIT_W,t):e.z<=e.w?$.clone($.UNIT_Z,t):$.clone($.UNIT_W,t):e.y<=e.z?e.y<=e.w?$.clone($.UNIT_Y,t):$.clone($.UNIT_W,t):e.z<=e.w?$.clone($.UNIT_Z,t):$.clone($.UNIT_W,t)},$.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&e.x===t.x&&e.y===t.y&&e.z===t.z&&e.w===t.w},$.equalsArray=function(e,t,n){return e.x===t[n]&&e.y===t[n+1]&&e.z===t[n+2]&&e.w===t[n+3]},$.equalsEpsilon=function(e,t,n,r){return e===t||Ue(e)&&Ue(t)&&Ce.equalsEpsilon(e.x,t.x,n,r)&&Ce.equalsEpsilon(e.y,t.y,n,r)&&Ce.equalsEpsilon(e.z,t.z,n,r)&&Ce.equalsEpsilon(e.w,t.w,n,r)},$.ZERO=Object.freeze(new $(0,0,0,0)),$.UNIT_X=Object.freeze(new $(1,0,0,0)),$.UNIT_Y=Object.freeze(new $(0,1,0,0)),$.UNIT_Z=Object.freeze(new $(0,0,1,0)),$.UNIT_W=Object.freeze(new $(0,0,0,1)),$.prototype.clone=function(e){return $.clone(this,e)},$.prototype.equals=function(e){return $.equals(this,e)},$.prototype.equalsEpsilon=function(e,t,n){return $.equalsEpsilon(this,e,t,n)},$.prototype.toString=function(){return"("+this.x+", "+this.y+", "+this.z+", "+this.w+")"};var re=new Float32Array(1),ie=new Uint8Array(re.buffer),ae=new Uint32Array([287454020]),oe=new Uint8Array(ae.buffer),se=68===oe[0];function ue(e){var t;this.name="RuntimeError",this.message=e;try{throw new Error}catch(e){t=e.stack}this.stack=t}function Fe(e,t,n,r,i,a,o,s,u,c,l,f,h,d,m,p){this[0]=Pe(e,0),this[1]=Pe(i,0),this[2]=Pe(u,0),this[3]=Pe(h,0),this[4]=Pe(t,0),this[5]=Pe(a,0),this[6]=Pe(c,0),this[7]=Pe(d,0),this[8]=Pe(n,0),this[9]=Pe(o,0),this[10]=Pe(l,0),this[11]=Pe(m,0),this[12]=Pe(r,0),this[13]=Pe(s,0),this[14]=Pe(f,0),this[15]=Pe(p,0)}$.packFloat=function(e,t){return Ue(t)||(t=new $),re[0]=e,se?(t.x=ie[0],t.y=ie[1],t.z=ie[2],t.w=ie[3]):(t.x=ie[3],t.y=ie[2],t.z=ie[1],t.w=ie[0]),t},$.unpackFloat=function(e){return se?(ie[0]=e.x,ie[1]=e.y,ie[2]=e.z,ie[3]=e.w):(ie[0]=e.w,ie[1]=e.z,ie[2]=e.y,ie[3]=e.x),re[0]},Ue(Object.create)&&(ue.prototype=Object.create(Error.prototype),ue.prototype.constructor=ue),ue.prototype.toString=function(){var e=this.name+": "+this.message;return Ue(this.stack)&&(e+="\\n"+this.stack.toString()),e},Fe.packedLength=16,Fe.pack=function(e,t,n){return n=Pe(n,0),t[n++]=e[0],t[n++]=e[1],t[n++]=e[2],t[n++]=e[3],t[n++]=e[4],t[n++]=e[5],t[n++]=e[6],t[n++]=e[7],t[n++]=e[8],t[n++]=e[9],t[n++]=e[10],t[n++]=e[11],t[n++]=e[12],t[n++]=e[13],t[n++]=e[14],t[n]=e[15],t},Fe.unpack=function(e,t,n){return t=Pe(t,0),(n=!Ue(n)?new Fe:n)[0]=e[t++],n[1]=e[t++],n[2]=e[t++],n[3]=e[t++],n[4]=e[t++],n[5]=e[t++],n[6]=e[t++],n[7]=e[t++],n[8]=e[t++],n[9]=e[t++],n[10]=e[t++],n[11]=e[t++],n[12]=e[t++],n[13]=e[t++],n[14]=e[t++],n[15]=e[t],n},Fe.clone=function(e,t){if(Ue(e))return Ue(t)?(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t):new Fe(e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15])},Fe.fromArray=Fe.unpack,Fe.fromColumnMajorArray=function(e,t){return Fe.clone(e,t)},Fe.fromRowMajorArray=function(e,t){return Ue(t)?(t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15],t):new Fe(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])},Fe.fromRotationTranslation=function(e,t,n){return t=Pe(t,De.ZERO),Ue(n)?(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=0,n[4]=e[3],n[5]=e[4],n[6]=e[5],n[7]=0,n[8]=e[6],n[9]=e[7],n[10]=e[8],n[11]=0,n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=1,n):new Fe(e[0],e[3],e[6],t.x,e[1],e[4],e[7],t.y,e[2],e[5],e[8],t.z,0,0,0,1)},Fe.fromTranslationQuaternionRotationScale=function(e,t,n,r){Ue(r)||(r=new Fe);var i=n.x,a=n.y,o=n.z,s=t.x*t.x,u=t.x*t.y,c=t.x*t.z,l=t.x*t.w,f=t.y*t.y,h=t.y*t.z,d=t.y*t.w,m=t.z*t.z,p=t.z*t.w,E=t.w*t.w,y=s-f-m+E,_=2*(u-p),n=2*(c+d),t=2*(u+p),u=f-s-m+E,p=2*(h-l),d=2*(c-d),l=2*(h+l),E=-s-f+m+E;return r[0]=y*i,r[1]=t*i,r[2]=d*i,r[3]=0,r[4]=_*a,r[5]=u*a,r[6]=l*a,r[7]=0,r[8]=n*o,r[9]=p*o,r[10]=E*o,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,r},Fe.fromTranslationRotationScale=function(e,t){return Fe.fromTranslationQuaternionRotationScale(e.translation,e.rotation,e.scale,t)},Fe.fromTranslation=function(e,t){return Fe.fromRotationTranslation(V.IDENTITY,e,t)},Fe.fromScale=function(e,t){return Ue(t)?(t[0]=e.x,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e.y,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e.z,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t):new Fe(e.x,0,0,0,0,e.y,0,0,0,0,e.z,0,0,0,0,1)},Fe.fromUniformScale=function(e,t){return Ue(t)?(t[0]=e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t):new Fe(e,0,0,0,0,e,0,0,0,0,e,0,0,0,0,1)};var ce=new De,le=new De,fe=new De;Fe.fromCamera=function(e,t){var n=e.position,r=e.direction,i=e.up;De.normalize(r,ce),De.normalize(De.cross(ce,i,le),le),De.normalize(De.cross(le,ce,fe),fe);var a=le.x,o=le.y,s=le.z,u=ce.x,c=ce.y,l=ce.z,f=fe.x,h=fe.y,d=fe.z,m=n.x,e=n.y,r=n.z,i=a*-m+o*-e+s*-r,n=f*-m+h*-e+d*-r,r=u*m+c*e+l*r;return Ue(t)?(t[0]=a,t[1]=f,t[2]=-u,t[3]=0,t[4]=o,t[5]=h,t[6]=-c,t[7]=0,t[8]=s,t[9]=d,t[10]=-l,t[11]=0,t[12]=i,t[13]=n,t[14]=r,t[15]=1,t):new Fe(a,o,s,i,f,h,d,n,-u,-c,-l,r,0,0,0,1)},Fe.computePerspectiveFieldOfView=function(e,t,n,r,i){var a=1/Math.tan(.5*e),e=a/t,t=(r+n)/(n-r),r=2*r*n/(n-r);return i[0]=e,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=a,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=t,i[11]=-1,i[12]=0,i[13]=0,i[14]=r,i[15]=0,i},Fe.computeOrthographicOffCenter=function(e,t,n,r,i,a,o){var s=1/(t-e),u=1/(r-n),c=1/(a-i),e=-(t+e)*s,n=-(r+n)*u,i=-(a+i)*c;return s*=2,u*=2,c*=-2,o[0]=s,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=u,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=c,o[11]=0,o[12]=e,o[13]=n,o[14]=i,o[15]=1,o},Fe.computePerspectiveOffCenter=function(e,t,n,r,i,a,o){var s=2*i/(t-e),u=2*i/(r-n),e=(t+e)/(t-e),r=(r+n)/(r-n),n=-(a+i)/(a-i),i=-2*a*i/(a-i);return o[0]=s,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=u,o[6]=0,o[7]=0,o[8]=e,o[9]=r,o[10]=n,o[11]=-1,o[12]=0,o[13]=0,o[14]=i,o[15]=0,o},Fe.computeInfinitePerspectiveOffCenter=function(e,t,n,r,i,a){var o=2*i/(t-e),s=2*i/(r-n),e=(t+e)/(t-e),n=(r+n)/(r-n),i=-2*i;return a[0]=o,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=s,a[6]=0,a[7]=0,a[8]=e,a[9]=n,a[10]=-1,a[11]=-1,a[12]=0,a[13]=0,a[14]=i,a[15]=0,a},Fe.computeViewportTransformation=function(e,t,n,r){Ue(r)||(r=new Fe),e=Pe(e,Pe.EMPTY_OBJECT);var i=Pe(e.x,0),a=Pe(e.y,0),o=Pe(e.width,0),s=Pe(e.height,0);t=Pe(t,0);var u=.5*o,e=.5*s,o=.5*((n=Pe(n,1))-t),s=e,n=o,i=i+u,e=a+e,o=t+o;return r[0]=u,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=s,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=n,r[11]=0,r[12]=i,r[13]=e,r[14]=o,r[15]=1,r},Fe.computeView=function(e,t,n,r,i){return i[0]=r.x,i[1]=n.x,i[2]=-t.x,i[3]=0,i[4]=r.y,i[5]=n.y,i[6]=-t.y,i[7]=0,i[8]=r.z,i[9]=n.z,i[10]=-t.z,i[11]=0,i[12]=-De.dot(r,e),i[13]=-De.dot(n,e),i[14]=De.dot(t,e),i[15]=1,i},Fe.toArray=function(e,t){return Ue(t)?(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t):[e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15]]},Fe.getElementIndex=function(e,t){return 4*e+t},Fe.getColumn=function(e,t,n){var r=4*t,i=e[r],a=e[1+r],t=e[2+r],r=e[3+r];return n.x=i,n.y=a,n.z=t,n.w=r,n},Fe.setColumn=function(e,t,n,r){t*=4;return(r=Fe.clone(e,r))[t]=n.x,r[1+t]=n.y,r[2+t]=n.z,r[3+t]=n.w,r},Fe.setTranslation=function(e,t,n){return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=e[15],n};var he=new De;Fe.setScale=function(e,t,n){var r=Fe.getScale(e,he),r=De.divideComponents(t,r,he);return Fe.multiplyByScale(e,r,n)},Fe.getRow=function(e,t,n){var r=e[t],i=e[t+4],a=e[t+8],t=e[t+12];return n.x=r,n.y=i,n.z=a,n.w=t,n},Fe.setRow=function(e,t,n,r){return(r=Fe.clone(e,r))[t]=n.x,r[t+4]=n.y,r[t+8]=n.z,r[t+12]=n.w,r};var de=new De;Fe.getScale=function(e,t){return t.x=De.magnitude(De.fromElements(e[0],e[1],e[2],de)),t.y=De.magnitude(De.fromElements(e[4],e[5],e[6],de)),t.z=De.magnitude(De.fromElements(e[8],e[9],e[10],de)),t};var me=new De;Fe.getMaximumScale=function(e){return Fe.getScale(e,me),De.maximumComponent(me)},Fe.multiply=function(e,t,n){var r=e[0],i=e[1],a=e[2],o=e[3],s=e[4],u=e[5],c=e[6],l=e[7],f=e[8],h=e[9],d=e[10],m=e[11],p=e[12],E=e[13],y=e[14],_=e[15],T=t[0],R=t[1],A=t[2],g=t[3],S=t[4],w=t[5],I=t[6],M=t[7],O=t[8],N=t[9],x=t[10],v=t[11],U=t[12],P=t[13],C=t[14],D=t[15],b=r*T+s*R+f*A+p*g,e=i*T+u*R+h*A+E*g,t=a*T+c*R+d*A+y*g,T=o*T+l*R+m*A+_*g,R=r*S+s*w+f*I+p*M,A=i*S+u*w+h*I+E*M,g=a*S+c*w+d*I+y*M,S=o*S+l*w+m*I+_*M,w=r*O+s*N+f*x+p*v,I=i*O+u*N+h*x+E*v,M=a*O+c*N+d*x+y*v,v=o*O+l*N+m*x+_*v,p=r*U+s*P+f*C+p*D,E=i*U+u*P+h*C+E*D,y=a*U+c*P+d*C+y*D,D=o*U+l*P+m*C+_*D;return n[0]=b,n[1]=e,n[2]=t,n[3]=T,n[4]=R,n[5]=A,n[6]=g,n[7]=S,n[8]=w,n[9]=I,n[10]=M,n[11]=v,n[12]=p,n[13]=E,n[14]=y,n[15]=D,n},Fe.add=function(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n[3]=e[3]+t[3],n[4]=e[4]+t[4],n[5]=e[5]+t[5],n[6]=e[6]+t[6],n[7]=e[7]+t[7],n[8]=e[8]+t[8],n[9]=e[9]+t[9],n[10]=e[10]+t[10],n[11]=e[11]+t[11],n[12]=e[12]+t[12],n[13]=e[13]+t[13],n[14]=e[14]+t[14],n[15]=e[15]+t[15],n},Fe.subtract=function(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n[3]=e[3]-t[3],n[4]=e[4]-t[4],n[5]=e[5]-t[5],n[6]=e[6]-t[6],n[7]=e[7]-t[7],n[8]=e[8]-t[8],n[9]=e[9]-t[9],n[10]=e[10]-t[10],n[11]=e[11]-t[11],n[12]=e[12]-t[12],n[13]=e[13]-t[13],n[14]=e[14]-t[14],n[15]=e[15]-t[15],n},Fe.multiplyTransformation=function(e,t,n){var r=e[0],i=e[1],a=e[2],o=e[4],s=e[5],u=e[6],c=e[8],l=e[9],f=e[10],h=e[12],d=e[13],m=e[14],p=t[0],E=t[1],y=t[2],_=t[4],T=t[5],R=t[6],A=t[8],g=t[9],S=t[10],w=t[12],I=t[13],M=t[14],e=r*p+o*E+c*y,t=i*p+s*E+l*y,p=a*p+u*E+f*y,E=r*_+o*T+c*R,y=i*_+s*T+l*R,_=a*_+u*T+f*R,T=r*A+o*g+c*S,R=i*A+s*g+l*S,S=a*A+u*g+f*S,h=r*w+o*I+c*M+h,d=i*w+s*I+l*M+d,m=a*w+u*I+f*M+m;return n[0]=e,n[1]=t,n[2]=p,n[3]=0,n[4]=E,n[5]=y,n[6]=_,n[7]=0,n[8]=T,n[9]=R,n[10]=S,n[11]=0,n[12]=h,n[13]=d,n[14]=m,n[15]=1,n},Fe.multiplyByMatrix3=function(e,t,n){var r=e[0],i=e[1],a=e[2],o=e[4],s=e[5],u=e[6],c=e[8],l=e[9],f=e[10],h=t[0],d=t[1],m=t[2],p=t[3],E=t[4],y=t[5],_=t[6],T=t[7],R=t[8],A=r*h+o*d+c*m,t=i*h+s*d+l*m,h=a*h+u*d+f*m,d=r*p+o*E+c*y,m=i*p+s*E+l*y,y=a*p+u*E+f*y,c=r*_+o*T+c*R,l=i*_+s*T+l*R,R=a*_+u*T+f*R;return n[0]=A,n[1]=t,n[2]=h,n[3]=0,n[4]=d,n[5]=m,n[6]=y,n[7]=0,n[8]=c,n[9]=l,n[10]=R,n[11]=0,n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15],n},Fe.multiplyByTranslation=function(e,t,n){var r=t.x,i=t.y,a=t.z,o=r*e[0]+i*e[4]+a*e[8]+e[12],t=r*e[1]+i*e[5]+a*e[9]+e[13],a=r*e[2]+i*e[6]+a*e[10]+e[14];return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=o,n[13]=t,n[14]=a,n[15]=e[15],n};var pe=new De;Fe.multiplyByUniformScale=function(e,t,n){return pe.x=t,pe.y=t,pe.z=t,Fe.multiplyByScale(e,pe,n)},Fe.multiplyByScale=function(e,t,n){var r=t.x,i=t.y,t=t.z;return 1===r&&1===i&&1===t?Fe.clone(e,n):(n[0]=r*e[0],n[1]=r*e[1],n[2]=r*e[2],n[3]=0,n[4]=i*e[4],n[5]=i*e[5],n[6]=i*e[6],n[7]=0,n[8]=t*e[8],n[9]=t*e[9],n[10]=t*e[10],n[11]=0,n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=1,n)},Fe.multiplyByVector=function(e,t,n){var r=t.x,i=t.y,a=t.z,o=t.w,s=e[0]*r+e[4]*i+e[8]*a+e[12]*o,u=e[1]*r+e[5]*i+e[9]*a+e[13]*o,t=e[2]*r+e[6]*i+e[10]*a+e[14]*o,o=e[3]*r+e[7]*i+e[11]*a+e[15]*o;return n.x=s,n.y=u,n.z=t,n.w=o,n},Fe.multiplyByPointAsVector=function(e,t,n){var r=t.x,i=t.y,a=t.z,o=e[0]*r+e[4]*i+e[8]*a,t=e[1]*r+e[5]*i+e[9]*a,a=e[2]*r+e[6]*i+e[10]*a;return n.x=o,n.y=t,n.z=a,n},Fe.multiplyByPoint=function(e,t,n){var r=t.x,i=t.y,a=t.z,o=e[0]*r+e[4]*i+e[8]*a+e[12],t=e[1]*r+e[5]*i+e[9]*a+e[13],e=e[2]*r+e[6]*i+e[10]*a+e[14];return n.x=o,n.y=t,n.z=e,n},Fe.multiplyByScalar=function(e,t,n){return n[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n[3]=e[3]*t,n[4]=e[4]*t,n[5]=e[5]*t,n[6]=e[6]*t,n[7]=e[7]*t,n[8]=e[8]*t,n[9]=e[9]*t,n[10]=e[10]*t,n[11]=e[11]*t,n[12]=e[12]*t,n[13]=e[13]*t,n[14]=e[14]*t,n[15]=e[15]*t,n},Fe.negate=function(e,t){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t[4]=-e[4],t[5]=-e[5],t[6]=-e[6],t[7]=-e[7],t[8]=-e[8],t[9]=-e[9],t[10]=-e[10],t[11]=-e[11],t[12]=-e[12],t[13]=-e[13],t[14]=-e[14],t[15]=-e[15],t},Fe.transpose=function(e,t){var n=e[1],r=e[2],i=e[3],a=e[6],o=e[7],s=e[11];return t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=n,t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=r,t[9]=a,t[10]=e[10],t[11]=e[14],t[12]=i,t[13]=o,t[14]=s,t[15]=e[15],t},Fe.abs=function(e,t){return t[0]=Math.abs(e[0]),t[1]=Math.abs(e[1]),t[2]=Math.abs(e[2]),t[3]=Math.abs(e[3]),t[4]=Math.abs(e[4]),t[5]=Math.abs(e[5]),t[6]=Math.abs(e[6]),t[7]=Math.abs(e[7]),t[8]=Math.abs(e[8]),t[9]=Math.abs(e[9]),t[10]=Math.abs(e[10]),t[11]=Math.abs(e[11]),t[12]=Math.abs(e[12]),t[13]=Math.abs(e[13]),t[14]=Math.abs(e[14]),t[15]=Math.abs(e[15]),t},Fe.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[3]===t[3]&&e[7]===t[7]&&e[11]===t[11]&&e[15]===t[15]},Fe.equalsEpsilon=function(e,t,n){return n=Pe(n,0),e===t||Ue(e)&&Ue(t)&&Math.abs(e[0]-t[0])<=n&&Math.abs(e[1]-t[1])<=n&&Math.abs(e[2]-t[2])<=n&&Math.abs(e[3]-t[3])<=n&&Math.abs(e[4]-t[4])<=n&&Math.abs(e[5]-t[5])<=n&&Math.abs(e[6]-t[6])<=n&&Math.abs(e[7]-t[7])<=n&&Math.abs(e[8]-t[8])<=n&&Math.abs(e[9]-t[9])<=n&&Math.abs(e[10]-t[10])<=n&&Math.abs(e[11]-t[11])<=n&&Math.abs(e[12]-t[12])<=n&&Math.abs(e[13]-t[13])<=n&&Math.abs(e[14]-t[14])<=n&&Math.abs(e[15]-t[15])<=n},Fe.getTranslation=function(e,t){return t.x=e[12],t.y=e[13],t.z=e[14],t},Fe.getMatrix3=function(e,t){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[4],t[4]=e[5],t[5]=e[6],t[6]=e[8],t[7]=e[9],t[8]=e[10],t};var Ee=new V,ye=new V,_e=new $,Te=new $(0,0,0,1);Fe.inverse=function(e,t){var n=e[0],r=e[4],i=e[8],a=e[12],o=e[1],s=e[5],u=e[9],c=e[13],l=e[2],f=e[6],h=e[10],d=e[14],m=e[3],p=e[7],E=e[11],y=e[15],_=h*y,T=d*E,R=f*y,A=d*p,g=f*E,S=h*p,w=l*y,I=d*m,M=l*E,O=h*m,N=l*p,x=f*m,v=_*s+A*u+g*c-(T*s+R*u+S*c),U=T*o+w*u+O*c-(_*o+I*u+M*c),P=R*o+I*s+N*c-(A*o+w*s+x*c),C=S*o+M*s+x*u-(g*o+O*s+N*u),D=T*r+R*i+S*a-(_*r+A*i+g*a),b=_*n+I*i+M*a-(T*n+w*i+O*a),L=A*n+w*r+x*a-(R*n+I*r+N*a),F=g*n+O*r+N*i-(S*n+M*r+x*i),B=(_=i*c)*p+(A=a*s)*E+(g=r*u)*y-((T=a*u)*p+(R=r*c)*E+(S=i*s)*y),u=T*m+(w=n*c)*E+(O=i*o)*y-(_*m+(I=a*o)*E+(M=n*u)*y),y=R*m+I*p+(N=n*s)*y-(A*m+w*p+(x=r*o)*y),p=S*m+M*p+x*E-(g*m+O*p+N*E),E=R*h+S*d+T*f-(g*d+_*f+A*h),T=M*d+_*l+I*h-(w*h+O*d+T*l),I=w*f+x*d+A*l-(N*d+R*l+I*f),l=N*h+g*l+O*f-(M*f+x*h+S*l),a=n*v+r*U+i*P+a*C;if(Math.abs(a)<Ce.EPSILON21){if(V.equalsEpsilon(Fe.getMatrix3(e,Ee),ye,Ce.EPSILON7)&&$.equals(Fe.getRow(e,3,_e),Te))return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=0,t[11]=0,t[12]=-e[12],t[13]=-e[13],t[14]=-e[14],t[15]=1,t;throw new ue("matrix is not invertible because its determinate is zero.")}return a=1/a,t[0]=v*a,t[1]=U*a,t[2]=P*a,t[3]=C*a,t[4]=D*a,t[5]=b*a,t[6]=L*a,t[7]=F*a,t[8]=B*a,t[9]=u*a,t[10]=y*a,t[11]=p*a,t[12]=E*a,t[13]=T*a,t[14]=I*a,t[15]=l*a,t},Fe.inverseTransformation=function(e,t){var n=e[0],r=e[1],i=e[2],a=e[4],o=e[5],s=e[6],u=e[8],c=e[9],l=e[10],f=e[12],h=e[13],d=e[14],m=-n*f-r*h-i*d,e=-a*f-o*h-s*d,d=-u*f-c*h-l*d;return t[0]=n,t[1]=a,t[2]=u,t[3]=0,t[4]=r,t[5]=o,t[6]=c,t[7]=0,t[8]=i,t[9]=s,t[10]=l,t[11]=0,t[12]=m,t[13]=e,t[14]=d,t[15]=1,t};var Re=new Fe;function Be(e,t,n,r){this.west=Pe(e,0),this.south=Pe(t,0),this.east=Pe(n,0),this.north=Pe(r,0)}Fe.inverseTranspose=function(e,t){return Fe.inverse(Fe.transpose(e,Re),t)},Fe.IDENTITY=Object.freeze(new Fe(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)),Fe.ZERO=Object.freeze(new Fe(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)),Fe.COLUMN0ROW0=0,Fe.COLUMN0ROW1=1,Fe.COLUMN0ROW2=2,Fe.COLUMN0ROW3=3,Fe.COLUMN1ROW0=4,Fe.COLUMN1ROW1=5,Fe.COLUMN1ROW2=6,Fe.COLUMN1ROW3=7,Fe.COLUMN2ROW0=8,Fe.COLUMN2ROW1=9,Fe.COLUMN2ROW2=10,Fe.COLUMN2ROW3=11,Fe.COLUMN3ROW0=12,Fe.COLUMN3ROW1=13,Fe.COLUMN3ROW2=14,Fe.COLUMN3ROW3=15,Object.defineProperties(Fe.prototype,{length:{get:function(){return Fe.packedLength}}}),Fe.prototype.clone=function(e){return Fe.clone(this,e)},Fe.prototype.equals=function(e){return Fe.equals(this,e)},Fe.equalsArray=function(e,t,n){return e[0]===t[n]&&e[1]===t[n+1]&&e[2]===t[n+2]&&e[3]===t[n+3]&&e[4]===t[n+4]&&e[5]===t[n+5]&&e[6]===t[n+6]&&e[7]===t[n+7]&&e[8]===t[n+8]&&e[9]===t[n+9]&&e[10]===t[n+10]&&e[11]===t[n+11]&&e[12]===t[n+12]&&e[13]===t[n+13]&&e[14]===t[n+14]&&e[15]===t[n+15]},Fe.prototype.equalsEpsilon=function(e,t){return Fe.equalsEpsilon(this,e,t)},Fe.prototype.toString=function(){return"("+this[0]+", "+this[4]+", "+this[8]+", "+this[12]+")\\n("+this[1]+", "+this[5]+", "+this[9]+", "+this[13]+")\\n("+this[2]+", "+this[6]+", "+this[10]+", "+this[14]+")\\n("+this[3]+", "+this[7]+", "+this[11]+", "+this[15]+")"},Object.defineProperties(Be.prototype,{width:{get:function(){return Be.computeWidth(this)}},height:{get:function(){return Be.computeHeight(this)}}}),Be.packedLength=4,Be.pack=function(e,t,n){return n=Pe(n,0),t[n++]=e.west,t[n++]=e.south,t[n++]=e.east,t[n]=e.north,t},Be.unpack=function(e,t,n){return t=Pe(t,0),(n=!Ue(n)?new Be:n).west=e[t++],n.south=e[t++],n.east=e[t++],n.north=e[t],n},Be.computeWidth=function(e){var t=e.east,e=e.west;return t<e&&(t+=Ce.TWO_PI),t-e},Be.computeHeight=function(e){return e.north-e.south},Be.fromDegrees=function(e,t,n,r,i){return e=Ce.toRadians(Pe(e,0)),t=Ce.toRadians(Pe(t,0)),n=Ce.toRadians(Pe(n,0)),r=Ce.toRadians(Pe(r,0)),Ue(i)?(i.west=e,i.south=t,i.east=n,i.north=r,i):new Be(e,t,n,r)},Be.fromRadians=function(e,t,n,r,i){return Ue(i)?(i.west=Pe(e,0),i.south=Pe(t,0),i.east=Pe(n,0),i.north=Pe(r,0),i):new Be(e,t,n,r)},Be.fromCartographicArray=function(e,t){for(var n=Number.MAX_VALUE,r=-Number.MAX_VALUE,i=Number.MAX_VALUE,a=-Number.MAX_VALUE,o=Number.MAX_VALUE,s=-Number.MAX_VALUE,u=0,c=e.length;u<c;u++)var l=e[u],n=Math.min(n,l.longitude),r=Math.max(r,l.longitude),o=Math.min(o,l.latitude),s=Math.max(s,l.latitude),l=0<=l.longitude?l.longitude:l.longitude+Ce.TWO_PI,i=Math.min(i,l),a=Math.max(a,l);return a-i<r-n&&(n=i,(r=a)>Ce.PI&&(r-=Ce.TWO_PI),n>Ce.PI&&(n-=Ce.TWO_PI)),Ue(t)?(t.west=n,t.south=o,t.east=r,t.north=s,t):new Be(n,o,r,s)},Be.fromCartesianArray=function(e,t,n){t=Pe(t,be.WGS84);for(var r=Number.MAX_VALUE,i=-Number.MAX_VALUE,a=Number.MAX_VALUE,o=-Number.MAX_VALUE,s=Number.MAX_VALUE,u=-Number.MAX_VALUE,c=0,l=e.length;c<l;c++)var f=t.cartesianToCartographic(e[c]),r=Math.min(r,f.longitude),i=Math.max(i,f.longitude),s=Math.min(s,f.latitude),u=Math.max(u,f.latitude),f=0<=f.longitude?f.longitude:f.longitude+Ce.TWO_PI,a=Math.min(a,f),o=Math.max(o,f);return o-a<i-r&&(r=a,(i=o)>Ce.PI&&(i-=Ce.TWO_PI),r>Ce.PI&&(r-=Ce.TWO_PI)),Ue(n)?(n.west=r,n.south=s,n.east=i,n.north=u,n):new Be(r,s,i,u)},Be.clone=function(e,t){if(Ue(e))return Ue(t)?(t.west=e.west,t.south=e.south,t.east=e.east,t.north=e.north,t):new Be(e.west,e.south,e.east,e.north)},Be.equalsEpsilon=function(e,t,n){return n=Pe(n,0),e===t||Ue(e)&&Ue(t)&&Math.abs(e.west-t.west)<=n&&Math.abs(e.south-t.south)<=n&&Math.abs(e.east-t.east)<=n&&Math.abs(e.north-t.north)<=n},Be.prototype.clone=function(e){return Be.clone(this,e)},Be.prototype.equals=function(e){return Be.equals(this,e)},Be.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&e.west===t.west&&e.south===t.south&&e.east===t.east&&e.north===t.north},Be.prototype.equalsEpsilon=function(e,t){return Be.equalsEpsilon(this,e,t)},Be.validate=function(e){},Be.southwest=function(e,t){return Ue(t)?(t.longitude=e.west,t.latitude=e.south,t.height=0,t):new R(e.west,e.south)},Be.northwest=function(e,t){return Ue(t)?(t.longitude=e.west,t.latitude=e.north,t.height=0,t):new R(e.west,e.north)},Be.northeast=function(e,t){return Ue(t)?(t.longitude=e.east,t.latitude=e.north,t.height=0,t):new R(e.east,e.north)},Be.southeast=function(e,t){return Ue(t)?(t.longitude=e.east,t.latitude=e.south,t.height=0,t):new R(e.east,e.south)},Be.center=function(e,t){var n=e.east,r=e.west;n<r&&(n+=Ce.TWO_PI);n=Ce.negativePiToPi(.5*(r+n)),e=.5*(e.south+e.north);return Ue(t)?(t.longitude=n,t.latitude=e,t.height=0,t):new R(n,e)},Be.intersection=function(e,t,n){var r=e.east,i=e.west,a=t.east,o=t.west;r<i&&0<a?r+=Ce.TWO_PI:a<o&&0<r&&(a+=Ce.TWO_PI),r<i&&o<0?o+=Ce.TWO_PI:a<o&&i<0&&(i+=Ce.TWO_PI);o=Ce.negativePiToPi(Math.max(i,o)),r=Ce.negativePiToPi(Math.min(r,a));if(!((e.west<e.east||t.west<t.east)&&r<=o)){a=Math.max(e.south,t.south),t=Math.min(e.north,t.north);if(!(t<=a))return Ue(n)?(n.west=o,n.south=a,n.east=r,n.north=t,n):new Be(o,a,r,t)}},Be.simpleIntersection=function(e,t,n){var r=Math.max(e.west,t.west),i=Math.max(e.south,t.south),a=Math.min(e.east,t.east),t=Math.min(e.north,t.north);if(!(t<=i||a<=r))return Ue(n)?(n.west=r,n.south=i,n.east=a,n.north=t,n):new Be(r,i,a,t)},Be.union=function(e,t,n){Ue(n)||(n=new Be);var r=e.east,i=e.west,a=t.east,o=t.west;r<i&&0<a?r+=Ce.TWO_PI:a<o&&0<r&&(a+=Ce.TWO_PI),r<i&&o<0?o+=Ce.TWO_PI:a<o&&i<0&&(i+=Ce.TWO_PI);o=Ce.convertLongitudeRange(Math.min(i,o)),a=Ce.convertLongitudeRange(Math.max(r,a));return n.west=o,n.south=Math.min(e.south,t.south),n.east=a,n.north=Math.max(e.north,t.north),n},Be.expand=function(e,t,n){return(n=!Ue(n)?new Be:n).west=Math.min(e.west,t.longitude),n.south=Math.min(e.south,t.latitude),n.east=Math.max(e.east,t.longitude),n.north=Math.max(e.north,t.latitude),n},Be.contains=function(e,t){var n=t.longitude,r=t.latitude,i=e.west,t=e.east;return t<i&&(t+=Ce.TWO_PI,n<0&&(n+=Ce.TWO_PI)),(i<n||Ce.equalsEpsilon(n,i,Ce.EPSILON14))&&(n<t||Ce.equalsEpsilon(n,t,Ce.EPSILON14))&&r>=e.south&&r<=e.north};var Ae=new R;function ze(e,t){this.center=De.clone(Pe(e,De.ZERO)),this.radius=Pe(t,0)}Be.subsample=function(e,t,n,r){t=Pe(t,be.WGS84),n=Pe(n,0),Ue(r)||(r=[]);var i=0,a=e.north,o=e.south,s=e.east,u=e.west,c=Ae;c.height=n,c.longitude=u,c.latitude=a,r[i]=t.cartographicToCartesian(c,r[i]),i++,c.longitude=s,r[i]=t.cartographicToCartesian(c,r[i]),i++,c.latitude=o,r[i]=t.cartographicToCartesian(c,r[i]),i++,c.longitude=u,r[i]=t.cartographicToCartesian(c,r[i]),i++,c.latitude=a<0?a:0<o?o:0;for(var l=1;l<8;++l)c.longitude=-Math.PI+l*Ce.PI_OVER_TWO,Be.contains(e,c)&&(r[i]=t.cartographicToCartesian(c,r[i]),i++);return 0===c.latitude&&(c.longitude=u,r[i]=t.cartographicToCartesian(c,r[i]),i++,c.longitude=s,r[i]=t.cartographicToCartesian(c,r[i]),i++),r.length=i,r},Be.MAX_VALUE=Object.freeze(new Be(-Math.PI,-Ce.PI_OVER_TWO,Math.PI,Ce.PI_OVER_TWO));var ge=new De,Se=new De,we=new De,Ie=new De,Me=new De,Oe=new De,Ne=new De,xe=new De,ve=new De,qe=new De,Ve=new De,ke=new De,Ge=4/3*Ce.PI;ze.fromPoints=function(e,t){if(Ue(t)||(t=new ze),!Ue(e)||0===e.length)return t.center=De.clone(De.ZERO,t.center),t.radius=0,t;for(var n=De.clone(e[0],Ne),r=De.clone(n,ge),i=De.clone(n,Se),a=De.clone(n,we),o=De.clone(n,Ie),s=De.clone(n,Me),u=De.clone(n,Oe),c=e.length,l=1;l<c;l++){De.clone(e[l],n);var f=n.x,h=n.y,d=n.z;f<r.x&&De.clone(n,r),f>o.x&&De.clone(n,o),h<i.y&&De.clone(n,i),h>s.y&&De.clone(n,s),d<a.z&&De.clone(n,a),d>u.z&&De.clone(n,u)}var m=De.magnitudeSquared(De.subtract(o,r,xe)),p=De.magnitudeSquared(De.subtract(s,i,xe)),E=De.magnitudeSquared(De.subtract(u,a,xe)),y=r,_=o,m=m;m<p&&(m=p,y=i,_=s),m<E&&(m=E,y=a,_=u);var T=ve;T.x=.5*(y.x+_.x),T.y=.5*(y.y+_.y),T.z=.5*(y.z+_.z);var R=De.magnitudeSquared(De.subtract(_,T,xe)),A=Math.sqrt(R),y=qe;y.x=r.x,y.y=i.y,y.z=a.z;_=Ve;_.x=o.x,_.y=s.y,_.z=u.z;var g=De.midpoint(y,_,ke),S=0;for(l=0;l<c;l++){De.clone(e[l],n);var w=De.magnitude(De.subtract(n,g,xe));S<w&&(S=w);var I=De.magnitudeSquared(De.subtract(n,T,xe));R<I&&(R=(A=.5*(A+(w=Math.sqrt(I))))*A,I=w-A,T.x=(A*T.x+I*n.x)/w,T.y=(A*T.y+I*n.y)/w,T.z=(A*T.z+I*n.z)/w)}return A<S?(De.clone(T,t.center),t.radius=A):(De.clone(g,t.center),t.radius=S),t};var Xe=new z,We=new De,He=new De,Ye=new R,je=new R;ze.fromRectangle2D=function(e,t,n){return ze.fromRectangleWithHeights2D(e,t,0,0,n)},ze.fromRectangleWithHeights2D=function(e,t,n,r,i){if(Ue(i)||(i=new ze),!Ue(e))return i.center=De.clone(De.ZERO,i.center),i.radius=0,i;t=Pe(t,Xe),Be.southwest(e,Ye),Ye.height=n,Be.northeast(e,je),je.height=r;var a=t.project(Ye,We),n=t.project(je,He),e=n.x-a.x,r=n.y-a.y,t=n.z-a.z;i.radius=.5*Math.sqrt(e*e+r*r+t*t);n=i.center;return n.x=a.x+.5*e,n.y=a.y+.5*r,n.z=a.z+.5*t,i};var Ze=[];ze.fromRectangle3D=function(e,t,n,r){if(t=Pe(t,be.WGS84),n=Pe(n,0),Ue(r)||(r=new ze),!Ue(e))return r.center=De.clone(De.ZERO,r.center),r.radius=0,r;n=Be.subsample(e,t,n,Ze);return ze.fromPoints(n,r)},ze.fromVertices=function(e,t,n,r){if(Ue(r)||(r=new ze),!Ue(e)||0===e.length)return r.center=De.clone(De.ZERO,r.center),r.radius=0,r;t=Pe(t,De.ZERO),n=Pe(n,3);var i=Ne;i.x=e[0]+t.x,i.y=e[1]+t.y,i.z=e[2]+t.z;for(var a=De.clone(i,ge),o=De.clone(i,Se),s=De.clone(i,we),u=De.clone(i,Ie),c=De.clone(i,Me),l=De.clone(i,Oe),f=e.length,h=0;h<f;h+=n){var d=e[h]+t.x,m=e[h+1]+t.y,p=e[h+2]+t.z;i.x=d,i.y=m,i.z=p,d<a.x&&De.clone(i,a),d>u.x&&De.clone(i,u),m<o.y&&De.clone(i,o),m>c.y&&De.clone(i,c),p<s.z&&De.clone(i,s),p>l.z&&De.clone(i,l)}var E=De.magnitudeSquared(De.subtract(u,a,xe)),y=De.magnitudeSquared(De.subtract(c,o,xe)),_=De.magnitudeSquared(De.subtract(l,s,xe)),T=a,R=u,E=E;E<y&&(E=y,T=o,R=c),E<_&&(E=_,T=s,R=l);var A=ve;A.x=.5*(T.x+R.x),A.y=.5*(T.y+R.y),A.z=.5*(T.z+R.z);var g=De.magnitudeSquared(De.subtract(R,A,xe)),S=Math.sqrt(g),T=qe;T.x=a.x,T.y=o.y,T.z=s.z;R=Ve;R.x=u.x,R.y=c.y,R.z=l.z;var w=De.midpoint(T,R,ke),I=0;for(h=0;h<f;h+=n){i.x=e[h]+t.x,i.y=e[h+1]+t.y,i.z=e[h+2]+t.z;var M=De.magnitude(De.subtract(i,w,xe));I<M&&(I=M);var O=De.magnitudeSquared(De.subtract(i,A,xe));g<O&&(g=(S=.5*(S+(M=Math.sqrt(O))))*S,O=M-S,A.x=(S*A.x+O*i.x)/M,A.y=(S*A.y+O*i.y)/M,A.z=(S*A.z+O*i.z)/M)}return S<I?(De.clone(A,r.center),r.radius=S):(De.clone(w,r.center),r.radius=I),r},ze.fromEncodedCartesianVertices=function(e,t,n){if(Ue(n)||(n=new ze),!Ue(e)||!Ue(t)||e.length!==t.length||0===e.length)return n.center=De.clone(De.ZERO,n.center),n.radius=0,n;var r=Ne;r.x=e[0]+t[0],r.y=e[1]+t[1],r.z=e[2]+t[2];for(var i=De.clone(r,ge),a=De.clone(r,Se),o=De.clone(r,we),s=De.clone(r,Ie),u=De.clone(r,Me),c=De.clone(r,Oe),l=e.length,f=0;f<l;f+=3){var h=e[f]+t[f],d=e[f+1]+t[f+1],m=e[f+2]+t[f+2];r.x=h,r.y=d,r.z=m,h<i.x&&De.clone(r,i),h>s.x&&De.clone(r,s),d<a.y&&De.clone(r,a),d>u.y&&De.clone(r,u),m<o.z&&De.clone(r,o),m>c.z&&De.clone(r,c)}var p=De.magnitudeSquared(De.subtract(s,i,xe)),E=De.magnitudeSquared(De.subtract(u,a,xe)),y=De.magnitudeSquared(De.subtract(c,o,xe)),_=i,T=s,p=p;p<E&&(p=E,_=a,T=u),p<y&&(p=y,_=o,T=c);var R=ve;R.x=.5*(_.x+T.x),R.y=.5*(_.y+T.y),R.z=.5*(_.z+T.z);var A=De.magnitudeSquared(De.subtract(T,R,xe)),g=Math.sqrt(A),_=qe;_.x=i.x,_.y=a.y,_.z=o.z;T=Ve;T.x=s.x,T.y=u.y,T.z=c.z;var S=De.midpoint(_,T,ke),w=0;for(f=0;f<l;f+=3){r.x=e[f]+t[f],r.y=e[f+1]+t[f+1],r.z=e[f+2]+t[f+2];var I=De.magnitude(De.subtract(r,S,xe));w<I&&(w=I);var M=De.magnitudeSquared(De.subtract(r,R,xe));A<M&&(A=(g=.5*(g+(I=Math.sqrt(M))))*g,M=I-g,R.x=(g*R.x+M*r.x)/I,R.y=(g*R.y+M*r.y)/I,R.z=(g*R.z+M*r.z)/I)}return g<w?(De.clone(R,n.center),n.radius=g):(De.clone(S,n.center),n.radius=w),n},ze.fromCornerPoints=function(e,t,n){Ue(n)||(n=new ze);e=De.midpoint(e,t,n.center);return n.radius=De.distance(e,t),n},ze.fromEllipsoid=function(e,t){return Ue(t)||(t=new ze),De.clone(De.ZERO,t.center),t.radius=e.maximumRadius,t};var Ke=new De;ze.fromBoundingSpheres=function(e,t){if(Ue(t)||(t=new ze),!Ue(e)||0===e.length)return t.center=De.clone(De.ZERO,t.center),t.radius=0,t;var n=e.length;if(1===n)return ze.clone(e[0],t);if(2===n)return ze.union(e[0],e[1],t);for(var r=[],i=0;i<n;i++)r.push(e[i].center);var a=(t=ze.fromPoints(r,t)).center,o=t.radius;for(i=0;i<n;i++)var s=e[i],o=Math.max(o,De.distance(a,s.center,Ke)+s.radius);return t.radius=o,t};var Je=new De,Qe=new De,$e=new De;ze.fromOrientedBoundingBox=function(e,t){Ue(t)||(t=new ze);var n=e.halfAxes,r=V.getColumn(n,0,Je),i=V.getColumn(n,1,Qe),n=V.getColumn(n,2,$e);return De.add(r,i,r),De.add(r,n,r),t.center=De.clone(e.center,t.center),t.radius=De.magnitude(r),t},ze.clone=function(e,t){if(Ue(e))return Ue(t)?(t.center=De.clone(e.center,t.center),t.radius=e.radius,t):new ze(e.center,e.radius)},ze.packedLength=4,ze.pack=function(e,t,n){n=Pe(n,0);var r=e.center;return t[n++]=r.x,t[n++]=r.y,t[n++]=r.z,t[n]=e.radius,t},ze.unpack=function(e,t,n){t=Pe(t,0);var r=(n=!Ue(n)?new ze:n).center;return r.x=e[t++],r.y=e[t++],r.z=e[t++],n.radius=e[t],n};var et=new De,tt=new De;ze.union=function(e,t,n){Ue(n)||(n=new ze);var r=e.center,i=e.radius,a=t.center,o=t.radius,s=De.subtract(a,r,et),a=De.magnitude(s);if(a+o<=i)return e.clone(n),n;if(a+i<=o)return t.clone(n),n;o=.5*(i+a+o),a=De.multiplyByScalar(s,(o-i)/a,tt);return De.add(a,r,a),De.clone(a,n.center),n.radius=o,n};var nt=new De;ze.expand=function(e,t,n){n=ze.clone(e,n);t=De.magnitude(De.subtract(t,n.center,nt));return t>n.radius&&(n.radius=t),n},ze.intersectPlane=function(e,t){var n=e.center,r=e.radius,e=t.normal,t=De.dot(e,n)+t.distance;return t<-r?F.OUTSIDE:t<r?F.INTERSECTING:F.INSIDE},ze.transform=function(e,t,n){return(n=!Ue(n)?new ze:n).center=Fe.multiplyByPoint(t,e.center,n.center),n.radius=Fe.getMaximumScale(t)*e.radius,n};var rt=new De;ze.distanceSquaredTo=function(e,t){t=De.subtract(e.center,t,rt);return De.magnitudeSquared(t)-e.radius*e.radius},ze.transformWithoutScale=function(e,t,n){return(n=!Ue(n)?new ze:n).center=Fe.multiplyByPoint(t,e.center,n.center),n.radius=e.radius,n};var it=new De;ze.computePlaneDistances=function(e,t,n,r){Ue(r)||(r=new q);t=De.subtract(e.center,t,it),t=De.dot(n,t);return r.start=t-e.radius,r.stop=t+e.radius,r};for(var at=new De,ot=new De,st=new De,ut=new De,ct=new De,lt=new R,ft=new Array(8),ht=0;ht<8;++ht)ft[ht]=new De;var dt=new z;function mt(e,t){this.x=Pe(e,0),this.y=Pe(t,0)}ze.projectTo2D=function(e,t,n){var r=(t=Pe(t,dt)).ellipsoid,i=e.center,a=e.radius,o=De.equals(i,De.ZERO)?De.clone(De.UNIT_X,at):r.geodeticSurfaceNormal(i,at),s=De.cross(De.UNIT_Z,o,ot);De.normalize(s,s);var u=De.cross(o,s,st);De.normalize(u,u),De.multiplyByScalar(o,a,o),De.multiplyByScalar(u,a,u),De.multiplyByScalar(s,a,s);var c=De.negate(u,ct),e=De.negate(s,ut),l=ft,a=l[0];De.add(o,u,a),De.add(a,s,a),a=l[1],De.add(o,u,a),De.add(a,e,a),a=l[2],De.add(o,c,a),De.add(a,e,a),a=l[3],De.add(o,c,a),De.add(a,s,a),De.negate(o,o),a=l[4],De.add(o,u,a),De.add(a,s,a),a=l[5],De.add(o,u,a),De.add(a,e,a),a=l[6],De.add(o,c,a),De.add(a,e,a),a=l[7],De.add(o,c,a),De.add(a,s,a);for(var f=l.length,h=0;h<f;++h){var d=l[h];De.add(i,d,d);var m=r.cartesianToCartographic(d,lt);t.project(m,d)}c=(i=(n=ze.fromPoints(l,n)).center).x,s=i.y,a=i.z;return i.x=a,i.y=c,i.z=s,n},ze.isOccluded=function(e,t){return!t.isBoundingSphereVisible(e)},ze.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&De.equals(e.center,t.center)&&e.radius===t.radius},ze.prototype.intersectPlane=function(e){return ze.intersectPlane(this,e)},ze.prototype.distanceSquaredTo=function(e){return ze.distanceSquaredTo(this,e)},ze.prototype.computePlaneDistances=function(e,t,n){return ze.computePlaneDistances(this,e,t,n)},ze.prototype.isOccluded=function(e){return ze.isOccluded(this,e)},ze.prototype.equals=function(e){return ze.equals(this,e)},ze.prototype.clone=function(e){return ze.clone(this,e)},ze.prototype.volume=function(){var e=this.radius;return Ge*e*e*e},mt.fromElements=function(e,t,n){return Ue(n)?(n.x=e,n.y=t,n):new mt(e,t)},mt.clone=function(e,t){if(Ue(e))return Ue(t)?(t.x=e.x,t.y=e.y,t):new mt(e.x,e.y)},mt.fromCartesian3=mt.clone,mt.fromCartesian4=mt.clone,mt.packedLength=2,mt.pack=function(e,t,n){return n=Pe(n,0),t[n++]=e.x,t[n]=e.y,t},mt.unpack=function(e,t,n){return t=Pe(t,0),(n=!Ue(n)?new mt:n).x=e[t++],n.y=e[t],n},mt.packArray=function(e,t){var n=e.length,r=2*n;if(Ue(t)){if(!Array.isArray(t)&&t.length!==r)throw new s("If result is a typed array, it must have exactly array.length * 2 elements");t.length!==r&&(t.length=r)}else t=new Array(r);for(var i=0;i<n;++i)mt.pack(e[i],t,2*i);return t},mt.unpackArray=function(e,t){var n=e.length;Ue(t)?t.length=n/2:t=new Array(n/2);for(var r=0;r<n;r+=2){var i=r/2;t[i]=mt.unpack(e,r,t[i])}return t},mt.fromArray=mt.unpack,mt.maximumComponent=function(e){return Math.max(e.x,e.y)},mt.minimumComponent=function(e){return Math.min(e.x,e.y)},mt.minimumByComponent=function(e,t,n){return n.x=Math.min(e.x,t.x),n.y=Math.min(e.y,t.y),n},mt.maximumByComponent=function(e,t,n){return n.x=Math.max(e.x,t.x),n.y=Math.max(e.y,t.y),n},mt.magnitudeSquared=function(e){return e.x*e.x+e.y*e.y},mt.magnitude=function(e){return Math.sqrt(mt.magnitudeSquared(e))};var pt=new mt;mt.distance=function(e,t){return mt.subtract(e,t,pt),mt.magnitude(pt)},mt.distanceSquared=function(e,t){return mt.subtract(e,t,pt),mt.magnitudeSquared(pt)},mt.normalize=function(e,t){var n=mt.magnitude(e);return t.x=e.x/n,t.y=e.y/n,t},mt.dot=function(e,t){return e.x*t.x+e.y*t.y},mt.cross=function(e,t){return e.x*t.y-e.y*t.x},mt.multiplyComponents=function(e,t,n){return n.x=e.x*t.x,n.y=e.y*t.y,n},mt.divideComponents=function(e,t,n){return n.x=e.x/t.x,n.y=e.y/t.y,n},mt.add=function(e,t,n){return n.x=e.x+t.x,n.y=e.y+t.y,n},mt.subtract=function(e,t,n){return n.x=e.x-t.x,n.y=e.y-t.y,n},mt.multiplyByScalar=function(e,t,n){return n.x=e.x*t,n.y=e.y*t,n},mt.divideByScalar=function(e,t,n){return n.x=e.x/t,n.y=e.y/t,n},mt.negate=function(e,t){return t.x=-e.x,t.y=-e.y,t},mt.abs=function(e,t){return t.x=Math.abs(e.x),t.y=Math.abs(e.y),t};var Et=new mt;mt.lerp=function(e,t,n,r){return mt.multiplyByScalar(t,n,Et),r=mt.multiplyByScalar(e,1-n,r),mt.add(Et,r,r)};var yt=new mt,_t=new mt;mt.angleBetween=function(e,t){return mt.normalize(e,yt),mt.normalize(t,_t),Ce.acosClamped(mt.dot(yt,_t))};var Tt=new mt;function Rt(e,t){this._ellipsoid=e,this._cameraPosition=new De,this._cameraPositionInScaledSpace=new De,this._distanceToLimbInScaledSpaceSquared=0,Ue(t)&&(this.cameraPosition=t)}mt.mostOrthogonalAxis=function(e,t){e=mt.normalize(e,Tt);return mt.abs(e,e),t=e.x<=e.y?mt.clone(mt.UNIT_X,t):mt.clone(mt.UNIT_Y,t)},mt.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&e.x===t.x&&e.y===t.y},mt.equalsArray=function(e,t,n){return e.x===t[n]&&e.y===t[n+1]},mt.equalsEpsilon=function(e,t,n,r){return e===t||Ue(e)&&Ue(t)&&Ce.equalsEpsilon(e.x,t.x,n,r)&&Ce.equalsEpsilon(e.y,t.y,n,r)},mt.ZERO=Object.freeze(new mt(0,0)),mt.UNIT_X=Object.freeze(new mt(1,0)),mt.UNIT_Y=Object.freeze(new mt(0,1)),mt.prototype.clone=function(e){return mt.clone(this,e)},mt.prototype.equals=function(e){return mt.equals(this,e)},mt.prototype.equalsEpsilon=function(e,t,n){return mt.equalsEpsilon(this,e,t,n)},mt.prototype.toString=function(){return"("+this.x+", "+this.y+")"},Object.defineProperties(Rt.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},cameraPosition:{get:function(){return this._cameraPosition},set:function(e){var t=this._ellipsoid.transformPositionToScaledSpace(e,this._cameraPositionInScaledSpace),n=De.magnitudeSquared(t)-1;De.clone(e,this._cameraPosition),this._cameraPositionInScaledSpace=t,this._distanceToLimbInScaledSpaceSquared=n}}});var At=new De;Rt.prototype.isPointVisible=function(e){return vt(this._ellipsoid.transformPositionToScaledSpace(e,At),this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)},Rt.prototype.isScaledSpacePointVisible=function(e){return vt(e,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)};var gt=new De;Rt.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid=function(e,t){var n,r=this._ellipsoid,t=Ue(t)&&t<0&&r.minimumRadius>-t?((n=gt).x=this._cameraPosition.x/(r.radii.x+t),n.y=this._cameraPosition.y/(r.radii.y+t),n.z=this._cameraPosition.z/(r.radii.z+t),n.x*n.x+n.y*n.y+n.z*n.z-1):(n=this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared);return vt(e,n,t)},Rt.prototype.computeHorizonCullingPoint=function(e,t,n){return Ot(this._ellipsoid,e,t,n)};var St=be.clone(be.UNIT_SPHERE);Rt.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid=function(e,t,n,r){return Ot(Mt(this._ellipsoid,n,St),e,t,r)},Rt.prototype.computeHorizonCullingPointFromVertices=function(e,t,n,r,i){return xt(this._ellipsoid,e,t,n,r,i)},Rt.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid=function(e,t,n,r,i,a){return xt(Mt(this._ellipsoid,i,St),e,t,n,r,a)};var wt=[];Rt.prototype.computeHorizonCullingPointFromRectangle=function(e,t,n){var r=Be.subsample(e,t,0,wt),e=ze.fromPoints(r);if(!(De.magnitude(e.center)<.1*t.minimumRadius))return this.computeHorizonCullingPoint(e.center,r,n)};var It=new De;function Mt(e,t,n){return Ue(t)&&t<0&&e.minimumRadius>-t&&(t=De.fromElements(e.radii.x+t,e.radii.y+t,e.radii.z+t,It),e=be.fromCartesian3(t,n)),e}function Ot(e,t,n,r){Ue(r)||(r=new De);for(var i=Lt(e,t),a=0,o=0,s=n.length;o<s;++o){var u=Ct(e,n[o],i);if(u<0)return;a=Math.max(a,u)}return Dt(i,a,r)}var Nt=new De;function xt(e,t,n,r,i,a){Ue(a)||(a=new De),r=Pe(r,3),i=Pe(i,De.ZERO);for(var o=Lt(e,t),s=0,u=0,c=n.length;u<c;u+=r){Nt.x=n[u]+i.x,Nt.y=n[u+1]+i.y,Nt.z=n[u+2]+i.z;var l=Ct(e,Nt,o);if(l<0)return;s=Math.max(s,l)}return Dt(o,s,a)}function vt(e,t,n){e=De.subtract(e,t,At),t=-De.dot(e,t);return!(n<0?0<t:n<t&&t*t/De.magnitudeSquared(e)>n)}var Ut=new De,Pt=new De;function Ct(e,t,n){var r=e.transformPositionToScaledSpace(t,Ut),e=De.magnitudeSquared(r),t=Math.sqrt(e),r=De.divideByScalar(r,t,Pt),e=Math.max(1,e),t=1/(t=Math.max(1,t));return 1/(De.dot(r,n)*t-De.magnitude(De.cross(r,n,r))*(Math.sqrt(e-1)*t))}function Dt(e,t,n){if(!(t<=0||t===1/0||t!=t))return De.multiplyByScalar(e,t,n)}var bt=new De;function Lt(e,t){return De.equals(t,De.ZERO)?t:(e.transformPositionToScaledSpace(t,bt),De.normalize(bt,bt))}var Ft={};function Bt(e,t,n){var r=e+t;return Ce.sign(e)!==Ce.sign(t)&&Math.abs(r/Math.max(Math.abs(e),Math.abs(t)))<n?0:r}Ft.computeDiscriminant=function(e,t,n){return t*t-4*e*n},Ft.computeRealRoots=function(e,t,n){if(0===e)return 0===t?[]:[-n/t];if(0===t){if(0===n)return[0,0];var r=Math.abs(n),i=Math.abs(e);if(r<i&&r/i<Ce.EPSILON14)return[0,0];if(i<r&&i/r<Ce.EPSILON14)return[];if((i=-n/e)<0)return[];r=Math.sqrt(i);return[-r,r]}if(0===n)return(i=-t/e)<0?[i,0]:[0,i];i=Bt(t*t,-(4*e*n),Ce.EPSILON14);if(i<0)return[];i=-.5*Bt(t,Ce.sign(t)*Math.sqrt(i),Ce.EPSILON14);return 0<t?[i/e,n/i]:[n/i,i/e]};var zt={};function qt(e,t,n,r){var i=e,a=t/3,o=n/3,s=r,u=i*o,c=a*s,l=a*a,f=o*o,h=i*o-l,e=i*s-a*o,t=a*s-f,n=4*h*t-e*e;if(n<0){var r=u*f<=l*c?-2*a*(p=h)+(m=i)*e:-(m=s)*e+2*o*(p=t),d=-(r<0?-1:1)*Math.abs(m)*Math.sqrt(-n),m=(E=d-r)/2,m=m<0?-Math.pow(-m,1/3):Math.pow(m,1/3),d=E===d?-m:-p/m,d=p<=0?m+d:-r/(m*m+d*d+p);return u*f<=l*c?[(d-a)/i]:[-s/(d+o)]}var p=h,u=-2*a*h+i*e,f=t,l=-s*e+2*o*t,c=Math.sqrt(n),h=Math.sqrt(3)/2,e=Math.abs(Math.atan2(i*c,-u)/3);d=2*Math.sqrt(-p);t=Math.cos(e);E=d*t;var n=d*(-t/2-h*Math.sin(e)),u=2*a<E+n?E-a:n-a,p=i,i=u/p,e=Math.abs(Math.atan2(s*c,-l)/3),s=-s,e=(E=(d=2*Math.sqrt(-f))*(t=Math.cos(e)))+(n=d*(-t/2-h*Math.sin(e)))<2*o?E+o:n+o,E=s/e,n=-u*e-p*s,e=(o*n-a*(u*s))/(-a*n+o*(p*e));return i<=e?i<=E?e<=E?[i,e,E]:[i,E,e]:[E,i,e]:i<=E?[e,i,E]:e<=E?[e,E,i]:[E,e,i]}zt.computeDiscriminant=function(e,t,n,r){var i=t*t,a=n*n;return 18*e*t*n*r+i*a-27*(e*e)*(r*r)-4*(e*a*n+i*t*r)},zt.computeRealRoots=function(e,t,n,r){var i;if(0===e)return Ft.computeRealRoots(t,n,r);if(0!==t)return 0===n?0===r?(a=-t/e)<0?[a,0,0]:[0,0,a]:qt(e,t,0,r):0===r?0===(i=Ft.computeRealRoots(e,t,n)).length?[0]:i[1]<=0?[i[0],i[1],0]:0<=i[0]?[0,i[0],i[1]]:[i[0],0,i[1]]:qt(e,t,n,r);if(0!==n)return 0===r?0===(i=Ft.computeRealRoots(e,0,n)).Length?[0]:[i[0],0,i[1]]:qt(e,0,n,r);if(0===r)return[0,0,0];var a=(a=-r/e)<0?-Math.pow(-a,1/3):Math.pow(a,1/3);return[a,a,a]};var Vt={};function kt(e,t,n,r){var i=e*e,a=t-3*i/8,o=n-t*e/2+i*e/8,r=r-n*e/4+t*i/16-3*i*i/256,n=zt.computeRealRoots(1,2*a,a*a-4*r,-o*o);if(0<n.length){t=-e/4,i=n[n.length-1];if(Math.abs(i)<Ce.EPSILON14){e=Ft.computeRealRoots(1,a,r);if(2===e.length){var n=e[0],s=e[1];if(0<=n&&0<=s){r=Math.sqrt(n),e=Math.sqrt(s);return[t-e,t-r,t+r,t+e]}if(0<=n&&s<0)return[t-(u=Math.sqrt(n)),t+u];if(n<0&&0<=s)return[t-(u=Math.sqrt(s)),t+u]}return[]}if(0<i){var s=Math.sqrt(i),u=(a+i-o/s)/2,o=(a+i+o/s)/2,u=Ft.computeRealRoots(1,s,u),o=Ft.computeRealRoots(1,-s,o);return 0!==u.length?(u[0]+=t,u[1]+=t,0!==o.length?(o[0]+=t,o[1]+=t,u[1]<=o[0]?[u[0],u[1],o[0],o[1]]:o[1]<=u[0]?[o[0],o[1],u[0],u[1]]:u[0]>=o[0]&&u[1]<=o[1]?[o[0],u[0],u[1],o[1]]:o[0]>=u[0]&&o[1]<=u[1]?[u[0],o[0],o[1],u[1]]:u[0]>o[0]&&u[0]<o[1]?[o[0],u[0],o[1],u[1]]:[u[0],o[0],u[1],o[1]]):u):0!==o.length?(o[0]+=t,o[1]+=t,o):[]}}return[]}function Gt(e,t,n,r){var i=e*e,a=-2*t,o=n*e+t*t-4*r,s=i*r-n*t*e+n*n,u=zt.computeRealRoots(1,a,o,s);if(0<u.length){var c,l,f,h,d=u[0],a=t-d,o=a*a,s=e/2,u=a/2,t=o-4*r,a=o+4*Math.abs(r),o=i-4*d,i=i+4*Math.abs(d);l=d<0||t*i<o*a?(c=(o=Math.sqrt(o))/2,0===o?0:(e*u-n)/o):(c=0===(l=Math.sqrt(t))?0:(e*u-n)/l,l/2),0==s&&0===c?h=f=0:Ce.sign(s)===Ce.sign(c)?h=d/(f=s+c):f=d/(h=s-c),0==u&&0===l?p=m=0:Ce.sign(u)===Ce.sign(l)?p=r/(m=u+l):m=r/(p=u-l);var m=Ft.computeRealRoots(1,f,m),p=Ft.computeRealRoots(1,h,p);if(0!==m.length)return 0!==p.length?m[1]<=p[0]?[m[0],m[1],p[0],p[1]]:p[1]<=m[0]?[p[0],p[1],m[0],m[1]]:m[0]>=p[0]&&m[1]<=p[1]?[p[0],m[0],m[1],p[1]]:p[0]>=m[0]&&p[1]<=m[1]?[m[0],p[0],p[1],m[1]]:m[0]>p[0]&&m[0]<p[1]?[p[0],m[0],p[1],m[1]]:[m[0],p[0],m[1],p[1]]:m;if(0!==p.length)return p}return[]}function Xt(e,t){t=De.clone(Pe(t,De.ZERO)),De.equals(t,De.ZERO)||De.normalize(t,t),this.origin=De.clone(Pe(e,De.ZERO)),this.direction=t}Vt.computeDiscriminant=function(e,t,n,r,i){var a=e*e,o=t*t,s=o*t,u=n*n,c=u*n,l=r*r,f=l*r,h=i*i;return o*u*l-4*s*f-4*e*c*l+18*e*t*n*f-27*a*l*l+256*(a*e)*(h*i)+i*(18*s*n*r-4*o*c+16*e*u*u-80*e*t*u*r-6*e*o*l+144*a*n*l)+h*(144*e*o*n-27*o*o-128*a*u-192*a*t*r)},Vt.computeRealRoots=function(e,t,n,r,i){if(Math.abs(e)<Ce.EPSILON15)return zt.computeRealRoots(t,n,r,i);var a=t/e,o=n/e,s=r/e,u=i/e,e=a<0?1:0;switch(e+=o<0?e+1:e,e+=s<0?e+1:e,e+=u<0?e+1:e){case 0:return kt(a,o,s,u);case 1:case 2:return Gt(a,o,s,u);case 3:case 4:return kt(a,o,s,u);case 5:return Gt(a,o,s,u);case 6:case 7:return kt(a,o,s,u);case 8:return Gt(a,o,s,u);case 9:case 10:return kt(a,o,s,u);case 11:return Gt(a,o,s,u);case 12:case 13:case 14:case 15:return kt(a,o,s,u);default:return}},Xt.clone=function(e,t){if(Ue(e))return Ue(t)?(t.origin=De.clone(e.origin),t.direction=De.clone(e.direction),t):new Xt(e.origin,e.direction)},Xt.getPoint=function(e,t,n){return Ue(n)||(n=new De),n=De.multiplyByScalar(e.direction,t,n),De.add(e.origin,n,n)};var Wt={rayPlane:function(e,t,n){Ue(n)||(n=new De);var r=e.origin,i=e.direction,a=t.normal,e=De.dot(a,i);if(!(Math.abs(e)<Ce.EPSILON15)){e=(-t.distance-De.dot(a,r))/e;if(!(e<0))return n=De.multiplyByScalar(i,e,n),De.add(r,n,n)}}},Ht=new De,Yt=new De,jt=new De,Zt=new De,Kt=new De;Wt.rayTriangleParametric=function(e,t,n,r,i){i=Pe(i,!1);var a,o,s,u=e.origin,c=e.direction,l=De.subtract(n,t,Ht),e=De.subtract(r,t,Yt),n=De.cross(c,e,jt),r=De.dot(l,n);if(i){if(r<Ce.EPSILON6)return;if(h=De.subtract(u,t,Zt),(f=De.dot(h,n))<0||r<f)return;if(a=De.cross(h,l,Kt),(o=De.dot(c,a))<0||r<f+o)return;s=De.dot(e,a)/r}else{if(Math.abs(r)<Ce.EPSILON6)return;var f,r=1/r,h=De.subtract(u,t,Zt);if((f=De.dot(h,n)*r)<0||1<f)return;if(a=De.cross(h,l,Kt),(o=De.dot(c,a)*r)<0||1<f+o)return;s=De.dot(e,a)*r}return s},Wt.rayTriangle=function(e,t,n,r,i,a){i=Wt.rayTriangleParametric(e,t,n,r,i);if(Ue(i)&&!(i<0))return Ue(a)||(a=new De),De.multiplyByScalar(e.direction,i,a),De.add(e.origin,a,a)};var Jt=new Xt;function Qt(e,t,n,r){var i=t*t-4*e*n;if(!(i<0)){if(0<i){var a=1/(2*e),n=Math.sqrt(i),i=(-t+n)*a,a=(-t-n)*a;return i<a?(r.root0=i,r.root1=a):(r.root0=a,r.root1=i),r}e=-t/(2*e);if(0!=e)return r.root0=r.root1=e,r}}Wt.lineSegmentTriangle=function(e,t,n,r,i,a,o){var s=Jt;De.clone(e,s.origin),De.subtract(t,e,s.direction),De.normalize(s.direction,s.direction);a=Wt.rayTriangleParametric(s,n,r,i,a);if(!(!Ue(a)||a<0||a>De.distance(e,t)))return Ue(o)||(o=new De),De.multiplyByScalar(s.direction,a,o),De.add(s.origin,o,o)};var $t={root0:0,root1:0};function en(e,t,n){Ue(n)||(n=new q);var r=e.origin,i=e.direction,e=t.center,t=t.radius*t.radius,e=De.subtract(r,e,jt),t=Qt(De.dot(i,i),2*De.dot(i,e),De.magnitudeSquared(e)-t,$t);if(Ue(t))return n.start=t.root0,n.stop=t.root1,n}Wt.raySphere=function(e,t,n){if(Ue(n=en(e,t,n))&&!(n.stop<0))return n.start=Math.max(n.start,0),n};var tn=new Xt;Wt.lineSegmentSphere=function(e,t,n,r){var i=tn;De.clone(e,i.origin);t=De.subtract(t,e,i.direction),e=De.magnitude(t);if(De.normalize(t,t),!(!Ue(r=en(i,n,r))||r.stop<0||r.start>e))return r.start=Math.max(r.start,0),r.stop=Math.min(r.stop,e),r};var nn=new De,rn=new De;function an(e,t,n){var r=e+t;return Ce.sign(e)!==Ce.sign(t)&&Math.abs(r/Math.max(Math.abs(e),Math.abs(t)))<n?0:r}function on(e,t,n,r,i){var a,o=r*r,s=i*i,u=(e[V.COLUMN1ROW1]-e[V.COLUMN2ROW2])*s,c=i*(r*an(e[V.COLUMN1ROW0],e[V.COLUMN0ROW1],Ce.EPSILON15)+t.y),l=e[V.COLUMN0ROW0]*o+e[V.COLUMN2ROW2]*s+r*t.x+n,f=s*an(e[V.COLUMN2ROW1],e[V.COLUMN1ROW2],Ce.EPSILON15),h=i*(r*an(e[V.COLUMN2ROW0],e[V.COLUMN0ROW2])+t.z),d=[];if(0==h&&0==f){if(0===(a=Ft.computeRealRoots(u,c,l)).length)return d;var m=a[0],p=Math.sqrt(Math.max(1-m*m,0));return d.push(new De(r,i*m,i*-p)),d.push(new De(r,i*m,i*p)),2===a.length&&(E=a[1],y=Math.sqrt(Math.max(1-E*E,0)),d.push(new De(r,i*E,i*-y)),d.push(new De(r,i*E,i*y))),d}var t=h*h,m=f*f,p=h*f,E=u*u+m,y=2*(c*u+p),m=2*l*u+c*c-m+t,p=2*(l*c-p),t=l*l-t;if(0==E&&0==y&&0==m&&0==p)return d;var _=(a=Vt.computeRealRoots(E,y,m,p,t)).length;if(0===_)return d;for(var T=0;T<_;++T){var R=a[T],A=R*R,g=Math.max(1-A,0),g=Math.sqrt(g),A=Ce.sign(u)===Ce.sign(l)?an(u*A+l,c*R,Ce.EPSILON12):Ce.sign(l)===Ce.sign(c*R)?an(u*A,c*R+l,Ce.EPSILON12):an(u*A+c*R,l,Ce.EPSILON12),A=A*an(f*R,h,Ce.EPSILON15);A<0?d.push(new De(r,i*R,i*g)):0<A?d.push(new De(r,i*R,i*-g)):0!==g?(d.push(new De(r,i*R,i*-g)),d.push(new De(r,i*R,i*g)),++T):d.push(new De(r,i*R,i*g))}return d}Wt.rayEllipsoid=function(e,t){var n,r,i=t.oneOverRadii,a=De.multiplyComponents(i,e.origin,nn),t=De.multiplyComponents(i,e.direction,rn),i=De.magnitudeSquared(a),e=De.dot(a,t);if(1<i){if(0<=e)return;var o,s,a=e*e,u=i-1;if(a<(s=(o=De.magnitudeSquared(t))*u))return;if(s<a){n=e*e-s;var c=(r=-e+Math.sqrt(n))/o,a=u/r;return c<a?new q(c,a):{start:a,stop:c}}c=Math.sqrt(u/o);return new q(c,c)}return i<1?(u=i-1,n=e*e-(s=(o=De.magnitudeSquared(t))*u),new q(0,(r=-e+Math.sqrt(n))/o)):e<0?new q(0,-e/(o=De.magnitudeSquared(t))):void 0};var sn=new De,un=new De,cn=new De,ln=new De,fn=new De,hn=new V,dn=new V,mn=new V,pn=new V,En=new V,yn=new V,_n=new V,Tn=new De,Rn=new De,An=new R;Wt.grazingAltitudeLocation=function(e,t){var n=e.origin,r=e.direction;if(!De.equals(n,De.ZERO)){var i=t.geodeticSurfaceNormal(n,sn);if(0<=De.dot(r,i))return n}var a=Ue(this.rayEllipsoid(e,t)),o=t.transformPositionToScaledSpace(r,sn),i=De.normalize(o,o),e=De.mostOrthogonalAxis(o,ln),o=De.normalize(De.cross(e,i,un),un),e=De.normalize(De.cross(i,o,cn),cn),s=hn;s[0]=i.x,s[1]=i.y,s[2]=i.z,s[3]=o.x,s[4]=o.y,s[5]=o.z,s[6]=e.x,s[7]=e.y,s[8]=e.z;var i=V.transpose(s,dn),u=V.fromScale(t.radii,mn),o=V.fromScale(t.oneOverRadii,pn),e=En;e[0]=0,e[1]=-r.z,e[2]=r.y,e[3]=r.z,e[4]=0,e[5]=-r.x,e[6]=-r.y,e[7]=r.x,e[8]=0;var c,o=V.multiply(V.multiply(i,o,yn),e,yn),e=V.multiply(V.multiply(o,u,_n),s,_n),o=V.multiplyByVector(o,n,fn),l=on(e,De.negate(o,sn),0,0,1),f=l.length;if(0<f){for(var h=De.clone(De.ZERO,Rn),d=Number.NEGATIVE_INFINITY,m=0;m<f;++m){c=V.multiplyByVector(u,V.multiplyByVector(s,l[m],Tn),Tn);var p=De.normalize(De.subtract(c,n,ln),ln),p=De.dot(p,r);d<p&&(d=p,h=De.clone(c,h))}e=t.cartesianToCartographic(h,An),d=Ce.clamp(d,0,1),o=De.magnitude(De.subtract(h,n,ln))*Math.sqrt(1-d*d);return o=a?-o:o,e.height=o,t.cartographicToCartesian(e,new De)}};var gn=new De;function Sn(e,t){this.normal=De.clone(e),this.distance=t}Wt.lineSegmentPlane=function(e,t,n,r){Ue(r)||(r=new De);var i=De.subtract(t,e,gn),a=n.normal,t=De.dot(a,i);if(!(Math.abs(t)<Ce.EPSILON6)){a=De.dot(a,e),t=-(n.distance+a)/t;if(!(t<0||1<t))return De.multiplyByScalar(i,t,r),De.add(e,r,r),r}},Wt.trianglePlaneIntersection=function(e,t,n,r){var i,a,o=r.normal,s=r.distance,u=De.dot(o,e)+s<0,c=De.dot(o,t)+s<0,o=De.dot(o,n)+s<0,s=0;if(s+=u?1:0,s+=c?1:0,1!=(s+=o?1:0)&&2!=s||(i=new De,a=new De),1==s){if(u)return Wt.lineSegmentPlane(e,t,r,i),Wt.lineSegmentPlane(e,n,r,a),{positions:[e,t,n,i,a],indices:[0,3,4,1,2,4,1,4,3]};if(c)return Wt.lineSegmentPlane(t,n,r,i),Wt.lineSegmentPlane(t,e,r,a),{positions:[e,t,n,i,a],indices:[1,3,4,2,0,4,2,4,3]};if(o)return Wt.lineSegmentPlane(n,e,r,i),Wt.lineSegmentPlane(n,t,r,a),{positions:[e,t,n,i,a],indices:[2,3,4,0,1,4,0,4,3]}}else if(2==s){if(!u)return Wt.lineSegmentPlane(t,e,r,i),Wt.lineSegmentPlane(n,e,r,a),{positions:[e,t,n,i,a],indices:[1,2,4,1,4,3,0,3,4]};if(!c)return Wt.lineSegmentPlane(n,t,r,i),Wt.lineSegmentPlane(e,t,r,a),{positions:[e,t,n,i,a],indices:[2,0,4,2,4,3,1,3,4]};if(!o)return Wt.lineSegmentPlane(e,n,r,i),Wt.lineSegmentPlane(t,n,r,a),{positions:[e,t,n,i,a],indices:[0,1,4,0,4,3,2,3,4]}}},Sn.fromPointNormal=function(e,t,n){e=-De.dot(t,e);return Ue(n)?(De.clone(t,n.normal),n.distance=e,n):new Sn(t,e)};var wn=new De;Sn.fromCartesian4=function(e,t){var n=De.fromCartesian4(e,wn),e=e.w;return Ue(t)?(De.clone(n,t.normal),t.distance=e,t):new Sn(n,e)},Sn.getPointDistance=function(e,t){return De.dot(e.normal,t)+e.distance};var In=new De;Sn.projectPointOntoPlane=function(e,t,n){Ue(n)||(n=new De);var r=Sn.getPointDistance(e,t),r=De.multiplyByScalar(e.normal,r,In);return De.subtract(t,r,n)};var Mn,On,Nn,xn=new Fe,vn=new $,Un=new De;function Pn(e,t,n,r){return Cn(e).then(t,n,r)}function Cn(e){var t,e=e instanceof bn?e:zn(e)?(t=Bn(),e.then(function(e){t.resolve(e)},function(e){t.reject(e)},function(e){t.progress(e)}),t.promise):Ln(e);return e}function Dn(e){return Pn(e,Fn)}function bn(e){this.then=e}function Ln(t){return new bn(function(e){try{return Cn(e?e(t):t)}catch(e){return Fn(e)}})}function Fn(n){return new bn(function(e,t){try{return t?Cn(t(n)):Fn(n)}catch(e){return Fn(e)}})}function Bn(){var e=new bn(i),o=[],s=[],r=function(t,n,r){var i=Bn(),a="function"==typeof r?function(e){try{i.progress(r(e))}catch(e){i.progress(e)}}:function(e){i.progress(e)};return o.push(function(e){e.then(t,n).then(i.resolve,i.reject,a)}),s.push(a),i.promise},t=function(e){return Yn(s,e),e},n=function(e){return e=Cn(e),r=e.then,n=Cn,t=Zn,Yn(o,e),s=o=Nn,e};return{then:i,resolve:a,reject:u,progress:c,promise:e,resolver:{resolve:a,reject:u,progress:c}};function i(e,t,n){return r(e,t,n)}function a(e){return n(e)}function u(e){return n(Fn(e))}function c(e){return t(e)}}function zn(e){return e&&"function"==typeof e.then}function qn(e,d,m,p,E){return jn(2,arguments),Pn(e,function(e){var t,n,r,i,a=e.length>>>0,o=Math.max(0,Math.min(d,a)),s=[],u=a-o+1,c=[],l=Bn();if(o)for(r=l.progress,n=function(e){c.push(e),--u||(t=n=Zn,l.reject(c))},t=function(e){s.push(e),--o||(t=n=Zn,l.resolve(s))},i=0;i<a;++i)i in e&&Pn(e[i],h,f,r);else l.resolve(s);return l.then(m,p,E);function f(e){n(e)}function h(e){t(e)}})}function Vn(e,t,n,r){return qn(e,1,function(e){return t?t(e[0]):e[0]},n,r)}function kn(e,t,n,r){return jn(1,arguments),Xn(e,Kn).then(t,n,r)}function Gn(){return Xn(arguments,Kn)}function Xn(e,s){return Pn(e,function(e){var t,n,r,i=t=e.length>>>0,a=[],o=Bn();if(i)for(n=function(e,t){Pn(e,s).then(function(e){a[t]=e,--i||o.resolve(a)},o.reject)},r=0;r<t;r++)r in e?n(e[r],r):--i;else o.resolve(a);return o.promise})}function Wn(e,a){var t=On.call(arguments,1);return Pn(e,function(e){var i=e.length;return t[0]=function(e,n,r){return Pn(e,function(t){return Pn(n,function(e){return a(t,e,r,i)})})},Mn.apply(e,t)})}function Hn(e,t,n){var r=2<arguments.length;return Pn(e,function(e){return e=r?n:e,t.resolve(e),e},function(e){return t.reject(e),Fn(e)},t.progress)}function Yn(e,t){for(var n,r=0;n=e[r++];)n(t)}function jn(e,t){for(var n,r=t.length;e<r;)if(null!=(n=t[--r])&&"function"!=typeof n)throw new Error("arg "+r+" must be a function")}function Zn(){}function Kn(e){return e}function Jn(e,t,n){for(var r,i,a=0,o=e.length-1;a<=o;)if((i=n(e[r=~~((a+o)/2)],t))<0)a=1+r;else{if(!(0<i))return r;o=r-1}return~(o+1)}function Qn(e,t,n,r,i){this.xPoleWander=e,this.yPoleWander=t,this.xPoleOffset=n,this.yPoleOffset=r,this.ut1MinusUtc=i}function $n(){function T(e,t,n,r){return n=n||" ",n=e.length>=t?"":Array(1+t-e.length>>>0).join(n),r?e+n:n+e}function R(e,t,n,r,i,a){var o=r-e.length;return e=0<o?n||!i?T(e,r,a,n):e.slice(0,t.length)+T("",o,"0",!0)+e.slice(t.length):e}function A(e,t,n,r,i,a,o){var s=e>>>0;return e=(n=n&&s&&{2:"0b",8:"0",16:"0x"}[t]||"")+T(s.toString(t),a||0,"0",!1),R(e,n,r,i,o)}function g(e,t,n,r,i,a){return null!=r&&(e=e.slice(0,r)),R(e,"",t,n,i,a)}var S=arguments,w=0,e=S[w++];return e.replace(/%%|%(\\d+\\$)?([-+\\'#0 ]*)(\\*\\d+\\$|\\*|\\d+)?(\\.(\\*\\d+\\$|\\*|\\d+))?([scboxXuideEfFgG])/g,function(e,t,n,r,i,a,o){var s,u,c,l,f;if("%%"==e)return"%";for(var h=!1,d="",m=!1,p=!1,E=" ",y=n.length,_=0;n&&_<y;_++)switch(n.charAt(_)){case" ":d=" ";break;case"+":d="+";break;case"-":h=!0;break;case"'":E=n.charAt(_+1);break;case"0":m=!0;break;case"#":p=!0}if((r=r?"*"==r?+S[w++]:"*"==r.charAt(0)?+S[r.slice(1,-1)]:+r:0)<0&&(r=-r,h=!0),!isFinite(r))throw new Error("sprintf: (minimum-)width must be finite");switch(a=a?"*"==a?+S[w++]:"*"==a.charAt(0)?+S[a.slice(1,-1)]:+a:-1<"fFeE".indexOf(o)?6:"d"==o?0:void 0,f=t?S[t.slice(0,-1)]:S[w++],o){case"s":return g(String(f),h,r,a,m,E);case"c":return g(String.fromCharCode(+f),h,r,a,m);case"b":return A(f,2,p,h,r,a,m);case"o":return A(f,8,p,h,r,a,m);case"x":return A(f,16,p,h,r,a,m);case"X":return A(f,16,p,h,r,a,m).toUpperCase();case"u":return A(f,10,p,h,r,a,m);case"i":case"d":return s=+f||0,f=(u=(s=Math.round(s-s%1))<0?"-":d)+T(String(Math.abs(s)),a,"0",!1),R(f,u,h,r,m);case"e":case"E":case"f":case"F":case"g":case"G":return u=(s=+f)<0?"-":d,c=["toExponential","toFixed","toPrecision"]["efg".indexOf(o.toLowerCase())],l=["toString","toUpperCase"]["eEfFgG".indexOf(o)%2],f=u+Math.abs(s)[c](a),R(f,u,h,r,m)[l]();default:return e}})}function er(e,t,n,r,i,a,o,s){this.year=e,this.month=t,this.day=n,this.hour=r,this.minute=i,this.second=a,this.millisecond=o,this.isLeapSecond=s}function tr(e){return e%4==0&&e%100!=0||e%400==0}function nr(e,t){this.julianDate=e,this.offset=t}Sn.transform=function(e,t,n){var r=e.normal,e=e.distance,t=Fe.inverseTranspose(t,xn),e=$.fromElements(r.x,r.y,r.z,e,vn),e=Fe.multiplyByVector(t,e,e),t=De.fromCartesian4(e,Un);return e=$.divideByScalar(e,De.magnitude(t),e),Sn.fromCartesian4(e,n)},Sn.clone=function(e,t){return Ue(t)?(De.clone(e.normal,t.normal),t.distance=e.distance,t):new Sn(e.normal,e.distance)},Sn.equals=function(e,t){return e.distance===t.distance&&De.equals(e.normal,t.normal)},Sn.ORIGIN_XY_PLANE=Object.freeze(new Sn(De.UNIT_Z,0)),Sn.ORIGIN_YZ_PLANE=Object.freeze(new Sn(De.UNIT_X,0)),Sn.ORIGIN_ZX_PLANE=Object.freeze(new Sn(De.UNIT_Y,0)),Pn.defer=Bn,Pn.resolve=Cn,Pn.reject=Dn,Pn.join=Gn,Pn.all=kn,Pn.map=Xn,Pn.reduce=Wn,Pn.any=Vn,Pn.some=qn,Pn.chain=Hn,Pn.isPromise=zn,bn.prototype={always:function(e,t){return this.then(e,e,t)},otherwise:function(e){return this.then(Nn,e)},yield:function(e){return this.then(function(){return e})},spread:function(t){return this.then(function(e){return kn(e,function(e){return t.apply(Nn,e)})})}},On=[].slice,Mn=[].reduce||function(e){var t,n=0,r=Object(this),i=r.length>>>0,a=arguments;if(a.length<=1)for(;;){if(n in r){t=r[n++];break}if(++n>=i)throw new TypeError}else t=a[1];for(;n<i;++n)n in r&&(t=e(t,r[n],n,r));return t};var rr={SECONDS_PER_MILLISECOND:.001,SECONDS_PER_MINUTE:60,MINUTES_PER_HOUR:60,HOURS_PER_DAY:24,SECONDS_PER_HOUR:3600,MINUTES_PER_DAY:1440,SECONDS_PER_DAY:86400,DAYS_PER_JULIAN_CENTURY:36525,PICOSECOND:1e-9,MODIFIED_JULIAN_DATE_DIFFERENCE:2400000.5},ir=Object.freeze(rr),ar={UTC:0,TAI:1},or=Object.freeze(ar),sr=new er,ur=[31,28,31,30,31,30,31,31,30,31,30,31],cr=29;function lr(e,t){return Ir.compare(e.julianDate,t.julianDate)}var fr=new nr;function hr(e){fr.julianDate=e;var t=Ir.leapSeconds,n=Jn(t,fr,lr),r=t[n=(n=n<0?~n:n)>=t.length?t.length-1:n].offset;0<n&&r<Ir.secondsDifference(t[n].julianDate,e)&&(r=t[--n].offset),Ir.addSeconds(e,r,e)}function dr(e,t){fr.julianDate=e;var n=Ir.leapSeconds,r=Jn(n,fr,lr);if(0===(r=r<0?~r:r))return Ir.addSeconds(e,-n[0].offset,t);if(r>=n.length)return Ir.addSeconds(e,-n[r-1].offset,t);var i=Ir.secondsDifference(n[r].julianDate,e);return 0===i?Ir.addSeconds(e,-n[r].offset,t):i<=1?void 0:Ir.addSeconds(e,-n[--r].offset,t)}function mr(e,t,n){var r=t/ir.SECONDS_PER_DAY|0;return e+=r,(t-=ir.SECONDS_PER_DAY*r)<0&&(e--,t+=ir.SECONDS_PER_DAY),n.dayNumber=e,n.secondsOfDay=t,n}function pr(e,t,n,r,i,a,o){var s=(t-14)/12|0,e=e+4800+s,n=(1461*e/4|0)+(367*(t-2-12*s)/12|0)-(3*((e+100)/100|0)/4|0)+n-32075;(r-=12)<0&&(r+=24);o=a+(r*ir.SECONDS_PER_HOUR+i*ir.SECONDS_PER_MINUTE+o*ir.SECONDS_PER_MILLISECOND);return 43200<=o&&--n,[n,o]}var Er=/^(\\d{4})$/,yr=/^(\\d{4})-(\\d{2})$/,_r=/^(\\d{4})-?(\\d{3})$/,Tr=/^(\\d{4})-?W(\\d{2})-?(\\d{1})?$/,Rr=/^(\\d{4})-?(\\d{2})-?(\\d{2})$/,Ar=/([Z+\\-])?(\\d{2})?:?(\\d{2})?$/,gr=/^(\\d{2})(\\.\\d+)?/.source+Ar.source,Sr=/^(\\d{2}):?(\\d{2})(\\.\\d+)?/.source+Ar.source,wr=/^(\\d{2}):?(\\d{2}):?(\\d{2})(\\.\\d+)?/.source+Ar.source;function Ir(e,t,n){this.dayNumber=void 0,this.secondsOfDay=void 0,e=Pe(e,0),t=Pe(t,0),n=Pe(n,or.UTC);var r=0|e;mr(r,t+=(e-r)*ir.SECONDS_PER_DAY,this),n===or.UTC&&hr(this)}Ir.fromGregorianDate=function(e,t){e=pr(e.year,e.month,e.day,e.hour,e.minute,e.second,e.millisecond);return Ue(t)?(mr(e[0],e[1],t),hr(t),t):new Ir(e[0],e[1],or.UTC)},Ir.fromDate=function(e,t){e=pr(e.getUTCFullYear(),e.getUTCMonth()+1,e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds(),e.getUTCMilliseconds());return Ue(t)?(mr(e[0],e[1],t),hr(t),t):new Ir(e[0],e[1],or.UTC)},Ir.fromIso8601=function(e,t){var n,r,i,a,o,s=(e=e.replace(",",".")).split("T"),u=1,c=1,l=0,f=0,h=0,d=0,m=s[0],e=s[1];if(null!==(s=m.match(Rr))?(n=+s[1],u=+s[2],c=+s[3]):null!==(s=m.match(yr))?(n=+s[1],u=+s[2]):null!==(s=m.match(Er))?n=+s[1]:(null!==(s=m.match(_r))?(n=+s[1],a=+s[2],i=tr(n)):null!==(s=m.match(Tr))&&(n=+s[1],a=7*+s[2]+(+s[3]||0)-new Date(Date.UTC(n,0,4)).getUTCDay()-3),(r=new Date(Date.UTC(n,0,1))).setUTCDate(a),u=r.getUTCMonth()+1,c=r.getUTCDate()),i=tr(n),Ue(e)){null!==(s=e.match(wr))?(l=+s[1],f=+s[2],h=+s[3],d=1e3*+(s[4]||0),o=5):null!==(s=e.match(Sr))?(l=+s[1],f=+s[2],h=60*+(s[3]||0),o=4):null!==(s=e.match(gr))&&(l=+s[1],f=60*+(s[2]||0),o=3);var p=s[o],E=+s[o+1],y=+(s[o+2]||0);switch(p){case"+":l-=E,f-=y;break;case"-":l+=E,f+=y;break;case"Z":break;default:f+=new Date(Date.UTC(n,u-1,c,l,f)).getTimezoneOffset()}}p=60===h;for(p&&h--;60<=f;)f-=60,l++;for(;24<=l;)l-=24,c++;for(r=i&&2===u?cr:ur[u-1];r<c;)c-=r,12<++u&&(u-=12,n++),r=i&&2===u?cr:ur[u-1];for(;f<0;)f+=60,l--;for(;l<0;)l+=24,c--;for(;c<1;)--u<1&&(u+=12,n--),c+=r=i&&2===u?cr:ur[u-1];d=pr(n,u,c,l,f,h,d);return Ue(t)?(mr(d[0],d[1],t),hr(t)):t=new Ir(d[0],d[1],or.UTC),p&&Ir.addSeconds(t,1,t),t},Ir.now=function(e){return Ir.fromDate(new Date,e)};var Mr=new Ir(0,0,or.TAI);function Or(e){e instanceof Or?(this.scheme=e.scheme,this.authority=e.authority,this.path=e.path,this.query=e.query,this.fragment=e.fragment):e&&(e=Nr.exec(e),this.scheme=e[1],this.authority=e[2],this.path=e[3],this.query=e[4],this.fragment=e[5])}Ir.toGregorianDate=function(e,t){var n=!1,r=dr(e,Mr);Ue(r)||(Ir.addSeconds(e,-1,Mr),r=dr(Mr,Mr),n=!0);var i=r.dayNumber,a=r.secondsOfDay;43200<=a&&(i+=1);var o=i+68569|0,s=4*o/146097|0,u=4e3*(1+(o=o-((146097*s+3)/4|0)|0))/1461001|0,e=80*(o=o-(1461*u/4|0)+31|0)/2447|0,r=o-(2447*e/80|0)|0,i=2+e-12*(o=e/11|0)|0,e=100*(s-49)+u+o|0,s=a/ir.SECONDS_PER_HOUR|0,u=a-s*ir.SECONDS_PER_HOUR,o=u/ir.SECONDS_PER_MINUTE|0,a=0|(u-=o*ir.SECONDS_PER_MINUTE),u=(u-a)/ir.SECONDS_PER_MILLISECOND;return 23<(s+=12)&&(s-=24),n&&(a+=1),Ue(t)?(t.year=e,t.month=i,t.day=r,t.hour=s,t.minute=o,t.second=a,t.millisecond=u,t.isLeapSecond=n,t):new er(e,i,r,s,o,a,u,n)},Ir.toDate=function(e){var t=Ir.toGregorianDate(e,sr),e=t.second;return t.isLeapSecond&&--e,new Date(Date.UTC(t.year,t.month-1,t.day,t.hour,t.minute,e,t.millisecond))},Ir.toIso8601=function(e,t){var n=Ir.toGregorianDate(e,sr),r=n.year,i=n.month,a=n.day,o=n.hour,s=n.minute,e=n.second,n=n.millisecond;return 1e4===r&&1===i&&1===a&&0===o&&0===s&&0===e&&0===n&&(r=9999,i=12,a=31,o=24),Ue(t)||0===n?Ue(t)&&0!==t?$n("%04d-%02d-%02dT%02d:%02d:%02d.%sZ",r,i,a,o,s,e,(.01*n).toFixed(t).replace(".","").slice(0,t)):$n("%04d-%02d-%02dT%02d:%02d:%02dZ",r,i,a,o,s,e):$n("%04d-%02d-%02dT%02d:%02d:%02d.%sZ",r,i,a,o,s,e,(.01*n).toString().replace(".",""))},Ir.clone=function(e,t){if(Ue(e))return Ue(t)?(t.dayNumber=e.dayNumber,t.secondsOfDay=e.secondsOfDay,t):new Ir(e.dayNumber,e.secondsOfDay,or.TAI)},Ir.compare=function(e,t){var n=e.dayNumber-t.dayNumber;return 0!=n?n:e.secondsOfDay-t.secondsOfDay},Ir.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&e.dayNumber===t.dayNumber&&e.secondsOfDay===t.secondsOfDay},Ir.equalsEpsilon=function(e,t,n){return n=Pe(n,0),e===t||Ue(e)&&Ue(t)&&Math.abs(Ir.secondsDifference(e,t))<=n},Ir.totalDays=function(e){return e.dayNumber+e.secondsOfDay/ir.SECONDS_PER_DAY},Ir.secondsDifference=function(e,t){return(e.dayNumber-t.dayNumber)*ir.SECONDS_PER_DAY+(e.secondsOfDay-t.secondsOfDay)},Ir.daysDifference=function(e,t){return e.dayNumber-t.dayNumber+(e.secondsOfDay-t.secondsOfDay)/ir.SECONDS_PER_DAY},Ir.computeTaiMinusUtc=function(e){fr.julianDate=e;var t=Ir.leapSeconds,e=Jn(t,fr,lr);return e<0&&(e=~e,--e<0&&(e=0)),t[e].offset},Ir.addSeconds=function(e,t,n){return mr(e.dayNumber,e.secondsOfDay+t,n)},Ir.addMinutes=function(e,t,n){t=e.secondsOfDay+t*ir.SECONDS_PER_MINUTE;return mr(e.dayNumber,t,n)},Ir.addHours=function(e,t,n){t=e.secondsOfDay+t*ir.SECONDS_PER_HOUR;return mr(e.dayNumber,t,n)},Ir.addDays=function(e,t,n){return mr(e.dayNumber+t,e.secondsOfDay,n)},Ir.lessThan=function(e,t){return Ir.compare(e,t)<0},Ir.lessThanOrEquals=function(e,t){return Ir.compare(e,t)<=0},Ir.greaterThan=function(e,t){return 0<Ir.compare(e,t)},Ir.greaterThanOrEquals=function(e,t){return 0<=Ir.compare(e,t)},Ir.prototype.clone=function(e){return Ir.clone(this,e)},Ir.prototype.equals=function(e){return Ir.equals(this,e)},Ir.prototype.equalsEpsilon=function(e,t){return Ir.equalsEpsilon(this,e,t)},Ir.prototype.toString=function(){return Ir.toIso8601(this)},Ir.leapSeconds=[new nr(new Ir(2441317,43210,or.TAI),10),new nr(new Ir(2441499,43211,or.TAI),11),new nr(new Ir(2441683,43212,or.TAI),12),new nr(new Ir(2442048,43213,or.TAI),13),new nr(new Ir(2442413,43214,or.TAI),14),new nr(new Ir(2442778,43215,or.TAI),15),new nr(new Ir(2443144,43216,or.TAI),16),new nr(new Ir(2443509,43217,or.TAI),17),new nr(new Ir(2443874,43218,or.TAI),18),new nr(new Ir(2444239,43219,or.TAI),19),new nr(new Ir(2444786,43220,or.TAI),20),new nr(new Ir(2445151,43221,or.TAI),21),new nr(new Ir(2445516,43222,or.TAI),22),new nr(new Ir(2446247,43223,or.TAI),23),new nr(new Ir(2447161,43224,or.TAI),24),new nr(new Ir(2447892,43225,or.TAI),25),new nr(new Ir(2448257,43226,or.TAI),26),new nr(new Ir(2448804,43227,or.TAI),27),new nr(new Ir(2449169,43228,or.TAI),28),new nr(new Ir(2449534,43229,or.TAI),29),new nr(new Ir(2450083,43230,or.TAI),30),new nr(new Ir(2450630,43231,or.TAI),31),new nr(new Ir(2451179,43232,or.TAI),32),new nr(new Ir(2453736,43233,or.TAI),33),new nr(new Ir(2454832,43234,or.TAI),34),new nr(new Ir(2456109,43235,or.TAI),35),new nr(new Ir(2457204,43236,or.TAI),36),new nr(new Ir(2457754,43237,or.TAI),37)],Or.prototype.scheme=null,Or.prototype.authority=null,Or.prototype.path="",Or.prototype.query=null,Or.prototype.fragment=null;var Nr=new RegExp("^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\\\?([^#]*))?(?:#(.*))?$");Or.prototype.getScheme=function(){return this.scheme},Or.prototype.getAuthority=function(){return this.authority},Or.prototype.getPath=function(){return this.path},Or.prototype.getQuery=function(){return this.query},Or.prototype.getFragment=function(){return this.fragment},Or.prototype.isAbsolute=function(){return!!this.scheme&&!this.fragment},Or.prototype.isSameDocumentAs=function(e){return e.scheme==this.scheme&&e.authority==this.authority&&e.path==this.path&&e.query==this.query},Or.prototype.equals=function(e){return this.isSameDocumentAs(e)&&e.fragment==this.fragment},Or.prototype.normalize=function(){this.removeDotSegments(),this.scheme&&(this.scheme=this.scheme.toLowerCase()),this.authority&&(this.authority=this.authority.replace(Ur,Cr).replace(xr,Pr)),this.path&&(this.path=this.path.replace(xr,Pr)),this.query&&(this.query=this.query.replace(xr,Pr)),this.fragment&&(this.fragment=this.fragment.replace(xr,Pr))};var xr=/%[0-9a-z]{2}/gi,vr=/[a-zA-Z0-9\\-\\._~]/,Ur=/(.*@)?([^@:]*)(:.*)?/;function Pr(e){var t=unescape(e);return vr.test(t)?t:e.toUpperCase()}function Cr(e,t,n,r){return(t||"")+n.toLowerCase()+(r||"")}function Dr(e){return 0!==e.length&&"/"===e[e.length-1]||(e+="/"),e}function br(e,t){if(null===e||"object"!=typeof e)return e;t=Pe(t,!1);var n,r,i=new e.constructor;for(n in e)e.hasOwnProperty(n)&&(r=e[n],t&&(r=br(r,t)),i[n]=r);return i}function Lr(e,t,n){n=Pe(n,!1);var r,i,a,o={},s=Ue(e),u=Ue(t);if(s)for(r in e)e.hasOwnProperty(r)&&(i=e[r],u&&n&&"object"==typeof i&&t.hasOwnProperty(r)?(a=t[r],o[r]="object"==typeof a?Lr(i,a,n):i):o[r]=i);if(u)for(r in t)t.hasOwnProperty(r)&&!o.hasOwnProperty(r)&&(a=t[r],o[r]=a);return o}function Fr(e,t){var n;return"undefined"!=typeof document&&(n=document),Fr._implementation(e,t,n)}function Br(e,t){var n="",r=e.lastIndexOf("/");return-1!==r&&(n=e.substring(0,r+1)),t&&(Ue((e=new Or(e)).query)&&(n+="?"+e.query),Ue(e.fragment)&&(n+="#"+e.fragment)),n}function zr(e){var t=new Or(e);t.normalize();e=t.path,t=e.lastIndexOf("/");return e=-1===(t=(e=-1!==t?e.substr(t+1):e).lastIndexOf("."))?"":e.substr(t+1)}Or.prototype.resolve=function(e){var t=new Or;return this.scheme?(t.scheme=this.scheme,t.authority=this.authority,t.path=this.path,t.query=this.query):(t.scheme=e.scheme,this.authority?(t.authority=this.authority,t.path=this.path,t.query=this.query):(t.authority=e.authority,""==this.path?(t.path=e.path,t.query=this.query||e.query):("/"==this.path.charAt(0)?t.path=this.path:e.authority&&""==e.path?t.path="/"+this.path:t.path=e.path.substring(0,e.path.lastIndexOf("/")+1)+this.path,t.removeDotSegments(),t.query=this.query))),t.fragment=this.fragment,t},Or.prototype.removeDotSegments=function(){var e,t=this.path.split("/"),n=[],r=""==t[0];for(r&&t.shift(),""==t[0]&&t.shift();t.length;)".."==(e=t.shift())?n.pop():"."!=e&&n.push(e);"."!=e&&".."!=e||n.push(""),r&&n.unshift(""),this.path=n.join("/")},Or.prototype.toString=function(){var e="";return this.scheme&&(e+=this.scheme+":"),this.authority&&(e+="//"+this.authority),e+=this.path,this.query&&(e+="?"+this.query),this.fragment&&(e+="#"+this.fragment),e},Fr._implementation=function(e,t,n){if(!Ue(t)){if(void 0===n)return e;t=Pe(n.baseURI,n.location.href)}t=new Or(t);return new Or(e).resolve(t).toString()};var qr,Vr=/^blob:/i;function kr(e){return Vr.test(e)}function Gr(e){(qr=!Ue(qr)?document.createElement("a"):qr).href=window.location.href;var t=qr.host,n=qr.protocol;return qr.href=e,qr.href=qr.href,n!==qr.protocol||t!==qr.host}var Xr=/^data:/i;function Wr(e){return Xr.test(e)}function Hr(e){var t=Pn.defer(),n=document.createElement("script");n.async=!0,n.src=e;var r=document.getElementsByTagName("head")[0];return n.onload=function(){n.onload=void 0,r.removeChild(n),t.resolve()},n.onerror=function(e){t.reject(e)},r.appendChild(n),t.promise}function Yr(e){var t,n="";for(t in e)if(e.hasOwnProperty(t)){var r=e[t],i=encodeURIComponent(t)+"=";if(Array.isArray(r))for(var a=0,o=r.length;a<o;++a)n+=i+encodeURIComponent(r[a])+"&";else n+=i+encodeURIComponent(r)+"&"}return n=n.slice(0,-1)}function jr(e){var t={};if(""===e)return t;for(var n=e.replace(/\\+/g,"%20").split(/[&;]/),r=0,i=n.length;r<i;++r){var a=n[r].split("="),o=decodeURIComponent(a[0]),s=Ue(s=a[1])?decodeURIComponent(s):"",a=t[o];"string"==typeof a?t[o]=[a,s]:Array.isArray(a)?a.push(s):t[o]=s}return t}var Zr={UNISSUED:0,ISSUED:1,ACTIVE:2,RECEIVED:3,CANCELLED:4,FAILED:5},Kr=Object.freeze(Zr),Jr={TERRAIN:0,IMAGERY:1,TILES3D:2,OTHER:3},Qr=Object.freeze(Jr);function $r(e){e=Pe(e,Pe.EMPTY_OBJECT);var t=Pe(e.throttleByServer,!1),n=Pe(e.throttle,!1);this.url=e.url,this.requestFunction=e.requestFunction,this.cancelFunction=e.cancelFunction,this.priorityFunction=e.priorityFunction,this.priority=Pe(e.priority,0),this.throttle=n,this.throttleByServer=t,this.type=Pe(e.type,Qr.OTHER),this.serverKey=void 0,this.state=Kr.UNISSUED,this.deferred=void 0,this.cancelled=!1}function ei(e){var t={};if(!e)return t;for(var n=e.split("\\r\\n"),r=0;r<n.length;++r){var i,a=n[r],o=a.indexOf(": ");0<o&&(i=a.substring(0,o),o=a.substring(o+2),t[i]=o)}return t}function ti(e,t,n){this.statusCode=e,this.response=t,this.responseHeaders=n,"string"==typeof this.responseHeaders&&(this.responseHeaders=ei(this.responseHeaders))}function ni(){this._listeners=[],this._scopes=[],this._toRemove=[],this._insideRaiseEvent=!1}function ri(e,t){return t-e}function ii(e){this._comparator=e.comparator,this._array=[],this._length=0,this._maximumLength=void 0}function ai(e,t,n){var r=e[t];e[t]=e[n],e[n]=r}function oi(e,t){return e.priority-t.priority}$r.prototype.cancel=function(){this.cancelled=!0},$r.prototype.clone=function(e){return Ue(e)?(e.url=this.url,e.requestFunction=this.requestFunction,e.cancelFunction=this.cancelFunction,e.priorityFunction=this.priorityFunction,e.priority=this.priority,e.throttle=this.throttle,e.throttleByServer=this.throttleByServer,e.type=this.type,e.serverKey=this.serverKey,e.state=this.RequestState.UNISSUED,e.deferred=void 0,e.cancelled=!1,e):new $r(this)},ti.prototype.toString=function(){var e="Request has failed.";return Ue(this.statusCode)&&(e+=" Status Code: "+this.statusCode),e},Object.defineProperties(ni.prototype,{numberOfListeners:{get:function(){return this._listeners.length-this._toRemove.length}}}),ni.prototype.addEventListener=function(e,t){this._listeners.push(e),this._scopes.push(t);var n=this;return function(){n.removeEventListener(e,t)}},ni.prototype.removeEventListener=function(e,t){for(var n=this._listeners,r=this._scopes,i=-1,a=0;a<n.length;a++)if(n[a]===e&&r[a]===t){i=a;break}return-1!==i&&(this._insideRaiseEvent?(this._toRemove.push(i),n[i]=void 0,r[i]=void 0):(n.splice(i,1),r.splice(i,1)),!0)},ni.prototype.raiseEvent=function(){this._insideRaiseEvent=!0;for(var e=this._listeners,t=this._scopes,n=e.length,r=0;r<n;r++)Ue(e[r])&&e[r].apply(t[r],arguments);var i=this._toRemove;if(0<(n=i.length)){for(i.sort(ri),r=0;r<n;r++){var a=i[r];e.splice(a,1),t.splice(a,1)}i.length=0}this._insideRaiseEvent=!1},Object.defineProperties(ii.prototype,{length:{get:function(){return this._length}},internalArray:{get:function(){return this._array}},maximumLength:{get:function(){return this._maximumLength},set:function(e){var t=this._length;if(e<t){for(var n=this._array,r=e;r<t;++r)n[r]=void 0;this._length=e,n.length=e}this._maximumLength=e}},comparator:{get:function(){return this._comparator}}}),ii.prototype.reserve=function(e){e=Pe(e,this._length),this._array.length=e},ii.prototype.heapify=function(e){e=Pe(e,0);for(var t=this._length,n=this._comparator,r=this._array,i=-1,a=!0;a;){var o=2*(e+1),s=o-1,i=s<t&&n(r[s],r[e])<0?s:e;(i=o<t&&n(r[o],r[i])<0?o:i)!==e?(ai(r,i,e),e=i):a=!1}},ii.prototype.resort=function(){for(var e=this._length,t=Math.ceil(e/2);0<=t;--t)this.heapify(t)},ii.prototype.insert=function(e){var t,n=this._array,r=this._comparator,i=this._maximumLength,a=this._length++;for(a<n.length?n[a]=e:n.push(e);0!==a;){var o=Math.floor((a-1)/2);if(!(r(n[a],n[o])<0))break;ai(n,a,o),a=o}return Ue(i)&&this._length>i&&(t=n[i],this._length=i),t},ii.prototype.pop=function(e){if(e=Pe(e,0),0!==this._length){var t=this._array,n=t[e];return ai(t,e,--this._length),this.heapify(e),t[this._length]=void 0,n}};var si={numberOfAttemptedRequests:0,numberOfActiveRequests:0,numberOfCancelledRequests:0,numberOfCancelledActiveRequests:0,numberOfFailedRequests:0,numberOfActiveRequestsEver:0,lastNumberOfActiveRequests:0},ui=20,ci=new ii({comparator:oi});ci.maximumLength=ui,ci.reserve(ui);var li=[],fi={},hi="undefined"!=typeof document?new Or(document.location.href):new Or,di=new ni;function mi(){}function pi(e){Ue(e.priorityFunction)&&(e.priority=e.priorityFunction())}function Ei(e){var t=Pe(mi.requestsByServer[e],mi.maximumRequestsPerServer);return fi[e]<t}function yi(e){return e.state===Kr.UNISSUED&&(e.state=Kr.ISSUED,e.deferred=Pn.defer()),e.deferred.promise}function _i(n){return function(e){var t;n.state!==Kr.CANCELLED&&(t=n.deferred,--si.numberOfActiveRequests,--fi[n.serverKey],di.raiseEvent(),n.state=Kr.RECEIVED,n.deferred=void 0,t.resolve(e))}}function Ti(t){return function(e){t.state!==Kr.CANCELLED&&(++si.numberOfFailedRequests,--si.numberOfActiveRequests,--fi[t.serverKey],di.raiseEvent(e),t.state=Kr.FAILED,t.deferred.reject(e))}}function Ri(e){var t=yi(e);return e.state=Kr.ACTIVE,li.push(e),++si.numberOfActiveRequests,++si.numberOfActiveRequestsEver,++fi[e.serverKey],e.requestFunction().then(_i(e)).otherwise(Ti(e)),t}function Ai(e){var t,n=e.state===Kr.ACTIVE;e.state=Kr.CANCELLED,++si.numberOfCancelledRequests,Ue(e.deferred)&&(t=e.deferred,e.deferred=void 0,t.reject()),n&&(--si.numberOfActiveRequests,--fi[e.serverKey],++si.numberOfCancelledActiveRequests),Ue(e.cancelFunction)&&e.cancelFunction()}function gi(){mi.debugShowStatistics&&(0===si.numberOfActiveRequests&&0<si.lastNumberOfActiveRequests&&(0<si.numberOfAttemptedRequests&&(console.log("Number of attempted requests: "+si.numberOfAttemptedRequests),si.numberOfAttemptedRequests=0),0<si.numberOfCancelledRequests&&(console.log("Number of cancelled requests: "+si.numberOfCancelledRequests),si.numberOfCancelledRequests=0),0<si.numberOfCancelledActiveRequests&&(console.log("Number of cancelled active requests: "+si.numberOfCancelledActiveRequests),si.numberOfCancelledActiveRequests=0),0<si.numberOfFailedRequests&&(console.log("Number of failed requests: "+si.numberOfFailedRequests),si.numberOfFailedRequests=0)),si.lastNumberOfActiveRequests=si.numberOfActiveRequests)}mi.maximumRequests=50,mi.maximumRequestsPerServer=6,mi.requestsByServer={"api.cesium.com:443":18,"assets.cesium.com:443":18},mi.throttleRequests=!0,mi.debugShowStatistics=!1,mi.requestCompletedEvent=di,Object.defineProperties(mi,{statistics:{get:function(){return si}},priorityHeapLength:{get:function(){return ui},set:function(e){if(e<ui)for(;ci.length>e;)Ai(ci.pop());ui=e,ci.maximumLength=e,ci.reserve(e)}}}),mi.update=function(){for(var e,t=0,n=li.length,r=0;r<n;++r)(e=li[r]).cancelled&&Ai(e),e.state===Kr.ACTIVE?0<t&&(li[r-t]=e):++t;li.length-=t;var i=ci.internalArray,a=ci.length;for(r=0;r<a;++r)pi(i[r]);ci.resort();for(var o=Math.max(mi.maximumRequests-li.length,0),s=0;s<o&&0<ci.length;)!(e=ci.pop()).cancelled&&(!e.throttleByServer||Ei(e.serverKey))?(Ri(e),++s):Ai(e);gi()},mi.getServerKey=function(e){var t=new Or(e).resolve(hi);t.normalize();e=t.authority;return/:/.test(e)||(e=e+":"+("https"===t.scheme?"443":"80")),Ue(fi[e])||(fi[e]=0),e},mi.request=function(e){if(Wr(e.url)||kr(e.url))return di.raiseEvent(),e.state=Kr.RECEIVED,e.requestFunction();if(++si.numberOfAttemptedRequests,Ue(e.serverKey)||(e.serverKey=mi.getServerKey(e.url)),!mi.throttleRequests||!e.throttleByServer||Ei(e.serverKey)){if(!mi.throttleRequests||!e.throttle)return Ri(e);if(!(li.length>=mi.maximumRequests)){pi(e);var t=ci.insert(e);if(Ue(t)){if(t===e)return;Ai(t)}return yi(e)}}},mi.clearForSpecs=function(){for(;0<ci.length;)Ai(ci.pop());for(var e=li.length,t=0;t<e;++t)Ai(li[t]);li.length=0,fi={},si.numberOfAttemptedRequests=0,si.numberOfActiveRequests=0,si.numberOfCancelledRequests=0,si.numberOfCancelledActiveRequests=0,si.numberOfFailedRequests=0,si.numberOfActiveRequestsEver=0,si.lastNumberOfActiveRequests=0},mi.numberOfActiveRequestsByServer=function(e){return fi[e]},mi.requestHeap=ci;var Si={},wi={};function Ii(e){var t=new Or(e);t.normalize();e=t.getAuthority();if(Ue(e)){if(-1===(e=-1!==e.indexOf("@")?e.split("@")[1]:e).indexOf(":")){t=t.getScheme();if("http"===(t=!Ue(t)?(t=window.location.protocol).substring(0,t.length-1):t))e+=":80";else{if("https"!==t)return;e+=":443"}}return e}}Si.add=function(e,t){t=e.toLowerCase()+":"+t;Ue(wi[t])||(wi[t]=!0)},Si.remove=function(e,t){t=e.toLowerCase()+":"+t;Ue(wi[t])&&delete wi[t]},Si.contains=function(e){e=Ii(e);return!(!Ue(e)||!Ue(wi[e]))},Si.clear=function(){wi={}};var Mi,Oi=function(){try{var e=new XMLHttpRequest;return e.open("GET","#",!0),(e.responseType="blob")===e.responseType}catch(e){return!1}}();function Ni(e,t,n,r){var i,a=e.query;if(!Ue(a)||0===a.length)return{};a=-1===a.indexOf("=")?((i={})[a]=void 0,i):jr(a),t._queryParameters=n?Pi(a,t._queryParameters,r):a,e.query=void 0}function xi(e,t){var n=t._queryParameters,t=Object.keys(n);1!==t.length||Ue(n[t[0]])?e.query=Yr(n):e.query=t[0]}function vi(e,t){return Ue(e)?Ue(e.clone)?e.clone():br(e):t}function Ui(e){if(e.state===Kr.ISSUED||e.state===Kr.ACTIVE)throw new ue("The Resource is already being fetched.");e.state=Kr.UNISSUED,e.deferred=void 0}function Pi(e,t,n){if(!n)return Lr(e,t);var r,i,a,o=br(e,!0);for(r in t)t.hasOwnProperty(r)&&(i=o[r],a=t[r],Ue(i)?(Array.isArray(i)||(i=o[r]=[i]),o[r]=i.concat(a)):o[r]=Array.isArray(a)?a.slice():a);return o}function Ci(e){"string"==typeof(e=Pe(e,Pe.EMPTY_OBJECT))&&(e={url:e}),this._url=void 0,this._templateValues=vi(e.templateValues,{}),this._queryParameters=vi(e.queryParameters,{}),this.headers=vi(e.headers,{}),this.request=Pe(e.request,new $r),this.proxy=e.proxy,this.retryCallback=e.retryCallback,this.retryAttempts=Pe(e.retryAttempts,0),this._retryCount=0;e=new Or(e.url);Ni(e,this,!0,!0),e.fragment=void 0,this._url=e.toString()}function Di(e){var n=e.resource,r=e.flipY,i=e.preferImageBitmap,a=n.request;a.url=n.url,a.requestFunction=function(){var e=!1;n.isDataUri||n.isBlobUri||(e=n.isCrossOriginUrl);var t=Pn.defer();return Ci._Implementations.createImage(a,e,t,r,i),t.promise};e=mi.request(a);if(Ue(e))return e.otherwise(function(t){return a.state!==Kr.FAILED?Pn.reject(t):n.retryOnError(t).then(function(e){return e?(a.state=Kr.UNISSUED,a.deferred=void 0,Di({resource:n,flipY:r,preferImageBitmap:i})):Pn.reject(t)})})}function bi(n,r,i){var e={};e[r]=i,n.setQueryParameters(e);var a=n.request;a.url=n.url,a.requestFunction=function(){var t=Pn.defer();return window[i]=function(e){t.resolve(e);try{delete window[i]}catch(e){window[i]=void 0}},Ci._Implementations.loadAndExecuteScript(n.url,i,t),t.promise};e=mi.request(a);if(Ue(e))return e.otherwise(function(t){return a.state!==Kr.FAILED?Pn.reject(t):n.retryOnError(t).then(function(e){return e?(a.state=Kr.UNISSUED,a.deferred=void 0,bi(n,r,i)):Pn.reject(t)})})}Ci.createIfNeeded=function(e){return e instanceof Ci?e.getDerivedResource({request:e.request}):"string"!=typeof e?e:new Ci({url:e})},Ci.supportsImageBitmapOptions=function(){if(Ue(Mi))return Mi;if("function"!=typeof createImageBitmap)return Mi=Pn.resolve(!1);return Mi=Ci.fetchBlob({url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWP4////fwAJ+wP9CNHoHgAAAABJRU5ErkJggg=="}).then(function(e){return createImageBitmap(e,{imageOrientation:"flipY",premultiplyAlpha:"none"})}).then(function(e){return!0}).otherwise(function(){return!1})},Object.defineProperties(Ci,{isBlobSupported:{get:function(){return Oi}}}),Object.defineProperties(Ci.prototype,{queryParameters:{get:function(){return this._queryParameters}},templateValues:{get:function(){return this._templateValues}},url:{get:function(){return this.getUrlComponent(!0,!0)},set:function(e){e=new Or(e);Ni(e,this,!1),e.fragment=void 0,this._url=e.toString()}},extension:{get:function(){return zr(this._url)}},isDataUri:{get:function(){return Wr(this._url)}},isBlobUri:{get:function(){return kr(this._url)}},isCrossOriginUrl:{get:function(){return Gr(this._url)}},hasHeaders:{get:function(){return 0<Object.keys(this.headers).length}}}),Ci.prototype.toString=function(){return this.getUrlComponent(!0,!0)},Ci.prototype.getUrlComponent=function(e,t){if(this.isDataUri)return this._url;var n=new Or(this._url);e&&xi(n,this);var n=n.toString().replace(/%7B/g,"{").replace(/%7D/g,"}"),r=this._templateValues,n=n.replace(/{(.*?)}/g,function(e,t){t=r[t];return Ue(t)?encodeURIComponent(t):e});return n=t&&Ue(this.proxy)?this.proxy.getURL(n):n},Ci.prototype.setQueryParameters=function(e,t){this._queryParameters=t?Pi(this._queryParameters,e,!1):Pi(e,this._queryParameters,!1)},Ci.prototype.appendQueryParameters=function(e){this._queryParameters=Pi(e,this._queryParameters,!0)},Ci.prototype.setTemplateValues=function(e,t){this._templateValues=t?Lr(this._templateValues,e):Lr(e,this._templateValues)},Ci.prototype.getDerivedResource=function(e){var t,n=this.clone();return n._retryCount=0,Ue(e.url)&&(Ni(t=new Or(e.url),n,!0,Pe(e.preserveQueryParameters,!1)),t.fragment=void 0,n._url=t.resolve(new Or(Fr(this._url))).toString()),Ue(e.queryParameters)&&(n._queryParameters=Lr(e.queryParameters,n._queryParameters)),Ue(e.templateValues)&&(n._templateValues=Lr(e.templateValues,n.templateValues)),Ue(e.headers)&&(n.headers=Lr(e.headers,n.headers)),Ue(e.proxy)&&(n.proxy=e.proxy),Ue(e.request)&&(n.request=e.request),Ue(e.retryCallback)&&(n.retryCallback=e.retryCallback),Ue(e.retryAttempts)&&(n.retryAttempts=e.retryAttempts),n},Ci.prototype.retryOnError=function(e){var t=this.retryCallback;if("function"!=typeof t||this._retryCount>=this.retryAttempts)return Pn(!1);var n=this;return Pn(t(this,e)).then(function(e){return++n._retryCount,e})},Ci.prototype.clone=function(e){return(e=!Ue(e)?new Ci({url:this._url}):e)._url=this._url,e._queryParameters=br(this._queryParameters),e._templateValues=br(this._templateValues),e.headers=br(this.headers),e.proxy=this.proxy,e.retryCallback=this.retryCallback,e.retryAttempts=this.retryAttempts,e._retryCount=0,e.request=this.request.clone(),e},Ci.prototype.getBaseUri=function(e){return Br(this.getUrlComponent(e),e)},Ci.prototype.appendForwardSlash=function(){this._url=Dr(this._url)},Ci.prototype.fetchArrayBuffer=function(){return this.fetch({responseType:"arraybuffer"})},Ci.fetchArrayBuffer=function(e){return new Ci(e).fetchArrayBuffer()},Ci.prototype.fetchBlob=function(){return this.fetch({responseType:"blob"})},Ci.fetchBlob=function(e){return new Ci(e).fetchBlob()},Ci.prototype.fetchImage=function(e){e=Pe(e,Pe.EMPTY_OBJECT);var t=Pe(e.preferImageBitmap,!1),n=Pe(e.preferBlob,!1),r=Pe(e.flipY,!1);if(Ui(this.request),!Oi||this.isDataUri||this.isBlobUri||!this.hasHeaders&&!n)return Di({resource:this,flipY:r,preferImageBitmap:t});var i,a,o,s=this.fetchBlob();return Ue(s)?Ci.supportsImageBitmapOptions().then(function(e){return i=e&&t,s}).then(function(e){if(Ue(e)){if(o=e,i)return Ci.createImageBitmapFromBlob(e,{flipY:r,premultiplyAlpha:!1});e=window.URL.createObjectURL(e);return Di({resource:a=new Ci({url:e}),flipY:r,preferImageBitmap:!1})}}).then(function(e){if(Ue(e))return e.blob=o,i||window.URL.revokeObjectURL(a.url),e}).otherwise(function(e){return Ue(a)&&window.URL.revokeObjectURL(a.url),e.blob=o,Pn.reject(e)}):void 0},Ci.fetchImage=function(e){return new Ci(e).fetchImage({flipY:e.flipY,preferBlob:e.preferBlob,preferImageBitmap:e.preferImageBitmap})},Ci.prototype.fetchText=function(){return this.fetch({responseType:"text"})},Ci.fetchText=function(e){return new Ci(e).fetchText()},Ci.prototype.fetchJson=function(){var e=this.fetch({responseType:"text",headers:{Accept:"application/json,*/*;q=0.01"}});if(Ue(e))return e.then(function(e){if(Ue(e))return JSON.parse(e)})},Ci.fetchJson=function(e){return new Ci(e).fetchJson()},Ci.prototype.fetchXML=function(){return this.fetch({responseType:"document",overrideMimeType:"text/xml"})},Ci.fetchXML=function(e){return new Ci(e).fetchXML()},Ci.prototype.fetchJsonp=function(e){var t;for(e=Pe(e,"callback"),Ui(this.request);t="loadJsonp"+Math.random().toString().substring(2,8),Ue(window[t]););return bi(this,e,t)},Ci.fetchJsonp=function(e){return new Ci(e).fetchJsonp(e.callbackParameterName)},Ci.prototype._makeRequest=function(s){var u=this;Ui(u.request);var c=u.request;c.url=u.url,c.requestFunction=function(){var e=s.responseType,t=Lr(s.headers,u.headers),n=s.overrideMimeType,r=s.method,i=s.data,a=Pn.defer(),o=Ci._Implementations.loadWithXhr(u.url,e,r,i,t,a,n);return Ue(o)&&Ue(o.abort)&&(c.cancelFunction=function(){o.abort()}),a.promise};var e=mi.request(c);if(Ue(e))return e.then(function(e){return c.cancelFunction=void 0,e}).otherwise(function(t){return c.cancelFunction=void 0,c.state!==Kr.FAILED?Pn.reject(t):u.retryOnError(t).then(function(e){return e?(c.state=Kr.UNISSUED,c.deferred=void 0,u.fetch(s)):Pn.reject(t)})})};var Li=/^data:(.*?)(;base64)?,(.*)$/;function Fi(e,t){t=decodeURIComponent(t);return e?atob(t):t}function Bi(e,t){for(var n=Fi(e,t),t=new ArrayBuffer(n.length),r=new Uint8Array(t),i=0;i<n.length;i++)r[i]=n.charCodeAt(i);return t}function zi(e,t){t=Pe(t,"");var n=e[1],r=!!e[2],i=e[3];switch(t){case"":case"text":return Fi(r,i);case"arraybuffer":return Bi(r,i);case"blob":var a=Bi(r,i);return new Blob([a],{type:n});case"document":return(new DOMParser).parseFromString(Fi(r,i),n);case"json":return JSON.parse(Fi(r,i))}}function qi(e,t,n){var r=new Image;r.onload=function(){n.resolve(r)},r.onerror=function(e){n.reject(e)},t&&(Si.contains(e)?r.crossOrigin="use-credentials":r.crossOrigin=""),r.src=e}function Vi(e,t){switch(t){case"text":return e.toString("utf8");case"json":return JSON.parse(e.toString("utf8"));default:return new Uint8Array(e).buffer}}function ki(e,r,t,n,i,a,o){var s=require("url").parse(e),e="https:"===s.protocol?require("https"):require("http"),u=require("zlib"),i={protocol:s.protocol,hostname:s.hostname,port:s.port,path:s.path,query:s.query,method:t,headers:i};e.request(i).on("response",function(t){var n;t.statusCode<200||300<=t.statusCode?a.reject(new ti(t.statusCode,t,t.headers)):(n=[],t.on("data",function(e){n.push(e)}),t.on("end",function(){var e=Buffer.concat(n);"gzip"===t.headers["content-encoding"]?u.gunzip(e,function(e,t){e?a.reject(new ue("Error decompressing response.")):a.resolve(Vi(t,r))}):a.resolve(Vi(e,r))}))}).on("error",function(e){a.reject(new ti)}).end()}Ci.prototype.fetch=function(e){return(e=vi(e,{})).method="GET",this._makeRequest(e)},Ci.fetch=function(e){return new Ci(e).fetch({responseType:e.responseType,overrideMimeType:e.overrideMimeType})},Ci.prototype.delete=function(e){return(e=vi(e,{})).method="DELETE",this._makeRequest(e)},Ci.delete=function(e){return new Ci(e).delete({responseType:e.responseType,overrideMimeType:e.overrideMimeType,data:e.data})},Ci.prototype.head=function(e){return(e=vi(e,{})).method="HEAD",this._makeRequest(e)},Ci.head=function(e){return new Ci(e).head({responseType:e.responseType,overrideMimeType:e.overrideMimeType})},Ci.prototype.options=function(e){return(e=vi(e,{})).method="OPTIONS",this._makeRequest(e)},Ci.options=function(e){return new Ci(e).options({responseType:e.responseType,overrideMimeType:e.overrideMimeType})},Ci.prototype.post=function(e,t){return i.defined("data",e),(t=vi(t,{})).method="POST",t.data=e,this._makeRequest(t)},Ci.post=function(e){return new Ci(e).post(e.data,{responseType:e.responseType,overrideMimeType:e.overrideMimeType})},Ci.prototype.put=function(e,t){return i.defined("data",e),(t=vi(t,{})).method="PUT",t.data=e,this._makeRequest(t)},Ci.put=function(e){return new Ci(e).put(e.data,{responseType:e.responseType,overrideMimeType:e.overrideMimeType})},Ci.prototype.patch=function(e,t){return i.defined("data",e),(t=vi(t,{})).method="PATCH",t.data=e,this._makeRequest(t)},Ci.patch=function(e){return new Ci(e).patch(e.data,{responseType:e.responseType,overrideMimeType:e.overrideMimeType})},Ci._Implementations={},Ci._Implementations.createImage=function(n,r,i,a,o){var s=n.url;Ci.supportsImageBitmapOptions().then(function(e){if(e&&o){var e=Pn.defer(),t=Ci._Implementations.loadWithXhr(s,"blob","GET",void 0,void 0,e,void 0,void 0,void 0);return Ue(t)&&Ue(t.abort)&&(n.cancelFunction=function(){t.abort()}),e.promise.then(function(e){return Ue(e)?Ci.createImageBitmapFromBlob(e,{flipY:a,premultiplyAlpha:!1}):void i.reject(new ue("Successfully retrieved "+s+" but it contained no content."))}).then(i.resolve)}qi(s,r,i)}).otherwise(i.reject)},Ci.createImageBitmapFromBlob=function(e,t){return i.defined("options",t),i.typeOf.bool("options.flipY",t.flipY),i.typeOf.bool("options.premultiplyAlpha",t.premultiplyAlpha),createImageBitmap(e,{imageOrientation:t.flipY?"flipY":"none",premultiplyAlpha:t.premultiplyAlpha?"premultiply":"none"})};var Gi="undefined"==typeof XMLHttpRequest;function Xi(e){var t,n;e=Pe(e,Pe.EMPTY_OBJECT),this._dates=void 0,this._samples=void 0,this._dateColumn=-1,this._xPoleWanderRadiansColumn=-1,this._yPoleWanderRadiansColumn=-1,this._ut1MinusUtcSecondsColumn=-1,this._xCelestialPoleOffsetRadiansColumn=-1,this._yCelestialPoleOffsetRadiansColumn=-1,this._taiMinusUtcSecondsColumn=-1,this._columnCount=0,this._lastIndex=-1,this._downloadPromise=void 0,this._dataError=void 0,this._addNewLeapSeconds=Pe(e.addNewLeapSeconds,!0),Ue(e.data)?Hi(this,e.data):Ue(e.url)?(t=Ci.createIfNeeded(e.url),(n=this)._downloadPromise=t.fetchJson().then(function(e){Hi(n,e)}).otherwise(function(){n._dataError="An error occurred while retrieving the EOP data from the URL "+t.url+"."})):Hi(this,{columnNames:["dateIso8601","modifiedJulianDateUtc","xPoleWanderRadians","yPoleWanderRadians","ut1MinusUtcSeconds","lengthOfDayCorrectionSeconds","xCelestialPoleOffsetRadians","yCelestialPoleOffsetRadians","taiMinusUtcSeconds"],samples:[]})}function Wi(e,t){return Ir.compare(e.julianDate,t)}function Hi(e,t){if(Ue(t.columnNames))if(Ue(t.samples)){var n=t.columnNames.indexOf("modifiedJulianDateUtc"),r=t.columnNames.indexOf("xPoleWanderRadians"),i=t.columnNames.indexOf("yPoleWanderRadians"),a=t.columnNames.indexOf("ut1MinusUtcSeconds"),o=t.columnNames.indexOf("xCelestialPoleOffsetRadians"),s=t.columnNames.indexOf("yCelestialPoleOffsetRadians"),u=t.columnNames.indexOf("taiMinusUtcSeconds");if(n<0||r<0||i<0||a<0||o<0||s<0||u<0)e._dataError="Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns";else{var c,l=e._samples=t.samples,f=e._dates=[];e._dateColumn=n,e._xPoleWanderRadiansColumn=r,e._yPoleWanderRadiansColumn=i,e._ut1MinusUtcSecondsColumn=a,e._xCelestialPoleOffsetRadiansColumn=o,e._yCelestialPoleOffsetRadiansColumn=s,e._taiMinusUtcSecondsColumn=u,e._columnCount=t.columnNames.length,e._lastIndex=void 0;for(var h=e._addNewLeapSeconds,d=0,m=l.length;d<m;d+=e._columnCount){var p,E=l[d+n],y=l[d+u],_=new Ir(E+ir.MODIFIED_JULIAN_DATE_DIFFERENCE,y,or.TAI);f.push(_),h&&(y===c||!Ue(c)||(E=Jn(p=Ir.leapSeconds,_,Wi))<0&&(_=new nr(_,y),p.splice(~E,0,_)),c=y)}}}else e._dataError="Error in loaded EOP data: The samples property is required.";else e._dataError="Error in loaded EOP data: The columnNames property is required."}function Yi(e,t,n,r,i){r*=n;i.xPoleWander=t[r+e._xPoleWanderRadiansColumn],i.yPoleWander=t[r+e._yPoleWanderRadiansColumn],i.xPoleOffset=t[r+e._xCelestialPoleOffsetRadiansColumn],i.yPoleOffset=t[r+e._yCelestialPoleOffsetRadiansColumn],i.ut1MinusUtc=t[r+e._ut1MinusUtcSecondsColumn]}function ji(e,t,n){return t+e*(n-t)}function Zi(e,t,n,r,i,a,o){var s=e._columnCount;if(a>t.length-1)return o.xPoleWander=0,o.yPoleWander=0,o.xPoleOffset=0,o.yPoleOffset=0,o.ut1MinusUtc=0,o;var u=t[i],c=t[a];if(u.equals(c)||r.equals(u))return Yi(e,n,i,s,o),o;if(r.equals(c))return Yi(e,n,a,s,o),o;var l=Ir.secondsDifference(r,u)/Ir.secondsDifference(c,u),f=i*s,t=a*s,u=n[f+e._ut1MinusUtcSecondsColumn],i=n[t+e._ut1MinusUtcSecondsColumn],a=i-u;return!(.5<a||a<-.5)||(s=n[f+e._taiMinusUtcSecondsColumn])!==(a=n[t+e._taiMinusUtcSecondsColumn])&&(c.equals(r)?u=i:i-=a-s),o.xPoleWander=ji(l,n[f+e._xPoleWanderRadiansColumn],n[t+e._xPoleWanderRadiansColumn]),o.yPoleWander=ji(l,n[f+e._yPoleWanderRadiansColumn],n[t+e._yPoleWanderRadiansColumn]),o.xPoleOffset=ji(l,n[f+e._xCelestialPoleOffsetRadiansColumn],n[t+e._xCelestialPoleOffsetRadiansColumn]),o.yPoleOffset=ji(l,n[f+e._yCelestialPoleOffsetRadiansColumn],n[t+e._yCelestialPoleOffsetRadiansColumn]),o.ut1MinusUtc=ji(l,u,i),o}function Ki(e,t,n){this.heading=Pe(e,0),this.pitch=Pe(t,0),this.roll=Pe(n,0)}Ci._Implementations.loadWithXhr=function(e,i,a,t,n,o,r){var s=Li.exec(e);if(null===s){if(!Gi){var u=new XMLHttpRequest;if(Si.contains(e)&&(u.withCredentials=!0),u.open(a,e,!0),Ue(r)&&Ue(u.overrideMimeType)&&u.overrideMimeType(r),Ue(n))for(var c in n)n.hasOwnProperty(c)&&u.setRequestHeader(c,n[c]);Ue(i)&&(u.responseType=i);var l=!1;return"string"==typeof e&&(l=0===e.indexOf("file://")||"undefined"!=typeof window&&"file://"===window.location.origin),u.onload=function(){if(!(u.status<200||300<=u.status)||l&&0===u.status){var e=u.response,t=u.responseType;if("HEAD"===a||"OPTIONS"===a){var n=u.getAllResponseHeaders().trim().split(/[\\r\\n]+/),r={};return n.forEach(function(e){var t=e.split(": "),e=t.shift();r[e]=t.join(": ")}),void o.resolve(r)}if(204===u.status)o.resolve();else if(!Ue(e)||Ue(i)&&t!==i)if("json"===i&&"string"==typeof e)try{o.resolve(JSON.parse(e))}catch(e){o.reject(e)}else(""===t||"document"===t)&&Ue(u.responseXML)&&u.responseXML.hasChildNodes()?o.resolve(u.responseXML):""!==t&&"text"!==t||!Ue(u.responseText)?o.reject(new ue("Invalid XMLHttpRequest response type.")):o.resolve(u.responseText);else o.resolve(e)}else o.reject(new ti(u.status,u.response,u.getAllResponseHeaders()))},u.onerror=function(e){o.reject(new ti)},u.send(t),u}ki(e,i,a,t,n,o)}else o.resolve(zi(s,i))},Ci._Implementations.loadAndExecuteScript=function(e,t,n){return Hr(e).otherwise(n.reject)},Ci._DefaultImplementations={},Ci._DefaultImplementations.createImage=Ci._Implementations.createImage,Ci._DefaultImplementations.loadWithXhr=Ci._Implementations.loadWithXhr,Ci._DefaultImplementations.loadAndExecuteScript=Ci._Implementations.loadAndExecuteScript,Ci.DEFAULT=Object.freeze(new Ci({url:"undefined"==typeof document?"":document.location.href.split("?")[0]})),Xi.NONE=Object.freeze({getPromiseToLoad:function(){return Pn.resolve()},compute:function(e,t){return Ue(t)?(t.xPoleWander=0,t.yPoleWander=0,t.xPoleOffset=0,t.yPoleOffset=0,t.ut1MinusUtc=0):t=new Qn(0,0,0,0,0),t}}),Xi.prototype.getPromiseToLoad=function(){return Pn(this._downloadPromise)},Xi.prototype.compute=function(e,t){if(Ue(this._samples)){if(Ue(t)||(t=new Qn(0,0,0,0,0)),0===this._samples.length)return t.xPoleWander=0,t.yPoleWander=0,t.xPoleOffset=0,t.yPoleOffset=0,t.ut1MinusUtc=0,t;var n=this._dates,r=this._lastIndex,i=0,a=0;if(Ue(r)){var o=n[r],s=n[r+1],u=Ir.lessThanOrEquals(o,e),c=!Ue(s),o=c||Ir.greaterThanOrEquals(s,e);if(u&&o)return i=r,!c&&s.equals(e)&&++i,a=i+1,Zi(this,n,this._samples,e,i,a,t),t}s=Jn(n,e,Ir.compare,this._dateColumn);return 0<=s?(s<n.length-1&&n[s+1].equals(e)&&++s,a=i=s):(i=(a=~s)-1)<0&&(i=0),this._lastIndex=i,Zi(this,n,this._samples,e,i,a,t),t}if(Ue(this._dataError))throw new ue(this._dataError)},Ki.fromQuaternion=function(e,t){Ue(t)||(t=new Ki);var n=2*(e.w*e.y-e.z*e.x),r=1-2*(e.x*e.x+e.y*e.y),i=2*(e.w*e.x+e.y*e.z),a=1-2*(e.y*e.y+e.z*e.z),e=2*(e.w*e.z+e.x*e.y);return t.heading=-Math.atan2(e,a),t.roll=Math.atan2(i,r),t.pitch=-Ce.asinClamped(n),t},Ki.fromDegrees=function(e,t,n,r){return(r=!Ue(r)?new Ki:r).heading=e*Ce.RADIANS_PER_DEGREE,r.pitch=t*Ce.RADIANS_PER_DEGREE,r.roll=n*Ce.RADIANS_PER_DEGREE,r},Ki.clone=function(e,t){if(Ue(e))return Ue(t)?(t.heading=e.heading,t.pitch=e.pitch,t.roll=e.roll,t):new Ki(e.heading,e.pitch,e.roll)},Ki.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&e.heading===t.heading&&e.pitch===t.pitch&&e.roll===t.roll},Ki.equalsEpsilon=function(e,t,n,r){return e===t||Ue(e)&&Ue(t)&&Ce.equalsEpsilon(e.heading,t.heading,n,r)&&Ce.equalsEpsilon(e.pitch,t.pitch,n,r)&&Ce.equalsEpsilon(e.roll,t.roll,n,r)},Ki.prototype.clone=function(e){return Ki.clone(this,e)},Ki.prototype.equals=function(e){return Ki.equals(this,e)},Ki.prototype.equalsEpsilon=function(e,t,n){return Ki.equalsEpsilon(this,e,t,n)},Ki.prototype.toString=function(){return"("+this.heading+", "+this.pitch+", "+this.roll+")"};var Ji,Qi,$i,ea=/((?:.*\\/)|^)Cesium\\.js(?:\\?|\\#|$)/;function ta(){for(var e=document.getElementsByTagName("script"),t=0,n=e.length;t<n;++t){var r=e[t].getAttribute("src"),r=ea.exec(r);if(null!==r)return r[1]}}function na(e){return"undefined"==typeof document?e:((Ji=!Ue(Ji)?document.createElement("a"):Ji).href=e,Ji.href=Ji.href,Ji.href)}function ra(){if(Ue(Qi))return Qi;var e="undefined"!=typeof CESIUM_BASE_URL?CESIUM_BASE_URL:"object"==typeof define&&Ue(define.amd)&&!define.amd.toUrlUndefined&&Ue(require.toUrl)?Fr("..",aa("Core/buildModuleUrl.js")):ta();return(Qi=new Ci({url:na(e)})).appendForwardSlash(),Qi}function ia(e){return ra().getDerivedResource({url:e}).url}function aa(e){return($i=!Ue($i)?ia:$i)(e)}function oa(e,t,n){this.x=e,this.y=t,this.s=n}function sa(e){e=Pe(e,Pe.EMPTY_OBJECT),this._xysFileUrlTemplate=Ci.createIfNeeded(e.xysFileUrlTemplate),this._interpolationOrder=Pe(e.interpolationOrder,9),this._sampleZeroJulianEphemerisDate=Pe(e.sampleZeroJulianEphemerisDate,2442396.5),this._sampleZeroDateTT=new Ir(this._sampleZeroJulianEphemerisDate,0,or.TAI),this._stepSizeDays=Pe(e.stepSizeDays,1),this._samplesPerXysFile=Pe(e.samplesPerXysFile,1e3),this._totalSamples=Pe(e.totalSamples,27426),this._samples=new Array(3*this._totalSamples),this._chunkDownloadsInProgress=[];for(var t=this._interpolationOrder,n=this._denominators=new Array(t+1),r=this._xTable=new Array(t+1),i=Math.pow(this._stepSizeDays,t),a=0;a<=t;++a){n[a]=i,r[a]=a*this._stepSizeDays;for(var o=0;o<=t;++o)o!==a&&(n[a]*=a-o);n[a]=1/n[a]}this._work=new Array(t+1),this._coef=new Array(t+1)}aa._cesiumScriptRegex=ea,aa._buildModuleUrlFromBaseUrl=ia,aa._clearBaseResource=function(){Qi=void 0},aa.setBaseUrl=function(e){Qi=Ci.DEFAULT.getDerivedResource({url:e})},aa.getCesiumBaseUrl=ra;var ua,ca=new Ir(0,0,or.TAI);function la(e,t,n){var r=ca;return r.dayNumber=t,r.secondsOfDay=n,Ir.daysDifference(r,e._sampleZeroDateTT)}function fa(o,s){if(o._chunkDownloadsInProgress[s])return o._chunkDownloadsInProgress[s];var u=Pn.defer();o._chunkDownloadsInProgress[s]=u;var e=o._xysFileUrlTemplate;return Pn((Ue(e)?e.getDerivedResource({templateValues:{0:s}}):new Ci({url:aa("Assets/IAU2006_XYS/IAU2006_XYS_"+s+".json")})).fetchJson(),function(e){o._chunkDownloadsInProgress[s]=!1;for(var t=o._samples,n=e.samples,r=s*o._samplesPerXysFile*3,i=0,a=n.length;i<a;++i)t[r+i]=n[i];u.resolve()}),u.promise}sa.prototype.preload=function(e,t,n,r){t=la(this,e,t),r=la(this,n,r),t=t/this._stepSizeDays-this._interpolationOrder/2|0;t<0&&(t=0);r=r/this._stepSizeDays-this._interpolationOrder/2|0+this._interpolationOrder;r>=this._totalSamples&&(r=this._totalSamples-1);for(var t=t/this._samplesPerXysFile|0,i=r/this._samplesPerXysFile|0,a=[],o=t;o<=i;++o)a.push(fa(this,o));return Pn.all(a)},sa.prototype.computeXysRadians=function(e,t,n){var r=la(this,e,t);if(!(r<0)){e=r/this._stepSizeDays|0;if(!(e>=this._totalSamples)){var i=this._interpolationOrder,a=e-(i/2|0),t=(a=a<0?0:a)+i;t>=this._totalSamples&&(a=(t=this._totalSamples-1)-i)<0&&(a=0);var e=!1,o=this._samples;if(Ue(o[3*a])||(fa(this,a/this._samplesPerXysFile|0),e=!0),Ue(o[3*t])||(fa(this,t/this._samplesPerXysFile|0),e=!0),!e){Ue(n)?(n.x=0,n.y=0,n.s=0):n=new oa(0,0,0);for(var s,u=r-a*this._stepSizeDays,c=this._work,l=this._denominators,f=this._coef,h=this._xTable,d=0;d<=i;++d)c[d]=u-h[d];for(d=0;d<=i;++d){for(f[d]=1,s=0;s<=i;++s)s!==d&&(f[d]*=c[s]);f[d]*=l[d];var m=3*(a+d);n.x+=f[d]*o[m++],n.y+=f[d]*o[m++],n.s+=f[d]*o[m]}return n}}}};var ha,da,ma,pa,Ea,ya,_a,Ta,Ra,Aa,ga,Sa,wa,Ia,Ma,Oa,Na,xa={requestFullscreen:void 0,exitFullscreen:void 0,fullscreenEnabled:void 0,fullscreenElement:void 0,fullscreenchange:void 0,fullscreenerror:void 0},va={};function Ua(e){for(var t=e.split("."),n=0,r=t.length;n<r;++n)t[n]=parseInt(t[n],10);return t}function Pa(){var e;return Ue(da)||(da=!1,qa()||null!==(e=/ Chrome\\/([\\.0-9]+)/.exec(ha.userAgent))&&(da=!0,ma=Ua(e[1]))),da}function Ca(){return Pa()&&ma}function Da(){var e;return Ue(pa)||(pa=!1,Pa()||qa()||!/ Safari\\/[\\.0-9]+/.test(ha.userAgent)||null!==(e=/ Version\\/([\\.0-9]+)/.exec(ha.userAgent))&&(pa=!0,Ea=Ua(e[1]))),pa}function ba(){return Da()&&Ea}function La(){var e;return Ue(ya)||(ya=!1,null!==(e=/ AppleWebKit\\/([\\.0-9]+)(\\+?)/.exec(ha.userAgent))&&(ya=!0,(_a=Ua(e[1])).isNightly=!!e[2])),ya}function Fa(){return La()&&_a}function Ba(){var e;return Ue(Ta)||(Ta=!1,"Microsoft Internet Explorer"===ha.appName?null!==(e=/MSIE ([0-9]{1,}[\\.0-9]{0,})/.exec(ha.userAgent))&&(Ta=!0,Ra=Ua(e[1])):"Netscape"===ha.appName&&null!==(e=/Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(ha.userAgent))&&(Ta=!0,Ra=Ua(e[1]))),Ta}function za(){return Ba()&&Ra}function qa(){var e;return Ue(Aa)||(Aa=!1,null!==(e=/ Edge\\/([\\.0-9]+)/.exec(ha.userAgent))&&(Aa=!0,ga=Ua(e[1]))),Aa}function Va(){return qa()&&ga}function ka(){var e;return Ue(Sa)||(Sa=!1,null!==(e=/Firefox\\/([\\.0-9]+)/.exec(ha.userAgent))&&(Sa=!0,wa=Ua(e[1]))),Sa}function Ga(){return Ia=!Ue(Ia)?/Windows/i.test(ha.appVersion):Ia}function Xa(){return ka()&&wa}function Wa(){return Ma=!Ue(Ma)?!ka()&&"undefined"!=typeof PointerEvent&&(!Ue(ha.pointerEnabled)||ha.pointerEnabled):Ma}function Ha(){var e;return Ue(Na)||((e=document.createElement("canvas")).setAttribute("style","image-rendering: -moz-crisp-edges;image-rendering: pixelated;"),e=e.style.imageRendering,(Na=Ue(e)&&""!==e)&&(Oa=e)),Na}function Ya(){return Ha()?Oa:void 0}function ja(){return ja._result}Object.defineProperties(va,{element:{get:function(){if(va.supportsFullscreen())return document[xa.fullscreenElement]}},changeEventName:{get:function(){if(va.supportsFullscreen())return xa.fullscreenchange}},errorEventName:{get:function(){if(va.supportsFullscreen())return xa.fullscreenerror}},enabled:{get:function(){if(va.supportsFullscreen())return document[xa.fullscreenEnabled]}},fullscreen:{get:function(){if(va.supportsFullscreen())return null!==va.element}}}),va.supportsFullscreen=function(){if(Ue(ua))return ua;ua=!1;var e=document.body;if("function"==typeof e.requestFullscreen)return xa.requestFullscreen="requestFullscreen",xa.exitFullscreen="exitFullscreen",xa.fullscreenEnabled="fullscreenEnabled",xa.fullscreenElement="fullscreenElement",xa.fullscreenchange="fullscreenchange",xa.fullscreenerror="fullscreenerror",ua=!0;for(var t=["webkit","moz","o","ms","khtml"],n=0,r=t.length;n<r;++n){var i,a=t[n];"function"!=typeof e[i=a+"RequestFullscreen"]&&"function"!=typeof e[i=a+"RequestFullScreen"]||(xa.requestFullscreen=i,ua=!0),i=a+"ExitFullscreen","function"==typeof document[i]?xa.exitFullscreen=i:(i=a+"CancelFullScreen","function"==typeof document[i]&&(xa.exitFullscreen=i)),i=a+"FullscreenEnabled",void 0!==document[i]?xa.fullscreenEnabled=i:(i=a+"FullScreenEnabled",void 0!==document[i]&&(xa.fullscreenEnabled=i)),i=a+"FullscreenElement",void 0!==document[i]?xa.fullscreenElement=i:(i=a+"FullScreenElement",void 0!==document[i]&&(xa.fullscreenElement=i)),i=a+"fullscreenchange",void 0!==document["on"+i]&&("ms"===a&&(i="MSFullscreenChange"),xa.fullscreenchange=i),i=a+"fullscreenerror",void 0!==document["on"+i]&&("ms"===a&&(i="MSFullscreenError"),xa.fullscreenerror=i)}return ua},va.requestFullscreen=function(e,t){va.supportsFullscreen()&&e[xa.requestFullscreen]({vrDisplay:t})},va.exitFullscreen=function(){va.supportsFullscreen()&&document[xa.exitFullscreen]()},va._names=xa,ha="undefined"!=typeof navigator?navigator:{},ja._promise=void 0,ja._result=void 0,ja.initialize=function(){if(Ue(ja._promise))return ja._promise;var e=Pn.defer();if(ja._promise=e.promise,qa())return ja._result=!1,e.resolve(ja._result),e.promise;var t=new Image;return t.onload=function(){ja._result=0<t.width&&0<t.height,e.resolve(ja._result)},t.onerror=function(){ja._result=!1,e.resolve(ja._result)},t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.promise},Object.defineProperties(ja,{initialized:{get:function(){return Ue(ja._result)}}});var Za=[];"undefined"!=typeof ArrayBuffer&&(Za.push(Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array),"undefined"!=typeof Uint8ClampedArray&&Za.push(Uint8ClampedArray),"undefined"!=typeof Uint8ClampedArray&&Za.push(Uint8ClampedArray));var Ka={isChrome:Pa,chromeVersion:Ca,isSafari:Da,safariVersion:ba,isWebkit:La,webkitVersion:Fa,isInternetExplorer:Ba,internetExplorerVersion:za,isEdge:qa,edgeVersion:Va,isFirefox:ka,firefoxVersion:Xa,isWindows:Ga,hardwareConcurrency:Pe(ha.hardwareConcurrency,3),supportsPointerEvents:Wa,supportsImageRenderingPixelated:Ha,supportsWebP:ja,imageRenderingValue:Ya,typedArrayTypes:Za};function Ja(e,t,n,r){this.x=Pe(e,0),this.y=Pe(t,0),this.z=Pe(n,0),this.w=Pe(r,0)}Ka.supportsFullscreen=function(){return va.supportsFullscreen()},Ka.supportsTypedArrays=function(){return"undefined"!=typeof ArrayBuffer},Ka.supportsWebWorkers=function(){return"undefined"!=typeof Worker},Ka.supportsWebAssembly=function(){return"undefined"!=typeof WebAssembly&&!Ka.isEdge()};var Qa=new De;Ja.fromAxisAngle=function(e,t,n){var r=t/2,i=Math.sin(r),t=(Qa=De.normalize(e,Qa)).x*i,e=Qa.y*i,i=Qa.z*i,r=Math.cos(r);return Ue(n)?(n.x=t,n.y=e,n.z=i,n.w=r,n):new Ja(t,e,i,r)};var $a=[1,2,0],eo=new Array(3);Ja.fromRotationMatrix=function(e,t){var n,r,i,a,o=e[V.COLUMN0ROW0],s=e[V.COLUMN1ROW1],u=e[V.COLUMN2ROW2],c=o+s+u,l=0<c?(i=.5*(a=Math.sqrt(c+1)),a=.5/a,n=(e[V.COLUMN1ROW2]-e[V.COLUMN2ROW1])*a,r=(e[V.COLUMN2ROW0]-e[V.COLUMN0ROW2])*a,(e[V.COLUMN0ROW1]-e[V.COLUMN1ROW0])*a):(o=$a[u=o<u&&s<u?2:o<s?1:0],s=$a[o],a=Math.sqrt(e[V.getElementIndex(u,u)]-e[V.getElementIndex(o,o)]-e[V.getElementIndex(s,s)]+1),(l=eo)[u]=.5*a,a=.5/a,i=(e[V.getElementIndex(s,o)]-e[V.getElementIndex(o,s)])*a,l[o]=(e[V.getElementIndex(o,u)]+e[V.getElementIndex(u,o)])*a,l[s]=(e[V.getElementIndex(s,u)]+e[V.getElementIndex(u,s)])*a,n=-l[0],r=-l[1],-l[2]);return Ue(t)?(t.x=n,t.y=r,t.z=l,t.w=i,t):new Ja(n,r,l,i)};var to=new Ja,no=new Ja,ro=new Ja,io=new Ja;Ja.fromHeadingPitchRoll=function(e,t){return io=Ja.fromAxisAngle(De.UNIT_X,e.roll,to),ro=Ja.fromAxisAngle(De.UNIT_Y,-e.pitch,t),t=Ja.multiply(ro,io,ro),no=Ja.fromAxisAngle(De.UNIT_Z,-e.heading,to),Ja.multiply(no,t,t)};var ao=new De,oo=new De,so=new Ja,uo=new Ja,co=new Ja;Ja.packedLength=4,Ja.pack=function(e,t,n){return n=Pe(n,0),t[n++]=e.x,t[n++]=e.y,t[n++]=e.z,t[n]=e.w,t},Ja.unpack=function(e,t,n){return t=Pe(t,0),(n=!Ue(n)?new Ja:n).x=e[t],n.y=e[t+1],n.z=e[t+2],n.w=e[t+3],n},Ja.packedInterpolationLength=3,Ja.convertPackedArrayForInterpolation=function(e,t,n,r){Ja.unpack(e,4*n,co),Ja.conjugate(co,co);for(var i=0,a=n-t+1;i<a;i++){var o=3*i;Ja.unpack(e,4*(t+i),so),Ja.multiply(so,co,so),so.w<0&&Ja.negate(so,so),Ja.computeAxis(so,ao);var s=Ja.computeAngle(so);(r=!Ue(r)?[]:r)[o]=ao.x*s,r[1+o]=ao.y*s,r[2+o]=ao.z*s}},Ja.unpackInterpolationResult=function(e,t,n,r,i){Ue(i)||(i=new Ja),De.fromArray(e,0,oo);e=De.magnitude(oo);return Ja.unpack(t,4*r,uo),0===e?Ja.clone(Ja.IDENTITY,so):Ja.fromAxisAngle(oo,e,so),Ja.multiply(so,uo,i)},Ja.clone=function(e,t){if(Ue(e))return Ue(t)?(t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t):new Ja(e.x,e.y,e.z,e.w)},Ja.conjugate=function(e,t){return t.x=-e.x,t.y=-e.y,t.z=-e.z,t.w=e.w,t},Ja.magnitudeSquared=function(e){return e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w},Ja.magnitude=function(e){return Math.sqrt(Ja.magnitudeSquared(e))},Ja.normalize=function(e,t){var n=1/Ja.magnitude(e),r=e.x*n,i=e.y*n,a=e.z*n,n=e.w*n;return t.x=r,t.y=i,t.z=a,t.w=n,t},Ja.inverse=function(e,t){var n=Ja.magnitudeSquared(e);return t=Ja.conjugate(e,t),Ja.multiplyByScalar(t,1/n,t)},Ja.add=function(e,t,n){return n.x=e.x+t.x,n.y=e.y+t.y,n.z=e.z+t.z,n.w=e.w+t.w,n},Ja.subtract=function(e,t,n){return n.x=e.x-t.x,n.y=e.y-t.y,n.z=e.z-t.z,n.w=e.w-t.w,n},Ja.negate=function(e,t){return t.x=-e.x,t.y=-e.y,t.z=-e.z,t.w=-e.w,t},Ja.dot=function(e,t){return e.x*t.x+e.y*t.y+e.z*t.z+e.w*t.w},Ja.multiply=function(e,t,n){var r=e.x,i=e.y,a=e.z,o=e.w,s=t.x,u=t.y,c=t.z,l=t.w,f=o*s+r*l+i*c-a*u,e=o*u-r*c+i*l+a*s,t=o*c+r*u-i*s+a*l,c=o*l-r*s-i*u-a*c;return n.x=f,n.y=e,n.z=t,n.w=c,n},Ja.multiplyByScalar=function(e,t,n){return n.x=e.x*t,n.y=e.y*t,n.z=e.z*t,n.w=e.w*t,n},Ja.divideByScalar=function(e,t,n){return n.x=e.x/t,n.y=e.y/t,n.z=e.z/t,n.w=e.w/t,n},Ja.computeAxis=function(e,t){var n=e.w;if(Math.abs(n-1)<Ce.EPSILON6)return t.x=t.y=t.z=0,t;n=1/Math.sqrt(1-n*n);return t.x=e.x*n,t.y=e.y*n,t.z=e.z*n,t},Ja.computeAngle=function(e){return Math.abs(e.w-1)<Ce.EPSILON6?0:2*Math.acos(e.w)};var lo=new Ja;Ja.lerp=function(e,t,n,r){return lo=Ja.multiplyByScalar(t,n,lo),r=Ja.multiplyByScalar(e,1-n,r),Ja.add(lo,r,r)};var fo=new Ja,ho=new Ja,mo=new Ja;Ja.slerp=function(e,t,n,r){var i=Ja.dot(e,t),a=t;if(i<0&&(i=-i,a=fo=Ja.negate(t,fo)),1-i<Ce.EPSILON6)return Ja.lerp(e,a,n,r);i=Math.acos(i);return ho=Ja.multiplyByScalar(e,Math.sin((1-n)*i),ho),mo=Ja.multiplyByScalar(a,Math.sin(n*i),mo),r=Ja.add(ho,mo,r),Ja.multiplyByScalar(r,1/Math.sin(i),r)},Ja.log=function(e,t){var n=Ce.acosClamped(e.w),r=0;return 0!==n&&(r=n/Math.sin(n)),De.multiplyByScalar(e,r,t)},Ja.exp=function(e,t){var n=De.magnitude(e),r=0;return 0!==n&&(r=Math.sin(n)/n),t.x=e.x*r,t.y=e.y*r,t.z=e.z*r,t.w=Math.cos(n),t};var po=new De,Eo=new De,yo=new Ja,_o=new Ja;Ja.computeInnerQuadrangle=function(e,t,n,r){var i=Ja.conjugate(t,yo);Ja.multiply(i,n,_o);n=Ja.log(_o,po);Ja.multiply(i,e,_o);e=Ja.log(_o,Eo);return De.add(n,e,n),De.multiplyByScalar(n,.25,n),De.negate(n,n),Ja.exp(n,yo),Ja.multiply(t,yo,r)},Ja.squad=function(e,t,n,r,i,a){t=Ja.slerp(e,t,i,yo),r=Ja.slerp(n,r,i,_o);return Ja.slerp(t,r,2*i*(1-i),a)};for(var To=new Ja,Ro=1.9011074535173003,Ao=Ka.supportsTypedArrays()?new Float32Array(8):[],go=Ka.supportsTypedArrays()?new Float32Array(8):[],So=Ka.supportsTypedArrays()?new Float32Array(8):[],wo=Ka.supportsTypedArrays()?new Float32Array(8):[],Io=0;Io<7;++Io){var Mo=Io+1,Oo=2*Mo+1;Ao[Io]=1/(Mo*Oo),go[Io]=Mo/Oo}Ao[7]=Ro/136,go[7]=8*Ro/17,Ja.fastSlerp=function(e,t,n,r){var i,a=Ja.dot(e,t);0<=a?i=1:(i=-1,a=-a);for(var o=a-1,a=1-n,s=n*n,u=a*a,c=7;0<=c;--c)So[c]=(Ao[c]*s-go[c])*o,wo[c]=(Ao[c]*u-go[c])*o;n=i*n*(1+So[0]*(1+So[1]*(1+So[2]*(1+So[3]*(1+So[4]*(1+So[5]*(1+So[6]*(1+So[7])))))))),a*=1+wo[0]*(1+wo[1]*(1+wo[2]*(1+wo[3]*(1+wo[4]*(1+wo[5]*(1+wo[6]*(1+wo[7]))))))),a=Ja.multiplyByScalar(e,a,To);return Ja.multiplyByScalar(t,n,r),Ja.add(a,r,r)},Ja.fastSquad=function(e,t,n,r,i,a){t=Ja.fastSlerp(e,t,i,yo),r=Ja.fastSlerp(n,r,i,_o);return Ja.fastSlerp(t,r,2*i*(1-i),a)},Ja.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&e.x===t.x&&e.y===t.y&&e.z===t.z&&e.w===t.w},Ja.equalsEpsilon=function(e,t,n){return n=Pe(n,0),e===t||Ue(e)&&Ue(t)&&Math.abs(e.x-t.x)<=n&&Math.abs(e.y-t.y)<=n&&Math.abs(e.z-t.z)<=n&&Math.abs(e.w-t.w)<=n},Ja.ZERO=Object.freeze(new Ja(0,0,0,0)),Ja.IDENTITY=Object.freeze(new Ja(0,0,0,1)),Ja.prototype.clone=function(e){return Ja.clone(this,e)},Ja.prototype.equals=function(e){return Ja.equals(this,e)},Ja.prototype.equalsEpsilon=function(e,t){return Ja.equalsEpsilon(this,e,t)},Ja.prototype.toString=function(){return"("+this.x+", "+this.y+", "+this.z+", "+this.w+")"};var No={},xo={up:{south:"east",north:"west",west:"south",east:"north"},down:{south:"west",north:"east",west:"north",east:"south"},south:{up:"west",down:"east",west:"down",east:"up"},north:{up:"east",down:"west",west:"up",east:"down"},west:{up:"north",down:"south",north:"down",south:"up"},east:{up:"south",down:"north",north:"up",south:"down"}},vo={north:[-1,0,0],east:[0,1,0],up:[0,0,1],south:[1,0,0],west:[0,-1,0],down:[0,0,-1]},Uo={},Po={east:new De,north:new De,up:new De,west:new De,south:new De,down:new De},Co=new De,Do=new De,bo=new De;No.localFrameToFixedFrameGenerator=function(i,a){if(!xo.hasOwnProperty(i)||!xo[i].hasOwnProperty(a))throw new s("firstAxis and secondAxis must be east, north, up, west, south or down.");var e,o=xo[i][a],t=i+a;return Ue(Uo[t])?e=Uo[t]:(e=function(e,t,n){var r;return Ue(n)||(n=new Fe),De.equalsEpsilon(e,De.ZERO,Ce.EPSILON14)?(De.unpack(vo[i],0,Co),De.unpack(vo[a],0,Do),De.unpack(vo[o],0,bo)):Ce.equalsEpsilon(e.x,0,Ce.EPSILON14)&&Ce.equalsEpsilon(e.y,0,Ce.EPSILON14)?(r=Ce.sign(e.z),De.unpack(vo[i],0,Co),"east"!==i&&"west"!==i&&De.multiplyByScalar(Co,r,Co),De.unpack(vo[a],0,Do),"east"!==a&&"west"!==a&&De.multiplyByScalar(Do,r,Do),De.unpack(vo[o],0,bo),"east"!==o&&"west"!==o&&De.multiplyByScalar(bo,r,bo)):((t=Pe(t,be.WGS84)).geodeticSurfaceNormal(e,Po.up),r=Po.up,(t=Po.east).x=-e.y,t.y=e.x,t.z=0,De.normalize(t,Po.east),De.cross(r,t,Po.north),De.multiplyByScalar(Po.up,-1,Po.down),De.multiplyByScalar(Po.east,-1,Po.west),De.multiplyByScalar(Po.north,-1,Po.south),Co=Po[i],Do=Po[a],bo=Po[o]),n[0]=Co.x,n[1]=Co.y,n[2]=Co.z,n[3]=0,n[4]=Do.x,n[5]=Do.y,n[6]=Do.z,n[7]=0,n[8]=bo.x,n[9]=bo.y,n[10]=bo.z,n[11]=0,n[12]=e.x,n[13]=e.y,n[14]=e.z,n[15]=1,n},Uo[t]=e),e},No.eastNorthUpToFixedFrame=No.localFrameToFixedFrameGenerator("east","north"),No.northEastDownToFixedFrame=No.localFrameToFixedFrameGenerator("north","east"),No.northUpEastToFixedFrame=No.localFrameToFixedFrameGenerator("north","up"),No.northWestUpToFixedFrame=No.localFrameToFixedFrameGenerator("north","west");var Lo=new Ja,Fo=new De(1,1,1),Bo=new Fe;No.headingPitchRollToFixedFrame=function(e,t,n,r,i){r=Pe(r,No.eastNorthUpToFixedFrame);t=Ja.fromHeadingPitchRoll(t,Lo),t=Fe.fromTranslationQuaternionRotationScale(De.ZERO,t,Fo,Bo);return i=r(e,n,i),Fe.multiply(i,t,i)};var zo=new Fe,qo=new V;No.headingPitchRollQuaternion=function(e,t,n,r,i){r=No.headingPitchRollToFixedFrame(e,t,n,r,zo),r=Fe.getMatrix3(r,qo);return Ja.fromRotationMatrix(r,i)};var Vo=new De(1,1,1),ko=new De,Go=new Fe,Xo=new Fe,Wo=new V,Ho=new Ja;No.fixedFrameToHeadingPitchRoll=function(e,t,n,r){t=Pe(t,be.WGS84),n=Pe(n,No.eastNorthUpToFixedFrame),Ue(r)||(r=new Ki);var i=Fe.getTranslation(e,ko);if(De.equals(i,De.ZERO))return r.heading=0,r.pitch=0,r.roll=0,r;t=Fe.inverseTransformation(n(i,t,Go),Go),e=Fe.setScale(e,Vo,Xo),e=Fe.setTranslation(e,De.ZERO,e),t=Fe.multiply(t,e,t),t=Ja.fromRotationMatrix(Fe.getMatrix3(t,Wo),Ho),t=Ja.normalize(t,t);return Ki.fromQuaternion(t,r)};var Yo=24110.54841,jo=8640184.812866,Zo=.093104,Ko=-62e-7,Jo=11772758384668e-32,Qo=72921158553e-15,$o=Ce.TWO_PI/86400,es=new Ir;No.computeTemeToPseudoFixedMatrix=function(e,t){var n=(es=Ir.addSeconds(e,-Ir.computeTaiMinusUtc(e),es)).dayNumber,r=es.secondsOfDay,e=n-2451545,e=43200<=r?(.5+e)/ir.DAYS_PER_JULIAN_CENTURY:(e-.5)/ir.DAYS_PER_JULIAN_CENTURY,n=(Yo+e*(jo+e*(Zo+e*Ko)))*$o%Ce.TWO_PI+(Qo+Jo*(n-2451545.5))*((r+.5*ir.SECONDS_PER_DAY)%ir.SECONDS_PER_DAY),r=Math.cos(n),n=Math.sin(n);return Ue(t)?(t[0]=r,t[1]=-n,t[2]=0,t[3]=n,t[4]=r,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t):new V(r,n,0,-n,r,0,0,0,1)},No.iau2006XysData=new sa,No.earthOrientationParameters=Xi.NONE;var ts=32.184,ns=2451545;No.preloadIcrfFixed=function(e){var t=e.start.dayNumber,n=e.start.secondsOfDay+ts,r=e.stop.dayNumber,e=e.stop.secondsOfDay+ts,r=No.iau2006XysData.preload(t,n,r,e),e=No.earthOrientationParameters.getPromiseToLoad();return Pn.all([r,e])},No.computeIcrfToFixedMatrix=function(e,t){Ue(t)||(t=new V);e=No.computeFixedToIcrfMatrix(e,t);if(Ue(e))return V.transpose(e,t)};var rs=new oa(0,0,0),is=new Qn(0,0,0,0,0,0),as=new V,os=new V;No.computeFixedToIcrfMatrix=function(e,t){Ue(t)||(t=new V);var n=No.earthOrientationParameters.compute(e,is);if(Ue(n)){var r=e.dayNumber,i=e.secondsOfDay+ts,a=No.iau2006XysData.computeXysRadians(r,i,rs);if(Ue(a)){var o=a.x+n.xPoleOffset,s=a.y+n.yPoleOffset,u=1/(1+Math.sqrt(1-o*o-s*s)),c=as;c[0]=1-u*o*o,c[3]=-u*o*s,c[6]=o,c[1]=-u*o*s,c[4]=1-u*s*s,c[7]=s,c[2]=-o,c[5]=-s,c[8]=1-u*(o*o+s*s);o=V.fromRotationZ(-a.s,os),s=V.multiply(c,o,as),a=e.dayNumber-2451545,c=(e.secondsOfDay-Ir.computeTaiMinusUtc(e)+n.ut1MinusUtc)/ir.SECONDS_PER_DAY,o=(o=.779057273264+c+.00273781191135448*(a+c))%1*Ce.TWO_PI,e=V.fromRotationZ(o,os),a=V.multiply(s,e,as),c=Math.cos(n.xPoleWander),o=Math.cos(n.yPoleWander),s=Math.sin(n.xPoleWander),e=Math.sin(n.yPoleWander),n=r-ns+i/ir.SECONDS_PER_DAY,r=-47e-6*(n/=36525)*Ce.RADIANS_PER_DEGREE/3600,i=Math.cos(r),n=Math.sin(r),r=os;return r[0]=c*i,r[1]=c*n,r[2]=s,r[3]=-o*n+e*s*i,r[4]=o*i+e*s*n,r[5]=-e*c,r[6]=-e*n-o*s*i,r[7]=e*i-o*s*n,r[8]=o*c,V.multiply(a,r,t)}}};var ss=new $;No.pointToWindowCoordinates=function(e,t,n,r){return(r=No.pointToGLWindowCoordinates(e,t,n,r)).y=2*t[5]-r.y,r},No.pointToGLWindowCoordinates=function(e,t,n,r){Ue(r)||(r=new mt);var i=ss;return Fe.multiplyByVector(e,$.fromElements(n.x,n.y,n.z,1,i),i),$.multiplyByScalar(i,1/i.w,i),Fe.multiplyByVector(t,i,i),mt.fromCartesian4(i,r)};var us=new De,cs=new De,ls=new De;No.rotationMatrixFromPositionVelocity=function(e,t,n,r){n=Pe(n,be.WGS84).geodeticSurfaceNormal(e,us),e=De.cross(t,n,cs);De.equalsEpsilon(e,De.ZERO,Ce.EPSILON6)&&(e=De.clone(De.UNIT_X,e));n=De.cross(e,t,ls);return De.normalize(n,n),De.cross(t,n,e),De.negate(e,e),De.normalize(e,e),(r=!Ue(r)?new V:r)[0]=t.x,r[1]=t.y,r[2]=t.z,r[3]=e.x,r[4]=e.y,r[5]=e.z,r[6]=n.x,r[7]=n.y,r[8]=n.z,r};var fs=new Fe(0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1),hs=new R,ds=new De,ms=new De,ps=new V,Es=new Fe,ys=new Fe;No.basisTo2D=function(e,t,n){var r=Fe.getTranslation(t,ms),i=e.ellipsoid,a=i.cartesianToCartographic(r,hs),a=e.project(a,ds);De.fromElements(a.z,a.x,a.y,a);i=No.eastNorthUpToFixedFrame(r,i,Es),i=Fe.inverseTransformation(i,ys),t=Fe.getMatrix3(t,ps),t=Fe.multiplyByMatrix3(i,t,n);return Fe.multiply(fs,t,n),Fe.setTranslation(n,a,n),n},No.wgs84To2DModelMatrix=function(e,t,n){var r=e.ellipsoid,i=No.eastNorthUpToFixedFrame(t,r,Es),i=Fe.inverseTransformation(i,ys),t=r.cartesianToCartographic(t,hs),t=e.project(t,ds);De.fromElements(t.z,t.x,t.y,t);t=Fe.fromTranslation(t,Es);return Fe.multiply(fs,i,n),Fe.multiply(t,n,n),n};var _s=new $;function Ts(e,t){e=(t=Pe(t,be.WGS84)).scaleToGeodeticSurface(e);var n=No.eastNorthUpToFixedFrame(e,t);this._ellipsoid=t,this._origin=e,this._xAxis=De.fromCartesian4(Fe.getColumn(n,0,_s)),this._yAxis=De.fromCartesian4(Fe.getColumn(n,1,_s));n=De.fromCartesian4(Fe.getColumn(n,2,_s));this._plane=Sn.fromPointNormal(e,n)}Object.defineProperties(Ts.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},origin:{get:function(){return this._origin}},plane:{get:function(){return this._plane}},xAxis:{get:function(){return this._xAxis}},yAxis:{get:function(){return this._yAxis}},zAxis:{get:function(){return this._plane.normal}}});var Rs=new Le;Ts.fromPoints=function(e,t){return new Ts(Le.fromPoints(e,Rs).center,t)};var As=new Xt,gs=new De;Ts.prototype.projectPointOntoPlane=function(e,t){var n=As;n.origin=e,De.normalize(e,n.direction);e=Wt.rayPlane(n,this._plane,gs);if(Ue(e)||(De.negate(n.direction,n.direction),e=Wt.rayPlane(n,this._plane,gs)),Ue(e)){n=De.subtract(e,this._origin,e),e=De.dot(this._xAxis,n),n=De.dot(this._yAxis,n);return Ue(t)?(t.x=e,t.y=n,t):new mt(e,n)}},Ts.prototype.projectPointsOntoPlane=function(e,t){Ue(t)||(t=[]);for(var n=0,r=e.length,i=0;i<r;i++){var a=this.projectPointOntoPlane(e[i],t[n]);Ue(a)&&(t[n]=a,n++)}return t.length=n,t},Ts.prototype.projectPointToNearestOnPlane=function(e,t){Ue(t)||(t=new mt);var n=As;n.origin=e,De.clone(this._plane.normal,n.direction);e=Wt.rayPlane(n,this._plane,gs);Ue(e)||(De.negate(n.direction,n.direction),e=Wt.rayPlane(n,this._plane,gs));n=De.subtract(e,this._origin,e),e=De.dot(this._xAxis,n),n=De.dot(this._yAxis,n);return t.x=e,t.y=n,t},Ts.prototype.projectPointsToNearestOnPlane=function(e,t){Ue(t)||(t=[]);var n=e.length;t.length=n;for(var r=0;r<n;r++)t[r]=this.projectPointToNearestOnPlane(e[r],t[r]);return t};var Ss=new De;function ws(e,t){this.center=De.clone(Pe(e,De.ZERO)),this.halfAxes=V.clone(Pe(t,V.ZERO))}Ts.prototype.projectPointOntoEllipsoid=function(e,t){Ue(t)||(t=new De);var n=this._ellipsoid,r=this._origin,i=this._xAxis,a=this._yAxis,o=Ss;return De.multiplyByScalar(i,e.x,o),t=De.add(r,o,t),De.multiplyByScalar(a,e.y,o),De.add(t,o,t),n.scaleToGeocentricSurface(t,t),t},Ts.prototype.projectPointsOntoEllipsoid=function(e,t){var n=e.length;Ue(t)?t.length=n:t=new Array(n);for(var r=0;r<n;++r)t[r]=this.projectPointOntoEllipsoid(e[r],t[r]);return t},ws.packedLength=De.packedLength+V.packedLength,ws.pack=function(e,t,n){return n=Pe(n,0),De.pack(e.center,t,n),V.pack(e.halfAxes,t,n+De.packedLength),t},ws.unpack=function(e,t,n){return t=Pe(t,0),Ue(n)||(n=new ws),De.unpack(e,t,n.center),V.unpack(e,t+De.packedLength,n.halfAxes),n};var Is=new De,Ms=new De,Os=new De,Ns=new De,xs=new De,vs=new De,Us=new V,Ps={unitary:new V,diagonal:new V};ws.fromPoints=function(e,t){if(Ue(t)||(t=new ws),!Ue(e)||0===e.length)return t.halfAxes=V.ZERO,t.center=De.ZERO,t;for(var n=e.length,r=De.clone(e[0],Is),i=1;i<n;i++)De.add(r,e[i],r);var a=1/n;De.multiplyByScalar(r,a,r);var o,s=0,u=0,c=0,l=0,f=0,h=0;for(i=0;i<n;i++)s+=(o=De.subtract(e[i],r,Ms)).x*o.x,u+=o.x*o.y,c+=o.x*o.z,l+=o.y*o.y,f+=o.y*o.z,h+=o.z*o.z;s*=a,u*=a,c*=a,l*=a,f*=a,h*=a;a=Us;a[0]=s,a[1]=u,a[2]=c,a[3]=u,a[4]=l,a[5]=f,a[6]=c,a[7]=f,a[8]=h;var a=V.computeEigenDecomposition(a,Ps),a=V.clone(a.unitary,t.halfAxes),d=V.getColumn(a,0,Ns),m=V.getColumn(a,1,xs),p=V.getColumn(a,2,vs),E=-Number.MAX_VALUE,y=-Number.MAX_VALUE,_=-Number.MAX_VALUE,T=Number.MAX_VALUE,R=Number.MAX_VALUE,A=Number.MAX_VALUE;for(i=0;i<n;i++)o=e[i],E=Math.max(De.dot(d,o),E),y=Math.max(De.dot(m,o),y),_=Math.max(De.dot(p,o),_),T=Math.min(De.dot(d,o),T),R=Math.min(De.dot(m,o),R),A=Math.min(De.dot(p,o),A);d=De.multiplyByScalar(d,.5*(T+E),d),m=De.multiplyByScalar(m,.5*(R+y),m),p=De.multiplyByScalar(p,.5*(A+_),p);a=De.add(d,m,t.center);De.add(a,p,a);a=Os;return a.x=E-T,a.y=y-R,a.z=_-A,De.multiplyByScalar(a,.5,a),V.multiplyByScale(t.halfAxes,a,t.halfAxes),t};var Cs=new De,Ds=new De;function bs(e,t,n,r,i,a,o,s,u,c,l){var f=(l=!Ue(l)?new ws:l).halfAxes;V.setColumn(f,0,t,f),V.setColumn(f,1,n,f),V.setColumn(f,2,r,f),(n=Cs).x=(i+a)/2,n.y=(o+s)/2,n.z=(u+c)/2;r=Ds;r.x=(a-i)/2,r.y=(s-o)/2,r.z=(c-u)/2;u=l.center,n=V.multiplyByVector(f,n,n);return De.add(e,n,u),V.multiplyByScale(f,r,f),l}var Ls=new R,Fs=new De,Bs=new R,zs=new R,qs=new R,Vs=new R,ks=new R,Gs=new De,Xs=new De,Ws=new De,Hs=new De,Ys=new De,js=new mt,Zs=new mt,Ks=new mt,Js=new mt,Qs=new mt,$s=new De,eu=new De,tu=new De,nu=new De,ru=new mt,iu=new De,au=new De,ou=new De,su=new Sn(De.UNIT_X,0);ws.fromRectangle=function(e,t,n,r,i){if(t=Pe(t,0),n=Pe(n,0),r=Pe(r,be.WGS84),e.width<=Ce.PI){var a=Be.center(e,Ls),o=new Ts(r.cartographicToCartesian(a,Fs),r),s=o.plane,u=a.longitude,c=e.south<0&&0<e.north?0:a.latitude,l=R.fromRadians(u,e.north,n,Bs),f=R.fromRadians(e.west,e.north,n,zs),h=R.fromRadians(e.west,c,n,qs),d=R.fromRadians(e.west,e.south,n,Vs),m=R.fromRadians(u,e.south,n,ks),p=r.cartographicToCartesian(l,Gs),E=r.cartographicToCartesian(f,Xs),y=r.cartographicToCartesian(h,Ws),_=r.cartographicToCartesian(d,Hs),T=r.cartographicToCartesian(m,Ys),a=o.projectPointToNearestOnPlane(p,js),c=o.projectPointToNearestOnPlane(E,Zs),u=o.projectPointToNearestOnPlane(y,Ks),l=o.projectPointToNearestOnPlane(_,Js),h=o.projectPointToNearestOnPlane(T,Qs),p=-(m=Math.min(c.x,u.x,l.x)),y=Math.max(c.y,a.y),T=Math.min(l.y,h.y);return f.height=d.height=t,E=r.cartographicToCartesian(f,Xs),_=r.cartographicToCartesian(d,Hs),u=Math.min(Sn.getPointDistance(s,E),Sn.getPointDistance(s,_)),c=n,bs(o.origin,o.xAxis,o.yAxis,o.zAxis,m,p,T,y,u,c,i)}a=0<e.south,l=e.north<0,h=a?e.south:l?e.north:0,f=Be.center(e,Ls).longitude,d=De.fromRadians(f,h,n,r,$s);d.z=0;E=Math.abs(d.x)<Ce.EPSILON10&&Math.abs(d.y)<Ce.EPSILON10?De.UNIT_X:De.normalize(d,eu),_=De.UNIT_Z,o=De.cross(E,_,tu);s=Sn.fromPointNormal(d,E,su);f=De.fromRadians(f+Ce.PI_OVER_TWO,h,n,r,nu);m=-(p=De.dot(Sn.projectPointOntoPlane(s,f,ru),o)),y=De.fromRadians(0,e.north,l?t:n,r,iu).z,T=De.fromRadians(0,e.south,a?t:n,r,au).z;r=De.fromRadians(e.east,h,n,r,ou);return bs(d,o,_,E,m,p,T,y,u=Sn.getPointDistance(s,r),c=0,i)},ws.clone=function(e,t){if(Ue(e))return Ue(t)?(De.clone(e.center,t.center),V.clone(e.halfAxes,t.halfAxes),t):new ws(e.center,e.halfAxes)},ws.intersectPlane=function(e,t){var n=e.center,r=t.normal,i=e.halfAxes,a=r.x,o=r.y,e=r.z,i=Math.abs(a*i[V.COLUMN0ROW0]+o*i[V.COLUMN0ROW1]+e*i[V.COLUMN0ROW2])+Math.abs(a*i[V.COLUMN1ROW0]+o*i[V.COLUMN1ROW1]+e*i[V.COLUMN1ROW2])+Math.abs(a*i[V.COLUMN2ROW0]+o*i[V.COLUMN2ROW1]+e*i[V.COLUMN2ROW2]),t=De.dot(r,n)+t.distance;return t<=-i?F.OUTSIDE:i<=t?F.INSIDE:F.INTERSECTING};var uu=new De,cu=new De,lu=new De,fu=new De;ws.distanceSquaredTo=function(e,t){var n=De.subtract(t,e.center,Cs),r=e.halfAxes,i=V.getColumn(r,0,uu),a=V.getColumn(r,1,cu),o=V.getColumn(r,2,lu),s=De.magnitude(i),t=De.magnitude(a),e=De.magnitude(o);De.normalize(i,i),De.normalize(a,a),De.normalize(o,o);r=fu;r.x=De.dot(n,i),r.y=De.dot(n,a),r.z=De.dot(n,o);var u,o=0;return r.x<-s?o+=(u=r.x+s)*u:r.x>s&&(o+=(u=r.x-s)*u),r.y<-t?o+=(u=r.y+t)*u:r.y>t&&(o+=(u=r.y-t)*u),r.z<-e?o+=(u=r.z+e)*u:r.z>e&&(o+=(u=r.z-e)*u),o};var hu=new De,du=new De;ws.computePlaneDistances=function(e,t,n,r){Ue(r)||(r=new q);var i=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY,o=e.center,s=e.halfAxes,u=V.getColumn(s,0,uu),c=V.getColumn(s,1,cu),l=V.getColumn(s,2,lu),f=De.add(u,c,hu);De.add(f,l,f),De.add(f,o,f);e=De.subtract(f,t,du),s=De.dot(n,e),i=Math.min(s,i),a=Math.max(s,a);return De.add(o,u,f),De.add(f,c,f),De.subtract(f,l,f),De.subtract(f,t,e),s=De.dot(n,e),i=Math.min(s,i),a=Math.max(s,a),De.add(o,u,f),De.subtract(f,c,f),De.add(f,l,f),De.subtract(f,t,e),s=De.dot(n,e),i=Math.min(s,i),a=Math.max(s,a),De.add(o,u,f),De.subtract(f,c,f),De.subtract(f,l,f),De.subtract(f,t,e),s=De.dot(n,e),i=Math.min(s,i),a=Math.max(s,a),De.subtract(o,u,f),De.add(f,c,f),De.add(f,l,f),De.subtract(f,t,e),s=De.dot(n,e),i=Math.min(s,i),a=Math.max(s,a),De.subtract(o,u,f),De.add(f,c,f),De.subtract(f,l,f),De.subtract(f,t,e),s=De.dot(n,e),i=Math.min(s,i),a=Math.max(s,a),De.subtract(o,u,f),De.subtract(f,c,f),De.add(f,l,f),De.subtract(f,t,e),s=De.dot(n,e),i=Math.min(s,i),a=Math.max(s,a),De.subtract(o,u,f),De.subtract(f,c,f),De.subtract(f,l,f),De.subtract(f,t,e),s=De.dot(n,e),i=Math.min(s,i),a=Math.max(s,a),r.start=i,r.stop=a,r};var mu=new ze;ws.isOccluded=function(e,t){e=ze.fromOrientedBoundingBox(e,mu);return!t.isBoundingSphereVisible(e)},ws.prototype.intersectPlane=function(e){return ws.intersectPlane(this,e)},ws.prototype.distanceSquaredTo=function(e){return ws.distanceSquaredTo(this,e)},ws.prototype.computePlaneDistances=function(e,t,n){return ws.computePlaneDistances(this,e,t,n)},ws.prototype.isOccluded=function(e){return ws.isOccluded(this,e)},ws.equals=function(e,t){return e===t||Ue(e)&&Ue(t)&&De.equals(e.center,t.center)&&V.equals(e.halfAxes,t.halfAxes)},ws.prototype.clone=function(e){return ws.clone(this,e)},ws.prototype.equals=function(e){return ws.equals(this,e)};var pu=1/256,Eu=256,yu={octEncodeInRange:function(e,t,n){var r;return n.x=e.x/(Math.abs(e.x)+Math.abs(e.y)+Math.abs(e.z)),n.y=e.y/(Math.abs(e.x)+Math.abs(e.y)+Math.abs(e.z)),e.z<0&&(r=n.x,e=n.y,n.x=(1-Math.abs(e))*Ce.signNotZero(r),n.y=(1-Math.abs(r))*Ce.signNotZero(e)),n.x=Ce.toSNorm(n.x,t),n.y=Ce.toSNorm(n.y,t),n},octEncode:function(e,t){return yu.octEncodeInRange(e,255,t)}},_u=new mt,Tu=new Uint8Array(1);function Ru(e){return Tu[0]=e,Tu[0]}yu.octEncodeToCartesian4=function(e,t){return yu.octEncodeInRange(e,65535,_u),t.x=Ru(_u.x*pu),t.y=Ru(_u.x),t.z=Ru(_u.y*pu),t.w=Ru(_u.y),t},yu.octDecodeInRange=function(e,t,n,r){return r.x=Ce.fromSNorm(e,n),r.y=Ce.fromSNorm(t,n),r.z=1-(Math.abs(r.x)+Math.abs(r.y)),r.z<0&&(n=r.x,r.x=(1-Math.abs(r.y))*Ce.signNotZero(n),r.y=(1-Math.abs(n))*Ce.signNotZero(r.y)),De.normalize(r,r)},yu.octDecode=function(e,t,n){return yu.octDecodeInRange(e,t,255,n)},yu.octDecodeFromCartesian4=function(e,t){var n=e.x,r=e.y,i=e.z,e=e.w,r=n*Eu+r,e=i*Eu+e;return yu.octDecodeInRange(r,e,65535,t)},yu.octPackFloat=function(e){return 256*e.x+e.y};var Au=new mt;function gu(e){return e>>1^-(1&e)}yu.octEncodeFloat=function(e){return yu.octEncode(e,Au),yu.octPackFloat(Au)},yu.octDecodeFloat=function(e,t){var n=e/256,e=Math.floor(n),n=256*(n-e);return yu.octDecode(e,n,t)},yu.octPack=function(e,t,n,r){e=yu.octEncodeFloat(e),t=yu.octEncodeFloat(t),n=yu.octEncode(n,Au);return r.x=65536*n.x+e,r.y=65536*n.y+t,r},yu.octUnpack=function(e,t,n,r){var i=e.x/65536,a=Math.floor(i),o=65536*(i-a),i=e.y/65536,e=Math.floor(i),i=65536*(i-e);yu.octDecodeFloat(o,t),yu.octDecodeFloat(i,n),yu.octDecode(a,e,r)},yu.compressTextureCoordinates=function(e){return 4096*(4095*e.x|0)+(4095*e.y|0)},yu.decompressTextureCoordinates=function(e,t){var n=e/4096,n=Math.floor(n);return t.x=n/4095,t.y=(e-4096*n)/4095,t},yu.zigZagDeltaDecode=function(e,t,n){for(var r=e.length,i=0,a=0,o=0,s=0;s<r;++s)i+=gu(e[s]),a+=gu(t[s]),e[s]=i,t[s]=a,Ue(n)&&(o+=gu(n[s]),n[s]=o)};var Su={DEPTH_BUFFER_BIT:256,STENCIL_BUFFER_BIT:1024,COLOR_BUFFER_BIT:16384,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,ZERO:0,ONE:1,SRC_COLOR:768,ONE_MINUS_SRC_COLOR:769,SRC_ALPHA:770,ONE_MINUS_SRC_ALPHA:771,DST_ALPHA:772,ONE_MINUS_DST_ALPHA:773,DST_COLOR:774,ONE_MINUS_DST_COLOR:775,SRC_ALPHA_SATURATE:776,FUNC_ADD:32774,BLEND_EQUATION:32777,BLEND_EQUATION_RGB:32777,BLEND_EQUATION_ALPHA:34877,FUNC_SUBTRACT:32778,FUNC_REVERSE_SUBTRACT:32779,BLEND_DST_RGB:32968,BLEND_SRC_RGB:32969,BLEND_DST_ALPHA:32970,BLEND_SRC_ALPHA:32971,CONSTANT_COLOR:32769,ONE_MINUS_CONSTANT_COLOR:32770,CONSTANT_ALPHA:32771,ONE_MINUS_CONSTANT_ALPHA:32772,BLEND_COLOR:32773,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,ARRAY_BUFFER_BINDING:34964,ELEMENT_ARRAY_BUFFER_BINDING:34965,STREAM_DRAW:35040,STATIC_DRAW:35044,DYNAMIC_DRAW:35048,BUFFER_SIZE:34660,BUFFER_USAGE:34661,CURRENT_VERTEX_ATTRIB:34342,FRONT:1028,BACK:1029,FRONT_AND_BACK:1032,CULL_FACE:2884,BLEND:3042,DITHER:3024,STENCIL_TEST:2960,DEPTH_TEST:2929,SCISSOR_TEST:3089,POLYGON_OFFSET_FILL:32823,SAMPLE_ALPHA_TO_COVERAGE:32926,SAMPLE_COVERAGE:32928,NO_ERROR:0,INVALID_ENUM:1280,INVALID_VALUE:1281,INVALID_OPERATION:1282,OUT_OF_MEMORY:1285,CW:2304,CCW:2305,LINE_WIDTH:2849,ALIASED_POINT_SIZE_RANGE:33901,ALIASED_LINE_WIDTH_RANGE:33902,CULL_FACE_MODE:2885,FRONT_FACE:2886,DEPTH_RANGE:2928,DEPTH_WRITEMASK:2930,DEPTH_CLEAR_VALUE:2931,DEPTH_FUNC:2932,STENCIL_CLEAR_VALUE:2961,STENCIL_FUNC:2962,STENCIL_FAIL:2964,STENCIL_PASS_DEPTH_FAIL:2965,STENCIL_PASS_DEPTH_PASS:2966,STENCIL_REF:2967,STENCIL_VALUE_MASK:2963,STENCIL_WRITEMASK:2968,STENCIL_BACK_FUNC:34816,STENCIL_BACK_FAIL:34817,STENCIL_BACK_PASS_DEPTH_FAIL:34818,STENCIL_BACK_PASS_DEPTH_PASS:34819,STENCIL_BACK_REF:36003,STENCIL_BACK_VALUE_MASK:36004,STENCIL_BACK_WRITEMASK:36005,VIEWPORT:2978,SCISSOR_BOX:3088,COLOR_CLEAR_VALUE:3106,COLOR_WRITEMASK:3107,UNPACK_ALIGNMENT:3317,PACK_ALIGNMENT:3333,MAX_TEXTURE_SIZE:3379,MAX_VIEWPORT_DIMS:3386,SUBPIXEL_BITS:3408,RED_BITS:3410,GREEN_BITS:3411,BLUE_BITS:3412,ALPHA_BITS:3413,DEPTH_BITS:3414,STENCIL_BITS:3415,POLYGON_OFFSET_UNITS:10752,POLYGON_OFFSET_FACTOR:32824,TEXTURE_BINDING_2D:32873,SAMPLE_BUFFERS:32936,SAMPLES:32937,SAMPLE_COVERAGE_VALUE:32938,SAMPLE_COVERAGE_INVERT:32939,COMPRESSED_TEXTURE_FORMATS:34467,DONT_CARE:4352,FASTEST:4353,NICEST:4354,GENERATE_MIPMAP_HINT:33170,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,DEPTH_COMPONENT:6402,ALPHA:6406,RGB:6407,RGBA:6408,LUMINANCE:6409,LUMINANCE_ALPHA:6410,UNSIGNED_SHORT_4_4_4_4:32819,UNSIGNED_SHORT_5_5_5_1:32820,UNSIGNED_SHORT_5_6_5:33635,FRAGMENT_SHADER:35632,VERTEX_SHADER:35633,MAX_VERTEX_ATTRIBS:34921,MAX_VERTEX_UNIFORM_VECTORS:36347,MAX_VARYING_VECTORS:36348,MAX_COMBINED_TEXTURE_IMAGE_UNITS:35661,MAX_VERTEX_TEXTURE_IMAGE_UNITS:35660,MAX_TEXTURE_IMAGE_UNITS:34930,MAX_FRAGMENT_UNIFORM_VECTORS:36349,SHADER_TYPE:35663,DELETE_STATUS:35712,LINK_STATUS:35714,VALIDATE_STATUS:35715,ATTACHED_SHADERS:35717,ACTIVE_UNIFORMS:35718,ACTIVE_ATTRIBUTES:35721,SHADING_LANGUAGE_VERSION:35724,CURRENT_PROGRAM:35725,NEVER:512,LESS:513,EQUAL:514,LEQUAL:515,GREATER:516,NOTEQUAL:517,GEQUAL:518,ALWAYS:519,KEEP:7680,REPLACE:7681,INCR:7682,DECR:7683,INVERT:5386,INCR_WRAP:34055,DECR_WRAP:34056,VENDOR:7936,RENDERER:7937,VERSION:7938,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,TEXTURE_MAG_FILTER:10240,TEXTURE_MIN_FILTER:10241,TEXTURE_WRAP_S:10242,TEXTURE_WRAP_T:10243,TEXTURE_2D:3553,TEXTURE:5890,TEXTURE_CUBE_MAP:34067,TEXTURE_BINDING_CUBE_MAP:34068,TEXTURE_CUBE_MAP_POSITIVE_X:34069,TEXTURE_CUBE_MAP_NEGATIVE_X:34070,TEXTURE_CUBE_MAP_POSITIVE_Y:34071,TEXTURE_CUBE_MAP_NEGATIVE_Y:34072,TEXTURE_CUBE_MAP_POSITIVE_Z:34073,TEXTURE_CUBE_MAP_NEGATIVE_Z:34074,MAX_CUBE_MAP_TEXTURE_SIZE:34076,TEXTURE0:33984,TEXTURE1:33985,TEXTURE2:33986,TEXTURE3:33987,TEXTURE4:33988,TEXTURE5:33989,TEXTURE6:33990,TEXTURE7:33991,TEXTURE8:33992,TEXTURE9:33993,TEXTURE10:33994,TEXTURE11:33995,TEXTURE12:33996,TEXTURE13:33997,TEXTURE14:33998,TEXTURE15:33999,TEXTURE16:34e3,TEXTURE17:34001,TEXTURE18:34002,TEXTURE19:34003,TEXTURE20:34004,TEXTURE21:34005,TEXTURE22:34006,TEXTURE23:34007,TEXTURE24:34008,TEXTURE25:34009,TEXTURE26:34010,TEXTURE27:34011,TEXTURE28:34012,TEXTURE29:34013,TEXTURE30:34014,TEXTURE31:34015,ACTIVE_TEXTURE:34016,REPEAT:10497,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,INT_VEC2:35667,INT_VEC3:35668,INT_VEC4:35669,BOOL:35670,BOOL_VEC2:35671,BOOL_VEC3:35672,BOOL_VEC4:35673,FLOAT_MAT2:35674,FLOAT_MAT3:35675,FLOAT_MAT4:35676,SAMPLER_2D:35678,SAMPLER_CUBE:35680,VERTEX_ATTRIB_ARRAY_ENABLED:34338,VERTEX_ATTRIB_ARRAY_SIZE:34339,VERTEX_ATTRIB_ARRAY_STRIDE:34340,VERTEX_ATTRIB_ARRAY_TYPE:34341,VERTEX_ATTRIB_ARRAY_NORMALIZED:34922,VERTEX_ATTRIB_ARRAY_POINTER:34373,VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:34975,IMPLEMENTATION_COLOR_READ_TYPE:35738,IMPLEMENTATION_COLOR_READ_FORMAT:35739,COMPILE_STATUS:35713,LOW_FLOAT:36336,MEDIUM_FLOAT:36337,HIGH_FLOAT:36338,LOW_INT:36339,MEDIUM_INT:36340,HIGH_INT:36341,FRAMEBUFFER:36160,RENDERBUFFER:36161,RGBA4:32854,RGB5_A1:32855,RGB565:36194,DEPTH_COMPONENT16:33189,STENCIL_INDEX:6401,STENCIL_INDEX8:36168,DEPTH_STENCIL:34041,RENDERBUFFER_WIDTH:36162,RENDERBUFFER_HEIGHT:36163,RENDERBUFFER_INTERNAL_FORMAT:36164,RENDERBUFFER_RED_SIZE:36176,RENDERBUFFER_GREEN_SIZE:36177,RENDERBUFFER_BLUE_SIZE:36178,RENDERBUFFER_ALPHA_SIZE:36179,RENDERBUFFER_DEPTH_SIZE:36180,RENDERBUFFER_STENCIL_SIZE:36181,FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:36048,FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:36049,FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:36050,FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:36051,COLOR_ATTACHMENT0:36064,DEPTH_ATTACHMENT:36096,STENCIL_ATTACHMENT:36128,DEPTH_STENCIL_ATTACHMENT:33306,NONE:0,FRAMEBUFFER_COMPLETE:36053,FRAMEBUFFER_INCOMPLETE_ATTACHMENT:36054,FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:36055,FRAMEBUFFER_INCOMPLETE_DIMENSIONS:36057,FRAMEBUFFER_UNSUPPORTED:36061,FRAMEBUFFER_BINDING:36006,RENDERBUFFER_BINDING:36007,MAX_RENDERBUFFER_SIZE:34024,INVALID_FRAMEBUFFER_OPERATION:1286,UNPACK_FLIP_Y_WEBGL:37440,UNPACK_PREMULTIPLY_ALPHA_WEBGL:37441,CONTEXT_LOST_WEBGL:37442,UNPACK_COLORSPACE_CONVERSION_WEBGL:37443,BROWSER_DEFAULT_WEBGL:37444,COMPRESSED_RGB_S3TC_DXT1_EXT:33776,COMPRESSED_RGBA_S3TC_DXT1_EXT:33777,COMPRESSED_RGBA_S3TC_DXT3_EXT:33778,COMPRESSED_RGBA_S3TC_DXT5_EXT:33779,COMPRESSED_RGB_PVRTC_4BPPV1_IMG:35840,COMPRESSED_RGB_PVRTC_2BPPV1_IMG:35841,COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:35842,COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:35843,COMPRESSED_RGB_ETC1_WEBGL:36196,HALF_FLOAT_OES:36193,DOUBLE:5130,READ_BUFFER:3074,UNPACK_ROW_LENGTH:3314,UNPACK_SKIP_ROWS:3315,UNPACK_SKIP_PIXELS:3316,PACK_ROW_LENGTH:3330,PACK_SKIP_ROWS:3331,PACK_SKIP_PIXELS:3332,COLOR:6144,DEPTH:6145,STENCIL:6146,RED:6403,RGB8:32849,RGBA8:32856,RGB10_A2:32857,TEXTURE_BINDING_3D:32874,UNPACK_SKIP_IMAGES:32877,UNPACK_IMAGE_HEIGHT:32878,TEXTURE_3D:32879,TEXTURE_WRAP_R:32882,MAX_3D_TEXTURE_SIZE:32883,UNSIGNED_INT_2_10_10_10_REV:33640,MAX_ELEMENTS_VERTICES:33e3,MAX_ELEMENTS_INDICES:33001,TEXTURE_MIN_LOD:33082,TEXTURE_MAX_LOD:33083,TEXTURE_BASE_LEVEL:33084,TEXTURE_MAX_LEVEL:33085,MIN:32775,MAX:32776,DEPTH_COMPONENT24:33190,MAX_TEXTURE_LOD_BIAS:34045,TEXTURE_COMPARE_MODE:34892,TEXTURE_COMPARE_FUNC:34893,CURRENT_QUERY:34917,QUERY_RESULT:34918,QUERY_RESULT_AVAILABLE:34919,STREAM_READ:35041,STREAM_COPY:35042,STATIC_READ:35045,STATIC_COPY:35046,DYNAMIC_READ:35049,DYNAMIC_COPY:35050,MAX_DRAW_BUFFERS:34852,DRAW_BUFFER0:34853,DRAW_BUFFER1:34854,DRAW_BUFFER2:34855,DRAW_BUFFER3:34856,DRAW_BUFFER4:34857,DRAW_BUFFER5:34858,DRAW_BUFFER6:34859,DRAW_BUFFER7:34860,DRAW_BUFFER8:34861,DRAW_BUFFER9:34862,DRAW_BUFFER10:34863,DRAW_BUFFER11:34864,DRAW_BUFFER12:34865,DRAW_BUFFER13:34866,DRAW_BUFFER14:34867,DRAW_BUFFER15:34868,MAX_FRAGMENT_UNIFORM_COMPONENTS:35657,MAX_VERTEX_UNIFORM_COMPONENTS:35658,SAMPLER_3D:35679,SAMPLER_2D_SHADOW:35682,FRAGMENT_SHADER_DERIVATIVE_HINT:35723,PIXEL_PACK_BUFFER:35051,PIXEL_UNPACK_BUFFER:35052,PIXEL_PACK_BUFFER_BINDING:35053,PIXEL_UNPACK_BUFFER_BINDING:35055,FLOAT_MAT2x3:35685,FLOAT_MAT2x4:35686,FLOAT_MAT3x2:35687,FLOAT_MAT3x4:35688,FLOAT_MAT4x2:35689,FLOAT_MAT4x3:35690,SRGB:35904,SRGB8:35905,SRGB8_ALPHA8:35907,COMPARE_REF_TO_TEXTURE:34894,RGBA32F:34836,RGB32F:34837,RGBA16F:34842,RGB16F:34843,VERTEX_ATTRIB_ARRAY_INTEGER:35069,MAX_ARRAY_TEXTURE_LAYERS:35071,MIN_PROGRAM_TEXEL_OFFSET:35076,MAX_PROGRAM_TEXEL_OFFSET:35077,MAX_VARYING_COMPONENTS:35659,TEXTURE_2D_ARRAY:35866,TEXTURE_BINDING_2D_ARRAY:35869,R11F_G11F_B10F:35898,UNSIGNED_INT_10F_11F_11F_REV:35899,RGB9_E5:35901,UNSIGNED_INT_5_9_9_9_REV:35902,TRANSFORM_FEEDBACK_BUFFER_MODE:35967,MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:35968,TRANSFORM_FEEDBACK_VARYINGS:35971,TRANSFORM_FEEDBACK_BUFFER_START:35972,TRANSFORM_FEEDBACK_BUFFER_SIZE:35973,TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:35976,RASTERIZER_DISCARD:35977,MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:35978,MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:35979,INTERLEAVED_ATTRIBS:35980,SEPARATE_ATTRIBS:35981,TRANSFORM_FEEDBACK_BUFFER:35982,TRANSFORM_FEEDBACK_BUFFER_BINDING:35983,RGBA32UI:36208,RGB32UI:36209,RGBA16UI:36214,RGB16UI:36215,RGBA8UI:36220,RGB8UI:36221,RGBA32I:36226,RGB32I:36227,RGBA16I:36232,RGB16I:36233,RGBA8I:36238,RGB8I:36239,RED_INTEGER:36244,RGB_INTEGER:36248,RGBA_INTEGER:36249,SAMPLER_2D_ARRAY:36289,SAMPLER_2D_ARRAY_SHADOW:36292,SAMPLER_CUBE_SHADOW:36293,UNSIGNED_INT_VEC2:36294,UNSIGNED_INT_VEC3:36295,UNSIGNED_INT_VEC4:36296,INT_SAMPLER_2D:36298,INT_SAMPLER_3D:36299,INT_SAMPLER_CUBE:36300,INT_SAMPLER_2D_ARRAY:36303,UNSIGNED_INT_SAMPLER_2D:36306,UNSIGNED_INT_SAMPLER_3D:36307,UNSIGNED_INT_SAMPLER_CUBE:36308,UNSIGNED_INT_SAMPLER_2D_ARRAY:36311,DEPTH_COMPONENT32F:36012,DEPTH32F_STENCIL8:36013,FLOAT_32_UNSIGNED_INT_24_8_REV:36269,FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:33296,FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:33297,FRAMEBUFFER_ATTACHMENT_RED_SIZE:33298,FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:33299,FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:33300,FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:33301,FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:33302,FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:33303,FRAMEBUFFER_DEFAULT:33304,UNSIGNED_INT_24_8:34042,DEPTH24_STENCIL8:35056,UNSIGNED_NORMALIZED:35863,DRAW_FRAMEBUFFER_BINDING:36006,READ_FRAMEBUFFER:36008,DRAW_FRAMEBUFFER:36009,READ_FRAMEBUFFER_BINDING:36010,RENDERBUFFER_SAMPLES:36011,FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:36052,MAX_COLOR_ATTACHMENTS:36063,COLOR_ATTACHMENT1:36065,COLOR_ATTACHMENT2:36066,COLOR_ATTACHMENT3:36067,COLOR_ATTACHMENT4:36068,COLOR_ATTACHMENT5:36069,COLOR_ATTACHMENT6:36070,COLOR_ATTACHMENT7:36071,COLOR_ATTACHMENT8:36072,COLOR_ATTACHMENT9:36073,COLOR_ATTACHMENT10:36074,COLOR_ATTACHMENT11:36075,COLOR_ATTACHMENT12:36076,COLOR_ATTACHMENT13:36077,COLOR_ATTACHMENT14:36078,COLOR_ATTACHMENT15:36079,FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:36182,MAX_SAMPLES:36183,HALF_FLOAT:5131,RG:33319,RG_INTEGER:33320,R8:33321,RG8:33323,R16F:33325,R32F:33326,RG16F:33327,RG32F:33328,R8I:33329,R8UI:33330,R16I:33331,R16UI:33332,R32I:33333,R32UI:33334,RG8I:33335,RG8UI:33336,RG16I:33337,RG16UI:33338,RG32I:33339,RG32UI:33340,VERTEX_ARRAY_BINDING:34229,R8_SNORM:36756,RG8_SNORM:36757,RGB8_SNORM:36758,RGBA8_SNORM:36759,SIGNED_NORMALIZED:36764,COPY_READ_BUFFER:36662,COPY_WRITE_BUFFER:36663,COPY_READ_BUFFER_BINDING:36662,COPY_WRITE_BUFFER_BINDING:36663,UNIFORM_BUFFER:35345,UNIFORM_BUFFER_BINDING:35368,UNIFORM_BUFFER_START:35369,UNIFORM_BUFFER_SIZE:35370,MAX_VERTEX_UNIFORM_BLOCKS:35371,MAX_FRAGMENT_UNIFORM_BLOCKS:35373,MAX_COMBINED_UNIFORM_BLOCKS:35374,MAX_UNIFORM_BUFFER_BINDINGS:35375,MAX_UNIFORM_BLOCK_SIZE:35376,MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:35377,MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:35379,UNIFORM_BUFFER_OFFSET_ALIGNMENT:35380,ACTIVE_UNIFORM_BLOCKS:35382,UNIFORM_TYPE:35383,UNIFORM_SIZE:35384,UNIFORM_BLOCK_INDEX:35386,UNIFORM_OFFSET:35387,UNIFORM_ARRAY_STRIDE:35388,UNIFORM_MATRIX_STRIDE:35389,UNIFORM_IS_ROW_MAJOR:35390,UNIFORM_BLOCK_BINDING:35391,UNIFORM_BLOCK_DATA_SIZE:35392,UNIFORM_BLOCK_ACTIVE_UNIFORMS:35394,UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:35395,UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:35396,UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:35398,INVALID_INDEX:4294967295,MAX_VERTEX_OUTPUT_COMPONENTS:37154,MAX_FRAGMENT_INPUT_COMPONENTS:37157,MAX_SERVER_WAIT_TIMEOUT:37137,OBJECT_TYPE:37138,SYNC_CONDITION:37139,SYNC_STATUS:37140,SYNC_FLAGS:37141,SYNC_FENCE:37142,SYNC_GPU_COMMANDS_COMPLETE:37143,UNSIGNALED:37144,SIGNALED:37145,ALREADY_SIGNALED:37146,TIMEOUT_EXPIRED:37147,CONDITION_SATISFIED:37148,WAIT_FAILED:37149,SYNC_FLUSH_COMMANDS_BIT:1,VERTEX_ATTRIB_ARRAY_DIVISOR:35070,ANY_SAMPLES_PASSED:35887,ANY_SAMPLES_PASSED_CONSERVATIVE:36202,SAMPLER_BINDING:35097,RGB10_A2UI:36975,INT_2_10_10_10_REV:36255,TRANSFORM_FEEDBACK:36386,TRANSFORM_FEEDBACK_PAUSED:36387,TRANSFORM_FEEDBACK_ACTIVE:36388,TRANSFORM_FEEDBACK_BINDING:36389,COMPRESSED_R11_EAC:37488,COMPRESSED_SIGNED_R11_EAC:37489,COMPRESSED_RG11_EAC:37490,COMPRESSED_SIGNED_RG11_EAC:37491,COMPRESSED_RGB8_ETC2:37492,COMPRESSED_SRGB8_ETC2:37493,COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:37494,COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:37495,COMPRESSED_RGBA8_ETC2_EAC:37496,COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:37497,TEXTURE_IMMUTABLE_FORMAT:37167,MAX_ELEMENT_INDEX:36203,TEXTURE_IMMUTABLE_LEVELS:33503,MAX_TEXTURE_MAX_ANISOTROPY_EXT:34047},wu=Object.freeze(Su),Iu={BYTE:wu.BYTE,UNSIGNED_BYTE:wu.UNSIGNED_BYTE,SHORT:wu.SHORT,UNSIGNED_SHORT:wu.UNSIGNED_SHORT,INT:wu.INT,UNSIGNED_INT:wu.UNSIGNED_INT,FLOAT:wu.FLOAT,DOUBLE:wu.DOUBLE,getSizeInBytes:function(e){switch(e){case Iu.BYTE:return Int8Array.BYTES_PER_ELEMENT;case Iu.UNSIGNED_BYTE:return Uint8Array.BYTES_PER_ELEMENT;case Iu.SHORT:return Int16Array.BYTES_PER_ELEMENT;case Iu.UNSIGNED_SHORT:return Uint16Array.BYTES_PER_ELEMENT;case Iu.INT:return Int32Array.BYTES_PER_ELEMENT;case Iu.UNSIGNED_INT:return Uint32Array.BYTES_PER_ELEMENT;case Iu.FLOAT:return Float32Array.BYTES_PER_ELEMENT;case Iu.DOUBLE:return Float64Array.BYTES_PER_ELEMENT}},fromTypedArray:function(e){return e instanceof Int8Array?Iu.BYTE:e instanceof Uint8Array?Iu.UNSIGNED_BYTE:e instanceof Int16Array?Iu.SHORT:e instanceof Uint16Array?Iu.UNSIGNED_SHORT:e instanceof Int32Array?Iu.INT:e instanceof Uint32Array?Iu.UNSIGNED_INT:e instanceof Float32Array?Iu.FLOAT:e instanceof Float64Array?Iu.DOUBLE:void 0},validate:function(e){return Ue(e)&&(e===Iu.BYTE||e===Iu.UNSIGNED_BYTE||e===Iu.SHORT||e===Iu.UNSIGNED_SHORT||e===Iu.INT||e===Iu.UNSIGNED_INT||e===Iu.FLOAT||e===Iu.DOUBLE)},createTypedArray:function(e,t){switch(e){case Iu.BYTE:return new Int8Array(t);case Iu.UNSIGNED_BYTE:return new Uint8Array(t);case Iu.SHORT:return new Int16Array(t);case Iu.UNSIGNED_SHORT:return new Uint16Array(t);case Iu.INT:return new Int32Array(t);case Iu.UNSIGNED_INT:return new Uint32Array(t);case Iu.FLOAT:return new Float32Array(t);case Iu.DOUBLE:return new Float64Array(t)}},createArrayBufferView:function(e,t,n,r){switch(n=Pe(n,0),r=Pe(r,(t.byteLength-n)/Iu.getSizeInBytes(e)),e){case Iu.BYTE:return new Int8Array(t,n,r);case Iu.UNSIGNED_BYTE:return new Uint8Array(t,n,r);case Iu.SHORT:return new Int16Array(t,n,r);case Iu.UNSIGNED_SHORT:return new Uint16Array(t,n,r);case Iu.INT:return new Int32Array(t,n,r);case Iu.UNSIGNED_INT:return new Uint32Array(t,n,r);case Iu.FLOAT:return new Float32Array(t,n,r);case Iu.DOUBLE:return new Float64Array(t,n,r)}},fromName:function(e){switch(e){case"BYTE":return Iu.BYTE;case"UNSIGNED_BYTE":return Iu.UNSIGNED_BYTE;case"SHORT":return Iu.SHORT;case"UNSIGNED_SHORT":return Iu.UNSIGNED_SHORT;case"INT":return Iu.INT;case"UNSIGNED_INT":return Iu.UNSIGNED_INT;case"FLOAT":return Iu.FLOAT;case"DOUBLE":return Iu.DOUBLE}}},Mu=Object.freeze(Iu),Ou={NONE:0,BITS12:1},Nu=Object.freeze(Ou),xu=new De,vu=new De,Uu=new mt,Pu=new Fe,Cu=new Fe,Du=Math.pow(2,12);function bu(e,t,n,r,i,a){var o,s,u,c,l,f=Nu.NONE;Ue(e)&&Ue(t)&&Ue(n)&&Ue(r)&&(c=e.minimum,s=e.maximum,l=De.subtract(s,c,vu),u=n-t,f=Math.max(De.maximumComponent(l),u)<Du-1?Nu.BITS12:Nu.NONE,o=e.center,s=Fe.inverseTransformation(r,new Fe),u=De.negate(c,xu),Fe.multiply(Fe.fromTranslation(u,Pu),s,s),(u=xu).x=1/l.x,u.y=1/l.y,u.z=1/l.z,Fe.multiply(Fe.fromScale(u,Pu),s,s),u=Fe.clone(r),Fe.setTranslation(u,De.ZERO,u),r=Fe.clone(r,new Fe),c=Fe.fromTranslation(c,Pu),l=Fe.fromScale(l,Cu),l=Fe.multiply(c,l,Pu),Fe.multiply(r,l,r),Fe.multiply(u,l,u)),this.quantization=f,this.minimumHeight=t,this.maximumHeight=n,this.center=o,this.toScaledENU=s,this.fromScaledENU=r,this.matrix=u,this.hasVertexNormals=i,this.hasWebMercatorT=Pe(a,!1)}bu.prototype.encode=function(e,t,n,r,i,a,o){var s,u,c=r.x,l=r.y;return this.quantization===Nu.BITS12?((n=Fe.multiplyByPoint(this.toScaledENU,n,xu)).x=Ce.clamp(n.x,0,1),n.y=Ce.clamp(n.y,0,1),n.z=Ce.clamp(n.z,0,1),s=this.maximumHeight-this.minimumHeight,u=Ce.clamp((i-this.minimumHeight)/s,0,1),mt.fromElements(n.x,n.y,Uu),r=yu.compressTextureCoordinates(Uu),mt.fromElements(n.z,u,Uu),s=yu.compressTextureCoordinates(Uu),mt.fromElements(c,l,Uu),u=yu.compressTextureCoordinates(Uu),e[t++]=r,e[t++]=s,e[t++]=u,this.hasWebMercatorT&&(mt.fromElements(o,0,Uu),u=yu.compressTextureCoordinates(Uu),e[t++]=u)):(De.subtract(n,this.center,xu),e[t++]=xu.x,e[t++]=xu.y,e[t++]=xu.z,e[t++]=i,e[t++]=c,e[t++]=l,this.hasWebMercatorT&&(e[t++]=o)),this.hasVertexNormals&&(e[t++]=yu.octPackFloat(a)),t},bu.prototype.decodePosition=function(e,t,n){if(Ue(n)||(n=new De),t*=this.getStride(),this.quantization!==Nu.BITS12)return n.x=e[t],n.y=e[t+1],n.z=e[t+2],De.add(n,this.center,n);var r=yu.decompressTextureCoordinates(e[t],Uu);n.x=r.x,n.y=r.y;t=yu.decompressTextureCoordinates(e[t+1],Uu);return n.z=t.x,Fe.multiplyByPoint(this.fromScaledENU,n,n)},bu.prototype.decodeTextureCoordinates=function(e,t,n){return Ue(n)||(n=new mt),t*=this.getStride(),this.quantization===Nu.BITS12?yu.decompressTextureCoordinates(e[t+2],n):mt.fromElements(e[t+4],e[t+5],n)},bu.prototype.decodeHeight=function(e,t){return t*=this.getStride(),this.quantization!==Nu.BITS12?e[t+3]:yu.decompressTextureCoordinates(e[t+1],Uu).y*(this.maximumHeight-this.minimumHeight)+this.minimumHeight},bu.prototype.decodeWebMercatorT=function(e,t){return t*=this.getStride(),this.quantization===Nu.BITS12?yu.decompressTextureCoordinates(e[t+3],Uu).x:e[t+6]},bu.prototype.getOctEncodedNormal=function(e,t,n){e=e[t=(t+1)*this.getStride()-1]/256,t=Math.floor(e),e=256*(e-t);return mt.fromElements(t,e,n)},bu.prototype.getStride=function(){var e=this.quantization===Nu.BITS12?3:6;return this.hasWebMercatorT&&++e,this.hasVertexNormals&&++e,e};var Lu={position3DAndHeight:0,textureCoordAndEncodedNormals:1},Fu={compressed0:0,compressed1:1};function Bu(e){this._ellipsoid=Pe(e,be.WGS84),this._semimajorAxis=this._ellipsoid.maximumRadius,this._oneOverSemimajorAxis=1/this._semimajorAxis}bu.prototype.getAttributes=function(e){var t,n=Mu.FLOAT,r=Mu.getSizeInBytes(n);if(this.quantization===Nu.NONE){var i=2;return this.hasWebMercatorT&&++i,this.hasVertexNormals&&++i,t=(4+i)*r,[{index:Lu.position3DAndHeight,vertexBuffer:e,componentDatatype:n,componentsPerAttribute:4,offsetInBytes:0,strideInBytes:t},{index:Lu.textureCoordAndEncodedNormals,vertexBuffer:e,componentDatatype:n,componentsPerAttribute:i,offsetInBytes:4*r,strideInBytes:t}]}var a=3,i=0;return(this.hasWebMercatorT||this.hasVertexNormals)&&++a,this.hasWebMercatorT&&this.hasVertexNormals?(++i,t=(a+1)*r,[{index:Fu.compressed0,vertexBuffer:e,componentDatatype:n,componentsPerAttribute:a,offsetInBytes:0,strideInBytes:t},{index:Fu.compressed1,vertexBuffer:e,componentDatatype:n,componentsPerAttribute:1,offsetInBytes:a*r,strideInBytes:t}]):[{index:Fu.compressed0,vertexBuffer:e,componentDatatype:n,componentsPerAttribute:a}]},bu.prototype.getAttributeLocations=function(){return this.quantization===Nu.NONE?Lu:Fu},bu.clone=function(e,t){return(t=!Ue(t)?new bu:t).quantization=e.quantization,t.minimumHeight=e.minimumHeight,t.maximumHeight=e.maximumHeight,t.center=De.clone(e.center),t.toScaledENU=Fe.clone(e.toScaledENU),t.fromScaledENU=Fe.clone(e.fromScaledENU),t.matrix=Fe.clone(e.matrix),t.hasVertexNormals=e.hasVertexNormals,t.hasWebMercatorT=e.hasWebMercatorT,t},Object.defineProperties(Bu.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}}),Bu.mercatorAngleToGeodeticLatitude=function(e){return Ce.PI_OVER_TWO-2*Math.atan(Math.exp(-e))},Bu.geodeticLatitudeToMercatorAngle=function(e){e>Bu.MaximumLatitude?e=Bu.MaximumLatitude:e<-Bu.MaximumLatitude&&(e=-Bu.MaximumLatitude);e=Math.sin(e);return.5*Math.log((1+e)/(1-e))},Bu.MaximumLatitude=Bu.mercatorAngleToGeodeticLatitude(Math.PI),Bu.prototype.project=function(e,t){var n=this._semimajorAxis,r=e.longitude*n,n=Bu.geodeticLatitudeToMercatorAngle(e.latitude)*n,e=e.height;return Ue(t)?(t.x=r,t.y=n,t.z=e,t):new De(r,n,e)},Bu.prototype.unproject=function(e,t){var n=this._oneOverSemimajorAxis,r=e.x*n,n=Bu.mercatorAngleToGeodeticLatitude(e.y*n),e=e.z;return Ue(t)?(t.longitude=r,t.latitude=n,t.height=e,t):new R(r,n,e)};var zu={};zu.DEFAULT_STRUCTURE=Object.freeze({heightScale:1,heightOffset:0,elementsPerHeight:1,stride:1,elementMultiplier:256,isBigEndian:!1});var qu=new De,Vu=new Fe,ku=new De,Gu=new De;zu.computeVertices=function(e){var t,n,r,i=Math.cos,a=Math.sin,o=Math.sqrt,s=Math.atan,u=Math.exp,c=Ce.PI_OVER_TWO,l=Ce.toRadians,f=e.heightmap,h=e.width,d=e.height,m=e.skirtHeight,p=Pe(e.isGeographic,!0),E=Pe(e.ellipsoid,be.WGS84),y=1/E.maximumRadius,_=e.nativeRectangle,T=e.rectangle,R=Ue(T)?(t=T.west,n=T.south,r=T.east,T.north):p?(t=l(_.west),n=l(_.south),r=l(_.east),l(_.north)):(t=_.west*y,n=c-2*s(u(-_.south*y)),r=_.east*y,c-2*s(u(-_.north*y))),A=Ue(g=e.relativeToCenter),g=A?g:De.ZERO,S=Pe(e.exaggeration,1),w=Pe(e.includeWebMercatorT,!1),I=Pe(e.structure,zu.DEFAULT_STRUCTURE),M=Pe(I.heightScale,zu.DEFAULT_STRUCTURE.heightScale),O=Pe(I.heightOffset,zu.DEFAULT_STRUCTURE.heightOffset),N=Pe(I.elementsPerHeight,zu.DEFAULT_STRUCTURE.elementsPerHeight),x=Pe(I.stride,zu.DEFAULT_STRUCTURE.stride),v=Pe(I.elementMultiplier,zu.DEFAULT_STRUCTURE.elementMultiplier),U=Pe(I.isBigEndian,zu.DEFAULT_STRUCTURE.isBigEndian),P=Be.computeWidth(_),C=Be.computeHeight(_),D=P/(h-1),b=C/(d-1);p||(P*=y,C*=y);var L,F,e=E.radiiSquared,B=e.x,z=e.y,q=e.z,V=65536,k=-65536,I=No.eastNorthUpToFixedFrame(g,E),G=Fe.inverseTransformation(I,Vu);w&&(L=Bu.geodeticLatitudeToMercatorAngle(n),F=1/(Bu.geodeticLatitudeToMercatorAngle(R)-L));var X=ku;X.x=Number.POSITIVE_INFINITY,X.y=Number.POSITIVE_INFINITY,X.z=Number.POSITIVE_INFINITY;var W=Gu;W.x=Number.NEGATIVE_INFINITY,W.y=Number.NEGATIVE_INFINITY,W.z=Number.NEGATIVE_INFINITY;var H=Number.POSITIVE_INFINITY,Y=h*d,j=Y+(0<m?2*h+2*d:0),Z=new Array(j),K=new Array(j),J=new Array(j),Q=w?new Array(j):[],$=0,ee=d,te=0,ne=h;0<m&&(--$,++ee,--te,++ne);for(var re=$;re<ee;++re){var ie=re;d<=(ie=ie<0?0:ie)&&(ie=d-1);var ae=_.north-b*ie,oe=((ae=p?l(ae):c-2*s(u(-ae*y)))-n)/(R-n),oe=Ce.clamp(oe,0,1),se=re===$,ue=re===ee-1;0<m&&(se?ae+=1e-5*C:ue&&(ae-=1e-5*C));var ce,le=i(ae),fe=a(ae),he=q*fe;w&&(ce=(Bu.geodeticLatitudeToMercatorAngle(ae)-L)*F);for(var de=te;de<ne;++de){var me=de,pe=ie*(h*x)+(me=h<=(me=me<0?0:me)?h-1:me)*x;if(1===N)ye=f[pe];else{var Ee,ye=0;if(U)for(Ee=0;Ee<N;++Ee)ye=ye*v+f[pe+Ee];else for(Ee=N-1;0<=Ee;--Ee)ye=ye*v+f[pe+Ee]}ye=(ye*M+O)*S,k=Math.max(k,ye),V=Math.min(V,ye);var _e=_.west+D*me;p?_e=l(_e):_e*=y;var Te=(_e-t)/(r-t),Te=Ce.clamp(Te,0,1),Re=ie*h+me;if(0<m){var Ae=de===te,ge=de===ne-1,Se=se||ue||Ae||ge;if((se||ue)&&(Ae||ge))continue;Se&&(ye-=m,Ae?(Re=d-ie-1+Y,_e-=1e-5*P):ue?Re=Y+d+(h-me-1):ge?(Re=Y+d+h+ie,_e+=1e-5*P):se&&(Re=Y+d+h+d+me))}var we=le*i(_e),Se=le*a(_e),Ae=B*we,ge=z*Se,me=1/o(Ae*we+ge*Se+he*fe),_e=Ae*me,Ae=ge*me,ge=he*me,me=new De;me.x=_e+we*ye,me.y=Ae+Se*ye,me.z=ge+fe*ye,Z[Re]=me,K[Re]=ye,J[Re]=new mt(Te,oe),w&&(Q[Re]=ce),Fe.multiplyByPoint(G,me,qu),De.minimumByComponent(qu,X,X),De.maximumByComponent(qu,W,W),H=Math.min(H,ye)}}var Ie,Me,e=ze.fromPoints(Z);Ue(T)&&(Ie=ws.fromRectangle(T,V,k,E)),A&&(Me=new Rt(E).computeHorizonCullingPointPossiblyUnderEllipsoid(g,Z,V));for(var Oe=new bu(new Le(X,W,g),H,k,I,!1,w),Ne=new Float32Array(j*Oe.getStride()),xe=0,ve=0;ve<j;++ve)xe=Oe.encode(Ne,xe,Z[ve],J[ve],K[ve],void 0,Q[ve]);return{vertices:Ne,maximumHeight:k,minimumHeight:V,encoding:Oe,boundingSphere3D:e,orientedBoundingBox:Ie,occludeePointInScaledSpace:Me}};var Xu={};!function(){var i,a,o,s,u,x,e,y=(i={defaultNoDataValue:-34027999387901484e22,decode:function(e,t){var n=(t=t||{}).encodedMaskData||null===t.encodedMaskData,r=u(e,t.inputOffset||0,n),e=null!==t.noDataValue?t.noDataValue:i.defaultNoDataValue,n=a(r,t.pixelType||Float32Array,t.encodedMaskData,e,t.returnMask),e={width:r.width,height:r.height,pixelData:n.resultPixels,minValue:n.minValue,maxValue:r.pixels.maxValue,noDataValue:e};return n.resultMask&&(e.maskData=n.resultMask),t.returnEncodedMask&&r.mask&&(e.encodedMaskData=r.mask.bitset||null),t.returnFileInfo&&(e.fileInfo=o(r),t.computeUsedBitDepths&&(e.fileInfo.bitDepths=s(r))),e}},a=function(e,t,n,r,i){var a,o,s,u=0,c=e.pixels.numBlocksX,l=e.pixels.numBlocksY,f=Math.floor(e.width/c),h=Math.floor(e.height/l),d=2*e.maxZError,m=Number.MAX_VALUE;n=n||(e.mask?e.mask.bitset:null),o=new t(e.width*e.height),i&&n&&(s=new Uint8Array(e.width*e.height));for(var p,E,y=new Float32Array(f*h),_=0;_<=l;_++){var T=_!==l?h:e.height%l;if(0!==T)for(var R=0;R<=c;R++){var A=R!==c?f:e.width%c;if(0!==A){var g,S,w,I,M=_*e.width*h+R*f,O=e.width-A,N=e.pixels.blocks[u];if(N.encoding<2?(g=0===N.encoding?N.rawData:(x(N.stuffedData,N.bitsPerPixel,N.numValidPixels,N.offset,d,y,e.pixels.maxValue),y),S=0):w=2===N.encoding?0:N.offset,n)for(E=0;E<T;E++){for(7&M&&(I=n[M>>3],I<<=7&M),p=0;p<A;p++)128&(I=!(7&M)?n[M>>3]:I)?(s&&(s[M]=1),m=(a=N.encoding<2?g[S++]:w)<m?a:m,o[M++]=a):(s&&(s[M]=0),o[M++]=r),I<<=1;M+=O}else if(N.encoding<2)for(E=0;E<T;E++){for(p=0;p<A;p++)m=(a=g[S++])<m?a:m,o[M++]=a;M+=O}else for(m=w<m?w:m,E=0;E<T;E++){for(p=0;p<A;p++)o[M++]=w;M+=O}if(1===N.encoding&&S!==N.numValidPixels)throw"Block and Mask do not match";u++}}}return{resultPixels:o,resultMask:s,minValue:m}},o=function(e){return{fileIdentifierString:e.fileIdentifierString,fileVersion:e.fileVersion,imageType:e.imageType,height:e.height,width:e.width,maxZError:e.maxZError,eofOffset:e.eofOffset,mask:e.mask?{numBlocksX:e.mask.numBlocksX,numBlocksY:e.mask.numBlocksY,numBytes:e.mask.numBytes,maxValue:e.mask.maxValue}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,numBytes:e.pixels.numBytes,maxValue:e.pixels.maxValue,noDataValue:e.noDataValue}}},s=function(e){for(var t=e.pixels.numBlocksX*e.pixels.numBlocksY,n={},r=0;r<t;r++){var i=e.pixels.blocks[r];0===i.encoding?n.float32=!0:1===i.encoding?n[i.bitsPerPixel]=!0:n[0]=!0}return Object.keys(n)},u=function(e,t,n){var r={},i=new Uint8Array(e,t,10);if(r.fileIdentifierString=String.fromCharCode.apply(null,i),"CntZImage"!==r.fileIdentifierString.trim())throw"Unexpected file identifier string: "+r.fileIdentifierString;t+=10;var a=new DataView(e,t,24);if(r.fileVersion=a.getInt32(0,!0),r.imageType=a.getInt32(4,!0),r.height=a.getUint32(8,!0),r.width=a.getUint32(12,!0),r.maxZError=a.getFloat64(16,!0),t+=24,!n)if(a=new DataView(e,t,16),r.mask={},r.mask.numBlocksY=a.getUint32(0,!0),r.mask.numBlocksX=a.getUint32(4,!0),r.mask.numBytes=a.getUint32(8,!0),r.mask.maxValue=a.getFloat32(12,!0),t+=16,0<r.mask.numBytes){var o=new Uint8Array(Math.ceil(r.width*r.height/8)),s=(a=new DataView(e,t,r.mask.numBytes)).getInt16(0,!0),u=2,c=0;do{if(0<s)for(;s--;)o[c++]=a.getUint8(u++);else for(var l=a.getUint8(u++),s=-s;s--;)o[c++]=l}while(s=a.getInt16(u,!0),(u+=2)<r.mask.numBytes);if(-32768!==s||c<o.length)throw"Unexpected end of mask RLE encoding";r.mask.bitset=o,t+=r.mask.numBytes}else 0==(r.mask.numBytes|r.mask.numBlocksY|r.mask.maxValue)&&(r.mask.bitset=new Uint8Array(Math.ceil(r.width*r.height/8)));a=new DataView(e,t,16),r.pixels={},r.pixels.numBlocksY=a.getUint32(0,!0),r.pixels.numBlocksX=a.getUint32(4,!0),r.pixels.numBytes=a.getUint32(8,!0),r.pixels.maxValue=a.getFloat32(12,!0),t+=16;var i=r.pixels.numBlocksX,n=r.pixels.numBlocksY,f=i+(0<r.width%i?1:0),h=n+(0<r.height%n?1:0);r.pixels.blocks=new Array(f*h);for(var d=0,m=0;m<h;m++)for(var p=0;p<f;p++){var E=0,y=e.byteLength-t;a=new DataView(e,t,Math.min(10,y));var _={};r.pixels.blocks[d++]=_;var T,y=a.getUint8(0);if(E++,_.encoding=63&y,3<_.encoding)throw"Invalid block encoding ("+_.encoding+")";if(2!==_.encoding){if(0!==y&&2!==y){if(y>>=6,2===(_.offsetType=y))_.offset=a.getInt8(1),E++;else if(1===y)_.offset=a.getInt16(1,!0),E+=2;else{if(0!==y)throw"Invalid block offset type";_.offset=a.getFloat32(1,!0),E+=4}if(1===_.encoding)if(y=a.getUint8(E),E++,_.bitsPerPixel=63&y,y>>=6,2===(_.numValidPixelsType=y))_.numValidPixels=a.getUint8(E),E++;else if(1===y)_.numValidPixels=a.getUint16(E,!0),E+=2;else{if(0!==y)throw"Invalid valid pixel count type";_.numValidPixels=a.getUint32(E,!0),E+=4}}if(t+=E,3!==_.encoding)if(0===_.encoding){var R=(r.pixels.numBytes-1)/4;if(R!==Math.floor(R))throw"uncompressed block has invalid length";T=new ArrayBuffer(4*R),new Uint8Array(T).set(new Uint8Array(e,t,4*R));var A=new Float32Array(T);_.rawData=A,t+=4*R}else 1===_.encoding&&(A=Math.ceil(_.numValidPixels*_.bitsPerPixel/8),R=Math.ceil(A/4),T=new ArrayBuffer(4*R),new Uint8Array(T).set(new Uint8Array(e,t,A)),_.stuffedData=new Uint32Array(T),t+=A)}else t++}return r.eofOffset=t,r},x=function(e,t,n,r,i,a,o){var s,u,c,l,f=(1<<t)-1,h=0,d=0,m=Math.ceil((o-r)/i),p=4*e.length-Math.ceil(t*n/8);for(e[e.length-1]<<=8*p,s=0;s<n;s++)0===d&&(l=e[h++],d=32),t<=d?(c=l>>>d-t&f,d-=t):(c=(l&f)<<(u=t-d)&f,c+=(l=e[h++])>>>(d=32-u)),a[s]=c<m?r+c*i:o;return a},i),_=function(){var R=function(e,t,n,r,i,a,o,s){var u,c,l,f,h,d=(1<<n)-1,m=0,p=0,E=4*e.length-Math.ceil(n*r/8);if(e[e.length-1]<<=8*E,i)for(u=0;u<r;u++)0===p&&(l=e[m++],p=32),n<=p?(c=l>>>p-n&d,p-=n):(c=(l&d)<<(f=n-p)&d,c+=(l=e[m++])>>>(p=32-f)),t[u]=i[c];else for(h=Math.ceil((s-a)/o),u=0;u<r;u++)0===p&&(l=e[m++],p=32),n<=p?(c=l>>>p-n&d,p-=n):(c=(l&d)<<(f=n-p)&d,c+=(l=e[m++])>>>(p=32-f)),t[u]=c<h?a+c*o:s},A=function(e,t,n,r,i,a){var o,s,u=(1<<t)-1,c=0,l=0,f=0,h=0,d=[],m=4*e.length-Math.ceil(t*n/8);e[e.length-1]<<=8*m;for(var p=Math.ceil((a-r)/i),l=0;l<n;l++)0===f&&(s=e[c++],f=32),t<=f?(h=s>>>f-t&u,f-=t):(h=(s&u)<<(o=t-f)&u,h+=(s=e[c++])>>>(f=32-o)),d[l]=h<p?r+h*i:a;return d.unshift(r),d},g=function(e,t,n,r,i,a,o,s){var u,c,l,f=(1<<n)-1,h=0,d=0,m=0;if(i)for(E=0;E<r;E++)0===d&&(c=e[h++],d=32,m=0),n<=d?(u=c>>>m&f,d-=n,m+=n):(u=c>>>m&f,d=32-(l=n-d),u|=((c=e[h++])&(1<<l)-1)<<n-l,m=l),t[E]=i[u];else for(var p=Math.ceil((s-a)/o),E=0;E<r;E++)0===d&&(c=e[h++],d=32,m=0),n<=d?(u=c>>>m&f,d-=n,m+=n):(u=c>>>m&f,d=32-(l=n-d),u|=((c=e[h++])&(1<<l)-1)<<n-l,m=l),t[E]=u<p?a+u*o:s;return t},S=function(e,t,n,r,i,a){for(var o,s,u=(1<<t)-1,c=0,l=0,f=0,h=0,d=0,m=[],p=Math.ceil((a-r)/i),l=0;l<n;l++)0===f&&(s=e[c++],f=32,d=0),t<=f?(h=s>>>d&u,f-=t,d+=t):(h=s>>>d&u,f=32-(o=t-f),h|=((s=e[c++])&(1<<o)-1)<<t-o,d=o),m[l]=h<p?r+h*i:a;return m.unshift(r),m},w=function(e,t,n,r){var i,a,o,s,u=(1<<n)-1,c=0,l=0,f=4*e.length-Math.ceil(n*r/8);for(e[e.length-1]<<=8*f,i=0;i<r;i++)0===l&&(o=e[c++],l=32),n<=l?(a=o>>>l-n&u,l-=n):(a=(o&u)<<(s=n-l)&u,a+=(o=e[c++])>>>(l=32-s)),t[i]=a;return t},I=function(e,t,n,r){for(var i,a,o,s=(1<<n)-1,u=0,c=0,l=0,f=0;f<r;f++)0===c&&(a=e[u++],c=32,l=0),n<=c?(i=a>>>l&s,c-=n,l+=n):(i=a>>>l&s,c=32-(o=n-c),i|=((a=e[u++])&(1<<o)-1)<<n-o,l=o),t[f]=i;return t},z={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(e){for(var t=65535,n=65535,r=e.length,i=Math.floor(r/2),a=0;i;){var o=359<=i?359:i;for(i-=o;t+=e[a++]<<8,n+=t+=e[a++],--o;);t=(65535&t)+(t>>>16),n=(65535&n)+(n>>>16)}return 1&r&&(n+=t+=e[a]<<8),((n=(65535&n)+(n>>>16))<<16|(t=(65535&t)+(t>>>16)))>>>0},readHeaderInfo:function(e,t){var n=t.ptr,r=new Uint8Array(e,n,6),i={};if(i.fileIdentifierString=String.fromCharCode.apply(null,r),0!==i.fileIdentifierString.lastIndexOf("Lerc2",0))throw"Unexpected file identifier string (expect Lerc2 ): "+i.fileIdentifierString;n+=6;var a=new DataView(e,n,8),r=a.getInt32(0,!0);if(i.fileVersion=r,n+=4,3<=r&&(i.checksum=a.getUint32(4,!0),n+=4),a=new DataView(e,n,12),i.height=a.getUint32(0,!0),i.width=a.getUint32(4,!0),n+=8,4<=r?(i.numDims=a.getUint32(8,!0),n+=4):i.numDims=1,a=new DataView(e,n,40),i.numValidPixel=a.getUint32(0,!0),i.microBlockSize=a.getInt32(4,!0),i.blobSize=a.getInt32(8,!0),i.imageType=a.getInt32(12,!0),i.maxZError=a.getFloat64(16,!0),i.zMin=a.getFloat64(24,!0),i.zMax=a.getFloat64(32,!0),n+=40,t.headerInfo=i,t.ptr=n,3<=r&&(r=4<=r?52:48,this.computeChecksumFletcher32(new Uint8Array(e,n-r,i.blobSize-14))!==i.checksum))throw"Checksum failed.";return!0},checkMinMaxRanges:function(e,t){var n=t.headerInfo,r=this.getDataTypeArray(n.imageType),i=n.numDims*this.getDataTypeSize(n.imageType),a=this.readSubArray(e,t.ptr,r,i),o=this.readSubArray(e,t.ptr+i,r,i);t.ptr+=2*i;for(var s=!0,u=0;u<n.numDims;u++)if(a[u]!==o[u]){s=!1;break}return n.minValues=a,n.maxValues=o,s},readSubArray:function(e,t,n,r){var i=n===Uint8Array?new Uint8Array(e,t,r):(i=new ArrayBuffer(r),new Uint8Array(i).set(new Uint8Array(e,t,r)),new n(i));return i},readMask:function(e,t){var n,r,i=t.ptr,a=t.headerInfo,o=a.width*a.height,a=a.numValidPixel,s=new DataView(e,i,4),u={};if(u.numBytes=s.getUint32(0,!0),i+=4,(0===a||o===a)&&0!==u.numBytes)throw"invalid mask";if(0===a)n=new Uint8Array(Math.ceil(o/8)),u.bitset=n,r=new Uint8Array(o),t.pixels.resultMask=r,i+=u.numBytes;else if(0<u.numBytes){n=new Uint8Array(Math.ceil(o/8));var c,l=(s=new DataView(e,i,u.numBytes)).getInt16(0,!0),f=2,h=0;do{if(0<l)for(;l--;)n[h++]=s.getUint8(f++);else for(c=s.getUint8(f++),l=-l;l--;)n[h++]=c}while(l=s.getInt16(f,!0),(f+=2)<u.numBytes);if(-32768!==l||h<n.length)throw"Unexpected end of mask RLE encoding";r=new Uint8Array(o);for(var d=0,m=0,m=0;m<o;m++)7&m?(d=n[m>>3],d<<=7&m):d=n[m>>3],128&d&&(r[m]=1);t.pixels.resultMask=r,u.bitset=n,i+=u.numBytes}return t.ptr=i,t.mask=u,!0},readDataOneSweep:function(e,t,n){var r=t.ptr,i=t.headerInfo,a=i.numDims,o=i.width*i.height,s=i.imageType,i=i.numValidPixel*z.getDataTypeSize(s)*a,u=t.pixels.resultMask,c=n===Uint8Array?new Uint8Array(e,r,i):(s=new ArrayBuffer(i),new Uint8Array(s).set(new Uint8Array(e,r,i)),new n(s));if(c.length===o*a)t.pixels.resultPixels=c;else{t.pixels.resultPixels=new n(o*a);var l,f=0,h=0,d=0;if(1<a)for(d=0;d<a;d++)for(l=d*o,h=0;h<o;h++)u[h]&&(t.pixels.resultPixels[l+h]=c[f++]);else for(h=0;h<o;h++)u[h]&&(t.pixels.resultPixels[h]=c[f++])}return r+=i,t.ptr=r,!0},readHuffmanTree:function(e,t){var n=this.HUFFMAN_LUT_BITS_MAX,r=new DataView(e,t.ptr,16);if(t.ptr+=16,r.getInt32(0,!0)<2)throw"unsupported Huffman version";var i=r.getInt32(4,!0),a=r.getInt32(8,!0),o=r.getInt32(12,!0);if(o<=a)return!1;var s=new Uint32Array(o-a);z.decodeBits(e,t,s);for(var u,c,l,f=[],h=a;h<o;h++)f[u=h-(h<i?0:i)]={first:s[h-a],second:null};var d=e.byteLength-t.ptr,r=Math.ceil(d/4),r=new ArrayBuffer(4*r);new Uint8Array(r).set(new Uint8Array(e,t.ptr,d));var m=new Uint32Array(r),p=0,E=0,y=m[0];for(h=a;h<o;h++)0<(l=f[u=h-(h<i?0:i)].first)&&(f[u].second=y<<p>>>32-l,l<=32-p?32===(p+=l)&&(p=0,y=m[++E]):(p+=l-32,y=m[++E],f[u].second|=y>>>32-p));var _=0,T=0,R=new O;for(h=0;h<f.length;h++)void 0!==f[h]&&(_=Math.max(_,f[h].first));T=n<=_?n:_,30<=_&&console.log("WARning, large NUM LUT BITS IS "+_);var A,g,S,w,I,M=[];for(h=a;h<o;h++)if(0<(l=f[u=h-(h<i?0:i)].first))if(A=[l,u],l<=T)for(g=f[u].second<<T-l,S=1<<T-l,c=0;c<S;c++)M[g|c]=A;else for(g=f[u].second,I=R,w=l-1;0<=w;w--)I=g>>>w&1?(I.right||(I.right=new O),I.right):(I.left||(I.left=new O),I.left),0!==w||I.val||(I.val=A[1]);return{decodeLut:M,numBitsLUTQick:T,numBitsLUT:_,tree:R,stuffedData:m,srcPtr:E,bitPos:p}},readHuffman:function(e,t,n){var r,i,a,o,s,u,c,l,f,h=t.headerInfo,d=h.numDims,m=t.headerInfo.height,p=t.headerInfo.width,E=p*m,e=this.readHuffmanTree(e,t),y=e.decodeLut,_=e.tree,T=e.stuffedData,R=e.srcPtr,A=e.bitPos,g=e.numBitsLUTQick,S=e.numBitsLUT,w=0===t.headerInfo.imageType?128:0,I=t.pixels.resultMask,M=0;0<A&&(R++,A=0);for(var O=T[R],N=1===t.encodeMode,x=new n(E*d),v=x,U=0;U<h.numDims;U++){if(1<d&&(v=new n(x.buffer,E*U,E),M=0),t.headerInfo.numValidPixel===p*m)for(u=l=0;u<m;u++)for(c=0;c<p;c++,l++){if(i=0,s=o=O<<A>>>32-g,y[s=32-A<g?o|=T[R+1]>>>64-A-g:s])i=y[s][1],A+=y[s][0];else for(s=o=O<<A>>>32-S,32-A<S&&(s=o|=T[R+1]>>>64-A-S),r=_,f=0;f<S;f++)if(!(r=o>>>S-f-1&1?r.right:r.left).left&&!r.right){i=r.val,A=A+f+1;break}32<=A&&(A-=32,O=T[++R]),a=i-w,N?(a+=!(0<c)&&0<u?v[l-p]:M,a&=255,M=v[l]=a):v[l]=a}else for(u=l=0;u<m;u++)for(c=0;c<p;c++,l++)if(I[l]){if(i=0,s=o=O<<A>>>32-g,y[s=32-A<g?o|=T[R+1]>>>64-A-g:s])i=y[s][1],A+=y[s][0];else for(s=o=O<<A>>>32-S,32-A<S&&(s=o|=T[R+1]>>>64-A-S),r=_,f=0;f<S;f++)if(!(r=o>>>S-f-1&1?r.right:r.left).left&&!r.right){i=r.val,A=A+f+1;break}32<=A&&(A-=32,O=T[++R]),a=i-w,N?(!(0<c&&I[l-1])&&0<u&&I[l-p]?a+=v[l-p]:a+=M,a&=255,M=v[l]=a):v[l]=a}t.ptr=t.ptr+4*(R+1)+(0<A?4:0)}t.pixels.resultPixels=x},decodeBits:function(e,t,n,r,i){var a=t.headerInfo,o=a.fileVersion,s=0,u=5<=e.byteLength-t.ptr?5:e.byteLength-t.ptr,c=new DataView(e,t.ptr,u),l=c.getUint8(0);s++;var f=l>>6,h=0==f?4:3-f,u=0<(32&l),f=31&l,l=0;if(1==h)l=c.getUint8(s),s++;else if(2==h)l=c.getUint16(s,!0),s+=2;else{if(4!=h)throw"Invalid valid pixel count type";l=c.getUint32(s,!0),s+=4}var d,m,p,E,y,_,T,h=2*a.maxZError,a=1<a.numDims?a.maxValues[i]:a.zMax;if(u){for(t.counter.lut++,_=c.getUint8(s),s++,E=Math.ceil((_-1)*f/8),y=Math.ceil(E/4),m=new ArrayBuffer(4*y),p=new Uint8Array(m),t.ptr+=s,p.set(new Uint8Array(e,t.ptr,E)),c=new Uint32Array(m),t.ptr+=E,T=0;_-1>>>T;)T++;E=Math.ceil(l*T/8),y=Math.ceil(E/4),m=new ArrayBuffer(4*y),(p=new Uint8Array(m)).set(new Uint8Array(e,t.ptr,E)),d=new Uint32Array(m),t.ptr+=E,c=(3<=o?S:A)(c,f,_-1,r,h,a),(3<=o?g:R)(d,n,T,l,c)}else t.counter.bitstuffer++,T=f,t.ptr+=s,0<T&&(E=Math.ceil(l*T/8),y=Math.ceil(E/4),m=new ArrayBuffer(4*y),(p=new Uint8Array(m)).set(new Uint8Array(e,t.ptr,E)),d=new Uint32Array(m),t.ptr+=E,3<=o?null===r?I(d,n,T,l):g(d,n,T,l,!1,r,h,a):null===r?w(d,n,T,l):R(d,n,T,l,!1,r,h,a))},readTiles:function(e,t,n){var r=t.headerInfo,i=r.width,a=r.height,o=r.microBlockSize,s=r.imageType,u=z.getDataTypeSize(s),c=Math.ceil(i/o),l=Math.ceil(a/o);t.pixels.numBlocksY=l,t.pixels.numBlocksX=c;for(var f,h,d,m,p,E,y,_,T,R,A,g,S,w,I=t.pixels.ptr=0,M=0,O=0,N=0,x=0,v=0,U=0,P=0,C=new n(o*o),D=a%o||o,b=i%o||o,L=r.numDims,F=t.pixels.resultMask,B=t.pixels.resultPixels,O=0;O<l;O++)for(f=O!==l-1?o:D,N=0;N<c;N++)for(x=O*i*o+N*o,E=i-(h=N!==c-1?o:b),w=0;w<L;w++){if(1<L&&(B=new n(t.pixels.resultPixels.buffer,i*a*w*u,i*a)),d=e.byteLength-t.ptr,T={},P=0,P++,p=(m=(_=new DataView(e,t.ptr,Math.min(10,d))).getUint8(0))>>6&255,(m>>2&15)!=(N*o>>3&15))throw"integrity issue";if(3<(A=3&m))throw t.ptr+=P,"Invalid block encoding ("+A+")";if(2!=A)if(0==A){if(t.counter.uncompressed++,t.ptr+=P,v=(v=f*h*u)<(y=e.byteLength-t.ptr)?v:y,g=new ArrayBuffer(v%u==0?v:v+u-v%u),new Uint8Array(g).set(new Uint8Array(e,t.ptr,v)),R=new n(g),U=0,F)for(I=0;I<f;I++){for(M=0;M<h;M++)F[x]&&(B[x]=R[U++]),x++;x+=E}else for(I=0;I<f;I++){for(M=0;M<h;M++)B[x++]=R[U++];x+=E}t.ptr+=U*u}else if(g=z.getDataTypeUsed(s,p),S=z.getOnePixel(T,P,g,_),P+=z.getDataTypeSize(g),3==A)if(t.ptr+=P,t.counter.constantoffset++,F)for(I=0;I<f;I++){for(M=0;M<h;M++)F[x]&&(B[x]=S),x++;x+=E}else for(I=0;I<f;I++){for(M=0;M<h;M++)B[x++]=S;x+=E}else if(t.ptr+=P,z.decodeBits(e,t,C,S,w),P=0,F)for(I=0;I<f;I++){for(M=0;M<h;M++)F[x]&&(B[x]=C[P++]),x++;x+=E}else for(I=0;I<f;I++){for(M=0;M<h;M++)B[x++]=C[P++];x+=E}else t.counter.constant++,t.ptr+=P}},formatFileInfo:function(e){return{fileIdentifierString:e.headerInfo.fileIdentifierString,fileVersion:e.headerInfo.fileVersion,imageType:e.headerInfo.imageType,height:e.headerInfo.height,width:e.headerInfo.width,numValidPixel:e.headerInfo.numValidPixel,microBlockSize:e.headerInfo.microBlockSize,blobSize:e.headerInfo.blobSize,maxZError:e.headerInfo.maxZError,pixelType:z.getPixelType(e.headerInfo.imageType),eofOffset:e.eofOffset,mask:e.mask?{numBytes:e.mask.numBytes}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,maxValue:e.headerInfo.zMax,minValue:e.headerInfo.zMin,noDataValue:e.noDataValue}}},constructConstantSurface:function(e){var t,n=e.headerInfo.zMax,r=e.headerInfo.numDims,i=e.headerInfo.height*e.headerInfo.width,a=i*r,o=0,s=0,u=e.pixels.resultMask;if(u)if(1<r)for(o=0;o<r;o++)for(t=o*i,s=0;s<i;s++)u[s]&&(e.pixels.resultPixels[t+s]=n);else for(s=0;s<i;s++)u[s]&&(e.pixels.resultPixels[s]=n);else if(e.pixels.resultPixels.fill)e.pixels.resultPixels.fill(n);else for(s=0;s<a;s++)e.pixels.resultPixels[s]=n},getDataTypeArray:function(e){var t;switch(e){case 0:t=Int8Array;break;case 1:t=Uint8Array;break;case 2:t=Int16Array;break;case 3:t=Uint16Array;break;case 4:t=Int32Array;break;case 5:t=Uint32Array;break;case 6:t=Float32Array;break;case 7:t=Float64Array;break;default:t=Float32Array}return t},getPixelType:function(e){var t;switch(e){case 0:t="S8";break;case 1:t="U8";break;case 2:t="S16";break;case 3:t="U16";break;case 4:t="S32";break;case 5:t="U32";break;case 6:t="F32";break;case 7:t="F64";break;default:t="F32"}return t},isValidPixelValue:function(e,t){if(null===t)return!1;var n;switch(e){case 0:n=-128<=t&&t<=127;break;case 1:n=0<=t&&t<=255;break;case 2:n=-32768<=t&&t<=32767;break;case 3:n=0<=t&&t<=65536;break;case 4:n=-2147483648<=t&&t<=2147483647;break;case 5:n=0<=t&&t<=4294967296;break;case 6:n=-34027999387901484e22<=t&&t<=34027999387901484e22;break;case 7:n=5e-324<=t&&t<=17976931348623157e292;break;default:n=!1}return n},getDataTypeSize:function(e){var t=0;switch(e){case 0:case 1:t=1;break;case 2:case 3:t=2;break;case 4:case 5:case 6:t=4;break;case 7:t=8;break;default:t=e}return t},getDataTypeUsed:function(e,t){var n=e;switch(e){case 2:case 4:n=e-t;break;case 3:case 5:n=e-2*t;break;case 6:n=0===t?e:1===t?2:1;break;case 7:n=0===t?e:e-2*t+1;break;default:n=e}return n},getOnePixel:function(e,t,n,r){var i=0;switch(n){case 0:i=r.getInt8(t);break;case 1:i=r.getUint8(t);break;case 2:i=r.getInt16(t,!0);break;case 3:i=r.getUint16(t,!0);break;case 4:i=r.getInt32(t,!0);break;case 5:i=r.getUInt32(t,!0);break;case 6:i=r.getFloat32(t,!0);break;case 7:i=r.getFloat64(t,!0);break;default:throw"the decoder does not understand this pixel type"}return i}},O=function(e,t,n){this.val=e,this.left=t,this.right=n};return{decode:function(e,t){var n=(t=t||{}).noDataValue,r=0,i={};if(i.ptr=t.inputOffset||0,i.pixels={},z.readHeaderInfo(e,i)){var a=i.headerInfo,o=a.fileVersion,s=z.getDataTypeArray(a.imageType);z.readMask(e,i),a.numValidPixel===a.width*a.height||i.pixels.resultMask||(i.pixels.resultMask=t.maskData);var u,c=a.width*a.height;if(i.pixels.resultPixels=new s(c*a.numDims),i.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0},0!==a.numValidPixel)if(a.zMax===a.zMin)z.constructConstantSurface(i);else if(4<=o&&z.checkMinMaxRanges(e,i))z.constructConstantSurface(i);else{var l=new DataView(e,i.ptr,2),f=l.getUint8(0);if(i.ptr++,f)z.readDataOneSweep(e,i,s);else if(1<o&&a.imageType<=1&&Math.abs(a.maxZError-.5)<1e-5){l=l.getUint8(1);if(i.ptr++,2<(i.encodeMode=l)||o<4&&1<l)throw"Invalid Huffman flag "+l;l?z.readHuffman(e,i,s):z.readTiles(e,i,s)}else z.readTiles(e,i,s)}i.eofOffset=i.ptr,t.inputOffset?(u=i.headerInfo.blobSize+t.inputOffset-i.ptr,1<=Math.abs(u)&&(i.eofOffset=t.inputOffset+i.headerInfo.blobSize)):(u=i.headerInfo.blobSize-i.ptr,1<=Math.abs(u)&&(i.eofOffset=i.headerInfo.blobSize));var h={width:a.width,height:a.height,pixelData:i.pixels.resultPixels,minValue:a.zMin,maxValue:a.zMax,validPixelCount:a.numValidPixel,dimCount:a.numDims,dimStats:{minValues:a.minValues,maxValues:a.maxValues},maskData:i.pixels.resultMask};if(i.pixels.resultMask&&z.isValidPixelValue(a.imageType,n)){for(var d=i.pixels.resultMask,r=0;r<c;r++)d[r]||(h.pixelData[r]=n);h.noDataValue=n}return i.noDataValue=n,t.returnFileInfo&&(h.fileInfo=z.formatFileInfo(i)),h}},getBandCount:function(e){for(var t=0,n=0,r={ptr:0,pixels:{}};n<e.byteLength-58;)z.readHeaderInfo(e,r),n+=r.headerInfo.blobSize,t++,r.ptr=n;return t}}}(),T=(e=new ArrayBuffer(4),t=new Uint8Array(e),(new Uint32Array(e)[0]=1)===t[0]),t={decode:function(e,t){if(!T)throw"Big endian system is not supported.";var n,r,i=(t=t||{}).inputOffset||0,a=new Uint8Array(e,i,10),a=String.fromCharCode.apply(null,a);if("CntZImage"===a.trim())n=y,r=1;else{if("Lerc2"!==a.substring(0,5))throw"Unexpected file identifier string: "+a;n=_,r=2}for(var o,s,u,c,l,f,h=0,d=e.byteLength-10,m=[],p={width:0,height:0,pixels:[],pixelType:t.pixelType,mask:null,statistics:[]};i<d;){var E=n.decode(e,{inputOffset:i,encodedMaskData:o,maskData:u,returnMask:0===h,returnEncodedMask:0===h,returnFileInfo:!0,pixelType:t.pixelType||null,noDataValue:t.noDataValue||null}),i=E.fileInfo.eofOffset;0===h&&(o=E.encodedMaskData,u=E.maskData,p.width=E.width,p.height=E.height,p.dimCount=E.dimCount||1,p.pixelType=E.pixelType||E.fileInfo.pixelType,p.mask=E.maskData),1<r&&E.fileInfo.mask&&0<E.fileInfo.mask.numBytes&&m.push(E.maskData),h++,p.pixels.push(E.pixelData),p.statistics.push({minValue:E.minValue,maxValue:E.maxValue,noDataValue:E.noDataValue,dimStats:E.dimStats})}if(1<r&&1<m.length){for(f=p.width*p.height,p.bandMasks=m,(u=new Uint8Array(f)).set(m[0]),c=1;c<m.length;c++)for(s=m[c],l=0;l<f;l++)u[l]=u[l]&s[l];p.maskData=u}return p}};Xu.Lerc=t}();var Wu=Xu.Lerc;function Hu(e){var t=e.name,n=e.message,n=Ue(t)&&Ue(n)?t+": "+n:e.toString(),e=e.stack;return Ue(e)&&(n+="\\n"+e),n}function Yu(e,t,n){try{return e(t,n)}catch(e){return Pn.reject(e)}}function ju(i){var a;return function(e){var t=e.data,n=[],r={id:t.id,result:void 0,error:void 0};return Pn(Yu(i,t.parameters,n)).then(function(e){r.result=e}).otherwise(function(e){e instanceof Error?r.error={name:e.name,message:e.message,stack:e.stack}:r.error=e}).always(function(){Ue(a)||(a=Pe(self.webkitPostMessage,self.postMessage)),t.canTransferArrayBuffer||(n.length=0);try{a(r,n)}catch(e){r.result=void 0,r.error="postMessage failed with error: "+Hu(e)+"\\n  with responseMessage: "+JSON.stringify(r),a(r)}})}}function Zu(e,t){if(e.encoding===b.LERC){var n;try{n=Wu.decode(e.heightmap)}catch(e){throw new ue(e)}if(n.statistics[0].minValue===Number.MAX_VALUE)throw new ue("Invalid tile data");e.heightmap=n.pixels[0],e.width=n.width,e.height=n.height}e.ellipsoid=be.clone(e.ellipsoid),e.rectangle=Be.clone(e.rectangle);var r=zu.computeVertices(e),i=r.vertices;return t.push(i.buffer),{vertices:i.buffer,numberOfAttributes:r.encoding.getStride(),minimumHeight:r.minimumHeight,maximumHeight:r.maximumHeight,gridWidth:e.width,gridHeight:e.height,boundingSphere3D:r.boundingSphere3D,orientedBoundingBox:r.orientedBoundingBox,occludeePointInScaledSpace:r.occludeePointInScaledSpace,encoding:r.encoding,westIndicesSouthToNorth:r.westIndicesSouthToNorth,southIndicesEastToWest:r.southIndicesEastToWest,eastIndicesNorthToSouth:r.eastIndicesNorthToSouth,northIndicesWestToEast:r.northIndicesWestToEast}}var Ku=ju(Zu),cesiumWorkers={createVerticesFromHeightmap:Ku,createTaskProcessorWorker:ju};module.exports=cesiumWorkers;

  self.CESIUM_BASE_URL = "/";

self.cesiumWorkers = cesiumWorkers;

onmessage = function(event) {
  if (event.data.CESIUM_BASE_URL) {
    self.CESIUM_BASE_URL = event.data.CESIUM_BASE_URL;
  }
  if (event.data.XYS2006_samples) {
    self.XYS2006_samples = event.data.XYS2006_samples;
  }
  if (event.data.approximateTerrainHeights) {
    self.approximateTerrainHeights = event.data.approximateTerrainHeights;
  }
  if (event.data.location) {
    globalThis.location = event.data.location;
  }
  var data = event.data;

  var dd = data.workerModule.split(/\\//g);
  var wModule = dd[dd.length - 1];

  self.onmessage = cesiumWorkers[wModule];
};

  `;
        try {
            r = new Blob([i], {
                type: "application/javascript"
            })
        } catch {
            var a = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,
                o = new a;
            o.append(i), r = o.getBlob("application/javascript")
        }
        return new Worker(URL.createObjectURL(r))
    }();
    t.postMessage = p(t.webkitPostMessage, t.postMessage);
    var n = {
        loaderConfig: {
            paths: {
                Workers: Hn("Workers")
            },
            baseUrl: Hn.getCesiumBaseUrl().url
        },
        workerModule: Lt._workerModulePrefix + e._workerName
    };
    return t.postMessage(n), t.onmessage = function(r) {
        Ug(e, r.data)
    }, t
}

function AD(e, t) {
    var n = {
        modulePath: void 0,
        wasmBinaryFile: void 0,
        wasmBinary: void 0
    };
    if (!An.supportsWebAssembly()) {
        if (!l(t.fallbackModulePath)) throw new je("This browser does not support Web Assembly, and no backup module was provided for " + e._workerName);
        return n.modulePath = Hn(t.fallbackModulePath), he.resolve(n)
    }
    return n.modulePath = Hn(t.modulePath), n.wasmBinaryFile = Hn(t.wasmBinaryFile), J.fetchArrayBuffer({
        url: n.wasmBinaryFile
    }).then(function(r) {
        return n.wasmBinary = r, n
    })
}

function Lt(e, t) {
    this._workerName = e, this._maximumActiveTasks = p(t, 5), this._activeTasks = 0, this._deferreds = {}, this._nextID = 0
}
var CD = [];
Lt.prototype.scheduleTask = function(e, t) {
    if (l(this._worker) || (this._worker = zg(this)), !(this._activeTasks >= this._maximumActiveTasks)) {
        ++this._activeTasks;
        var n = this;
        return he(Lg(), function(r) {
            l(t) ? r || (t.length = 0) : t = CD;
            var i = n._nextID++,
                a = he.defer();
            return n._deferreds[i] = a, n._worker.postMessage({
                id: i,
                parameters: e,
                canTransferArrayBuffer: r
            }, t), a.promise
        })
    }
};
Lt.prototype.initWebAssemblyModule = function(e) {
    l(this._worker) || (this._worker = zg(this));
    var t = he.defer(),
        n = this,
        r = this._worker;
    return AD(this, e).then(function(i) {
        return he(Lg(), function(a) {
            var o, s = i.wasmBinary;
            l(s) && a && (o = [s]), r.onmessage = function(c) {
                r.onmessage = function(f) {
                    Ug(n, f.data)
                }, t.resolve(c.data)
            }, r.postMessage({
                webAssemblyConfig: i
            }, o)
        })
    }), t
};
Lt.prototype.isDestroyed = function() {
    return !1
};
Lt.prototype.destroy = function() {
    return l(this._worker) && this._worker.terminate(), Pe(this)
};
Lt.taskCompletedEvent = ml;
Lt._defaultWorkerModulePrefix = "Workers/";
Lt._workerModulePrefix = Lt._defaultWorkerModulePrefix;
Lt._canTransferArrayBuffer = void 0;

function xd(e, t, n, r, i, a, o, s, c, f, h, d, _, v, m, g, y) {
    this.center = e, this.vertices = t, this.stride = p(f, 6), this.indices = n, this.indexCountWithoutSkirts = r, this.vertexCountWithoutSkirts = i, this.minimumHeight = a, this.maximumHeight = o, this.boundingSphere3D = s, this.occludeePointInScaledSpace = c, this.orientedBoundingBox = h, this.encoding = d, this.exaggeration = _, this.westIndicesSouthToNorth = v, this.southIndicesEastToWest = m, this.eastIndicesNorthToSouth = g, this.northIndicesWestToEast = y
}

function Nt() {
    we.throwInstantiationError()
}
Object.defineProperties(Nt.prototype, {
    errorEvent: {
        get: we.throwInstantiationError
    },
    credit: {
        get: we.throwInstantiationError
    },
    tilingScheme: {
        get: we.throwInstantiationError
    },
    ready: {
        get: we.throwInstantiationError
    },
    readyPromise: {
        get: we.throwInstantiationError
    },
    hasWaterMask: {
        get: we.throwInstantiationError
    },
    hasVertexNormals: {
        get: we.throwInstantiationError
    },
    availability: {
        get: we.throwInstantiationError
    }
});
var dv = [];
Nt.getRegularGridIndices = function(e, t) {
    var n = dv[e];
    l(n) || (dv[e] = n = []);
    var r = n[t];
    return l(r) || (e * t < T.SIXTY_FOUR_KILOBYTES ? r = n[t] = new Uint16Array((e - 1) * (t - 1) * 6) : r = n[t] = new Uint32Array((e - 1) * (t - 1) * 6), Vg(e, t, r, 0)), r
};
var _v = [];
Nt.getRegularGridIndicesAndEdgeIndices = function(e, t) {
    var n = _v[e];
    l(n) || (_v[e] = n = []);
    var r = n[t];
    if (!l(r)) {
        var i = Nt.getRegularGridIndices(e, t),
            a = Bg(e, t),
            o = a.westIndicesSouthToNorth,
            s = a.southIndicesEastToWest,
            c = a.eastIndicesNorthToSouth,
            f = a.northIndicesWestToEast;
        r = n[t] = {
            indices: i,
            westIndicesSouthToNorth: o,
            southIndicesEastToWest: s,
            eastIndicesNorthToSouth: c,
            northIndicesWestToEast: f
        }
    }
    return r
};
var vv = [];
Nt.getRegularGridAndSkirtIndicesAndEdgeIndices = function(e, t) {
    var n = vv[e];
    l(n) || (vv[e] = n = []);
    var r = n[t];
    if (!l(r)) {
        var i = e * t,
            a = (e - 1) * (t - 1) * 6,
            o = e * 2 + t * 2,
            s = Math.max(0, o - 4) * 6,
            c = i + o,
            f = a + s,
            h = Bg(e, t),
            d = h.westIndicesSouthToNorth,
            _ = h.southIndicesEastToWest,
            v = h.eastIndicesNorthToSouth,
            m = h.northIndicesWestToEast,
            g = yt.createTypedArray(c, f);
        Vg(e, t, g, 0), Nt.addSkirtIndices(d, _, v, m, i, g, a), r = n[t] = {
            indices: g,
            westIndicesSouthToNorth: d,
            southIndicesEastToWest: _,
            eastIndicesNorthToSouth: v,
            northIndicesWestToEast: m,
            indexCountWithoutSkirts: a
        }
    }
    return r
};
Nt.addSkirtIndices = function(e, t, n, r, i, a, o) {
    var s = i;
    o = pu(e, s, a, o), s += e.length, o = pu(t, s, a, o), s += t.length, o = pu(n, s, a, o), s += n.length, pu(r, s, a, o)
};

function Bg(e, t) {
    var n = new Array(t),
        r = new Array(e),
        i = new Array(t),
        a = new Array(e),
        o;
    for (o = 0; o < e; ++o) a[o] = o, r[o] = e * t - 1 - o;
    for (o = 0; o < t; ++o) i[o] = (o + 1) * e - 1, n[o] = (t - o - 1) * e;
    return {
        westIndicesSouthToNorth: n,
        southIndicesEastToWest: r,
        eastIndicesNorthToSouth: i,
        northIndicesWestToEast: a
    }
}

function Vg(e, t, n, r) {
    for (var i = 0, a = 0; a < t - 1; ++a) {
        for (var o = 0; o < e - 1; ++o) {
            var s = i,
                c = s + e,
                f = c + 1,
                h = s + 1;
            n[r++] = s, n[r++] = c, n[r++] = h, n[r++] = h, n[r++] = c, n[r++] = f, ++i
        }++i
    }
}

function pu(e, t, n, r) {
    for (var i = e[0], a = e.length, o = 1; o < a; ++o) {
        var s = e[o];
        n[r++] = i, n[r++] = s, n[r++] = t, n[r++] = t, n[r++] = s, n[r++] = t + 1, i = s, ++t
    }
    return r
}
Nt.heightmapTerrainQuality = .25;
Nt.getEstimatedLevelZeroGeometricErrorForAHeightmap = function(e, t, n) {
    return e.maximumRadius * 2 * Math.PI * Nt.heightmapTerrainQuality / (t * n)
};
Nt.prototype.requestTileGeometry = we.throwInstantiationError;
Nt.prototype.getLevelMaximumGeometricError = we.throwInstantiationError;
Nt.prototype.getTileDataAvailable = we.throwInstantiationError;
Nt.prototype.loadTileDataAvailability = we.throwInstantiationError;

function oi(e) {
    this._buffer = e.buffer, this._width = e.width, this._height = e.height, this._childTileMask = p(e.childTileMask, 15), this._encoding = p(e.encoding, uv.NONE);
    var t = br.DEFAULT_STRUCTURE,
        n = e.structure;
    l(n) ? n !== t && (n.heightScale = p(n.heightScale, t.heightScale), n.heightOffset = p(n.heightOffset, t.heightOffset), n.elementsPerHeight = p(n.elementsPerHeight, t.elementsPerHeight), n.stride = p(n.stride, t.stride), n.elementMultiplier = p(n.elementMultiplier, t.elementMultiplier), n.isBigEndian = p(n.isBigEndian, t.isBigEndian)) : n = t, this._structure = n, this._createdByUpsampling = p(e.createdByUpsampling, !1), this._waterMask = e.waterMask, this._skirtHeight = void 0, this._bufferType = this._encoding === uv.LERC ? Float32Array : this._buffer.constructor, this._mesh = void 0
}
Object.defineProperties(oi.prototype, {
    credits: {
        get: function() {}
    },
    waterMask: {
        get: function() {
            return this._waterMask
        }
    },
    childTileMask: {
        get: function() {
            return this._childTileMask
        }
    }
});
var wD = new Lt("createVerticesFromHeightmap");
oi.prototype.createMesh = function(e, t, n, r, i) {
    var a = e.ellipsoid,
        o = e.tileXYToNativeRectangle(t, n, r),
        s = e.tileXYToRectangle(t, n, r);
    i = p(i, 1);
    var c = a.cartographicToCartesian(W.center(s)),
        f = this._structure,
        h = Nt.getEstimatedLevelZeroGeometricErrorForAHeightmap(a, this._width, e.getNumberOfXTilesAtLevel(0)),
        d = h / (1 << r);
    this._skirtHeight = Math.min(d * 4, 1e3);
    var _ = wD.scheduleTask({
        heightmap: this._buffer,
        structure: f,
        includeWebMercatorT: !0,
        width: this._width,
        height: this._height,
        nativeRectangle: o,
        rectangle: s,
        relativeToCenter: c,
        ellipsoid: a,
        skirtHeight: this._skirtHeight,
        isGeographic: e.projection instanceof un,
        exaggeration: i,
        encoding: this._encoding
    });
    if (!!l(_)) {
        var v = this;
        return he(_, function(m) {
            var g;
            v._skirtHeight > 0 ? g = Nt.getRegularGridAndSkirtIndicesAndEdgeIndices(m.gridWidth, m.gridHeight) : g = Nt.getRegularGridIndicesAndEdgeIndices(m.gridWidth, m.gridHeight);
            var y = m.gridWidth * m.gridHeight;
            return v._mesh = new xd(c, new Float32Array(m.vertices), g.indices, g.indexCountWithoutSkirts, y, m.minimumHeight, m.maximumHeight, q.clone(m.boundingSphere3D), u.clone(m.occludeePointInScaledSpace), m.numberOfAttributes, $e.clone(m.orientedBoundingBox), qn.clone(m.encoding), i, g.westIndicesSouthToNorth, g.southIndicesEastToWest, g.eastIndicesNorthToSouth, g.northIndicesWestToEast), v._buffer = void 0, v._mesh
        })
    }
};
oi.prototype._createMeshSync = function(e, t, n, r, i) {
    var a = e.ellipsoid,
        o = e.tileXYToNativeRectangle(t, n, r),
        s = e.tileXYToRectangle(t, n, r);
    i = p(i, 1);
    var c = a.cartographicToCartesian(W.center(s)),
        f = this._structure,
        h = Nt.getEstimatedLevelZeroGeometricErrorForAHeightmap(a, this._width, e.getNumberOfXTilesAtLevel(0)),
        d = h / (1 << r);
    this._skirtHeight = Math.min(d * 4, 1e3);
    var _ = br.computeVertices({
        heightmap: this._buffer,
        structure: f,
        includeWebMercatorT: !0,
        width: this._width,
        height: this._height,
        nativeRectangle: o,
        rectangle: s,
        relativeToCenter: c,
        ellipsoid: a,
        skirtHeight: this._skirtHeight,
        isGeographic: e.projection instanceof un,
        exaggeration: i
    });
    this._buffer = void 0;
    var v;
    this._skirtHeight > 0 ? v = Nt.getRegularGridAndSkirtIndicesAndEdgeIndices(this._width, this._height) : v = Nt.getRegularGridIndicesAndEdgeIndices(this._width, this._height);
    var m = _.gridWidth * _.gridHeight;
    return new xd(c, _.vertices, v.indices, v.indexCountWithoutSkirts, m, _.minimumHeight, _.maximumHeight, _.boundingSphere3D, _.occludeePointInScaledSpace, _.encoding.getStride(), _.orientedBoundingBox, _.encoding, i, v.westIndicesSouthToNorth, v.southIndicesEastToWest, v.eastIndicesNorthToSouth, v.northIndicesWestToEast)
};
oi.prototype.interpolateHeight = function(e, t, n) {
    var r = this._width,
        i = this._height,
        a = this._structure,
        o = a.stride,
        s = a.elementsPerHeight,
        c = a.elementMultiplier,
        f = a.isBigEndian,
        h = a.heightOffset,
        d = a.heightScale,
        _;
    if (l(this._mesh)) {
        var v = this._mesh.vertices,
            m = this._mesh.encoding,
            g = this._mesh.exaggeration;
        _ = Gg(v, m, h, d, e, r, i, t, n, g)
    } else _ = xD(this._buffer, s, c, o, f, e, r, i, t, n), _ = _ * d + h;
    return _
};
oi.prototype.upsample = function(e, t, n, r, i, a, o) {
    var s = this._mesh;
    if (!!l(s)) {
        for (var c = this._width, f = this._height, h = this._structure, d = h.stride, _ = new this._bufferType(c * f * d), v = s.vertices, m = s.encoding, g = e.tileXYToRectangle(t, n, r), y = e.tileXYToRectangle(i, a, o), E = h.heightOffset, w = h.heightScale, C = s.exaggeration, A = h.elementsPerHeight, x = h.elementMultiplier, P = h.isBigEndian, I = Math.pow(x, A - 1), D = 0; D < f; ++D)
            for (var O = T.lerp(y.north, y.south, D / (f - 1)), F = 0; F < c; ++F) {
                var z = T.lerp(y.west, y.east, F / (c - 1)),
                    b = Gg(v, m, E, w, g, c, f, z, O, C);
                b = b < h.lowestEncodedHeight ? h.lowestEncodedHeight : b, b = b > h.highestEncodedHeight ? h.highestEncodedHeight : b, SD(_, A, x, I, d, P, D * c + F, b)
            }
        return new oi({
            buffer: _,
            width: c,
            height: f,
            childTileMask: 0,
            structure: this._structure,
            createdByUpsampling: !0
        })
    }
};
oi.prototype.isChildAvailable = function(e, t, n, r) {
    var i = 2;
    return n !== e * 2 && ++i, r !== t * 2 && (i -= 2), (this._childTileMask & 1 << i) !== 0
};
oi.prototype.wasCreatedByUpsampling = function() {
    return this._createdByUpsampling
};

function xD(e, t, n, r, i, a, o, s, c, f) {
    var h = (c - a.west) * (o - 1) / (a.east - a.west),
        d = (f - a.south) * (s - 1) / (a.north - a.south),
        _ = h | 0,
        v = _ + 1;
    v >= o && (v = o - 1, _ = o - 2);
    var m = d | 0,
        g = m + 1;
    g >= s && (g = s - 1, m = s - 2);
    var y = h - _,
        E = d - m;
    m = s - 1 - m, g = s - 1 - g;
    var w = gu(e, t, n, r, i, m * o + _),
        C = gu(e, t, n, r, i, m * o + v),
        A = gu(e, t, n, r, i, g * o + _),
        x = gu(e, t, n, r, i, g * o + v);
    return Hg(y, E, w, C, A, x)
}

function Gg(e, t, n, r, i, a, o, s, c, f) {
    var h = (s - i.west) * (a - 1) / (i.east - i.west),
        d = (c - i.south) * (o - 1) / (i.north - i.south),
        _ = h | 0,
        v = _ + 1;
    v >= a && (v = a - 1, _ = a - 2);
    var m = d | 0,
        g = m + 1;
    g >= o && (g = o - 1, m = o - 2);
    var y = h - _,
        E = d - m;
    m = o - 1 - m, g = o - 1 - g;
    var w = (t.decodeHeight(e, m * a + _) / f - n) / r,
        C = (t.decodeHeight(e, m * a + v) / f - n) / r,
        A = (t.decodeHeight(e, g * a + _) / f - n) / r,
        x = (t.decodeHeight(e, g * a + v) / f - n) / r;
    return Hg(y, E, w, C, A, x)
}

function Hg(e, t, n, r, i, a) {
    return t < e ? n + e * (r - n) + t * (a - r) : n + e * (a - i) + t * (i - n)
}

function gu(e, t, n, r, i, a) {
    a *= r;
    var o = 0,
        s;
    if (i)
        for (s = 0; s < t; ++s) o = o * n + e[a + s];
    else
        for (s = t - 1; s >= 0; --s) o = o * n + e[a + s];
    return o
}

function SD(e, t, n, r, i, a, o, s) {
    o *= i;
    var c;
    if (a)
        for (c = 0; c < t - 1; ++c) e[o + c] = s / r | 0, s -= e[o + c] * r, r /= n;
    else
        for (c = t - 1; c > 0; --c) e[o + c] = s / r | 0, s -= e[o + c] * r, r /= n;
    e[o + c] = s
}

function No(e) {
    e = p(e, p.EMPTY_OBJECT), this._tilingScheme = e.tilingScheme, l(this._tilingScheme) || (this._tilingScheme = new ra({
        ellipsoid: p(e.ellipsoid, ne.WGS84)
    })), this._levelZeroMaximumGeometricError = Nt.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid, 64, this._tilingScheme.getNumberOfXTilesAtLevel(0)), this._errorEvent = new ht, this._readyPromise = he.resolve(!0)
}
Object.defineProperties(No.prototype, {
    errorEvent: {
        get: function() {
            return this._errorEvent
        }
    },
    credit: {
        get: function() {}
    },
    tilingScheme: {
        get: function() {
            return this._tilingScheme
        }
    },
    ready: {
        get: function() {
            return !0
        }
    },
    readyPromise: {
        get: function() {
            return this._readyPromise
        }
    },
    hasWaterMask: {
        get: function() {
            return !1
        }
    },
    hasVertexNormals: {
        get: function() {
            return !1
        }
    },
    availability: {
        get: function() {}
    }
});
No.prototype.requestTileGeometry = function(e, t, n, r) {
    var i = 16,
        a = 16;
    return he.resolve(new oi({
        buffer: new Uint8Array(i * a),
        width: i,
        height: a
    }))
};
No.prototype.getLevelMaximumGeometricError = function(e) {
    return this._levelZeroMaximumGeometricError / (1 << e)
};
No.prototype.getTileDataAvailable = function(e, t, n) {};
No.prototype.loadTileDataAvailability = function(e, t, n) {};
const RD = `uniform vec4 u_initialColor;
#if TEXTURE_UNITS > 0
uniform sampler2D u_dayTextures[TEXTURE_UNITS];
uniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];
uniform bool u_dayTextureUseWebMercatorT[TEXTURE_UNITS];
#ifdef APPLY_ALPHA
uniform float u_dayTextureAlpha[TEXTURE_UNITS];
#endif
#ifdef APPLY_DAY_NIGHT_ALPHA
uniform float u_dayTextureNightAlpha[TEXTURE_UNITS];
uniform float u_dayTextureDayAlpha[TEXTURE_UNITS];
#endif
#ifdef APPLY_SPLIT
uniform float u_dayTextureSplit[TEXTURE_UNITS];
#endif
#ifdef APPLY_BRIGHTNESS
uniform float u_dayTextureBrightness[TEXTURE_UNITS];
#endif
#ifdef APPLY_CONTRAST
uniform float u_dayTextureContrast[TEXTURE_UNITS];
#endif
#ifdef APPLY_HUE
uniform float u_dayTextureHue[TEXTURE_UNITS];
#endif
#ifdef APPLY_SATURATION
uniform float u_dayTextureSaturation[TEXTURE_UNITS];
#endif
#ifdef APPLY_GAMMA
uniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];
#endif
#ifdef APPLY_IMAGERY_CUTOUT
uniform vec4 u_dayTextureCutoutRectangles[TEXTURE_UNITS];
#endif
#ifdef APPLY_COLOR_TO_ALPHA
uniform vec4 u_colorsToAlpha[TEXTURE_UNITS];
#endif
uniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS];
#endif
#ifdef SHOW_REFLECTIVE_OCEAN
uniform sampler2D u_waterMask;
uniform vec4 u_waterMaskTranslationAndScale;
uniform float u_zoomedOutOceanSpecularIntensity;
#endif
#ifdef SHOW_OCEAN_WAVES
uniform sampler2D u_oceanNormalMap;
#endif
#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)
uniform vec2 u_lightingFadeDistance;
#endif
#ifdef TILE_LIMIT_RECTANGLE
uniform vec4 u_cartographicLimitRectangle;
#endif
#ifdef GROUND_ATMOSPHERE
uniform vec2 u_nightFadeDistance;
#endif
#ifdef ENABLE_CLIPPING_PLANES
uniform highp sampler2D u_clippingPlanes;
uniform mat4 u_clippingPlanesMatrix;
uniform vec4 u_clippingPlanesEdgeStyle;
#endif
#if defined(FOG) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))
uniform float u_minimumBrightness;
#endif
#ifdef COLOR_CORRECT
uniform vec3 u_hsbShift;
#endif
#ifdef HIGHLIGHT_FILL_TILE
uniform vec4 u_fillHighlightColor;
#endif
#ifdef TRANSLUCENT
uniform vec4 u_frontFaceAlphaByDistance;
uniform vec4 u_backFaceAlphaByDistance;
uniform vec4 u_translucencyRectangle;
#endif
#ifdef UNDERGROUND_COLOR
uniform vec4 u_undergroundColor;
uniform vec4 u_undergroundColorAlphaByDistance;
#endif
varying vec3 v_positionMC;
varying vec3 v_positionEC;
varying vec3 v_textureCoordinates;
varying vec3 v_normalMC;
varying vec3 v_normalEC;
#ifdef APPLY_MATERIAL
varying float v_height;
varying float v_slope;
varying float v_aspect;
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
varying float v_distance;
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE)
varying vec3 v_fogRayleighColor;
varying vec3 v_fogMieColor;
#endif
#ifdef GROUND_ATMOSPHERE
varying vec3 v_rayleighColor;
varying vec3 v_mieColor;
#endif
#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
float interpolateByDistance(vec4 nearFarScalar, float distance)
{
float startDistance = nearFarScalar.x;
float startValue = nearFarScalar.y;
float endDistance = nearFarScalar.z;
float endValue = nearFarScalar.w;
float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);
return mix(startValue, endValue, t);
}
#endif
#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) || defined(APPLY_MATERIAL)
vec4 alphaBlend(vec4 sourceColor, vec4 destinationColor)
{
return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);
}
#endif
#ifdef TRANSLUCENT
bool inTranslucencyRectangle()
{
return
v_textureCoordinates.x > u_translucencyRectangle.x &&
v_textureCoordinates.x < u_translucencyRectangle.z &&
v_textureCoordinates.y > u_translucencyRectangle.y &&
v_textureCoordinates.y < u_translucencyRectangle.w;
}
#endif
vec4 sampleAndBlend(
vec4 previousColor,
sampler2D textureToSample,
vec2 tileTextureCoordinates,
vec4 textureCoordinateRectangle,
vec4 textureCoordinateTranslationAndScale,
float textureAlpha,
float textureNightAlpha,
float textureDayAlpha,
float textureBrightness,
float textureContrast,
float textureHue,
float textureSaturation,
float textureOneOverGamma,
float split,
vec4 colorToAlpha,
float nightBlend)
{
vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);
textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;
alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);
textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;
#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)
textureAlpha *= mix(textureDayAlpha, textureNightAlpha, nightBlend);
#endif
vec2 translation = textureCoordinateTranslationAndScale.xy;
vec2 scale = textureCoordinateTranslationAndScale.zw;
vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
vec4 value = texture2D(textureToSample, textureCoordinates);
vec3 color = value.rgb;
float alpha = value.a;
#ifdef APPLY_COLOR_TO_ALPHA
vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);
colorDiff.r = max(max(colorDiff.r, colorDiff.g), colorDiff.b);
alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);
#endif
#if !defined(APPLY_GAMMA)
vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));
color = tempColor.rgb;
alpha = tempColor.a;
#else
color = pow(color, vec3(textureOneOverGamma));
#endif
#ifdef APPLY_SPLIT
float splitPosition = czm_imagerySplitPosition;
if (split < 0.0 && gl_FragCoord.x > splitPosition) {
alpha = 0.0;
}
else if (split > 0.0 && gl_FragCoord.x < splitPosition) {
alpha = 0.0;
}
#endif
#ifdef APPLY_BRIGHTNESS
color = mix(vec3(0.0), color, textureBrightness);
#endif
#ifdef APPLY_CONTRAST
color = mix(vec3(0.5), color, textureContrast);
#endif
#ifdef APPLY_HUE
color = czm_hue(color, textureHue);
#endif
#ifdef APPLY_SATURATION
color = czm_saturation(color, textureSaturation);
#endif
float sourceAlpha = alpha * textureAlpha;
float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);
outAlpha += sign(outAlpha) - 1.0;
vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;
return vec4(outColor, max(outAlpha, 0.0));
}
vec3 colorCorrect(vec3 rgb) {
#ifdef COLOR_CORRECT
vec3 hsb = czm_RGBToHSB(rgb);
hsb.x += u_hsbShift.x;
hsb.y = clamp(hsb.y + u_hsbShift.y, 0.0, 1.0);
hsb.z = hsb.z > czm_epsilon7 ? hsb.z + u_hsbShift.z : 0.0;
rgb = czm_HSBToRGB(hsb);
#endif
return rgb;
}
vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend);
vec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue, float fade);
#ifdef GROUND_ATMOSPHERE
vec3 computeGroundAtmosphereColor(vec3 fogColor, vec4 finalColor, vec3 atmosphereLightDirection, float cameraDist);
#endif
const float fExposure = 2.0;
void main()
{
#ifdef TILE_LIMIT_RECTANGLE
if (v_textureCoordinates.x < u_cartographicLimitRectangle.x || u_cartographicLimitRectangle.z < v_textureCoordinates.x ||
v_textureCoordinates.y < u_cartographicLimitRectangle.y || u_cartographicLimitRectangle.w < v_textureCoordinates.y)
{
discard;
}
#endif
#ifdef ENABLE_CLIPPING_PLANES
float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);
#endif
#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(HDR)
vec3 normalMC = czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0));
vec3 normalEC = czm_normal3D * normalMC;
#endif
#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)
float nightBlend = 1.0 - clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0, 0.0, 1.0);
#else
float nightBlend = 0.0;
#endif
vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0), nightBlend);
#ifdef SHOW_TILE_BOUNDARIES
if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||
v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))
{
color = vec4(1.0, 0.0, 0.0, 1.0);
}
#endif
#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)
float cameraDist;
if (czm_sceneMode == czm_sceneMode2D)
{
cameraDist = max(czm_frustumPlanes.x - czm_frustumPlanes.y, czm_frustumPlanes.w - czm_frustumPlanes.z) * 0.5;
}
else if (czm_sceneMode == czm_sceneModeColumbusView)
{
cameraDist = -czm_view[3].z;
}
else
{
cameraDist = length(czm_view[3]);
}
float fadeOutDist = u_lightingFadeDistance.x;
float fadeInDist = u_lightingFadeDistance.y;
if (czm_sceneMode != czm_sceneMode3D) {
vec3 radii = czm_ellipsoidRadii;
float maxRadii = max(radii.x, max(radii.y, radii.z));
fadeOutDist -= maxRadii;
fadeInDist -= maxRadii;
}
float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);
#else
float fade = 0.0;
#endif
#ifdef SHOW_REFLECTIVE_OCEAN
vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;
vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;
vec2 waterMaskTextureCoordinates = v_textureCoordinates.xy * waterMaskScale + waterMaskTranslation;
waterMaskTextureCoordinates.y = 1.0 - waterMaskTextureCoordinates.y;
float mask = texture2D(u_waterMask, waterMaskTextureCoordinates).r;
if (mask > 0.0)
{
mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);
vec2 ellipsoidTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC);
vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC.zyx);
vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));
color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask, fade);
}
#endif
#ifdef APPLY_MATERIAL
czm_materialInput materialInput;
materialInput.st = v_textureCoordinates.st;
materialInput.normalEC = normalize(v_normalEC);
materialInput.slope = v_slope;
materialInput.height = v_height;
materialInput.aspect = v_aspect;
czm_material material = czm_getMaterial(materialInput);
vec4 materialColor = vec4(material.diffuse, material.alpha);
color = alphaBlend(materialColor, color);
#endif
#ifdef ENABLE_VERTEX_LIGHTING
float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalize(v_normalEC)) * 0.9 + 0.3, 0.0, 1.0);
vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);
#elif defined(ENABLE_DAYNIGHT_SHADING)
float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);
diffuseIntensity = mix(1.0, diffuseIntensity, fade);
vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);
#else
vec4 finalColor = color;
#endif
#ifdef ENABLE_CLIPPING_PLANES
vec4 clippingPlanesEdgeColor = vec4(1.0);
clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;
float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;
if (clipDistance < clippingPlanesEdgeWidth)
{
finalColor = clippingPlanesEdgeColor;
}
#endif
#ifdef HIGHLIGHT_FILL_TILE
finalColor = vec4(mix(finalColor.rgb, u_fillHighlightColor.rgb, u_fillHighlightColor.a), finalColor.a);
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE)
vec3 fogColor = colorCorrect(v_fogMieColor) + finalColor.rgb * colorCorrect(v_fogRayleighColor);
#ifndef HDR
fogColor = vec3(1.0) - exp(-fExposure * fogColor);
#endif
#endif
#if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN)
vec3 atmosphereLightDirection = czm_sunDirectionWC;
#else
vec3 atmosphereLightDirection = czm_lightDirectionWC;
#endif
#ifdef FOG
#if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))
float darken = clamp(dot(normalize(czm_viewerPositionWC), atmosphereLightDirection), u_minimumBrightness, 1.0);
fogColor *= darken;
#endif
#ifdef HDR
const float modifier = 0.15;
finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor, modifier), finalColor.a);
#else
finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor), finalColor.a);
#endif
#endif
#ifdef GROUND_ATMOSPHERE
if (!czm_backFacing())
{
vec3 groundAtmosphereColor = computeGroundAtmosphereColor(fogColor, finalColor, atmosphereLightDirection, cameraDist);
finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);
}
#endif
#ifdef UNDERGROUND_COLOR
if (czm_backFacing())
{
float distanceFromEllipsoid = max(czm_eyeHeight, 0.0);
float distance = max(v_distance - distanceFromEllipsoid, 0.0);
float blendAmount = interpolateByDistance(u_undergroundColorAlphaByDistance, distance);
vec4 undergroundColor = vec4(u_undergroundColor.rgb, u_undergroundColor.a * blendAmount);
finalColor = alphaBlend(undergroundColor, finalColor);
}
#endif
#ifdef TRANSLUCENT
if (inTranslucencyRectangle())
{
vec4 alphaByDistance = gl_FrontFacing ? u_frontFaceAlphaByDistance : u_backFaceAlphaByDistance;
finalColor.a *= interpolateByDistance(alphaByDistance, v_distance);
}
#endif
gl_FragColor = finalColor;
}
#ifdef GROUND_ATMOSPHERE
vec3 computeGroundAtmosphereColor(vec3 fogColor, vec4 finalColor, vec3 atmosphereLightDirection, float cameraDist)
{
#if defined(PER_FRAGMENT_GROUND_ATMOSPHERE) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING))
float mpp = czm_metersPerPixel(vec4(0.0, 0.0, -czm_currentFrustum.x, 1.0), 1.0);
vec2 xy = gl_FragCoord.xy / czm_viewport.zw * 2.0 - vec2(1.0);
xy *= czm_viewport.zw * mpp * 0.5;
vec3 direction = normalize(vec3(xy, -czm_currentFrustum.x));
czm_ray ray = czm_ray(vec3(0.0), direction);
vec3 ellipsoid_center = czm_view[3].xyz;
czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);
vec3 ellipsoidPosition = czm_pointAlongRay(ray, intersection.start);
ellipsoidPosition = (czm_inverseView * vec4(ellipsoidPosition, 1.0)).xyz;
AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(ellipsoidPosition, true, atmosphereLightDirection);
vec3 groundAtmosphereColor = colorCorrect(atmosColor.mie) + finalColor.rgb * colorCorrect(atmosColor.rayleigh);
#ifndef HDR
groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);
#endif
float fadeInDist = u_nightFadeDistance.x;
float fadeOutDist = u_nightFadeDistance.y;
float sunlitAtmosphereIntensity = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);
#ifdef HDR
sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);
#endif
groundAtmosphereColor = mix(groundAtmosphereColor, fogColor, sunlitAtmosphereIntensity);
#else
vec3 groundAtmosphereColor = fogColor;
#endif
#ifdef HDR
groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);
#endif
return groundAtmosphereColor;
}
#endif
#ifdef SHOW_REFLECTIVE_OCEAN
float waveFade(float edge0, float edge1, float x)
{
float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
return pow(1.0 - y, 5.0);
}
float linearFade(float edge0, float edge1, float x)
{
return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
}
const float oceanFrequencyLowAltitude = 825000.0;
const float oceanAnimationSpeedLowAltitude = 0.004;
const float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0;
const float oceanSpecularIntensity = 0.5;
const float oceanFrequencyHighAltitude = 125000.0;
const float oceanAnimationSpeedHighAltitude = 0.008;
const float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0;
vec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float maskValue, float fade)
{
vec3 positionToEyeEC = -positionEyeCoordinates;
float positionToEyeECLength = length(positionToEyeEC);
vec3 normalizedPositionToEyeEC = normalize(normalize(positionToEyeEC));
float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);
#ifdef SHOW_OCEAN_WAVES
float time = czm_frameNumber * oceanAnimationSpeedHighAltitude;
vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0);
vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude);
time = czm_frameNumber * oceanAnimationSpeedLowAltitude;
noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0);
vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude);
float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength);
float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength);
vec3 normalTangentSpace =
(highAltitudeFade * normalTangentSpaceHighAltitude) +
(lowAltitudeFade * normalTangentSpaceLowAltitude);
normalTangentSpace = normalize(normalTangentSpace);
normalTangentSpace.xy *= waveIntensity;
normalTangentSpace = normalize(normalTangentSpace);
#else
vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);
#endif
vec3 normalEC = enuToEye * normalTangentSpace;
const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);
float diffuseIntensity = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * maskValue;
vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity * (1.0 - fade);
#ifdef SHOW_OCEAN_WAVES
float tsPerturbationRatio = normalTangentSpace.z;
vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);
#else
vec3 nonDiffuseHighlight = vec3(0.0);
#endif
float specularIntensity = czm_getSpecular(czm_lightDirectionEC, normalizedPositionToEyeEC, normalEC, 10.0);
float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), maskValue);
float specular = specularIntensity * surfaceReflectance;
#ifdef HDR
specular *= 1.4;
float e = 0.2;
float d = 3.3;
float c = 1.7;
vec3 color = imageryColor.rgb + (c * (vec3(e) + imageryColor.rgb * d) * (diffuseHighlight + nonDiffuseHighlight + specular));
#else
vec3 color = imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular;
#endif
return vec4(color, imageryColor.a);
}
#endif // #ifdef SHOW_REFLECTIVE_OCEAN
`,
    DD = `#ifdef QUANTIZATION_BITS12
attribute vec4 compressed0;
attribute float compressed1;
#else
attribute vec4 position3DAndHeight;
attribute vec4 textureCoordAndEncodedNormals;
#endif
uniform vec3 u_center3D;
uniform mat4 u_modifiedModelView;
uniform mat4 u_modifiedModelViewProjection;
uniform vec4 u_tileRectangle;
uniform vec2 u_southAndNorthLatitude;
uniform vec2 u_southMercatorYAndOneOverHeight;
varying vec3 v_positionMC;
varying vec3 v_positionEC;
varying vec3 v_textureCoordinates;
varying vec3 v_normalMC;
varying vec3 v_normalEC;
#ifdef APPLY_MATERIAL
varying float v_slope;
varying float v_aspect;
varying float v_height;
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
varying float v_distance;
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE)
varying vec3 v_fogMieColor;
varying vec3 v_fogRayleighColor;
#endif
vec4 getPosition(vec3 position, float height, vec2 textureCoordinates);
float get2DYPositionFraction(vec2 textureCoordinates);
vec4 getPosition3DMode(vec3 position, float height, vec2 textureCoordinates)
{
return u_modifiedModelViewProjection * vec4(position, 1.0);
}
float get2DMercatorYPositionFraction(vec2 textureCoordinates)
{
const float maxTileWidth = 0.003068;
float positionFraction = textureCoordinates.y;
float southLatitude = u_southAndNorthLatitude.x;
float northLatitude = u_southAndNorthLatitude.y;
if (northLatitude - southLatitude > maxTileWidth)
{
float southMercatorY = u_southMercatorYAndOneOverHeight.x;
float oneOverMercatorHeight = u_southMercatorYAndOneOverHeight.y;
float currentLatitude = mix(southLatitude, northLatitude, textureCoordinates.y);
currentLatitude = clamp(currentLatitude, -czm_webMercatorMaxLatitude, czm_webMercatorMaxLatitude);
positionFraction = czm_latitudeToWebMercatorFraction(currentLatitude, southMercatorY, oneOverMercatorHeight);
}
return positionFraction;
}
float get2DGeographicYPositionFraction(vec2 textureCoordinates)
{
return textureCoordinates.y;
}
vec4 getPositionPlanarEarth(vec3 position, float height, vec2 textureCoordinates)
{
float yPositionFraction = get2DYPositionFraction(textureCoordinates);
vec4 rtcPosition2D = vec4(height, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);
return u_modifiedModelViewProjection * rtcPosition2D;
}
vec4 getPosition2DMode(vec3 position, float height, vec2 textureCoordinates)
{
return getPositionPlanarEarth(position, 0.0, textureCoordinates);
}
vec4 getPositionColumbusViewMode(vec3 position, float height, vec2 textureCoordinates)
{
return getPositionPlanarEarth(position, height, textureCoordinates);
}
vec4 getPositionMorphingMode(vec3 position, float height, vec2 textureCoordinates)
{
vec3 position3DWC = position + u_center3D;
float yPositionFraction = get2DYPositionFraction(textureCoordinates);
vec4 position2DWC = vec4(height, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);
vec4 morphPosition = czm_columbusViewMorph(position2DWC, vec4(position3DWC, 1.0), czm_morphTime);
return czm_modelViewProjection * morphPosition;
}
#ifdef QUANTIZATION_BITS12
uniform vec2 u_minMaxHeight;
uniform mat4 u_scaleAndBias;
#endif
void main()
{
#ifdef QUANTIZATION_BITS12
vec2 xy = czm_decompressTextureCoordinates(compressed0.x);
vec2 zh = czm_decompressTextureCoordinates(compressed0.y);
vec3 position = vec3(xy, zh.x);
float height = zh.y;
vec2 textureCoordinates = czm_decompressTextureCoordinates(compressed0.z);
height = height * (u_minMaxHeight.y - u_minMaxHeight.x) + u_minMaxHeight.x;
position = (u_scaleAndBias * vec4(position, 1.0)).xyz;
#if (defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL)) && defined(INCLUDE_WEB_MERCATOR_Y)
float webMercatorT = czm_decompressTextureCoordinates(compressed0.w).x;
float encodedNormal = compressed1;
#elif defined(INCLUDE_WEB_MERCATOR_Y)
float webMercatorT = czm_decompressTextureCoordinates(compressed0.w).x;
float encodedNormal = 0.0;
#elif defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL)
float webMercatorT = textureCoordinates.y;
float encodedNormal = compressed0.w;
#else
float webMercatorT = textureCoordinates.y;
float encodedNormal = 0.0;
#endif
#else
vec3 position = position3DAndHeight.xyz;
float height = position3DAndHeight.w;
vec2 textureCoordinates = textureCoordAndEncodedNormals.xy;
#if (defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)) && defined(INCLUDE_WEB_MERCATOR_Y)
float webMercatorT = textureCoordAndEncodedNormals.z;
float encodedNormal = textureCoordAndEncodedNormals.w;
#elif defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)
float webMercatorT = textureCoordinates.y;
float encodedNormal = textureCoordAndEncodedNormals.z;
#elif defined(INCLUDE_WEB_MERCATOR_Y)
float webMercatorT = textureCoordAndEncodedNormals.z;
float encodedNormal = 0.0;
#else
float webMercatorT = textureCoordinates.y;
float encodedNormal = 0.0;
#endif
#endif
vec3 position3DWC = position + u_center3D;
gl_Position = getPosition(position, height, textureCoordinates);
v_textureCoordinates = vec3(textureCoordinates, webMercatorT);
#if defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)
v_positionEC = (u_modifiedModelView * vec4(position, 1.0)).xyz;
v_positionMC = position3DWC;
vec3 normalMC = czm_octDecode(encodedNormal);
v_normalMC = normalMC;
v_normalEC = czm_normal3D * v_normalMC;
#elif defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(GENERATE_POSITION) || defined(HDR)
v_positionEC = (u_modifiedModelView * vec4(position, 1.0)).xyz;
v_positionMC = position3DWC;
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE)
AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(position3DWC, false, vec3(0.0));
v_fogMieColor = atmosFogColor.mie;
v_fogRayleighColor = atmosFogColor.rayleigh;
#endif
#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
v_distance = length((czm_modelView3D * vec4(position3DWC, 1.0)).xyz);
#endif
#ifdef APPLY_MATERIAL
float northPoleZ = czm_ellipsoidRadii.z;
vec3 northPolePositionMC = vec3(0.0, 0.0, northPoleZ);
vec3 ellipsoidNormal = normalize(v_positionMC);
vec3 vectorEastMC = normalize(cross(northPolePositionMC - v_positionMC, ellipsoidNormal));
float dotProd = abs(dot(ellipsoidNormal, v_normalMC));
v_slope = acos(dotProd);
vec3 normalRejected = ellipsoidNormal * dotProd;
vec3 normalProjected = v_normalMC - normalRejected;
vec3 aspectVector = normalize(normalProjected);
v_aspect = acos(dot(aspectVector, vectorEastMC));
float determ = dot(cross(vectorEastMC, aspectVector), ellipsoidNormal);
v_aspect = czm_branchFreeTernary(determ < 0.0, 2.0 * czm_pi - v_aspect, v_aspect);
v_height = height;
#endif
}
`,
    mv = `const float Kr = 0.0025;
const float Km = 0.0015;
const float ESun = 15.0;
const float fKrESun = Kr * ESun;
const float fKmESun = Km * ESun;
const float fKr4PI = Kr * 4.0 * czm_pi;
const float fKm4PI = Km * 4.0 * czm_pi;
const vec3 v3InvWavelength = vec3(5.60204474633241, 9.473284437923038, 19.64380261047721);
const float fScaleDepth = 0.25;
struct AtmosphereColor
{
vec3 mie;
vec3 rayleigh;
};
const int nSamples = 2;
const float fSamples = 2.0;
float scale(float fCos)
{
float x = 1.0 - fCos;
return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
}
AtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool dynamicLighting, vec3 lightDirectionWC)
{
float fInnerRadius = czm_ellipsoidRadii.x;
float fOuterRadius = czm_ellipsoidRadii.x * 1.025;
float fOuterRadius2 = fOuterRadius * fOuterRadius;
float fScale = 1.0 / (fOuterRadius - fInnerRadius);
float fScaleOverScaleDepth = fScale / fScaleDepth;
vec3 v3Ray = v3Pos - czm_viewerPositionWC;
float fFar = length(v3Ray);
v3Ray /= fFar;
float fCameraHeight = length(czm_viewerPositionWC);
float fCameraHeight2 = fCameraHeight * fCameraHeight;
float B = 2.0 * length(czm_viewerPositionWC) * dot(normalize(czm_viewerPositionWC), v3Ray);
float C = fCameraHeight2 - fOuterRadius2;
float fDet = max(0.0, B*B - 4.0 * C);
float fNear = 0.5 * (-B - sqrt(fDet));
vec3 v3Start = czm_viewerPositionWC + v3Ray * fNear;
fFar -= fNear;
float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);
float fLightAngle = czm_branchFreeTernary(dynamicLighting, dot(lightDirectionWC, v3Pos) / length(v3Pos), 1.0);
float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);
float fCameraScale = scale(fCameraAngle);
float fLightScale = scale(fLightAngle);
float fCameraOffset = fDepth*fCameraScale;
float fTemp = (fLightScale + fCameraScale);
float fSampleLength = fFar / fSamples;
float fScaledLength = fSampleLength * fScale;
vec3 v3SampleRay = v3Ray * fSampleLength;
vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;
vec3 v3FrontColor = vec3(0.0);
vec3 v3Attenuate = vec3(0.0);
for(int i=0; i<nSamples; i++)
{
float fHeight = length(v3SamplePoint);
float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
float fScatter = fDepth*fTemp - fCameraOffset;
v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));
v3FrontColor += v3Attenuate * (fDepth * fScaledLength);
v3SamplePoint += v3SampleRay;
}
AtmosphereColor color;
color.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);
color.rayleigh = v3Attenuate;
return color;
}
`;

function Ki(e, t) {
    this._distance = t, this._normal = new kg(e, this), this.onChangeCallback = void 0, this.index = -1
}
Object.defineProperties(Ki.prototype, {
    distance: {
        get: function() {
            return this._distance
        },
        set: function(e) {
            l(this.onChangeCallback) && e !== this._distance && this.onChangeCallback(this.index), this._distance = e
        }
    },
    normal: {
        get: function() {
            return this._normal
        },
        set: function(e) {
            l(this.onChangeCallback) && !u.equals(this._normal._cartesian3, e) && this.onChangeCallback(this.index), u.clone(e, this._normal._cartesian3)
        }
    }
});
Ki.fromPlane = function(e, t) {
    return l(t) ? (t.normal = e.normal, t.distance = e.distance) : t = new Ki(e.normal, e.distance), t
};
Ki.clone = function(e, t) {
    return l(t) ? (t.normal = e.normal, t.distance = e.distance, t) : new Ki(e.normal, e.distance)
};

function kg(e, t) {
    this._clippingPlane = t, this._cartesian3 = u.clone(e)
}
Object.defineProperties(kg.prototype, {
    x: {
        get: function() {
            return this._cartesian3.x
        },
        set: function(e) {
            l(this._clippingPlane.onChangeCallback) && e !== this._cartesian3.x && this._clippingPlane.onChangeCallback(this._clippingPlane.index), this._cartesian3.x = e
        }
    },
    y: {
        get: function() {
            return this._cartesian3.y
        },
        set: function(e) {
            l(this._clippingPlane.onChangeCallback) && e !== this._cartesian3.y && this._clippingPlane.onChangeCallback(this._clippingPlane.index), this._cartesian3.y = e
        }
    },
    z: {
        get: function() {
            return this._cartesian3.z
        },
        set: function(e) {
            l(this._clippingPlane.onChangeCallback) && e !== this._cartesian3.z && this._clippingPlane.onChangeCallback(this._clippingPlane.index), this._cartesian3.z = e
        }
    }
});

function Qt(e) {
    e = p(e, p.EMPTY_OBJECT), this._planes = [], this._dirtyIndex = -1, this._multipleDirtyPlanes = !1, this._enabled = p(e.enabled, !0), this.modelMatrix = S.clone(p(e.modelMatrix, S.IDENTITY)), this.edgeColor = H.clone(p(e.edgeColor, H.WHITE)), this.edgeWidth = p(e.edgeWidth, 0), this.planeAdded = new ht, this.planeRemoved = new ht, this._owner = void 0;
    var t = p(e.unionClippingRegions, !1);
    this._unionClippingRegions = t, this._testIntersection = t ? Wg : qg, this._uint8View = void 0, this._float32View = void 0, this._clippingPlanesTexture = void 0;
    var n = e.planes;
    if (l(n))
        for (var r = n.length, i = 0; i < r; ++i) this.add(n[i])
}

function Wg(e) {
    return e === nt.OUTSIDE
}

function qg(e) {
    return e === nt.INSIDE
}
Object.defineProperties(Qt.prototype, {
    length: {
        get: function() {
            return this._planes.length
        }
    },
    unionClippingRegions: {
        get: function() {
            return this._unionClippingRegions
        },
        set: function(e) {
            this._unionClippingRegions !== e && (this._unionClippingRegions = e, this._testIntersection = e ? Wg : qg)
        }
    },
    enabled: {
        get: function() {
            return this._enabled
        },
        set: function(e) {
            this._enabled !== e && (this._enabled = e)
        }
    },
    texture: {
        get: function() {
            return this._clippingPlanesTexture
        }
    },
    owner: {
        get: function() {
            return this._owner
        }
    },
    clippingPlanesState: {
        get: function() {
            return this._unionClippingRegions ? this._planes.length : -this._planes.length
        }
    }
});

function pv(e, t) {
    e._multipleDirtyPlanes = e._multipleDirtyPlanes || e._dirtyIndex !== -1 && e._dirtyIndex !== t, e._dirtyIndex = t
}
Qt.prototype.add = function(e) {
    var t = this._planes.length,
        n = this;
    e.onChangeCallback = function(r) {
        pv(n, r)
    }, e.index = t, pv(this, t), this._planes.push(e), this.planeAdded.raiseEvent(e, t)
};
Qt.prototype.get = function(e) {
    return this._planes[e]
};

function Yg(e, t) {
    for (var n = e.length, r = 0; r < n; ++r)
        if (Ne.equals(e[r], t)) return r;
    return -1
}
Qt.prototype.contains = function(e) {
    return Yg(this._planes, e) !== -1
};
Qt.prototype.remove = function(e) {
    var t = this._planes,
        n = Yg(t, e);
    if (n === -1) return !1;
    e instanceof Ki && (e.onChangeCallback = void 0, e.index = -1);
    for (var r = t.length - 1, i = n; i < r; ++i) {
        var a = t[i + 1];
        t[i] = a, a instanceof Ki && (a.index = i)
    }
    return this._multipleDirtyPlanes = !0, t.length = r, this.planeRemoved.raiseEvent(e, n), !0
};
Qt.prototype.removeAll = function() {
    for (var e = this._planes, t = e.length, n = 0; n < t; ++n) {
        var r = e[n];
        r instanceof Ki && (r.onChangeCallback = void 0, r.index = -1), this.planeRemoved.raiseEvent(r, n)
    }
    this._multipleDirtyPlanes = !0, this._planes = []
};
var ID = new U,
    PD = new U;

function gv(e, t, n) {
    for (var r = e._uint8View, i = e._planes, a = 0, o = t; o < n; ++o) {
        var s = i[o],
            c = Ee.octEncodeToCartesian4(s.normal, PD);
        r[a] = c.x, r[a + 1] = c.y, r[a + 2] = c.z, r[a + 3] = c.w;
        var f = U.packFloat(s.distance, ID);
        r[a + 4] = f.x, r[a + 5] = f.y, r[a + 6] = f.z, r[a + 7] = f.w, a += 8
    }
}

function yv(e, t, n) {
    for (var r = e._float32View, i = e._planes, a = 0, o = t; o < n; ++o) {
        var s = i[o],
            c = s.normal;
        r[a] = c.x, r[a + 1] = c.y, r[a + 2] = c.z, r[a + 3] = s.distance, a += 4
    }
}

function Xg(e, t) {
    var n = pe.maximumTextureSize;
    return t.x = Math.min(e, n), t.y = Math.ceil(e / t.x), t
}
var OD = new R;
Qt.prototype.update = function(e) {
    var t = this._clippingPlanesTexture,
        n = e.context,
        r = Qt.useFloatTexture(n),
        i = r ? this.length : this.length * 2;
    if (l(t)) {
        var a = t.width * t.height;
        (a < i || i < .25 * a) && (t.destroy(), t = void 0, this._clippingPlanesTexture = void 0)
    }
    if (this.length !== 0) {
        if (!l(t)) {
            var o = Xg(i, OD);
            o.y *= 2, r ? (t = new be({
                context: n,
                width: o.x,
                height: o.y,
                pixelFormat: de.RGBA,
                pixelDatatype: ae.FLOAT,
                sampler: gt.NEAREST,
                flipY: !1
            }), this._float32View = new Float32Array(o.x * o.y * 4)) : (t = new be({
                context: n,
                width: o.x,
                height: o.y,
                pixelFormat: de.RGBA,
                pixelDatatype: ae.UNSIGNED_BYTE,
                sampler: gt.NEAREST,
                flipY: !1
            }), this._uint8View = new Uint8Array(o.x * o.y * 4)), this._clippingPlanesTexture = t, this._multipleDirtyPlanes = !0
        }
        var s = this._dirtyIndex;
        if (!(!this._multipleDirtyPlanes && s === -1)) {
            if (this._multipleDirtyPlanes) r ? (yv(this, 0, this._planes.length), t.copyFrom({
                width: t.width,
                height: t.height,
                arrayBufferView: this._float32View
            })) : (gv(this, 0, this._planes.length), t.copyFrom({
                width: t.width,
                height: t.height,
                arrayBufferView: this._uint8View
            }));
            else {
                var c = 0,
                    f = 0;
                r ? (f = Math.floor(s / t.width), c = Math.floor(s - f * t.width), yv(this, s, s + 1), t.copyFrom({
                    width: 1,
                    height: 1,
                    arrayBufferView: this._float32View
                }, c, f)) : (f = Math.floor(s * 2 / t.width), c = Math.floor(s * 2 - f * t.width), gv(this, s, s + 1), t.copyFrom({
                    width: 2,
                    height: 1,
                    arrayBufferView: this._uint8View
                }, c, f))
            }
            this._multipleDirtyPlanes = !1, this._dirtyIndex = -1
        }
    }
};
var MD = new S,
    Tv = new Ne(u.UNIT_X, 0);
Qt.prototype.computeIntersectionWithBoundingVolume = function(e, t) {
    var n = this._planes,
        r = n.length,
        i = this.modelMatrix;
    l(t) && (i = S.multiply(t, i, MD));
    var a = nt.INSIDE;
    !this.unionClippingRegions && r > 0 && (a = nt.OUTSIDE);
    for (var o = 0; o < r; ++o) {
        var s = n[o];
        Ne.transform(s, i, Tv);
        var c = e.intersectPlane(Tv);
        if (c === nt.INTERSECTING) a = c;
        else if (this._testIntersection(c)) return c
    }
    return a
};
Qt.setOwner = function(e, t, n) {
    e !== t[n] && (t[n] = t[n] && t[n].destroy(), l(e) && (e._owner = t, t[n] = e))
};
Qt.useFloatTexture = function(e) {
    return e.floatingPointTexture
};
Qt.getTextureResolution = function(e, t, n) {
    var r = e.texture;
    if (l(r)) return n.x = r.width, n.y = r.height, n;
    var i = Qt.useFloatTexture(t) ? e.length : e.length * 2,
        a = Xg(i, n);
    return a.y *= 2, a
};
Qt.prototype.isDestroyed = function() {
    return !1
};
Qt.prototype.destroy = function() {
    return this._clippingPlanesTexture = this._clippingPlanesTexture && this._clippingPlanesTexture.destroy(), Pe(this)
};
var ND = new R;

function bD(e, t) {
    var n = e.unionClippingRegions,
        r = e.length,
        i = Qt.useFloatTexture(t),
        a = Qt.getTextureResolution(e, t, ND),
        o = a.x,
        s = a.y,
        c = i ? UD(o, s) : zD(o, s);
    return c += `
`, c += n ? FD(r) : LD(r), c
}

function FD(e) {
    var t = `float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)
{
    vec4 position = czm_windowToEyeCoordinates(fragCoord);
    vec3 clipNormal = vec3(0.0);
    vec3 clipPosition = vec3(0.0);
    float clipAmount;
    float pixelWidth = czm_metersPerPixel(position);
    bool breakAndDiscard = false;
    for (int i = 0; i < ` + e + `; ++i)
    {
        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);
        clipNormal = clippingPlane.xyz;
        clipPosition = -clippingPlane.w * clipNormal;
        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;
        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));
        if (amount <= 0.0)
        {
           breakAndDiscard = true;
           break;
        }
    }
    if (breakAndDiscard) {
        discard;
    }
    return clipAmount;
}
`;
    return t
}

function LD(e) {
    var t = `float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)
{
    bool clipped = true;
    vec4 position = czm_windowToEyeCoordinates(fragCoord);
    vec3 clipNormal = vec3(0.0);
    vec3 clipPosition = vec3(0.0);
    float clipAmount = 0.0;
    float pixelWidth = czm_metersPerPixel(position);
    for (int i = 0; i < ` + e + `; ++i)
    {
        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);
        clipNormal = clippingPlane.xyz;
        clipPosition = -clippingPlane.w * clipNormal;
        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;
        clipAmount = max(amount, clipAmount);
        clipped = clipped && (amount <= 0.0);
    }
    if (clipped)
    {
        discard;
    }
    return clipAmount;
}
`;
    return t
}

function UD(e, t) {
    var n = 1 / e,
        r = 1 / t,
        i = n + "";
    i.indexOf(".") === -1 && (i += ".0");
    var a = r + "";
    a.indexOf(".") === -1 && (a += ".0");
    var o = `vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)
{
    int pixY = clippingPlaneNumber / ` + e + `;
    int pixX = clippingPlaneNumber - (pixY * ` + e + `);
    float u = (float(pixX) + 0.5) * ` + i + `;
    float v = (float(pixY) + 0.5) * ` + a + `;
    vec4 plane = texture2D(packedClippingPlanes, vec2(u, v));
    return czm_transformPlane(plane, transform);
}
`;
    return o
}

function zD(e, t) {
    var n = 1 / e,
        r = 1 / t,
        i = n + "";
    i.indexOf(".") === -1 && (i += ".0");
    var a = r + "";
    a.indexOf(".") === -1 && (a += ".0");
    var o = `vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)
{
    int clippingPlaneStartIndex = clippingPlaneNumber * 2;
    int pixY = clippingPlaneStartIndex / ` + e + `;
    int pixX = clippingPlaneStartIndex - (pixY * ` + e + `);
    float u = (float(pixX) + 0.5) * ` + i + `;
    float v = (float(pixY) + 0.5) * ` + a + `;
    vec4 oct32 = texture2D(packedClippingPlanes, vec2(u, v)) * 255.0;
    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);
    vec4 plane;
    plane.xyz = czm_octDecode(oct, 65535.0);
    plane.w = czm_unpackFloat(texture2D(packedClippingPlanes, vec2(u + ` + i + `, v)));
    return czm_transformPlane(plane, transform);
}
`;
    return o
}

function BD(e, t, n, r, i) {
    this.numberOfDayTextures = e, this.flags = t, this.material = n, this.shaderProgram = r, this.clippingShaderState = i
}

function Sd() {
    this.baseVertexShaderSource = void 0, this.baseFragmentShaderSource = void 0, this._shadersByTexturesFlags = [], this.material = void 0
}

function VD(e) {
    var t = "vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }",
        n = "vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }",
        r = "vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }",
        i;
    switch (e) {
        case k.SCENE3D:
            i = t;
            break;
        case k.SCENE2D:
        case k.COLUMBUS_VIEW:
            i = n;
            break;
        case k.MORPHING:
            i = r;
            break
    }
    return i
}

function GD(e) {
    var t = "float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }",
        n = "float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }";
    return e ? n : t
}
Sd.prototype.getShaderProgram = function(e) {
    var t = e.frameState,
        n = e.surfaceTile,
        r = e.numberOfDayTextures,
        i = e.applyBrightness,
        a = e.applyContrast,
        o = e.applyHue,
        s = e.applySaturation,
        c = e.applyGamma,
        f = e.applyAlpha,
        h = e.applyDayNightAlpha,
        d = e.applySplit,
        _ = e.showReflectiveOcean,
        v = e.showOceanWaves,
        m = e.enableLighting,
        g = e.dynamicAtmosphereLighting,
        y = e.dynamicAtmosphereLightingFromSun,
        E = e.showGroundAtmosphere,
        w = e.perFragmentGroundAtmosphere,
        C = e.hasVertexNormals,
        A = e.useWebMercatorProjection,
        x = e.enableFog,
        P = e.enableClippingPlanes,
        I = e.clippingPlanes,
        D = e.clippedByBoundaries,
        O = e.hasImageryLayerCutout,
        F = e.colorCorrect,
        z = e.highlightFillTile,
        b = e.colorToAlpha,
        M = e.showUndergroundColor,
        G = e.translucent,
        V = 0,
        B = "",
        Y = n.renderedMesh,
        j = Y.encoding,
        Z = j.quantization;
    Z === er.BITS12 && (V = 1, B = "QUANTIZATION_BITS12");
    var Q = 0,
        ie = "";
    D && (Q = 1, ie = "TILE_LIMIT_RECTANGLE");
    var Ae = 0,
        re = "";
    O && (Ae = 1, re = "APPLY_IMAGERY_CUTOUT");
    var ve = t.mode,
        qe = ve | i << 2 | a << 3 | o << 4 | s << 5 | c << 6 | f << 7 | _ << 8 | v << 9 | m << 10 | g << 11 | y << 12 | E << 13 | w << 14 | C << 15 | A << 16 | x << 17 | V << 18 | d << 19 | P << 20 | Q << 21 | Ae << 22 | F << 23 | z << 24 | b << 25 | M << 26 | G << 27 | h << 28,
        De = 0;
    l(I) && I.length > 0 && (De = P ? I.clippingPlanesState : 0);
    var _e = n.surfaceShader;
    if (l(_e) && _e.numberOfDayTextures === r && _e.flags === qe && _e.material === this.material && _e.clippingShaderState === De) return _e.shaderProgram;
    var Oe = this._shadersByTexturesFlags[r];
    if (l(Oe) || (Oe = this._shadersByTexturesFlags[r] = []), _e = Oe[qe], !l(_e) || _e.material !== this.material || _e.clippingShaderState !== De) {
        var Fe = this.baseVertexShaderSource.clone(),
            ce = this.baseFragmentShaderSource.clone();
        De !== 0 && ce.sources.unshift(bD(I, t.context)), Fe.defines.push(B), ce.defines.push("TEXTURE_UNITS " + r, ie, re), i && ce.defines.push("APPLY_BRIGHTNESS"), a && ce.defines.push("APPLY_CONTRAST"), o && ce.defines.push("APPLY_HUE"), s && ce.defines.push("APPLY_SATURATION"), c && ce.defines.push("APPLY_GAMMA"), f && ce.defines.push("APPLY_ALPHA"), h && ce.defines.push("APPLY_DAY_NIGHT_ALPHA"), _ && (ce.defines.push("SHOW_REFLECTIVE_OCEAN"), Fe.defines.push("SHOW_REFLECTIVE_OCEAN")), v && ce.defines.push("SHOW_OCEAN_WAVES"), b && ce.defines.push("APPLY_COLOR_TO_ALPHA"), M && (Fe.defines.push("UNDERGROUND_COLOR"), ce.defines.push("UNDERGROUND_COLOR")), G && (Fe.defines.push("TRANSLUCENT"), ce.defines.push("TRANSLUCENT")), m && (C ? (Fe.defines.push("ENABLE_VERTEX_LIGHTING"), ce.defines.push("ENABLE_VERTEX_LIGHTING")) : (Fe.defines.push("ENABLE_DAYNIGHT_SHADING"), ce.defines.push("ENABLE_DAYNIGHT_SHADING"))), g && (ce.defines.push("DYNAMIC_ATMOSPHERE_LIGHTING"), y && ce.defines.push("DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN")), E && (Fe.defines.push("GROUND_ATMOSPHERE"), ce.defines.push("GROUND_ATMOSPHERE"), w && ce.defines.push("PER_FRAGMENT_GROUND_ATMOSPHERE")), Fe.defines.push("INCLUDE_WEB_MERCATOR_Y"), ce.defines.push("INCLUDE_WEB_MERCATOR_Y"), x && (Fe.defines.push("FOG"), ce.defines.push("FOG")), d && ce.defines.push("APPLY_SPLIT"), P && ce.defines.push("ENABLE_CLIPPING_PLANES"), F && ce.defines.push("COLOR_CORRECT"), z && ce.defines.push("HIGHLIGHT_FILL_TILE");
        var He = `    vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend)
    {
        vec4 color = initialColor;
`;
        O && (He += `        vec4 cutoutAndColorResult;
        bool texelUnclipped;
`);
        for (var le = 0; le < r; ++le) O ? He += "        cutoutAndColorResult = u_dayTextureCutoutRectangles[" + le + `];
        texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y;
        cutoutAndColorResult = sampleAndBlend(
` : He += `        color = sampleAndBlend(
`, He += `            color,
            u_dayTextures[` + le + `],
            u_dayTextureUseWebMercatorT[` + le + `] ? textureCoordinates.xz : textureCoordinates.xy,
            u_dayTextureTexCoordsRectangle[` + le + `],
            u_dayTextureTranslationAndScale[` + le + `],
            ` + (f ? "u_dayTextureAlpha[" + le + "]" : "1.0") + `,
            ` + (h ? "u_dayTextureNightAlpha[" + le + "]" : "1.0") + `,
` + (h ? "u_dayTextureDayAlpha[" + le + "]" : "1.0") + `,
` + (i ? "u_dayTextureBrightness[" + le + "]" : "0.0") + `,
            ` + (a ? "u_dayTextureContrast[" + le + "]" : "0.0") + `,
            ` + (o ? "u_dayTextureHue[" + le + "]" : "0.0") + `,
            ` + (s ? "u_dayTextureSaturation[" + le + "]" : "0.0") + `,
            ` + (c ? "u_dayTextureOneOverGamma[" + le + "]" : "0.0") + `,
            ` + (d ? "u_dayTextureSplit[" + le + "]" : "0.0") + `,
            ` + (b ? "u_colorsToAlpha[" + le + "]" : "vec4(0.0)") + `,
        nightBlend        );
`, O && (He += `        color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color);
`);
        He += `        return color;
    }`, ce.sources.push(He), Fe.sources.push(VD(ve)), Fe.sources.push(GD(A));
        var ft = Mt.fromCache({
            context: t.context,
            vertexShaderSource: Fe,
            fragmentShaderSource: ce,
            attributeLocations: j.getAttributeLocations()
        });
        _e = Oe[qe] = new BD(r, qe, this.material, ft, De)
    }
    return n.surfaceShader = _e, _e.shaderProgram
};
Sd.prototype.destroy = function() {
    var e, t, n = this._shadersByTexturesFlags;
    for (var r in n)
        if (n.hasOwnProperty(r)) {
            var i = n[r];
            if (!l(i)) continue;
            for (e in i) i.hasOwnProperty(e) && (t = i[e], l(t) && t.shaderProgram.destroy())
        }
    return Pe(this)
};

function Ri(e, t, n, r) {
    if (typeof e.fill == "function") return e.fill(t, n, r);
    for (var i = e.length >>> 0, a = p(n, 0), o = a < 0 ? Math.max(i + a, 0) : Math.min(a, i), s = p(r, i), c = s < 0 ? Math.max(i + s, 0) : Math.min(s, i); o < c;) e[o] = t, o++;
    return e
}

function ze(e) {
    e = p(e, p.EMPTY_OBJECT), this.componentDatatype = e.componentDatatype, this.componentsPerAttribute = e.componentsPerAttribute, this.normalize = p(e.normalize, !1), this.values = e.values
}

function Va(e) {
    e = p(e, p.EMPTY_OBJECT), this.position = e.position, this.normal = e.normal, this.st = e.st, this.bitangent = e.bitangent, this.tangent = e.tangent, this.color = e.color
}
var HD = {
    NONE: 0,
    TOP: 1,
    ALL: 2
};
const Di = Object.freeze(HD);
var kD = new u;

function si(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.minimum,
        n = e.maximum;
    this._min = u.clone(t), this._max = u.clone(n), this._offsetAttribute = e.offsetAttribute, this._workerName = "createBoxOutlineGeometry"
}
si.fromDimensions = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.dimensions,
        n = u.multiplyByScalar(t, .5, new u);
    return new si({
        minimum: u.negate(n, new u),
        maximum: n,
        offsetAttribute: e.offsetAttribute
    })
};
si.fromAxisAlignedBoundingBox = function(e) {
    return new si({
        minimum: e.minimum,
        maximum: e.maximum
    })
};
si.packedLength = 2 * u.packedLength + 1;
si.pack = function(e, t, n) {
    return n = p(n, 0), u.pack(e._min, t, n), u.pack(e._max, t, n + u.packedLength), t[n + u.packedLength * 2] = p(e._offsetAttribute, -1), t
};
var jg = new u,
    Zg = new u,
    Ev = {
        minimum: jg,
        maximum: Zg,
        offsetAttribute: void 0
    };
si.unpack = function(e, t, n) {
    t = p(t, 0);
    var r = u.unpack(e, t, jg),
        i = u.unpack(e, t + u.packedLength, Zg),
        a = e[t + u.packedLength * 2];
    return l(n) ? (n._min = u.clone(r, n._min), n._max = u.clone(i, n._max), n._offsetAttribute = a === -1 ? void 0 : a, n) : (Ev.offsetAttribute = a === -1 ? void 0 : a, new si(Ev))
};
si.createGeometry = function(e) {
    var t = e._min,
        n = e._max;
    if (!u.equals(t, n)) {
        var r = new Va,
            i = new Uint16Array(12 * 2),
            a = new Float64Array(8 * 3);
        a[0] = t.x, a[1] = t.y, a[2] = t.z, a[3] = n.x, a[4] = t.y, a[5] = t.z, a[6] = n.x, a[7] = n.y, a[8] = t.z, a[9] = t.x, a[10] = n.y, a[11] = t.z, a[12] = t.x, a[13] = t.y, a[14] = n.z, a[15] = n.x, a[16] = t.y, a[17] = n.z, a[18] = n.x, a[19] = n.y, a[20] = n.z, a[21] = t.x, a[22] = n.y, a[23] = n.z, r.position = new ze({
            componentDatatype: ee.DOUBLE,
            componentsPerAttribute: 3,
            values: a
        }), i[0] = 4, i[1] = 5, i[2] = 5, i[3] = 6, i[4] = 6, i[5] = 7, i[6] = 7, i[7] = 4, i[8] = 0, i[9] = 1, i[10] = 1, i[11] = 2, i[12] = 2, i[13] = 3, i[14] = 3, i[15] = 0, i[16] = 0, i[17] = 4, i[18] = 1, i[19] = 5, i[20] = 2, i[21] = 6, i[22] = 3, i[23] = 7;
        var o = u.subtract(n, t, kD),
            s = u.magnitude(o) * .5;
        if (l(e._offsetAttribute)) {
            var c = a.length,
                f = new Uint8Array(c / 3),
                h = e._offsetAttribute === Di.NONE ? 0 : 1;
            Ri(f, h), r.applyOffset = new ze({
                componentDatatype: ee.UNSIGNED_BYTE,
                componentsPerAttribute: 1,
                values: f
            })
        }
        return new rt({
            attributes: r,
            indices: i,
            primitiveType: Ve.LINES,
            boundingSphere: new q(u.ZERO, s),
            offsetAttribute: e._offsetAttribute
        })
    }
};

function ui(e, t, n, r) {
    e = p(e, 1), t = p(t, 1), n = p(n, 1), r = p(r, 1), this.value = new Uint8Array([H.floatToByte(e), H.floatToByte(t), H.floatToByte(n), H.floatToByte(r)])
}
Object.defineProperties(ui.prototype, {
    componentDatatype: {
        get: function() {
            return ee.UNSIGNED_BYTE
        }
    },
    componentsPerAttribute: {
        get: function() {
            return 4
        }
    },
    normalize: {
        get: function() {
            return !0
        }
    }
});
ui.fromColor = function(e) {
    return new ui(e.red, e.green, e.blue, e.alpha)
};
ui.toValue = function(e, t) {
    return l(t) ? e.toBytes(t) : new Uint8Array(e.toBytes())
};
ui.equals = function(e, t) {
    return e === t || l(e) && l(t) && e.value[0] === t.value[0] && e.value[1] === t.value[1] && e.value[2] === t.value[2] && e.value[3] === t.value[3]
};

function ws(e) {
    e = p(e, p.EMPTY_OBJECT), this.geometry = e.geometry, this.modelMatrix = S.clone(p(e.modelMatrix, S.IDENTITY)), this.id = e.id, this.pickPrimitive = e.pickPrimitive, this.attributes = p(e.attributes, {}), this.westHemisphereGeometry = void 0, this.eastHemisphereGeometry = void 0
}
var Av = new u,
    Cv = new u,
    wv = new u;

function WD(e, t, n, r, i) {
    l(i) || (i = new u);
    var a, o, s, c, f, h, d, _;
    if (l(t.z)) {
        if (u.equalsEpsilon(e, t, T.EPSILON14)) return u.clone(u.UNIT_X, i);
        if (u.equalsEpsilon(e, n, T.EPSILON14)) return u.clone(u.UNIT_Y, i);
        if (u.equalsEpsilon(e, r, T.EPSILON14)) return u.clone(u.UNIT_Z, i);
        a = u.subtract(n, t, Av), o = u.subtract(r, t, Cv), s = u.subtract(e, t, wv), c = u.dot(a, a), f = u.dot(a, o), h = u.dot(a, s), d = u.dot(o, o), _ = u.dot(o, s)
    } else {
        if (R.equalsEpsilon(e, t, T.EPSILON14)) return u.clone(u.UNIT_X, i);
        if (R.equalsEpsilon(e, n, T.EPSILON14)) return u.clone(u.UNIT_Y, i);
        if (R.equalsEpsilon(e, r, T.EPSILON14)) return u.clone(u.UNIT_Z, i);
        a = R.subtract(n, t, Av), o = R.subtract(r, t, Cv), s = R.subtract(e, t, wv), c = R.dot(a, a), f = R.dot(a, o), h = R.dot(a, s), d = R.dot(o, o), _ = R.dot(o, s)
    }
    i.y = d * h - f * _, i.z = c * _ - f * h;
    var v = c * d - f * f;
    return i.y !== 0 && (i.y /= v), i.z !== 0 && (i.z /= v), i.x = 1 - i.y - i.z, i
}
var Rd = {};
Rd.calculateACMR = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.indices,
        n = e.maximumIndex,
        r = p(e.cacheSize, 24),
        i = t.length;
    if (!l(n)) {
        n = 0;
        for (var a = 0, o = t[a]; a < i;) o > n && (n = o), ++a, o = t[a]
    }
    for (var s = [], c = 0; c < n + 1; c++) s[c] = 0;
    for (var f = r + 1, h = 0; h < i; ++h) f - s[t[h]] > r && (s[t[h]] = f, ++f);
    return (f - r + 1) / (i / 3)
};
Rd.tipsify = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.indices,
        n = e.maximumIndex,
        r = p(e.cacheSize, 24),
        i;

    function a(M, G, V, B) {
        for (; G.length >= 1;) {
            var Y = G[G.length - 1];
            if (G.splice(G.length - 1, 1), M[Y].numLiveTriangles > 0) return Y
        }
        for (; i < B;) {
            if (M[i].numLiveTriangles > 0) return ++i, i - 1;
            ++i
        }
        return -1
    }

    function o(M, G, V, B, Y, j, Z) {
        for (var Q = -1, ie, Ae = -1, re = 0; re < V.length;) {
            var ve = V[re];
            B[ve].numLiveTriangles && (ie = 0, Y - B[ve].timeStamp + 2 * B[ve].numLiveTriangles <= G && (ie = Y - B[ve].timeStamp), (ie > Ae || Ae === -1) && (Ae = ie, Q = ve)), ++re
        }
        return Q === -1 ? a(B, j, M, Z) : Q
    }
    var s = t.length,
        c = 0,
        f = 0,
        h = t[f],
        d = s;
    if (l(n)) c = n + 1;
    else {
        for (; f < d;) h > c && (c = h), ++f, h = t[f];
        if (c === -1) return 0;
        ++c
    }
    var _ = [],
        v;
    for (v = 0; v < c; v++) _[v] = {
        numLiveTriangles: 0,
        timeStamp: 0,
        vertexTriangles: []
    };
    f = 0;
    for (var m = 0; f < d;) _[t[f]].vertexTriangles.push(m), ++_[t[f]].numLiveTriangles, _[t[f + 1]].vertexTriangles.push(m), ++_[t[f + 1]].numLiveTriangles, _[t[f + 2]].vertexTriangles.push(m), ++_[t[f + 2]].numLiveTriangles, ++m, f += 3;
    var g = 0,
        y = r + 1;
    i = 1;
    var E = [],
        w = [],
        C, A, x = 0,
        P = [],
        I = s / 3,
        D = [];
    for (v = 0; v < I; v++) D[v] = !1;
    for (var O, F; g !== -1;) {
        E = [], A = _[g], F = A.vertexTriangles.length;
        for (var z = 0; z < F; ++z)
            if (m = A.vertexTriangles[z], !D[m]) {
                D[m] = !0, f = m + m + m;
                for (var b = 0; b < 3; ++b) O = t[f], E.push(O), w.push(O), P[x] = O, ++x, C = _[O], --C.numLiveTriangles, y - C.timeStamp > r && (C.timeStamp = y, ++y), ++f
            }
        g = o(t, r, E, _, y, w, c)
    }
    return P
};
var Qe = {};

function Nc(e, t, n, r, i) {
    e[t++] = n, e[t++] = r, e[t++] = r, e[t++] = i, e[t++] = i, e[t] = n
}

function qD(e) {
    for (var t = e.length, n = t / 3 * 6, r = yt.createTypedArray(t, n), i = 0, a = 0; a < t; a += 3, i += 6) Nc(r, i, e[a], e[a + 1], e[a + 2]);
    return r
}

function YD(e) {
    var t = e.length;
    if (t >= 3) {
        var n = (t - 2) * 6,
            r = yt.createTypedArray(t, n);
        Nc(r, 0, e[0], e[1], e[2]);
        for (var i = 6, a = 3; a < t; ++a, i += 6) Nc(r, i, e[a - 1], e[a], e[a - 2]);
        return r
    }
    return new Uint16Array
}

function XD(e) {
    if (e.length > 0) {
        for (var t = e.length - 1, n = (t - 1) * 6, r = yt.createTypedArray(t, n), i = e[0], a = 0, o = 1; o < t; ++o, a += 6) Nc(r, a, i, e[o], e[o + 1]);
        return r
    }
    return new Uint16Array
}
Qe.toWireframe = function(e) {
    var t = e.indices;
    if (l(t)) {
        switch (e.primitiveType) {
            case Ve.TRIANGLES:
                e.indices = qD(t);
                break;
            case Ve.TRIANGLE_STRIP:
                e.indices = YD(t);
                break;
            case Ve.TRIANGLE_FAN:
                e.indices = XD(t);
                break
        }
        e.primitiveType = Ve.LINES
    }
    return e
};
Qe.createLineSegmentsForVectors = function(e, t, n) {
    t = p(t, "normal"), n = p(n, 1e4);
    for (var r = e.attributes.position.values, i = e.attributes[t].values, a = r.length, o = new Float64Array(2 * a), s = 0, c = 0; c < a; c += 3) o[s++] = r[c], o[s++] = r[c + 1], o[s++] = r[c + 2], o[s++] = r[c] + i[c] * n, o[s++] = r[c + 1] + i[c + 1] * n, o[s++] = r[c + 2] + i[c + 2] * n;
    var f, h = e.boundingSphere;
    return l(h) && (f = new q(h.center, h.radius + n)), new rt({
        attributes: {
            position: new ze({
                componentDatatype: ee.DOUBLE,
                componentsPerAttribute: 3,
                values: o
            })
        },
        primitiveType: Ve.LINES,
        boundingSphere: f
    })
};
Qe.createAttributeLocations = function(e) {
    var t = ["position", "positionHigh", "positionLow", "position3DHigh", "position3DLow", "position2DHigh", "position2DLow", "pickColor", "normal", "st", "tangent", "bitangent", "extrudeDirection", "compressedAttributes"],
        n = e.attributes,
        r = {},
        i = 0,
        a, o = t.length;
    for (a = 0; a < o; ++a) {
        var s = t[a];
        l(n[s]) && (r[s] = i++)
    }
    for (var c in n) n.hasOwnProperty(c) && !l(r[c]) && (r[c] = i++);
    return r
};
Qe.reorderForPreVertexCache = function(e) {
    var t = rt.computeNumberOfVertices(e),
        n = e.indices;
    if (l(n)) {
        for (var r = new Int32Array(t), i = 0; i < t; i++) r[i] = -1;
        for (var a = n, o = a.length, s = yt.createTypedArray(t, o), c = 0, f = 0, h = 0, d; c < o;) d = r[a[c]], d !== -1 ? s[f] = d : (d = a[c], r[d] = h, s[f] = h, ++h), ++c, ++f;
        e.indices = s;
        var _ = e.attributes;
        for (var v in _)
            if (_.hasOwnProperty(v) && l(_[v]) && l(_[v].values)) {
                for (var m = _[v], g = m.values, y = 0, E = m.componentsPerAttribute, w = ee.createTypedArray(m.componentDatatype, h * E); y < t;) {
                    var C = r[y];
                    if (C !== -1)
                        for (var A = 0; A < E; A++) w[E * C + A] = g[E * y + A];
                    ++y
                }
                m.values = w
            }
    }
    return e
};
Qe.reorderForPostVertexCache = function(e, t) {
    var n = e.indices;
    if (e.primitiveType === Ve.TRIANGLES && l(n)) {
        for (var r = n.length, i = 0, a = 0; a < r; a++) n[a] > i && (i = n[a]);
        e.indices = Rd.tipsify({
            indices: n,
            maximumIndex: i,
            cacheSize: t
        })
    }
    return e
};

function xv(e) {
    var t = {};
    for (var n in e)
        if (e.hasOwnProperty(n) && l(e[n]) && l(e[n].values)) {
            var r = e[n];
            t[n] = new ze({
                componentDatatype: r.componentDatatype,
                componentsPerAttribute: r.componentsPerAttribute,
                normalize: r.normalize,
                values: []
            })
        }
    return t
}

function jD(e, t, n) {
    for (var r in t)
        if (t.hasOwnProperty(r) && l(t[r]) && l(t[r].values))
            for (var i = t[r], a = 0; a < i.componentsPerAttribute; ++a) e[r].values.push(i.values[n * i.componentsPerAttribute + a])
}
Qe.fitToUnsignedShortIndices = function(e) {
    var t = [],
        n = rt.computeNumberOfVertices(e);
    if (l(e.indices) && n >= T.SIXTY_FOUR_KILOBYTES) {
        var r = [],
            i = [],
            a = 0,
            o = xv(e.attributes),
            s = e.indices,
            c = s.length,
            f;
        e.primitiveType === Ve.TRIANGLES ? f = 3 : e.primitiveType === Ve.LINES ? f = 2 : e.primitiveType === Ve.POINTS && (f = 1);
        for (var h = 0; h < c; h += f) {
            for (var d = 0; d < f; ++d) {
                var _ = s[h + d],
                    v = r[_];
                l(v) || (v = a++, r[_] = v, jD(o, e.attributes, _)), i.push(v)
            }
            a + f >= T.SIXTY_FOUR_KILOBYTES && (t.push(new rt({
                attributes: o,
                indices: i,
                primitiveType: e.primitiveType,
                boundingSphere: e.boundingSphere,
                boundingSphereCV: e.boundingSphereCV
            })), r = [], i = [], a = 0, o = xv(e.attributes))
        }
        i.length !== 0 && t.push(new rt({
            attributes: o,
            indices: i,
            primitiveType: e.primitiveType,
            boundingSphere: e.boundingSphere,
            boundingSphereCV: e.boundingSphereCV
        }))
    } else t.push(e);
    return t
};
var Sv = new u,
    ZD = new K;
Qe.projectTo2D = function(e, t, n, r, i) {
    var a = e.attributes[t];
    i = l(i) ? i : new un;
    for (var o = i.ellipsoid, s = a.values, c = new Float64Array(s.length), f = 0, h = 0; h < s.length; h += 3) {
        var d = u.fromArray(s, h, Sv),
            _ = o.cartesianToCartographic(d, ZD),
            v = i.project(_, Sv);
        c[f++] = v.x, c[f++] = v.y, c[f++] = v.z
    }
    return e.attributes[n] = a, e.attributes[r] = new ze({
        componentDatatype: ee.DOUBLE,
        componentsPerAttribute: 3,
        values: c
    }), delete e.attributes[t], e
};
var fh = {
    high: 0,
    low: 0
};
Qe.encodeAttribute = function(e, t, n, r) {
    for (var i = e.attributes[t], a = i.values, o = a.length, s = new Float32Array(o), c = new Float32Array(o), f = 0; f < o; ++f) rn.encode(a[f], fh), s[f] = fh.high, c[f] = fh.low;
    var h = i.componentsPerAttribute;
    return e.attributes[n] = new ze({
        componentDatatype: ee.FLOAT,
        componentsPerAttribute: h,
        values: s
    }), e.attributes[r] = new ze({
        componentDatatype: ee.FLOAT,
        componentsPerAttribute: h,
        values: c
    }), delete e.attributes[t], e
};
var Fr = new u;

function hh(e, t) {
    if (l(t))
        for (var n = t.values, r = n.length, i = 0; i < r; i += 3) u.unpack(n, i, Fr), S.multiplyByPoint(e, Fr, Fr), u.pack(Fr, n, i)
}

function lh(e, t) {
    if (l(t))
        for (var n = t.values, r = n.length, i = 0; i < r; i += 3) u.unpack(n, i, Fr), N.multiplyByVector(e, Fr, Fr), Fr = u.normalize(Fr, Fr), u.pack(Fr, n, i)
}
var yu = new S,
    Tu = new N;
Qe.transformToWorldCoordinates = function(e) {
    var t = e.modelMatrix;
    if (S.equals(t, S.IDENTITY)) return e;
    var n = e.geometry.attributes;
    hh(t, n.position), hh(t, n.prevPosition), hh(t, n.nextPosition), (l(n.normal) || l(n.tangent) || l(n.bitangent)) && (S.inverse(t, yu), S.transpose(yu, yu), S.getMatrix3(yu, Tu), lh(Tu, n.normal), lh(Tu, n.tangent), lh(Tu, n.bitangent));
    var r = e.geometry.boundingSphere;
    return l(r) && (e.geometry.boundingSphere = q.transform(r, t, r)), e.modelMatrix = S.clone(S.IDENTITY), e
};

function KD(e, t) {
    var n = e.length,
        r = {},
        i = e[0][t].attributes,
        a;
    for (a in i)
        if (i.hasOwnProperty(a) && l(i[a]) && l(i[a].values)) {
            for (var o = i[a], s = o.values.length, c = !0, f = 1; f < n; ++f) {
                var h = e[f][t].attributes[a];
                if (!l(h) || o.componentDatatype !== h.componentDatatype || o.componentsPerAttribute !== h.componentsPerAttribute || o.normalize !== h.normalize) {
                    c = !1;
                    break
                }
                s += h.values.length
            }
            c && (r[a] = new ze({
                componentDatatype: o.componentDatatype,
                componentsPerAttribute: o.componentsPerAttribute,
                normalize: o.normalize,
                values: ee.createTypedArray(o.componentDatatype, s)
            }))
        }
    return r
}
var $D = new u;

function dh(e, t) {
    var n = e.length,
        r, i, a, o;
    e[0].modelMatrix;
    var s = l(e[0][t].indices),
        c = e[0][t].primitiveType,
        f = KD(e, t),
        h, d, _;
    for (r in f)
        if (f.hasOwnProperty(r))
            for (h = f[r].values, o = 0, i = 0; i < n; ++i)
                for (d = e[i][t].attributes[r].values, _ = d.length, a = 0; a < _; ++a) h[o++] = d[a];
    var v;
    if (s) {
        var m = 0;
        for (i = 0; i < n; ++i) m += e[i][t].indices.length;
        var g = rt.computeNumberOfVertices(new rt({
                attributes: f,
                primitiveType: Ve.POINTS
            })),
            y = yt.createTypedArray(g, m),
            E = 0,
            w = 0;
        for (i = 0; i < n; ++i) {
            var C = e[i][t].indices,
                A = C.length;
            for (o = 0; o < A; ++o) y[E++] = w + C[o];
            w += rt.computeNumberOfVertices(e[i][t])
        }
        v = y
    }
    var x = new u,
        P = 0,
        I;
    for (i = 0; i < n; ++i) {
        if (I = e[i][t].boundingSphere, !l(I)) {
            x = void 0;
            break
        }
        u.add(I.center, x, x)
    }
    if (l(x))
        for (u.divideByScalar(x, n, x), i = 0; i < n; ++i) {
            I = e[i][t].boundingSphere;
            var D = u.magnitude(u.subtract(I.center, x, $D)) + I.radius;
            D > P && (P = D)
        }
    return new rt({
        attributes: f,
        indices: v,
        primitiveType: c,
        boundingSphere: l(x) ? new q(x, P) : void 0
    })
}
Qe.combineInstances = function(e) {
    for (var t = [], n = [], r = e.length, i = 0; i < r; ++i) {
        var a = e[i];
        l(a.geometry) ? t.push(a) : l(a.westHemisphereGeometry) && l(a.eastHemisphereGeometry) && n.push(a)
    }
    var o = [];
    return t.length > 0 && o.push(dh(t, "geometry")), n.length > 0 && (o.push(dh(n, "westHemisphereGeometry")), o.push(dh(n, "eastHemisphereGeometry"))), o
};
var hr = new u,
    ts = new u,
    io = new u,
    ao = new u;
Qe.computeNormal = function(e) {
    var t = e.indices,
        n = e.attributes,
        r = n.position.values,
        i = n.position.values.length / 3,
        a = t.length,
        o = new Array(i),
        s = new Array(a / 3),
        c = new Array(a),
        f;
    for (f = 0; f < i; f++) o[f] = {
        indexOffset: 0,
        count: 0,
        currentCount: 0
    };
    var h = 0;
    for (f = 0; f < a; f += 3) {
        var d = t[f],
            _ = t[f + 1],
            v = t[f + 2],
            m = d * 3,
            g = _ * 3,
            y = v * 3;
        ts.x = r[m], ts.y = r[m + 1], ts.z = r[m + 2], io.x = r[g], io.y = r[g + 1], io.z = r[g + 2], ao.x = r[y], ao.y = r[y + 1], ao.z = r[y + 2], o[d].count++, o[_].count++, o[v].count++, u.subtract(io, ts, io), u.subtract(ao, ts, ao), s[h] = u.cross(io, ao, new u), h++
    }
    var E = 0;
    for (f = 0; f < i; f++) o[f].indexOffset += E, E += o[f].count;
    h = 0;
    var w;
    for (f = 0; f < a; f += 3) {
        w = o[t[f]];
        var C = w.indexOffset + w.currentCount;
        c[C] = h, w.currentCount++, w = o[t[f + 1]], C = w.indexOffset + w.currentCount, c[C] = h, w.currentCount++, w = o[t[f + 2]], C = w.indexOffset + w.currentCount, c[C] = h, w.currentCount++, h++
    }
    var A = new Float32Array(i * 3);
    for (f = 0; f < i; f++) {
        var x = f * 3;
        if (w = o[f], u.clone(u.ZERO, hr), w.count > 0) {
            for (h = 0; h < w.count; h++) u.add(hr, s[c[w.indexOffset + h]], hr);
            u.equalsEpsilon(u.ZERO, hr, T.EPSILON10) && u.clone(s[c[w.indexOffset]], hr)
        }
        u.equalsEpsilon(u.ZERO, hr, T.EPSILON10) && (hr.z = 1), u.normalize(hr, hr), A[x] = hr.x, A[x + 1] = hr.y, A[x + 2] = hr.z
    }
    return e.attributes.normal = new ze({
        componentDatatype: ee.FLOAT,
        componentsPerAttribute: 3,
        values: A
    }), e
};
var JD = new u,
    Rv = new u,
    QD = new u;
Qe.computeTangentAndBitangent = function(e) {
    e.attributes;
    var t = e.indices,
        n = e.attributes.position.values,
        r = e.attributes.normal.values,
        i = e.attributes.st.values,
        a = e.attributes.position.values.length / 3,
        o = t.length,
        s = new Array(a * 3),
        c;
    for (c = 0; c < s.length; c++) s[c] = 0;
    var f, h, d;
    for (c = 0; c < o; c += 3) {
        var _ = t[c],
            v = t[c + 1],
            m = t[c + 2];
        f = _ * 3, h = v * 3, d = m * 3;
        var g = _ * 2,
            y = v * 2,
            E = m * 2,
            w = n[f],
            C = n[f + 1],
            A = n[f + 2],
            x = i[g],
            P = i[g + 1],
            I = i[y + 1] - P,
            D = i[E + 1] - P,
            O = 1 / ((i[y] - x) * D - (i[E] - x) * I),
            F = (D * (n[h] - w) - I * (n[d] - w)) * O,
            z = (D * (n[h + 1] - C) - I * (n[d + 1] - C)) * O,
            b = (D * (n[h + 2] - A) - I * (n[d + 2] - A)) * O;
        s[f] += F, s[f + 1] += z, s[f + 2] += b, s[h] += F, s[h + 1] += z, s[h + 2] += b, s[d] += F, s[d + 1] += z, s[d + 2] += b
    }
    var M = new Float32Array(a * 3),
        G = new Float32Array(a * 3);
    for (c = 0; c < a; c++) {
        f = c * 3, h = f + 1, d = f + 2;
        var V = u.fromArray(r, f, JD),
            B = u.fromArray(s, f, QD),
            Y = u.dot(V, B);
        u.multiplyByScalar(V, Y, Rv), u.normalize(u.subtract(B, Rv, B), B), M[f] = B.x, M[h] = B.y, M[d] = B.z, u.normalize(u.cross(V, B, B), B), G[f] = B.x, G[h] = B.y, G[d] = B.z
    }
    return e.attributes.tangent = new ze({
        componentDatatype: ee.FLOAT,
        componentsPerAttribute: 3,
        values: M
    }), e.attributes.bitangent = new ze({
        componentDatatype: ee.FLOAT,
        componentsPerAttribute: 3,
        values: G
    }), e
};
var ns = new R,
    Pr = new u,
    Dv = new u,
    Iv = new u,
    Eu = new R;
Qe.compressVertices = function(e) {
    var t = e.attributes.extrudeDirection,
        n, r;
    if (l(t)) {
        var i = t.values;
        r = i.length / 3;
        var a = new Float32Array(r * 2),
            o = 0;
        for (n = 0; n < r; ++n) {
            if (u.fromArray(i, n * 3, Pr), u.equals(Pr, u.ZERO)) {
                o += 2;
                continue
            }
            Eu = Ee.octEncodeInRange(Pr, 65535, Eu), a[o++] = Eu.x, a[o++] = Eu.y
        }
        return e.attributes.compressedAttributes = new ze({
            componentDatatype: ee.FLOAT,
            componentsPerAttribute: 2,
            values: a
        }), delete e.attributes.extrudeDirection, e
    }
    var s = e.attributes.normal,
        c = e.attributes.st,
        f = l(s),
        h = l(c);
    if (!f && !h) return e;
    var d = e.attributes.tangent,
        _ = e.attributes.bitangent,
        v = l(d),
        m = l(_),
        g, y, E, w;
    f && (g = s.values), h && (y = c.values), v && (E = d.values), m && (w = _.values);
    var C = f ? g.length : y.length,
        A = f ? 3 : 2;
    r = C / A;
    var x = r,
        P = h && f ? 2 : 1;
    P += v || m ? 1 : 0, x *= P;
    var I = new Float32Array(x),
        D = 0;
    for (n = 0; n < r; ++n) {
        h && (R.fromArray(y, n * 2, ns), I[D++] = Ee.compressTextureCoordinates(ns));
        var O = n * 3;
        f && l(E) && l(w) ? (u.fromArray(g, O, Pr), u.fromArray(E, O, Dv), u.fromArray(w, O, Iv), Ee.octPack(Pr, Dv, Iv, ns), I[D++] = ns.x, I[D++] = ns.y) : (f && (u.fromArray(g, O, Pr), I[D++] = Ee.octEncodeFloat(Pr)), v && (u.fromArray(E, O, Pr), I[D++] = Ee.octEncodeFloat(Pr)), m && (u.fromArray(w, O, Pr), I[D++] = Ee.octEncodeFloat(Pr)))
    }
    return e.attributes.compressedAttributes = new ze({
        componentDatatype: ee.FLOAT,
        componentsPerAttribute: P,
        values: I
    }), f && delete e.attributes.normal, h && delete e.attributes.st, m && delete e.attributes.bitangent, v && delete e.attributes.tangent, e
};

function eI(e) {
    if (l(e.indices)) return e;
    for (var t = rt.computeNumberOfVertices(e), n = yt.createTypedArray(t, t), r = 0; r < t; ++r) n[r] = r;
    return e.indices = n, e
}

function tI(e) {
    var t = rt.computeNumberOfVertices(e),
        n = yt.createTypedArray(t, (t - 2) * 3);
    n[0] = 1, n[1] = 0, n[2] = 2;
    for (var r = 3, i = 3; i < t; ++i) n[r++] = i - 1, n[r++] = 0, n[r++] = i;
    return e.indices = n, e.primitiveType = Ve.TRIANGLES, e
}

function nI(e) {
    var t = rt.computeNumberOfVertices(e),
        n = yt.createTypedArray(t, (t - 2) * 3);
    n[0] = 0, n[1] = 1, n[2] = 2, t > 3 && (n[3] = 0, n[4] = 2, n[5] = 3);
    for (var r = 6, i = 3; i < t - 1; i += 2) n[r++] = i, n[r++] = i - 1, n[r++] = i + 1, i + 2 < t && (n[r++] = i, n[r++] = i + 1, n[r++] = i + 2);
    return e.indices = n, e.primitiveType = Ve.TRIANGLES, e
}

function rI(e) {
    if (l(e.indices)) return e;
    for (var t = rt.computeNumberOfVertices(e), n = yt.createTypedArray(t, t), r = 0; r < t; ++r) n[r] = r;
    return e.indices = n, e
}

function iI(e) {
    var t = rt.computeNumberOfVertices(e),
        n = yt.createTypedArray(t, (t - 1) * 2);
    n[0] = 0, n[1] = 1;
    for (var r = 2, i = 2; i < t; ++i) n[r++] = i - 1, n[r++] = i;
    return e.indices = n, e.primitiveType = Ve.LINES, e
}

function aI(e) {
    var t = rt.computeNumberOfVertices(e),
        n = yt.createTypedArray(t, t * 2);
    n[0] = 0, n[1] = 1;
    for (var r = 2, i = 2; i < t; ++i) n[r++] = i - 1, n[r++] = i;
    return n[r++] = t - 1, n[r] = 0, e.indices = n, e.primitiveType = Ve.LINES, e
}

function oI(e) {
    switch (e.primitiveType) {
        case Ve.TRIANGLE_FAN:
            return tI(e);
        case Ve.TRIANGLE_STRIP:
            return nI(e);
        case Ve.TRIANGLES:
            return eI(e);
        case Ve.LINE_STRIP:
            return iI(e);
        case Ve.LINE_LOOP:
            return aI(e);
        case Ve.LINES:
            return rI(e)
    }
    return e
}

function Wi(e, t) {
    Math.abs(e.y) < T.EPSILON6 && (t ? e.y = -T.EPSILON6 : e.y = T.EPSILON6)
}

function sI(e, t, n) {
    if (e.y !== 0 && t.y !== 0 && n.y !== 0) {
        Wi(e, e.y < 0), Wi(t, t.y < 0), Wi(n, n.y < 0);
        return
    }
    var r = Math.abs(e.y),
        i = Math.abs(t.y),
        a = Math.abs(n.y),
        o;
    r > i ? r > a ? o = T.sign(e.y) : o = T.sign(n.y) : i > a ? o = T.sign(t.y) : o = T.sign(n.y);
    var s = o < 0;
    Wi(e, s), Wi(t, s), Wi(n, s)
}
var Pv = new u;

function lr(e, t, n, r) {
    u.add(e, u.multiplyByScalar(u.subtract(t, e, Pv), e.y / (e.y - t.y), Pv), n), u.clone(n, r), Wi(n, !0), Wi(r, !1)
}
var _a = new u,
    va = new u,
    ma = new u,
    pa = new u,
    _h = {
        positions: new Array(7),
        indices: new Array(3 * 3)
    };

function uI(e, t, n) {
    if (!(e.x >= 0 || t.x >= 0 || n.x >= 0)) {
        sI(e, t, n);
        var r = e.y < 0,
            i = t.y < 0,
            a = n.y < 0,
            o = 0;
        o += r ? 1 : 0, o += i ? 1 : 0, o += a ? 1 : 0;
        var s = _h.indices;
        o === 1 ? (s[1] = 3, s[2] = 4, s[5] = 6, s[7] = 6, s[8] = 5, r ? (lr(e, t, _a, ma), lr(e, n, va, pa), s[0] = 0, s[3] = 1, s[4] = 2, s[6] = 1) : i ? (lr(t, n, _a, ma), lr(t, e, va, pa), s[0] = 1, s[3] = 2, s[4] = 0, s[6] = 2) : a && (lr(n, e, _a, ma), lr(n, t, va, pa), s[0] = 2, s[3] = 0, s[4] = 1, s[6] = 0)) : o === 2 && (s[2] = 4, s[4] = 4, s[5] = 3, s[7] = 5, s[8] = 6, r ? i ? a || (lr(n, e, _a, ma), lr(n, t, va, pa), s[0] = 0, s[1] = 1, s[3] = 0, s[6] = 2) : (lr(t, n, _a, ma), lr(t, e, va, pa), s[0] = 2, s[1] = 0, s[3] = 2, s[6] = 1) : (lr(e, t, _a, ma), lr(e, n, va, pa), s[0] = 1, s[1] = 2, s[3] = 1, s[6] = 0));
        var c = _h.positions;
        return c[0] = e, c[1] = t, c[2] = n, c.length = 3, (o === 1 || o === 2) && (c[3] = _a, c[4] = va, c[5] = ma, c[6] = pa, c.length = 7), _h
    }
}

function Ov(e, t) {
    var n = e.attributes;
    if (n.position.values.length !== 0) {
        for (var r in n)
            if (n.hasOwnProperty(r) && l(n[r]) && l(n[r].values)) {
                var i = n[r];
                i.values = ee.createTypedArray(i.componentDatatype, i.values)
            }
        var a = rt.computeNumberOfVertices(e);
        return e.indices = yt.createTypedArray(a, e.indices), t && (e.boundingSphere = q.fromVertices(n.position.values)), e
    }
}

function Co(e) {
    var t = e.attributes,
        n = {};
    for (var r in t)
        if (t.hasOwnProperty(r) && l(t[r]) && l(t[r].values)) {
            var i = t[r];
            n[r] = new ze({
                componentDatatype: i.componentDatatype,
                componentsPerAttribute: i.componentsPerAttribute,
                normalize: i.normalize,
                values: []
            })
        }
    return new rt({
        attributes: n,
        indices: [],
        primitiveType: e.primitiveType
    })
}

function Dd(e, t, n) {
    var r = l(e.geometry.boundingSphere);
    t = Ov(t, r), n = Ov(n, r), l(n) && !l(t) ? e.geometry = n : !l(n) && l(t) ? e.geometry = t : (e.westHemisphereGeometry = t, e.eastHemisphereGeometry = n, e.geometry = void 0)
}

function Id(e, t) {
    var n = new e,
        r = new e,
        i = new e;
    return function(a, o, s, c, f, h, d, _) {
        var v = e.fromArray(f, a * t, n),
            m = e.fromArray(f, o * t, r),
            g = e.fromArray(f, s * t, i);
        e.multiplyByScalar(v, c.x, v), e.multiplyByScalar(m, c.y, m), e.multiplyByScalar(g, c.z, g);
        var y = e.add(v, m, v);
        e.add(y, g, y), _ && e.normalize(y, y), e.pack(y, h, d * t)
    }
}
var cI = Id(U, 4),
    fc = Id(u, 3),
    Kg = Id(R, 2),
    fI = function(e, t, n, r, i, a, o) {
        var s = i[e] * r.x,
            c = i[t] * r.y,
            f = i[n] * r.z;
        a[o] = s + c + f > T.EPSILON6 ? 1 : 0
    },
    ys = new u,
    pl = new u,
    gl = new u,
    hI = new u;

function Au(e, t, n, r, i, a, o, s, c, f, h, d, _, v, m, g) {
    if (!(!l(a) && !l(o) && !l(s) && !l(c) && !l(f) && v === 0)) {
        var y = u.fromArray(i, e * 3, ys),
            E = u.fromArray(i, t * 3, pl),
            w = u.fromArray(i, n * 3, gl),
            C = WD(r, y, E, w, hI);
        if (l(a) && fc(e, t, n, C, a, d.normal.values, g, !0), l(f)) {
            var A = u.fromArray(f, e * 3, ys),
                x = u.fromArray(f, t * 3, pl),
                P = u.fromArray(f, n * 3, gl);
            u.multiplyByScalar(A, C.x, A), u.multiplyByScalar(x, C.y, x), u.multiplyByScalar(P, C.z, P);
            var I;
            !u.equals(A, u.ZERO) || !u.equals(x, u.ZERO) || !u.equals(P, u.ZERO) ? (I = u.add(A, x, A), u.add(I, P, I), u.normalize(I, I)) : (I = ys, I.x = 0, I.y = 0, I.z = 0), u.pack(I, d.extrudeDirection.values, g * 3)
        }
        if (l(h) && fI(e, t, n, C, h, d.applyOffset.values, g), l(o) && fc(e, t, n, C, o, d.tangent.values, g, !0), l(s) && fc(e, t, n, C, s, d.bitangent.values, g, !0), l(c) && Kg(e, t, n, C, c, d.st.values, g), v > 0)
            for (var D = 0; D < v; D++) {
                var O = _[D];
                lI(e, t, n, C, g, m[O], d[O])
            }
    }
}

function lI(e, t, n, r, i, a, o) {
    var s = a.componentsPerAttribute,
        c = a.values,
        f = o.values;
    switch (s) {
        case 4:
            cI(e, t, n, r, c, f, i, !1);
            break;
        case 3:
            fc(e, t, n, r, c, f, i, !1);
            break;
        case 2:
            Kg(e, t, n, r, c, f, i, !1);
            break;
        default:
            f[i] = c[e] * r.x + c[t] * r.y + c[n] * r.z
    }
}

function $r(e, t, n, r, i, a) {
    var o = e.position.values.length / 3;
    if (i !== -1) {
        var s = r[i],
            c = n[s];
        return c === -1 ? (n[s] = o, e.position.values.push(a.x, a.y, a.z), t.push(o), o) : (t.push(c), c)
    }
    return e.position.values.push(a.x, a.y, a.z), t.push(o), o
}
var dI = {
    position: !0,
    normal: !0,
    bitangent: !0,
    tangent: !0,
    st: !0,
    extrudeDirection: !0,
    applyOffset: !0
};

function Mv(e) {
    var t = e.geometry,
        n = t.attributes,
        r = n.position.values,
        i = l(n.normal) ? n.normal.values : void 0,
        a = l(n.bitangent) ? n.bitangent.values : void 0,
        o = l(n.tangent) ? n.tangent.values : void 0,
        s = l(n.st) ? n.st.values : void 0,
        c = l(n.extrudeDirection) ? n.extrudeDirection.values : void 0,
        f = l(n.applyOffset) ? n.applyOffset.values : void 0,
        h = t.indices,
        d = [];
    for (var _ in n) n.hasOwnProperty(_) && !dI[_] && l(n[_]) && d.push(_);
    var v = d.length,
        m = Co(t),
        g = Co(t),
        y, E, w, C, A, x = [];
    x.length = r.length / 3;
    var P = [];
    for (P.length = r.length / 3, A = 0; A < x.length; ++A) x[A] = -1, P[A] = -1;
    var I = h.length;
    for (A = 0; A < I; A += 3) {
        var D = h[A],
            O = h[A + 1],
            F = h[A + 2],
            z = u.fromArray(r, D * 3),
            b = u.fromArray(r, O * 3),
            M = u.fromArray(r, F * 3),
            G = uI(z, b, M);
        if (l(G) && G.positions.length > 3)
            for (var V = G.positions, B = G.indices, Y = B.length, j = 0; j < Y; ++j) {
                var Z = B[j],
                    Q = V[Z];
                Q.y < 0 ? (y = g.attributes, E = g.indices, w = x) : (y = m.attributes, E = m.indices, w = P), C = $r(y, E, w, h, Z < 3 ? A + Z : -1, Q), Au(D, O, F, Q, r, i, o, a, s, c, f, y, d, v, n, C)
            } else l(G) && (z = G.positions[0], b = G.positions[1], M = G.positions[2]), z.y < 0 ? (y = g.attributes, E = g.indices, w = x) : (y = m.attributes, E = m.indices, w = P), C = $r(y, E, w, h, A, z), Au(D, O, F, z, r, i, o, a, s, c, f, y, d, v, n, C), C = $r(y, E, w, h, A + 1, b), Au(D, O, F, b, r, i, o, a, s, c, f, y, d, v, n, C), C = $r(y, E, w, h, A + 2, M), Au(D, O, F, M, r, i, o, a, s, c, f, y, d, v, n, C)
    }
    Dd(e, g, m)
}
var $g = Ne.fromPointNormal(u.ZERO, u.UNIT_Y),
    _I = new u,
    vI = new u;

function oo(e, t, n, r, i, a, o) {
    if (!!l(o)) {
        var s = u.fromArray(r, e * 3, ys);
        u.equalsEpsilon(s, n, T.EPSILON10) ? a.applyOffset.values[i] = o[e] : a.applyOffset.values[i] = o[t]
    }
}

function Nv(e) {
    var t = e.geometry,
        n = t.attributes,
        r = n.position.values,
        i = l(n.applyOffset) ? n.applyOffset.values : void 0,
        a = t.indices,
        o = Co(t),
        s = Co(t),
        c, f = a.length,
        h = [];
    h.length = r.length / 3;
    var d = [];
    for (d.length = r.length / 3, c = 0; c < h.length; ++c) h[c] = -1, d[c] = -1;
    for (c = 0; c < f; c += 2) {
        var _ = a[c],
            v = a[c + 1],
            m = u.fromArray(r, _ * 3, ys),
            g = u.fromArray(r, v * 3, pl),
            y;
        Math.abs(m.y) < T.EPSILON6 && (m.y < 0 ? m.y = -T.EPSILON6 : m.y = T.EPSILON6), Math.abs(g.y) < T.EPSILON6 && (g.y < 0 ? g.y = -T.EPSILON6 : g.y = T.EPSILON6);
        var E = o.attributes,
            w = o.indices,
            C = d,
            A = s.attributes,
            x = s.indices,
            P = h,
            I = Me.lineSegmentPlane(m, g, $g, gl);
        if (l(I)) {
            var D = u.multiplyByScalar(u.UNIT_Y, 5 * T.EPSILON9, _I);
            m.y < 0 && (u.negate(D, D), E = s.attributes, w = s.indices, C = h, A = o.attributes, x = o.indices, P = d);
            var O = u.add(I, D, vI);
            y = $r(E, w, C, a, c, m), oo(_, v, m, r, y, E, i), y = $r(E, w, C, a, -1, O), oo(_, v, O, r, y, E, i), u.negate(D, D), u.add(I, D, O), y = $r(A, x, P, a, -1, O), oo(_, v, O, r, y, A, i), y = $r(A, x, P, a, c + 1, g), oo(_, v, g, r, y, A, i)
        } else {
            var F, z, b;
            m.y < 0 ? (F = s.attributes, z = s.indices, b = h) : (F = o.attributes, z = o.indices, b = d), y = $r(F, z, b, a, c, m), oo(_, v, m, r, y, F, i), y = $r(F, z, b, a, c + 1, g), oo(_, v, g, r, y, F, i)
        }
    }
    Dd(e, s, o)
}
var bv = new R,
    mI = new R,
    Jg = new u,
    Qg = new u,
    yl = new u,
    pI = new u,
    gI = new u,
    yI = new u,
    Fv = new U;

function Lv(e) {
    for (var t = e.attributes, n = t.position.values, r = t.prevPosition.values, i = t.nextPosition.values, a = n.length, o = 0; o < a; o += 3) {
        var s = u.unpack(n, o, Jg);
        if (!(s.x > 0)) {
            var c = u.unpack(r, o, Qg);
            (s.y < 0 && c.y > 0 || s.y > 0 && c.y < 0) && (o - 3 > 0 ? (r[o] = n[o - 3], r[o + 1] = n[o - 2], r[o + 2] = n[o - 1]) : u.pack(s, r, o));
            var f = u.unpack(i, o, yl);
            (s.y < 0 && f.y > 0 || s.y > 0 && f.y < 0) && (o + 3 < a ? (i[o] = n[o + 3], i[o + 1] = n[o + 4], i[o + 2] = n[o + 5]) : u.pack(s, i, o))
        }
    }
}
var TI = 5 * T.EPSILON9,
    Cu = T.EPSILON6;

function EI(e) {
    var t = e.geometry,
        n = t.attributes,
        r = n.position.values,
        i = n.prevPosition.values,
        a = n.nextPosition.values,
        o = n.expandAndWidth.values,
        s = l(n.st) ? n.st.values : void 0,
        c = l(n.color) ? n.color.values : void 0,
        f = Co(t),
        h = Co(t),
        d, _, v, m = !1,
        g = r.length / 3;
    for (d = 0; d < g; d += 4) {
        var y = d,
            E = d + 2,
            w = u.fromArray(r, y * 3, Jg),
            C = u.fromArray(r, E * 3, Qg);
        if (Math.abs(w.y) < Cu)
            for (w.y = Cu * (C.y < 0 ? -1 : 1), r[d * 3 + 1] = w.y, r[(d + 1) * 3 + 1] = w.y, _ = y * 3; _ < y * 3 + 4 * 3; _ += 3) i[_] = r[d * 3], i[_ + 1] = r[d * 3 + 1], i[_ + 2] = r[d * 3 + 2];
        if (Math.abs(C.y) < Cu)
            for (C.y = Cu * (w.y < 0 ? -1 : 1), r[(d + 2) * 3 + 1] = C.y, r[(d + 3) * 3 + 1] = C.y, _ = y * 3; _ < y * 3 + 4 * 3; _ += 3) a[_] = r[(d + 2) * 3], a[_ + 1] = r[(d + 2) * 3 + 1], a[_ + 2] = r[(d + 2) * 3 + 2];
        var A = f.attributes,
            x = f.indices,
            P = h.attributes,
            I = h.indices,
            D = Me.lineSegmentPlane(w, C, $g, pI);
        if (l(D)) {
            m = !0;
            var O = u.multiplyByScalar(u.UNIT_Y, TI, gI);
            w.y < 0 && (u.negate(O, O), A = h.attributes, x = h.indices, P = f.attributes, I = f.indices);
            var F = u.add(D, O, yI);
            A.position.values.push(w.x, w.y, w.z, w.x, w.y, w.z), A.position.values.push(F.x, F.y, F.z), A.position.values.push(F.x, F.y, F.z), A.prevPosition.values.push(i[y * 3], i[y * 3 + 1], i[y * 3 + 2]), A.prevPosition.values.push(i[y * 3 + 3], i[y * 3 + 4], i[y * 3 + 5]), A.prevPosition.values.push(w.x, w.y, w.z, w.x, w.y, w.z), A.nextPosition.values.push(F.x, F.y, F.z), A.nextPosition.values.push(F.x, F.y, F.z), A.nextPosition.values.push(F.x, F.y, F.z), A.nextPosition.values.push(F.x, F.y, F.z), u.negate(O, O), u.add(D, O, F), P.position.values.push(F.x, F.y, F.z), P.position.values.push(F.x, F.y, F.z), P.position.values.push(C.x, C.y, C.z, C.x, C.y, C.z), P.prevPosition.values.push(F.x, F.y, F.z), P.prevPosition.values.push(F.x, F.y, F.z), P.prevPosition.values.push(F.x, F.y, F.z), P.prevPosition.values.push(F.x, F.y, F.z), P.nextPosition.values.push(C.x, C.y, C.z, C.x, C.y, C.z), P.nextPosition.values.push(a[E * 3], a[E * 3 + 1], a[E * 3 + 2]), P.nextPosition.values.push(a[E * 3 + 3], a[E * 3 + 4], a[E * 3 + 5]);
            var z = R.fromArray(o, y * 2, bv),
                b = Math.abs(z.y);
            A.expandAndWidth.values.push(-1, b, 1, b), A.expandAndWidth.values.push(-1, -b, 1, -b), P.expandAndWidth.values.push(-1, b, 1, b), P.expandAndWidth.values.push(-1, -b, 1, -b);
            var M = u.magnitudeSquared(u.subtract(D, w, yl));
            if (M /= u.magnitudeSquared(u.subtract(C, w, yl)), l(c)) {
                var G = U.fromArray(c, y * 4, Fv),
                    V = U.fromArray(c, E * 4, Fv),
                    B = T.lerp(G.x, V.x, M),
                    Y = T.lerp(G.y, V.y, M),
                    j = T.lerp(G.z, V.z, M),
                    Z = T.lerp(G.w, V.w, M);
                for (_ = y * 4; _ < y * 4 + 2 * 4; ++_) A.color.values.push(c[_]);
                for (A.color.values.push(B, Y, j, Z), A.color.values.push(B, Y, j, Z), P.color.values.push(B, Y, j, Z), P.color.values.push(B, Y, j, Z), _ = E * 4; _ < E * 4 + 2 * 4; ++_) P.color.values.push(c[_])
            }
            if (l(s)) {
                var Q = R.fromArray(s, y * 2, bv),
                    ie = R.fromArray(s, (d + 3) * 2, mI),
                    Ae = T.lerp(Q.x, ie.x, M);
                for (_ = y * 2; _ < y * 2 + 2 * 2; ++_) A.st.values.push(s[_]);
                for (A.st.values.push(Ae, Q.y), A.st.values.push(Ae, ie.y), P.st.values.push(Ae, Q.y), P.st.values.push(Ae, ie.y), _ = E * 2; _ < E * 2 + 2 * 2; ++_) P.st.values.push(s[_])
            }
            v = A.position.values.length / 3 - 4, x.push(v, v + 2, v + 1), x.push(v + 1, v + 2, v + 3), v = P.position.values.length / 3 - 4, I.push(v, v + 2, v + 1), I.push(v + 1, v + 2, v + 3)
        } else {
            var re, ve;
            for (w.y < 0 ? (re = h.attributes, ve = h.indices) : (re = f.attributes, ve = f.indices), re.position.values.push(w.x, w.y, w.z), re.position.values.push(w.x, w.y, w.z), re.position.values.push(C.x, C.y, C.z), re.position.values.push(C.x, C.y, C.z), _ = d * 3; _ < d * 3 + 4 * 3; ++_) re.prevPosition.values.push(i[_]), re.nextPosition.values.push(a[_]);
            for (_ = d * 2; _ < d * 2 + 4 * 2; ++_) re.expandAndWidth.values.push(o[_]), l(s) && re.st.values.push(s[_]);
            if (l(c))
                for (_ = d * 4; _ < d * 4 + 4 * 4; ++_) re.color.values.push(c[_]);
            v = re.position.values.length / 3 - 4, ve.push(v, v + 2, v + 1), ve.push(v + 1, v + 2, v + 3)
        }
    }
    m && (Lv(h), Lv(f)), Dd(e, h, f)
}
Qe.splitLongitude = function(e) {
    var t = e.geometry,
        n = t.boundingSphere;
    if (l(n)) {
        var r = n.center.x - n.radius;
        if (r > 0 || q.intersectPlane(n, Ne.ORIGIN_ZX_PLANE) !== nt.INTERSECTING) return e
    }
    if (t.geometryType !== hs.NONE) switch (t.geometryType) {
        case hs.POLYLINES:
            EI(e);
            break;
        case hs.TRIANGLES:
            Mv(e);
            break;
        case hs.LINES:
            Nv(e);
            break
    } else oI(t), t.primitiveType === Ve.TRIANGLES ? Mv(e) : t.primitiveType === Ve.LINES && Nv(e);
    return e
};
var AI = new u(1, 1, 1),
    wu = Math.cos,
    xu = Math.sin;

function yr(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = p(e.radii, AI),
        n = p(e.innerRadii, t),
        r = p(e.minimumClock, 0),
        i = p(e.maximumClock, T.TWO_PI),
        a = p(e.minimumCone, 0),
        o = p(e.maximumCone, T.PI),
        s = Math.round(p(e.stackPartitions, 10)),
        c = Math.round(p(e.slicePartitions, 8)),
        f = Math.round(p(e.subdivisions, 128));
    this._radii = u.clone(t), this._innerRadii = u.clone(n), this._minimumClock = r, this._maximumClock = i, this._minimumCone = a, this._maximumCone = o, this._stackPartitions = s, this._slicePartitions = c, this._subdivisions = f, this._offsetAttribute = e.offsetAttribute, this._workerName = "createEllipsoidOutlineGeometry"
}
yr.packedLength = 2 * u.packedLength + 8;
yr.pack = function(e, t, n) {
    return n = p(n, 0), u.pack(e._radii, t, n), n += u.packedLength, u.pack(e._innerRadii, t, n), n += u.packedLength, t[n++] = e._minimumClock, t[n++] = e._maximumClock, t[n++] = e._minimumCone, t[n++] = e._maximumCone, t[n++] = e._stackPartitions, t[n++] = e._slicePartitions, t[n++] = e._subdivisions, t[n] = p(e._offsetAttribute, -1), t
};
var ey = new u,
    ty = new u,
    Ti = {
        radii: ey,
        innerRadii: ty,
        minimumClock: void 0,
        maximumClock: void 0,
        minimumCone: void 0,
        maximumCone: void 0,
        stackPartitions: void 0,
        slicePartitions: void 0,
        subdivisions: void 0,
        offsetAttribute: void 0
    };
yr.unpack = function(e, t, n) {
    t = p(t, 0);
    var r = u.unpack(e, t, ey);
    t += u.packedLength;
    var i = u.unpack(e, t, ty);
    t += u.packedLength;
    var a = e[t++],
        o = e[t++],
        s = e[t++],
        c = e[t++],
        f = e[t++],
        h = e[t++],
        d = e[t++],
        _ = e[t];
    return l(n) ? (n._radii = u.clone(r, n._radii), n._innerRadii = u.clone(i, n._innerRadii), n._minimumClock = a, n._maximumClock = o, n._minimumCone = s, n._maximumCone = c, n._stackPartitions = f, n._slicePartitions = h, n._subdivisions = d, n._offsetAttribute = _ === -1 ? void 0 : _, n) : (Ti.minimumClock = a, Ti.maximumClock = o, Ti.minimumCone = s, Ti.maximumCone = c, Ti.stackPartitions = f, Ti.slicePartitions = h, Ti.subdivisions = d, Ti.offsetAttribute = _ === -1 ? void 0 : _, new yr(Ti))
};
yr.createGeometry = function(e) {
    var t = e._radii;
    if (!(t.x <= 0 || t.y <= 0 || t.z <= 0)) {
        var n = e._innerRadii;
        if (!(n.x <= 0 || n.y <= 0 || n.z <= 0)) {
            var r = e._minimumClock,
                i = e._maximumClock,
                a = e._minimumCone,
                o = e._maximumCone,
                s = e._subdivisions,
                c = ne.fromCartesian3(t),
                f = e._slicePartitions + 1,
                h = e._stackPartitions + 1;
            f = Math.round(f * Math.abs(i - r) / T.TWO_PI), h = Math.round(h * Math.abs(o - a) / T.PI), f < 2 && (f = 2), h < 2 && (h = 2);
            var d = 0,
                _ = 1,
                v = n.x !== t.x || n.y !== t.y || n.z !== t.z,
                m = !1,
                g = !1;
            v && (_ = 2, a > 0 && (m = !0, d += f), o < Math.PI && (g = !0, d += f));
            var y = s * _ * (h + f),
                E = new Float64Array(y * 3),
                w = 2 * (y + d - (f + h) * _),
                C = yt.createTypedArray(y, w),
                A, x, P, I, D = 0,
                O = new Array(h),
                F = new Array(h);
            for (A = 0; A < h; A++) I = a + A * (o - a) / (h - 1), O[A] = xu(I), F[A] = wu(I);
            var z = new Array(s),
                b = new Array(s);
            for (A = 0; A < s; A++) P = r + A * (i - r) / (s - 1), z[A] = xu(P), b[A] = wu(P);
            for (A = 0; A < h; A++)
                for (x = 0; x < s; x++) E[D++] = t.x * O[A] * b[x], E[D++] = t.y * O[A] * z[x], E[D++] = t.z * F[A];
            if (v)
                for (A = 0; A < h; A++)
                    for (x = 0; x < s; x++) E[D++] = n.x * O[A] * b[x], E[D++] = n.y * O[A] * z[x], E[D++] = n.z * F[A];
            for (O.length = s, F.length = s, A = 0; A < s; A++) I = a + A * (o - a) / (s - 1), O[A] = xu(I), F[A] = wu(I);
            for (z.length = f, b.length = f, A = 0; A < f; A++) P = r + A * (i - r) / (f - 1), z[A] = xu(P), b[A] = wu(P);
            for (A = 0; A < s; A++)
                for (x = 0; x < f; x++) E[D++] = t.x * O[A] * b[x], E[D++] = t.y * O[A] * z[x], E[D++] = t.z * F[A];
            if (v)
                for (A = 0; A < s; A++)
                    for (x = 0; x < f; x++) E[D++] = n.x * O[A] * b[x], E[D++] = n.y * O[A] * z[x], E[D++] = n.z * F[A];
            for (D = 0, A = 0; A < h * _; A++) {
                var M = A * s;
                for (x = 0; x < s - 1; x++) C[D++] = M + x, C[D++] = M + x + 1
            }
            var G = h * s * _;
            for (A = 0; A < f; A++)
                for (x = 0; x < s - 1; x++) C[D++] = G + A + x * f, C[D++] = G + A + (x + 1) * f;
            if (v)
                for (G = h * s * _ + f * s, A = 0; A < f; A++)
                    for (x = 0; x < s - 1; x++) C[D++] = G + A + x * f, C[D++] = G + A + (x + 1) * f;
            if (v) {
                var V = h * s * _,
                    B = V + s * f;
                if (m)
                    for (A = 0; A < f; A++) C[D++] = V + A, C[D++] = B + A;
                if (g)
                    for (V += s * f - f, B += s * f - f, A = 0; A < f; A++) C[D++] = V + A, C[D++] = B + A
            }
            var Y = new Va({
                position: new ze({
                    componentDatatype: ee.DOUBLE,
                    componentsPerAttribute: 3,
                    values: E
                })
            });
            if (l(e._offsetAttribute)) {
                var j = E.length,
                    Z = new Uint8Array(j / 3),
                    Q = e._offsetAttribute === Di.NONE ? 0 : 1;
                Ri(Z, Q), Y.applyOffset = new ze({
                    componentDatatype: ee.UNSIGNED_BYTE,
                    componentsPerAttribute: 1,
                    values: Z
                })
            }
            return new rt({
                attributes: Y,
                indices: C,
                primitiveType: Ve.LINES,
                boundingSphere: q.fromEllipsoid(c),
                offsetAttribute: e._offsetAttribute
            })
        }
    }
};

function wo(e) {
    var t = p(e.radius, 1),
        n = new u(t, t, t),
        r = {
            radii: n,
            stackPartitions: e.stackPartitions,
            slicePartitions: e.slicePartitions,
            subdivisions: e.subdivisions
        };
    this._ellipsoidGeometry = new yr(r), this._workerName = "createSphereOutlineGeometry"
}
wo.packedLength = yr.packedLength;
wo.pack = function(e, t, n) {
    return yr.pack(e._ellipsoidGeometry, t, n)
};
var CI = new yr,
    ga = {
        radius: void 0,
        radii: new u,
        stackPartitions: void 0,
        slicePartitions: void 0,
        subdivisions: void 0
    };
wo.unpack = function(e, t, n) {
    var r = yr.unpack(e, t, CI);
    return ga.stackPartitions = r._stackPartitions, ga.slicePartitions = r._slicePartitions, ga.subdivisions = r._subdivisions, l(n) ? (u.clone(r._radii, ga.radii), n._ellipsoidGeometry = new yr(ga), n) : (ga.radius = r._radii.x, new wo(ga))
};
wo.createGeometry = function(e) {
    return yr.createGeometry(e._ellipsoidGeometry)
};
var wI = {
    NONE: -1,
    PARTIAL: 0,
    FULL: 1
};
const qt = Object.freeze(wI);
var xI = {
    NEVER: L.NEVER,
    LESS: L.LESS,
    EQUAL: L.EQUAL,
    LESS_OR_EQUAL: L.LEQUAL,
    GREATER: L.GREATER,
    NOT_EQUAL: L.NOTEQUAL,
    GREATER_OR_EQUAL: L.GEQUAL,
    ALWAYS: L.ALWAYS
};
const Tl = Object.freeze(xI);

function SI(e) {
    var t, n = e.name,
        r = e.message;
    l(n) && l(r) ? t = n + ": " + r : t = e.toString();
    var i = e.stack;
    return l(i) && (t += `
` + i), t
}

function xo(e, t, n, r, i, a, o) {
    this.provider = e, this.message = t, this.x = n, this.y = r, this.level = i, this.timesRetried = p(a, 0), this.retry = !1, this.error = o
}
xo.handleError = function(e, t, n, r, i, a, o, s, c) {
    var f = e;
    return l(e) ? (f.provider = t, f.message = r, f.x = i, f.y = a, f.level = o, f.retry = !1, f.error = c, ++f.timesRetried) : f = new xo(t, r, i, a, o, 0, c), n.numberOfListeners > 0 ? n.raiseEvent(f) : console.log('An error occurred in "' + t.constructor.name + '": ' + SI(r)), f.retry && l(s) && s(), f
};
xo.handleSuccess = function(e) {
    l(e) && (e.timesRetried = -1)
};
var RI = {
    UNLOADED: 0,
    TRANSITIONING: 1,
    RECEIVED: 2,
    TEXTURE_LOADED: 3,
    READY: 4,
    FAILED: 5,
    INVALID: 6,
    PLACEHOLDER: 7
};
const Ze = Object.freeze(RI);
var DI = {
    START: 0,
    LOADING: 1,
    DONE: 2,
    FAILED: 3
};
const Tr = Object.freeze(DI);
var II = {
    FAILED: 0,
    UNLOADED: 1,
    RECEIVING: 2,
    RECEIVED: 3,
    TRANSFORMING: 4,
    TRANSFORMED: 5,
    READY: 6
};
const Tt = Object.freeze(II);

function Ct() {
    this.imagery = [], this.waterMaskTexture = void 0, this.waterMaskTranslationAndScale = new U(0, 0, 1, 1), this.terrainData = void 0, this.vertexArray = void 0, this.orientedBoundingBox = void 0, this.boundingVolumeSourceTile = void 0, this.tileBoundingRegion = void 0, this.occludeePointInScaledSpace = new u, this.terrainState = Tt.UNLOADED, this.mesh = void 0, this.fill = void 0, this.pickBoundingSphere = new q, this.surfaceShader = void 0, this.isClipped = !0, this.clippedByBoundaries = !1
}
Object.defineProperties(Ct.prototype, {
    eligibleForUnloading: {
        get: function() {
            for (var e = this.terrainState, t = e === Tt.RECEIVING || e === Tt.TRANSFORMING, n = !t, r = this.imagery, i = 0, a = r.length; n && i < a; ++i) {
                var o = r[i];
                n = !l(o.loadingImagery) || o.loadingImagery.state !== Ze.TRANSITIONING
            }
            return n
        }
    },
    renderedMesh: {
        get: function() {
            if (l(this.vertexArray)) return this.mesh;
            if (l(this.fill)) return this.fill.mesh
        }
    }
});

function vh(e, t, n, r, i, a) {
    if (e.decodePosition(r, i, a), l(t) && t !== k.SCENE3D) {
        var o = n.ellipsoid,
            s = o.cartesianToCartographic(a);
        n.project(s, a), u.fromElements(a.z, a.x, a.y, a)
    }
    return a
}
var PI = new u,
    OI = new u,
    MI = new u;
Ct.prototype.pick = function(e, t, n, r, i) {
    var a = this.renderedMesh;
    if (!!l(a)) {
        for (var o = a.vertices, s = a.indices, c = a.encoding, f = s.length, h = Number.MAX_VALUE, d = 0; d < f; d += 3) {
            var _ = s[d],
                v = s[d + 1],
                m = s[d + 2],
                g = vh(c, t, n, o, _, PI),
                y = vh(c, t, n, o, v, OI),
                E = vh(c, t, n, o, m, MI),
                w = Me.rayTriangleParametric(e, g, y, E, r);
            l(w) && w < h && w >= 0 && (h = w)
        }
        return h !== Number.MAX_VALUE ? Ke.getPoint(e, h, i) : void 0
    }
};
Ct.prototype.freeResources = function() {
    l(this.waterMaskTexture) && (--this.waterMaskTexture.referenceCount, this.waterMaskTexture.referenceCount === 0 && this.waterMaskTexture.destroy(), this.waterMaskTexture = void 0), this.terrainData = void 0, this.terrainState = Tt.UNLOADED, this.mesh = void 0, this.fill = this.fill && this.fill.destroy();
    for (var e = this.imagery, t = 0, n = e.length; t < n; ++t) e[t].freeResources();
    this.imagery.length = 0, this.freeVertexArray()
};
Ct.prototype.freeVertexArray = function() {
    Ct._freeVertexArray(this.vertexArray), this.vertexArray = void 0, Ct._freeVertexArray(this.wireframeVertexArray), this.wireframeVertexArray = void 0
};
Ct.initialize = function(e, t, n) {
    var r = e.data;
    l(r) || (r = e.data = new Ct), e.state === Tr.START && (NI(e, t, n), e.state = Tr.LOADING)
};
Ct.processStateMachine = function(e, t, n, r, i, a) {
    Ct.initialize(e, n, r);
    var o = e.data;
    if (e.state === Tr.LOADING && bI(e, t, n, r, i), !a) {
        var s = e.renderable;
        e.renderable = l(o.vertexArray);
        var c = o.terrainState === Tt.READY;
        e.upsampledFromParent = l(o.terrainData) && o.terrainData.wasCreatedByUpsampling();
        var f = o.processImagery(e, n, t);
        if (c && f) {
            var h = e._loadedCallbacks,
                d = {};
            for (var _ in h) h.hasOwnProperty(_) && (h[_](e) || (d[_] = h[_]));
            e._loadedCallbacks = d, e.state = Tr.DONE
        }
        s && (e.renderable = !0)
    }
};
Ct.prototype.processImagery = function(e, t, n, r) {
    var i = e.data,
        a = e.upsampledFromParent,
        o = !1,
        s = !0,
        c = i.imagery,
        f, h;
    for (f = 0, h = c.length; f < h; ++f) {
        var d = c[f];
        if (!l(d.loadingImagery)) {
            a = !1;
            continue
        }
        if (d.loadingImagery.state === Ze.PLACEHOLDER) {
            var _ = d.loadingImagery.imageryLayer;
            if (_.imageryProvider.ready) {
                d.freeResources(), c.splice(f, 1), _._createTileImagerySkeletons(e, t, f), --f, h = c.length;
                continue
            } else a = !1
        }
        var v = d.processStateMachine(e, n, r);
        s = s && v, o = o || v || l(d.readyImagery), a = a && l(d.loadingImagery) && (d.loadingImagery.state === Ze.FAILED || d.loadingImagery.state === Ze.INVALID)
    }
    return e.upsampledFromParent = a, e.renderable = e.renderable && (o || s), s
};

function NI(e, t, n) {
    var r = t.getTileDataAvailable(e.x, e.y, e.level);
    if (!l(r) && l(e.parent)) {
        var i = e.parent,
            a = i.data;
        l(a) && l(a.terrainData) && (r = a.terrainData.isChildAvailable(i.x, i.y, e.x, e.y))
    }
    r === !1 && (e.data.terrainState = Tt.FAILED);
    for (var o = 0, s = n.length; o < s; ++o) {
        var c = n.get(o);
        c.show && c._createTileImagerySkeletons(e, t)
    }
}

function bI(e, t, n, r, i) {
    var a = e.data,
        o = e.parent;
    if (a.terrainState === Tt.FAILED && o !== void 0) {
        var s = o.data !== void 0 && o.data.terrainData !== void 0 && o.data.terrainData.canUpsample !== !1;
        s || Ct.processStateMachine(o, t, n, r, !0)
    }
    if (a.terrainState === Tt.FAILED && FI(a, e, t, n, e.x, e.y, e.level), a.terrainState === Tt.UNLOADED && LI(a, n, e.x, e.y, e.level), a.terrainState === Tt.RECEIVED && UI(a, t, n, e.x, e.y, e.level), a.terrainState === Tt.TRANSFORMED && zI(a, t.context, n, e.x, e.y, e.level, i), a.terrainState >= Tt.RECEIVED && a.waterMaskTexture === void 0 && n.hasWaterMask) {
        var c = a.terrainData;
        if (c.waterMask !== void 0) VI(t.context, a);
        else {
            var f = a._findAncestorTileWithTerrainData(e);
            l(f) && l(f.data.waterMaskTexture) && (a.waterMaskTexture = f.data.waterMaskTexture, ++a.waterMaskTexture.referenceCount, a._computeWaterMaskTranslationAndScale(e, f, a.waterMaskTranslationAndScale))
        }
    }
}

function FI(e, t, n, r, i, a, o) {
    var s = t.parent;
    if (!s) {
        t.state = Tr.FAILED;
        return
    }
    var c = s.data.terrainData,
        f = s.x,
        h = s.y,
        d = s.level;
    if (!!l(c)) {
        var _ = c.upsample(r.tilingScheme, f, h, d, i, a, o);
        !l(_) || (e.terrainState = Tt.RECEIVING, he(_, function(v) {
            e.terrainData = v, e.terrainState = Tt.RECEIVED
        }, function() {
            e.terrainState = Tt.FAILED
        }))
    }
}

function LI(e, t, n, r, i) {
    function a(c) {
        e.terrainData = c, e.terrainState = Tt.RECEIVED, e.request = void 0
    }

    function o() {
        if (e.request.state === It.CANCELLED) {
            e.terrainData = void 0, e.terrainState = Tt.UNLOADED, e.request = void 0;
            return
        }
        e.terrainState = Tt.FAILED, e.request = void 0;
        var c = "Failed to obtain terrain tile X: " + n + " Y: " + r + " Level: " + i + ".";
        t._requestError = xo.handleError(t._requestError, t, t.errorEvent, c, n, r, i, s)
    }

    function s() {
        var c = new Eo({
            throttle: !1,
            throttleByServer: !0,
            type: _d.TERRAIN
        });
        e.request = c;
        var f = t.requestTileGeometry(n, r, i, c);
        l(f) ? (e.terrainState = Tt.RECEIVING, he(f, a, o)) : (e.terrainState = Tt.UNLOADED, e.request = void 0)
    }
    s()
}

function UI(e, t, n, r, i, a) {
    var o = n.tilingScheme,
        s = e.terrainData,
        c = s.createMesh(o, r, i, a, t.terrainExaggeration);
    !l(c) || (e.terrainState = Tt.TRANSFORMING, he(c, function(f) {
        e.mesh = f, e.orientedBoundingBox = $e.clone(f.orientedBoundingBox, e.orientedBoundingBox), e.occludeePointInScaledSpace = u.clone(f.occludeePointInScaledSpace, e.occludeePointInScaledSpace), e.terrainState = Tt.TRANSFORMED
    }, function() {
        e.terrainState = Tt.FAILED
    }))
}
Ct._createVertexArrayForMesh = function(e, t) {
    var n = t.vertices,
        r = _t.createVertexBuffer({
            context: e,
            typedArray: n,
            usage: Ye.STATIC_DRAW
        }),
        i = t.encoding.getAttributes(r),
        a = t.indices.indexBuffers || {},
        o = a[e.id];
    if (!l(o) || o.isDestroyed()) {
        var s = t.indices;
        o = _t.createIndexBuffer({
            context: e,
            typedArray: s,
            usage: Ye.STATIC_DRAW,
            indexDatatype: yt.fromSizeInBytes(s.BYTES_PER_ELEMENT)
        }), o.vertexArrayDestroyable = !1, o.referenceCount = 1, a[e.id] = o, t.indices.indexBuffers = a
    } else ++o.referenceCount;
    return new Cn({
        context: e,
        attributes: i,
        indexBuffer: o
    })
};
Ct._freeVertexArray = function(e) {
    if (l(e)) {
        var t = e.indexBuffer;
        e.destroy(), l(t) && !t.isDestroyed() && l(t.referenceCount) && (--t.referenceCount, t.referenceCount === 0 && t.destroy())
    }
};

function zI(e, t, n, r, i, a, o) {
    e.vertexArray = Ct._createVertexArrayForMesh(t, e.mesh), e.terrainState = Tt.READY, e.fill = e.fill && e.fill.destroy(o)
}

function BI(e) {
    var t = e.cache.tile_waterMaskData;
    if (!l(t)) {
        var n = be.create({
            context: e,
            pixelFormat: de.LUMINANCE,
            pixelDatatype: ae.UNSIGNED_BYTE,
            source: {
                arrayBufferView: new Uint8Array([255]),
                width: 1,
                height: 1
            }
        });
        n.referenceCount = 1;
        var r = new gt({
            wrapS: gn.CLAMP_TO_EDGE,
            wrapT: gn.CLAMP_TO_EDGE,
            minificationFilter: Ot.LINEAR,
            magnificationFilter: zr.LINEAR
        });
        t = {
            allWaterTexture: n,
            sampler: r,
            destroy: function() {
                this.allWaterTexture.destroy()
            }
        }, e.cache.tile_waterMaskData = t
    }
    return t
}

function VI(e, t) {
    var n = t.terrainData.waterMask,
        r = BI(e),
        i, a = n.length;
    if (a === 1)
        if (n[0] !== 0) i = r.allWaterTexture;
        else return;
    else {
        var o = Math.sqrt(a);
        i = be.create({
            context: e,
            pixelFormat: de.LUMINANCE,
            pixelDatatype: ae.UNSIGNED_BYTE,
            source: {
                width: o,
                height: o,
                arrayBufferView: n
            },
            sampler: r.sampler,
            flipY: !1
        }), i.referenceCount = 0
    }++i.referenceCount, t.waterMaskTexture = i, U.fromElements(0, 0, 1, 1, t.waterMaskTranslationAndScale)
}
Ct.prototype._findAncestorTileWithTerrainData = function(e) {
    for (var t = e.parent; l(t) && (!l(t.data) || !l(t.data.terrainData) || t.data.terrainData.wasCreatedByUpsampling());) t = t.parent;
    return t
};
Ct.prototype._computeWaterMaskTranslationAndScale = function(e, t, n) {
    var r = t.rectangle,
        i = e.rectangle,
        a = i.width,
        o = i.height,
        s = a / r.width,
        c = o / r.height;
    return n.x = s * (i.west - r.west) / a, n.y = c * (i.south - r.south) / o, n.z = s, n.w = c, n
};

function bc(e) {
    e = p(e, p.EMPTY_OBJECT), this.vertexArray = e.vertexArray, this.fragmentShaderSource = e.fragmentShaderSource, this.shaderProgram = e.shaderProgram, this.uniformMap = e.uniformMap, this.outputTexture = e.outputTexture, this.preExecute = e.preExecute, this.postExecute = e.postExecute, this.canceled = e.canceled, this.persists = p(e.persists, !1), this.pass = ue.COMPUTE, this.owner = e.owner
}
bc.prototype.execute = function(e) {
    e.execute(this)
};
const GI = `uniform sampler2D u_texture;
varying vec2 v_textureCoordinates;
void main()
{
gl_FragColor = texture2D(u_texture, v_textureCoordinates);
}
`,
    HI = `attribute vec4 position;
attribute float webMercatorT;
uniform vec2 u_textureDimensions;
varying vec2 v_textureCoordinates;
void main()
{
v_textureCoordinates = vec2(position.x, webMercatorT);
gl_Position = czm_viewportOrthographic * (position * vec4(u_textureDimensions, 1.0, 1.0));
}
`;

function Oa(e, t, n, r, i) {
    if (this.imageryLayer = e, this.x = t, this.y = n, this.level = r, this.request = void 0, r !== 0) {
        var a = t / 2 | 0,
            o = n / 2 | 0,
            s = r - 1;
        this.parent = e.getImageryFromCache(a, o, s)
    }
    if (this.state = Ze.UNLOADED, this.imageUrl = void 0, this.image = void 0, this.texture = void 0, this.textureWebMercator = void 0, this.credits = void 0, this.referenceCount = 0, !l(i) && e.imageryProvider.ready) {
        var c = e.imageryProvider.tilingScheme;
        i = c.tileXYToRectangle(t, n, r)
    }
    this.rectangle = i
}
Oa.createPlaceholder = function(e) {
    var t = new Oa(e, 0, 0, 0);
    return t.addReference(), t.state = Ze.PLACEHOLDER, t
};
Oa.prototype.addReference = function() {
    ++this.referenceCount
};
Oa.prototype.releaseReference = function() {
    return --this.referenceCount, this.referenceCount === 0 ? (this.imageryLayer.removeImageryFromCache(this), l(this.parent) && this.parent.releaseReference(), l(this.image) && l(this.image.destroy) && this.image.destroy(), l(this.texture) && this.texture.destroy(), l(this.textureWebMercator) && this.texture !== this.textureWebMercator && this.textureWebMercator.destroy(), Pe(this), 0) : this.referenceCount
};
Oa.prototype.processStateMachine = function(e, t, n) {
    this.state === Ze.UNLOADED && !n && (this.state = Ze.TRANSITIONING, this.imageryLayer._requestImagery(this)), this.state === Ze.RECEIVED && (this.state = Ze.TRANSITIONING, this.imageryLayer._createTexture(e.context, this));
    var r = this.state === Ze.READY && t && !this.texture;
    (this.state === Ze.TEXTURE_LOADED || r) && (this.state = Ze.TRANSITIONING, this.imageryLayer._reprojectTexture(e, this, t))
};
var kI = {
    LEFT: -1,
    NONE: 0,
    RIGHT: 1
};
const WI = Object.freeze(kI);

function $c(e, t, n) {
    this.readyImagery = void 0, this.loadingImagery = e, this.textureCoordinateRectangle = t, this.textureTranslationAndScale = void 0, this.useWebMercatorT = n
}
$c.prototype.freeResources = function() {
    l(this.readyImagery) && this.readyImagery.releaseReference(), l(this.loadingImagery) && this.loadingImagery.releaseReference()
};
$c.prototype.processStateMachine = function(e, t, n) {
    var r = this.loadingImagery,
        i = r.imageryLayer;
    if (r.processStateMachine(t, !this.useWebMercatorT, n), r.state === Ze.READY) return l(this.readyImagery) && this.readyImagery.releaseReference(), this.readyImagery = this.loadingImagery, this.loadingImagery = void 0, this.textureTranslationAndScale = i._calculateTextureTranslationAndScale(e, this), !0;
    for (var a = r.parent, o; l(a) && (a.state !== Ze.READY || !this.useWebMercatorT && !l(a.texture));) a.state !== Ze.FAILED && a.state !== Ze.INVALID && (o = o || a), a = a.parent;
    return this.readyImagery !== a && (l(this.readyImagery) && this.readyImagery.releaseReference(), this.readyImagery = a, l(a) && (a.addReference(), this.textureTranslationAndScale = i._calculateTextureTranslationAndScale(e, this))), r.state === Ze.FAILED || r.state === Ze.INVALID ? l(o) ? (o.processStateMachine(t, !this.useWebMercatorT, n), !1) : !0 : !1
};

function Ue(e, t) {
    this._imageryProvider = e, t = p(t, p.EMPTY_OBJECT), this.alpha = p(t.alpha, p(e.defaultAlpha, 1)), this.nightAlpha = p(t.nightAlpha, p(e.defaultNightAlpha, 1)), this.dayAlpha = p(t.dayAlpha, p(e.defaultDayAlpha, 1)), this.brightness = p(t.brightness, p(e.defaultBrightness, Ue.DEFAULT_BRIGHTNESS)), this.contrast = p(t.contrast, p(e.defaultContrast, Ue.DEFAULT_CONTRAST)), this.hue = p(t.hue, p(e.defaultHue, Ue.DEFAULT_HUE)), this.saturation = p(t.saturation, p(e.defaultSaturation, Ue.DEFAULT_SATURATION)), this.gamma = p(t.gamma, p(e.defaultGamma, Ue.DEFAULT_GAMMA)), this.splitDirection = p(t.splitDirection, p(e.defaultSplit, Ue.DEFAULT_SPLIT)), this.minificationFilter = p(t.minificationFilter, p(e.defaultMinificationFilter, Ue.DEFAULT_MINIFICATION_FILTER)), this.magnificationFilter = p(t.magnificationFilter, p(e.defaultMagnificationFilter, Ue.DEFAULT_MAGNIFICATION_FILTER)), this.show = p(t.show, !0), this._minimumTerrainLevel = t.minimumTerrainLevel, this._maximumTerrainLevel = t.maximumTerrainLevel, this._rectangle = p(t.rectangle, W.MAX_VALUE), this._maximumAnisotropy = t.maximumAnisotropy, this._imageryCache = {}, this._skeletonPlaceholder = new $c(Oa.createPlaceholder(this)), this._show = !0, this._layerIndex = -1, this._isBaseLayer = !1, this._requestImageError = void 0, this._reprojectComputeCommands = [], this.cutoutRectangle = t.cutoutRectangle, this.colorToAlpha = t.colorToAlpha, this.colorToAlphaThreshold = p(t.colorToAlphaThreshold, Ue.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD)
}
Object.defineProperties(Ue.prototype, {
    imageryProvider: {
        get: function() {
            return this._imageryProvider
        }
    },
    rectangle: {
        get: function() {
            return this._rectangle
        }
    }
});
Ue.DEFAULT_BRIGHTNESS = 1;
Ue.DEFAULT_CONTRAST = 1;
Ue.DEFAULT_HUE = 0;
Ue.DEFAULT_SATURATION = 1;
Ue.DEFAULT_GAMMA = 1;
Ue.DEFAULT_SPLIT = WI.NONE;
Ue.DEFAULT_MINIFICATION_FILTER = Ot.LINEAR;
Ue.DEFAULT_MAGNIFICATION_FILTER = zr.LINEAR;
Ue.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD = .004;
Ue.prototype.isBaseLayer = function() {
    return this._isBaseLayer
};
Ue.prototype.isDestroyed = function() {
    return !1
};
Ue.prototype.destroy = function() {
    return Pe(this)
};
var ny = new W,
    Uv = new W,
    mh = new W,
    ry = new W;
Ue.prototype.getViewableRectangle = function() {
    var e = this._imageryProvider,
        t = this._rectangle;
    return e.readyPromise.then(function() {
        return W.intersection(e.rectangle, t)
    })
};
Ue.prototype._createTileImagerySkeletons = function(e, t, n) {
    var r = e.data;
    if (l(this._minimumTerrainLevel) && e.level < this._minimumTerrainLevel || l(this._maximumTerrainLevel) && e.level > this._maximumTerrainLevel) return !1;
    var i = this._imageryProvider;
    if (l(n) || (n = r.imagery.length), !i.ready) return this._skeletonPlaceholder.loadingImagery.addReference(), r.imagery.splice(n, 0, this._skeletonPlaceholder), !0;
    var a = i.tilingScheme.projection instanceof st && e.rectangle.north < st.MaximumLatitude && e.rectangle.south > -st.MaximumLatitude,
        o = W.intersection(i.rectangle, this._rectangle, ny),
        s = W.intersection(e.rectangle, o, Uv);
    if (!l(s)) {
        if (!this.isBaseLayer()) return !1;
        var c = o,
            f = e.rectangle;
        s = Uv, f.south >= c.north ? s.north = s.south = c.north : f.north <= c.south ? s.north = s.south = c.south : (s.south = Math.max(f.south, c.south), s.north = Math.min(f.north, c.north)), f.west >= c.east ? s.west = s.east = c.east : f.east <= c.west ? s.west = s.east = c.west : (s.west = Math.max(f.west, c.west), s.east = Math.min(f.east, c.east))
    }
    var h = 0;
    s.south > 0 ? h = s.south : s.north < 0 && (h = s.north);
    var d = 1,
        _ = d * t.getLevelMaximumGeometricError(e.level),
        v = XI(this, _, h);
    v = Math.max(0, v);
    var m = i.maximumLevel;
    if (v > m && (v = m), l(i.minimumLevel)) {
        var g = i.minimumLevel;
        v < g && (v = g)
    }
    var y = i.tilingScheme,
        E = y.positionToTileXY(W.northwest(s), v),
        w = y.positionToTileXY(W.southeast(s), v),
        C = e.rectangle.width / 512,
        A = e.rectangle.height / 512,
        x = y.tileXYToRectangle(E.x, E.y, v);
    Math.abs(x.south - e.rectangle.north) < A && E.y < w.y && ++E.y, Math.abs(x.east - e.rectangle.west) < C && E.x < w.x && ++E.x;
    var P = y.tileXYToRectangle(w.x, w.y, v);
    Math.abs(P.north - e.rectangle.south) < A && w.y > E.y && --w.y, Math.abs(P.west - e.rectangle.east) < C && w.x > E.x && --w.x;
    var I = W.clone(e.rectangle, ry),
        D = y.tileXYToRectangle(E.x, E.y, v),
        O = W.intersection(D, o, mh),
        F;
    a ? (y.rectangleToNativeRectangle(I, I), y.rectangleToNativeRectangle(D, D), y.rectangleToNativeRectangle(O, O), y.rectangleToNativeRectangle(o, o), F = y.tileXYToNativeRectangle.bind(y), C = I.width / 512, A = I.height / 512) : F = y.tileXYToRectangle.bind(y);
    var z, b = 0,
        M = 1,
        G;
    !this.isBaseLayer() && Math.abs(O.west - I.west) >= C && (b = Math.min(1, (O.west - I.west) / I.width)), !this.isBaseLayer() && Math.abs(O.north - I.north) >= A && (M = Math.max(0, (O.north - I.south) / I.height));
    for (var V = M, B = E.x; B <= w.x; B++)
        if (z = b, D = F(B, E.y, v), O = W.simpleIntersection(D, o, mh), !!l(O)) {
            b = Math.min(1, (O.east - I.west) / I.width), B === w.x && (this.isBaseLayer() || Math.abs(O.east - I.east) < C) && (b = 1), M = V;
            for (var Y = E.y; Y <= w.y; Y++)
                if (G = M, D = F(B, Y, v), O = W.simpleIntersection(D, o, mh), !!l(O)) {
                    M = Math.max(0, (O.south - I.south) / I.height), Y === w.y && (this.isBaseLayer() || Math.abs(O.south - I.south) < A) && (M = 0);
                    var j = new U(z, M, b, G),
                        Z = this.getImageryFromCache(B, Y, v);
                    r.imagery.splice(n, 0, new $c(Z, j, a)), ++n
                }
        }
    return !0
};
Ue.prototype._calculateTextureTranslationAndScale = function(e, t) {
    var n = t.readyImagery.rectangle,
        r = e.rectangle;
    if (t.useWebMercatorT) {
        var i = t.readyImagery.imageryLayer.imageryProvider.tilingScheme;
        n = i.rectangleToNativeRectangle(n, ny), r = i.rectangleToNativeRectangle(r, ry)
    }
    var a = r.width,
        o = r.height,
        s = a / n.width,
        c = o / n.height;
    return new U(s * (r.west - n.west) / a, c * (r.south - n.south) / o, s, c)
};
Ue.prototype._requestImagery = function(e) {
    var t = this._imageryProvider,
        n = this;

    function r(o) {
        if (!l(o)) return i();
        e.image = o, e.state = Ze.RECEIVED, e.request = void 0, xo.handleSuccess(n._requestImageError)
    }

    function i(o) {
        if (e.request.state === It.CANCELLED) {
            e.state = Ze.UNLOADED, e.request = void 0;
            return
        }
        e.state = Ze.FAILED, e.request = void 0;
        var s = "Failed to obtain image tile X: " + e.x + " Y: " + e.y + " Level: " + e.level + ".";
        n._requestImageError = xo.handleError(n._requestImageError, t, t.errorEvent, s, e.x, e.y, e.level, a, o)
    }

    function a() {
        var o = new Eo({
            throttle: !1,
            throttleByServer: !0,
            type: _d.IMAGERY
        });
        e.request = o, e.state = Ze.TRANSITIONING;
        var s = t.requestImage(e.x, e.y, e.level, o);
        if (!l(s)) {
            e.state = Ze.UNLOADED, e.request = void 0;
            return
        }
        l(t.getTileCredits) && (e.credits = t.getTileCredits(e.x, e.y, e.level)), he(s, r, i)
    }
    a()
};
Ue.prototype._createTextureWebGL = function(e, t) {
    var n = new gt({
            minificationFilter: this.minificationFilter,
            magnificationFilter: this.magnificationFilter
        }),
        r = t.image;
    return l(r.internalFormat) ? new be({
        context: e,
        pixelFormat: r.internalFormat,
        width: r.width,
        height: r.height,
        source: {
            arrayBufferView: r.bufferView
        },
        sampler: n
    }) : new be({
        context: e,
        source: r,
        pixelFormat: this._imageryProvider.hasAlphaChannel ? de.RGBA : de.RGB,
        sampler: n
    })
};
Ue.prototype._createTexture = function(e, t) {
    var n = this._imageryProvider,
        r = t.image;
    if (l(n.tileDiscardPolicy)) {
        var i = n.tileDiscardPolicy;
        if (l(i)) {
            if (!i.isReady()) {
                t.state = Ze.RECEIVED;
                return
            }
            if (i.shouldDiscardImage(r)) {
                t.state = Ze.INVALID;
                return
            }
        }
    }
    var a = this._createTextureWebGL(e, t);
    n.tilingScheme.projection instanceof st ? t.textureWebMercator = a : t.texture = a, t.image = void 0, t.state = Ze.TEXTURE_LOADED
};

function zv(e, t, n) {
    return e + ":" + t + ":" + n
}
Ue.prototype._finalizeReprojectTexture = function(e, t) {
    var n = this.minificationFilter,
        r = this.magnificationFilter,
        i = n === Ot.LINEAR && r === zr.LINEAR;
    if (i && !de.isCompressedFormat(t.pixelFormat) && T.isPowerOfTwo(t.width) && T.isPowerOfTwo(t.height)) {
        n = Ot.LINEAR_MIPMAP_LINEAR;
        var a = pe.maximumTextureFilterAnisotropy,
            o = Math.min(a, p(this._maximumAnisotropy, a)),
            s = zv(n, r, o),
            c = e.cache.imageryLayerMipmapSamplers;
        l(c) || (c = {}, e.cache.imageryLayerMipmapSamplers = c);
        var f = c[s];
        l(f) || (f = c[s] = new gt({
            wrapS: gn.CLAMP_TO_EDGE,
            wrapT: gn.CLAMP_TO_EDGE,
            minificationFilter: n,
            magnificationFilter: r,
            maximumAnisotropy: o
        })), t.generateMipmap(Kc.NICEST), t.sampler = f
    } else {
        var h = zv(n, r, 0),
            d = e.cache.imageryLayerNonMipmapSamplers;
        l(d) || (d = {}, e.cache.imageryLayerNonMipmapSamplers = d);
        var _ = d[h];
        l(_) || (_ = d[h] = new gt({
            wrapS: gn.CLAMP_TO_EDGE,
            wrapT: gn.CLAMP_TO_EDGE,
            minificationFilter: n,
            magnificationFilter: r
        })), t.sampler = _
    }
};
Ue.prototype._reprojectTexture = function(e, t, n) {
    var r = t.textureWebMercator || t.texture,
        i = t.rectangle,
        a = e.context;
    if (n = p(n, !0), n && !(this._imageryProvider.tilingScheme.projection instanceof un) && i.width / r.width > 1e-5) {
        var o = this;
        t.addReference();
        var s = new bc({
            persists: !0,
            owner: this,
            preExecute: function(c) {
                YI(c, a, r, t.rectangle)
            },
            postExecute: function(c) {
                t.texture = c, o._finalizeReprojectTexture(a, c), t.state = Ze.READY, t.releaseReference()
            },
            canceled: function() {
                t.state = Ze.TEXTURE_LOADED, t.releaseReference()
            }
        });
        this._reprojectComputeCommands.push(s)
    } else n && (t.texture = r), this._finalizeReprojectTexture(a, r), t.state = Ze.READY
};
Ue.prototype.queueReprojectionCommands = function(e) {
    for (var t = this._reprojectComputeCommands, n = t.length, r = 0; r < n; ++r) e.commandList.push(t[r]);
    t.length = 0
};
Ue.prototype.cancelReprojections = function() {
    this._reprojectComputeCommands.forEach(function(e) {
        l(e.canceled) && e.canceled()
    }), this._reprojectComputeCommands.length = 0
};
Ue.prototype.getImageryFromCache = function(e, t, n, r) {
    var i = iy(e, t, n),
        a = this._imageryCache[i];
    return l(a) || (a = new Oa(this, e, t, n, r), this._imageryCache[i] = a), a.addReference(), a
};
Ue.prototype.removeImageryFromCache = function(e) {
    var t = iy(e.x, e.y, e.level);
    delete this._imageryCache[t]
};

function iy(e, t, n) {
    return JSON.stringify([e, t, n])
}
var Su = {
        u_textureDimensions: function() {
            return this.textureDimensions
        },
        u_texture: function() {
            return this.texture
        },
        textureDimensions: new R,
        texture: void 0
    },
    qI = An.supportsTypedArrays() ? new Float32Array(2 * 64) : void 0;

function YI(e, t, n, r) {
    var i = t.cache.imageryLayer_reproject;
    if (!l(i)) {
        i = t.cache.imageryLayer_reproject = {
            vertexArray: void 0,
            shaderProgram: void 0,
            sampler: void 0,
            destroy: function() {
                l(this.framebuffer) && this.framebuffer.destroy(), l(this.vertexArray) && this.vertexArray.destroy(), l(this.shaderProgram) && this.shaderProgram.destroy()
            }
        };
        for (var a = new Float32Array(2 * 64 * 2), o = 0, s = 0; s < 64; ++s) {
            var c = s / 63;
            a[o++] = 0, a[o++] = c, a[o++] = 1, a[o++] = c
        }
        var f = {
                position: 0,
                webMercatorT: 1
            },
            h = Nt.getRegularGridIndices(2, 64),
            d = _t.createIndexBuffer({
                context: t,
                typedArray: h,
                usage: Ye.STATIC_DRAW,
                indexDatatype: yt.UNSIGNED_SHORT
            });
        i.vertexArray = new Cn({
            context: t,
            attributes: [{
                index: f.position,
                vertexBuffer: _t.createVertexBuffer({
                    context: t,
                    typedArray: a,
                    usage: Ye.STATIC_DRAW
                }),
                componentsPerAttribute: 2
            }, {
                index: f.webMercatorT,
                vertexBuffer: _t.createVertexBuffer({
                    context: t,
                    sizeInBytes: 64 * 2 * 4,
                    usage: Ye.STREAM_DRAW
                }),
                componentsPerAttribute: 1
            }],
            indexBuffer: d
        });
        var _ = new Re({
            sources: [HI]
        });
        i.shaderProgram = Mt.fromCache({
            context: t,
            vertexShaderSource: _,
            fragmentShaderSource: GI,
            attributeLocations: f
        }), i.sampler = new gt({
            wrapS: gn.CLAMP_TO_EDGE,
            wrapT: gn.CLAMP_TO_EDGE,
            minificationFilter: Ot.LINEAR,
            magnificationFilter: zr.LINEAR
        })
    }
    n.sampler = i.sampler;
    var v = n.width,
        m = n.height;
    Su.textureDimensions.x = v, Su.textureDimensions.y = m, Su.texture = n;
    var g = Math.sin(r.south),
        y = .5 * Math.log((1 + g) / (1 - g));
    g = Math.sin(r.north);
    var E = .5 * Math.log((1 + g) / (1 - g)),
        w = 1 / (E - y),
        C = new be({
            context: t,
            width: v,
            height: m,
            pixelFormat: n.pixelFormat,
            pixelDatatype: n.pixelDatatype,
            preMultiplyAlpha: n.preMultiplyAlpha
        });
    T.isPowerOfTwo(v) && T.isPowerOfTwo(m) && C.generateMipmap(Kc.NICEST);
    for (var A = r.south, x = r.north, P = qI, I = 0, D = 0; D < 64; ++D) {
        var O = D / 63,
            F = T.lerp(A, x, O);
        g = Math.sin(F);
        var z = .5 * Math.log((1 + g) / (1 - g)),
            b = (z - y) * w;
        P[I++] = b, P[I++] = b
    }
    i.vertexArray.getAttribute(1).vertexBuffer.copyFromArrayView(P), e.shaderProgram = i.shaderProgram, e.outputTexture = C, e.uniformMap = Su, e.vertexArray = i.vertexArray
}

function XI(e, t, n) {
    var r = e._imageryProvider,
        i = r.tilingScheme,
        a = i.ellipsoid,
        o = e._imageryProvider.tilingScheme.projection instanceof un ? 1 : Math.cos(n),
        s = i.rectangle,
        c = a.maximumRadius * s.width * o / (r.tileWidth * i.getNumberOfXTilesAtLevel(0)),
        f = c / t,
        h = Math.log(f) / Math.log(2),
        d = Math.round(h);
    return d | 0
}

function Le(e) {
    e = p(e, p.EMPTY_OBJECT), this.position = p(e.position, !1), this.normal = p(e.normal, !1), this.st = p(e.st, !1), this.bitangent = p(e.bitangent, !1), this.tangent = p(e.tangent, !1), this.color = p(e.color, !1)
}
Le.POSITION_ONLY = Object.freeze(new Le({
    position: !0
}));
Le.POSITION_AND_NORMAL = Object.freeze(new Le({
    position: !0,
    normal: !0
}));
Le.POSITION_NORMAL_AND_ST = Object.freeze(new Le({
    position: !0,
    normal: !0,
    st: !0
}));
Le.POSITION_AND_ST = Object.freeze(new Le({
    position: !0,
    st: !0
}));
Le.POSITION_AND_COLOR = Object.freeze(new Le({
    position: !0,
    color: !0
}));
Le.ALL = Object.freeze(new Le({
    position: !0,
    normal: !0,
    st: !0,
    tangent: !0,
    bitangent: !0
}));
Le.DEFAULT = Le.POSITION_NORMAL_AND_ST;
Le.packedLength = 6;
Le.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.position ? 1 : 0, t[n++] = e.normal ? 1 : 0, t[n++] = e.st ? 1 : 0, t[n++] = e.tangent ? 1 : 0, t[n++] = e.bitangent ? 1 : 0, t[n] = e.color ? 1 : 0, t
};
Le.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new Le), n.position = e[t++] === 1, n.normal = e[t++] === 1, n.st = e[t++] === 1, n.tangent = e[t++] === 1, n.bitangent = e[t++] === 1, n.color = e[t] === 1, n
};
Le.clone = function(e, t) {
    if (!!l(e)) return l(t) || (t = new Le), t.position = e.position, t.normal = e.normal, t.st = e.st, t.tangent = e.tangent, t.bitangent = e.bitangent, t.color = e.color, t
};
const jI = `varying vec3 v_positionEC;
varying vec3 v_normalEC;
varying vec4 v_color;
void main()
{
vec3 positionToEyeEC = -v_positionEC;
vec3 normalEC = normalize(v_normalEC);
#ifdef FACE_FORWARD
normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);
#endif
vec4 color = czm_gammaCorrect(v_color);
czm_materialInput materialInput;
materialInput.normalEC = normalEC;
materialInput.positionToEyeEC = positionToEyeEC;
czm_material material = czm_getDefaultMaterial(materialInput);
material.diffuse = color.rgb;
material.alpha = color.a;
gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
}
`,
    ZI = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec3 normal;
attribute vec4 color;
attribute float batchId;
varying vec3 v_positionEC;
varying vec3 v_normalEC;
varying vec4 v_color;
void main()
{
vec4 p = czm_computePosition();
v_positionEC = (czm_modelViewRelativeToEye * p).xyz;
v_normalEC = czm_normal * normal;
v_color = color;
gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`,
    KI = `varying vec4 v_color;
void main()
{
gl_FragColor = czm_gammaCorrect(v_color);
}
`,
    $I = `attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec4 color;
attribute float batchId;
varying vec4 v_color;
void main()
{
vec4 p = czm_computePosition();
v_color = color;
gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`;
var JI = {
    FRONT: L.FRONT,
    BACK: L.BACK,
    FRONT_AND_BACK: L.FRONT_AND_BACK
};
const Qn = Object.freeze(JI);

function Mi(e) {
    e = p(e, p.EMPTY_OBJECT), this.material = e.material, this.translucent = p(e.translucent, !0), this._vertexShaderSource = e.vertexShaderSource, this._fragmentShaderSource = e.fragmentShaderSource, this._renderState = e.renderState, this._closed = p(e.closed, !1)
}
Object.defineProperties(Mi.prototype, {
    vertexShaderSource: {
        get: function() {
            return this._vertexShaderSource
        }
    },
    fragmentShaderSource: {
        get: function() {
            return this._fragmentShaderSource
        }
    },
    renderState: {
        get: function() {
            return this._renderState
        }
    },
    closed: {
        get: function() {
            return this._closed
        }
    }
});
Mi.prototype.getFragmentShaderSource = function() {
    var e = [];
    return this.flat && e.push("#define FLAT"), this.faceForward && e.push("#define FACE_FORWARD"), l(this.material) && e.push(this.material.shaderSource), e.push(this.fragmentShaderSource), e.join(`
`)
};
Mi.prototype.isTranslucent = function() {
    return l(this.material) && this.material.isTranslucent() || !l(this.material) && this.translucent
};
Mi.prototype.getRenderState = function() {
    var e = this.isTranslucent(),
        t = sn(this.renderState, !1);
    return e ? (t.depthMask = !1, t.blending = fi.ALPHA_BLEND) : t.depthMask = !0, t
};
Mi.getDefaultRenderState = function(e, t, n) {
    var r = {
        depthTest: {
            enabled: !0
        }
    };
    return e && (r.depthMask = !1, r.blending = fi.ALPHA_BLEND), t && (r.cull = {
        enabled: !0,
        face: Qn.BACK
    }), l(n) && (r = En(n, r, !0)), r
};

function Gn(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = p(e.translucent, !0),
        n = p(e.closed, !1),
        r = p(e.flat, !1),
        i = r ? $I : ZI,
        a = r ? KI : jI,
        o = r ? Gn.FLAT_VERTEX_FORMAT : Gn.VERTEX_FORMAT;
    this.material = void 0, this.translucent = t, this._vertexShaderSource = p(e.vertexShaderSource, i), this._fragmentShaderSource = p(e.fragmentShaderSource, a), this._renderState = Mi.getDefaultRenderState(t, n, e.renderState), this._closed = n, this._vertexFormat = o, this._flat = r, this._faceForward = p(e.faceForward, !n)
}
Object.defineProperties(Gn.prototype, {
    vertexShaderSource: {
        get: function() {
            return this._vertexShaderSource
        }
    },
    fragmentShaderSource: {
        get: function() {
            return this._fragmentShaderSource
        }
    },
    renderState: {
        get: function() {
            return this._renderState
        }
    },
    closed: {
        get: function() {
            return this._closed
        }
    },
    vertexFormat: {
        get: function() {
            return this._vertexFormat
        }
    },
    flat: {
        get: function() {
            return this._flat
        }
    },
    faceForward: {
        get: function() {
            return this._faceForward
        }
    }
});
Gn.VERTEX_FORMAT = Le.POSITION_AND_NORMAL;
Gn.FLAT_VERTEX_FORMAT = Le.POSITION_ONLY;
Gn.prototype.getFragmentShaderSource = Mi.prototype.getFragmentShaderSource;
Gn.prototype.isTranslucent = Mi.prototype.isTranslucent;
Gn.prototype.getRenderState = Mi.prototype.getRenderState;

function QI(e, t) {
    for (var n = [], r = e.length, i = 0; i < r;) {
        var a = Math.ceil((r - i) / t--);
        n.push(e.slice(i, i + a)), i += a
    }
    return n
}

function Ni(e, t, n) {
    if (this._attributes = t, this._numberOfInstances = n, t.length !== 0) {
        var r = eP(t),
            i = e.floatingPointTexture,
            a = r === ae.FLOAT && !i,
            o = tP(t, a),
            s = nP(o, t, a),
            c = Math.floor(pe.maximumTextureSize / s),
            f = Math.min(n, c),
            h = s * f,
            d = Math.ceil(n / f),
            _ = 1 / h,
            v = _ * .5,
            m = 1 / d,
            g = m * .5;
        this._textureDimensions = new R(h, d), this._textureStep = new U(_, v, m, g), this._pixelDatatype = a ? ae.UNSIGNED_BYTE : r, this._packFloats = a, this._offsets = o, this._stride = s, this._texture = void 0;
        var y = 4 * h * d;
        this._batchValues = r === ae.FLOAT && !a ? new Float32Array(y) : new Uint8Array(y), this._batchValuesDirty = !1
    }
}
Object.defineProperties(Ni.prototype, {
    attributes: {
        get: function() {
            return this._attributes
        }
    },
    numberOfInstances: {
        get: function() {
            return this._numberOfInstances
        }
    }
});

function eP(e) {
    for (var t = !1, n = e.length, r = 0; r < n; ++r)
        if (e[r].componentDatatype !== ee.UNSIGNED_BYTE) {
            t = !0;
            break
        }
    return t ? ae.FLOAT : ae.UNSIGNED_BYTE
}

function ay(e, t) {
    var n = e[t].componentsPerAttribute;
    return n === 2 ? R : n === 3 ? u : n === 4 ? U : Number
}

function tP(e, t) {
    for (var n = new Array(e.length), r = 0, i = e.length, a = 0; a < i; ++a) {
        var o = e[a],
            s = o.componentDatatype;
        n[a] = r, s !== ee.UNSIGNED_BYTE && t ? r += 4 : ++r
    }
    return n
}

function nP(e, t, n) {
    var r = e.length,
        i = e[r - 1],
        a = t[r - 1],
        o = a.componentDatatype;
    return o !== ee.UNSIGNED_BYTE && n ? i + 4 : i + 1
}
var ds = new U;

function rP(e, t, n) {
    var r = U.unpack(e, t, ds),
        i = U.unpackFloat(r);
    r = U.unpack(e, t + 4, ds);
    var a = U.unpackFloat(r);
    r = U.unpack(e, t + 8, ds);
    var o = U.unpackFloat(r);
    r = U.unpack(e, t + 12, ds);
    var s = U.unpackFloat(r);
    return U.fromElements(i, a, o, s, n)
}

function iP(e, t, n) {
    var r = U.packFloat(e.x, ds);
    U.pack(r, t, n), r = U.packFloat(e.y, r), U.pack(r, t, n + 4), r = U.packFloat(e.z, r), U.pack(r, t, n + 8), r = U.packFloat(e.w, r), U.pack(r, t, n + 12)
}
var Bv = new U;
Ni.prototype.getBatchedAttribute = function(e, t, n) {
    var r = this._attributes,
        i = this._offsets[t],
        a = this._stride,
        o = 4 * a * e + 4 * i,
        s;
    this._packFloats && r[t].componentDatatype !== ae.UNSIGNED_BYTE ? s = rP(this._batchValues, o, Bv) : s = U.unpack(this._batchValues, o, Bv);
    var c = ay(r, t);
    return l(c.fromCartesian4) ? c.fromCartesian4(s, n) : l(c.clone) ? c.clone(s, n) : s.x
};
var aP = [void 0, void 0, new R, new u, new U],
    oP = new U;
Ni.prototype.setBatchedAttribute = function(e, t, n) {
    var r = this._attributes,
        i = aP[r[t].componentsPerAttribute],
        a = this.getBatchedAttribute(e, t, i),
        o = ay(this._attributes, t),
        s = l(o.equals) ? o.equals(a, n) : a === n;
    if (!s) {
        var c = oP;
        c.x = l(n.x) ? n.x : n, c.y = l(n.y) ? n.y : 0, c.z = l(n.z) ? n.z : 0, c.w = l(n.w) ? n.w : 0;
        var f = this._offsets[t],
            h = this._stride,
            d = 4 * h * e + 4 * f;
        this._packFloats && r[t].componentDatatype !== ae.UNSIGNED_BYTE ? iP(c, this._batchValues, d) : U.pack(c, this._batchValues, d), this._batchValuesDirty = !0
    }
};

function sP(e, t) {
    var n = e._textureDimensions;
    e._texture = new be({
        context: t,
        pixelFormat: de.RGBA,
        pixelDatatype: e._pixelDatatype,
        width: n.x,
        height: n.y,
        sampler: gt.NEAREST,
        flipY: !1
    })
}

function uP(e) {
    var t = e._textureDimensions;
    e._texture.copyFrom({
        width: t.x,
        height: t.y,
        arrayBufferView: e._batchValues
    })
}
Ni.prototype.update = function(e) {
    l(this._texture) && !this._batchValuesDirty || this._attributes.length === 0 || (this._batchValuesDirty = !1, l(this._texture) || sP(this, e.context), uP(this))
};
Ni.prototype.getUniformMapCallback = function() {
    var e = this;
    return function(t) {
        if (e._attributes.length === 0) return t;
        var n = {
            batchTexture: function() {
                return e._texture
            },
            batchTextureDimensions: function() {
                return e._textureDimensions
            },
            batchTextureStep: function() {
                return e._textureStep
            }
        };
        return En(t, n)
    }
};

function cP(e) {
    var t = e._stride;
    return e._textureDimensions.y === 1 ? `uniform vec4 batchTextureStep; 
vec2 computeSt(float batchId) 
{ 
    float stepX = batchTextureStep.x; 
    float centerX = batchTextureStep.y; 
    float numberOfAttributes = float(` + t + `); 
    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); 
} 
` : `uniform vec4 batchTextureStep; 
uniform vec2 batchTextureDimensions; 
vec2 computeSt(float batchId) 
{ 
    float stepX = batchTextureStep.x; 
    float centerX = batchTextureStep.y; 
    float stepY = batchTextureStep.z; 
    float centerY = batchTextureStep.w; 
    float numberOfAttributes = float(` + t + `); 
    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); 
    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); 
    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); 
} 
`
}

function fP(e) {
    return e === 1 ? "float" : "vec" + e
}

function hP(e) {
    return e === 1 ? ".x" : e === 2 ? ".xy" : e === 3 ? ".xyz" : ""
}

function lP(e, t) {
    var n = e._attributes,
        r = n[t],
        i = r.componentsPerAttribute,
        a = r.functionName,
        o = fP(i),
        s = hP(i),
        c = e._offsets[t],
        f = o + " " + a + `(float batchId) 
{ 
    vec2 st = computeSt(batchId); 
    st.x += batchTextureStep.x * float(` + c + `); 
`;
    return e._packFloats && r.componentDatatype !== ae.UNSIGNED_BYTE ? f += `vec4 textureValue; 
textureValue.x = czm_unpackFloat(texture2D(batchTexture, st)); 
textureValue.y = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x, 0.0))); 
textureValue.z = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); 
textureValue.w = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); 
` : f += `    vec4 textureValue = texture2D(batchTexture, st); 
`, f += "    " + o + " value = textureValue" + s + `; 
`, e._pixelDatatype === ae.UNSIGNED_BYTE && r.componentDatatype === ee.UNSIGNED_BYTE && !r.normalize ? f += `value *= 255.0; 
` : e._pixelDatatype === ae.FLOAT && r.componentDatatype === ee.UNSIGNED_BYTE && r.normalize && (f += `value /= 255.0; 
`), f += `    return value; 
} 
`, f
}
Ni.prototype.getVertexShaderCallback = function() {
    var e = this._attributes;
    if (e.length === 0) return function(i) {
        return i
    };
    var t = `uniform highp sampler2D batchTexture; 
`;
    t += cP(this) + `
`;
    for (var n = e.length, r = 0; r < n; ++r) t += lP(this, r);
    return function(i) {
        var a = i.indexOf("void main"),
            o = i.substring(0, a),
            s = i.substring(a);
        return o + `
` + t + `
` + s
    }
};
Ni.prototype.isDestroyed = function() {
    return !1
};
Ni.prototype.destroy = function() {
    return this._texture = this._texture && this._texture.destroy(), Pe(this)
};

function xs(e, t, n) {
    e = p(e, 0), t = p(t, 0), n = p(n, 0), this.value = new Float32Array([e, t, n])
}
Object.defineProperties(xs.prototype, {
    componentDatatype: {
        get: function() {
            return ee.FLOAT
        }
    },
    componentsPerAttribute: {
        get: function() {
            return 3
        }
    },
    normalize: {
        get: function() {
            return !1
        }
    }
});
xs.fromCartesian3 = function(e) {
    return new xs(e.x, e.y, e.z)
};
xs.toValue = function(e, t) {
    return l(t) || (t = new Float32Array([e.x, e.y, e.z])), t[0] = e.x, t[1] = e.y, t[2] = e.z, t
};

function dP(e, t, n) {
    var r = !n,
        i = e.length,
        a;
    if (!r && i > 1) {
        var o = e[0].modelMatrix;
        for (a = 1; a < i; ++a)
            if (!S.equals(o, e[a].modelMatrix)) {
                r = !0;
                break
            }
    }
    if (r)
        for (a = 0; a < i; ++a) l(e[a].geometry) && Qe.transformToWorldCoordinates(e[a]);
    else S.multiplyTransformation(t, e[0].modelMatrix, t)
}

function ph(e, t) {
    var n = e.attributes,
        r = n.position,
        i = r.values.length / r.componentsPerAttribute;
    n.batchId = new ze({
        componentDatatype: ee.FLOAT,
        componentsPerAttribute: 1,
        values: new Float32Array(i)
    });
    for (var a = n.batchId.values, o = 0; o < i; ++o) a[o] = t
}

function _P(e) {
    for (var t = e.length, n = 0; n < t; ++n) {
        var r = e[n];
        l(r.geometry) ? ph(r.geometry, n) : l(r.westHemisphereGeometry) && l(r.eastHemisphereGeometry) && (ph(r.westHemisphereGeometry, n), ph(r.eastHemisphereGeometry, n))
    }
}

function vP(e) {
    var t = e.instances,
        n = e.projection,
        r = e.elementIndexUintSupported,
        i = e.scene3DOnly,
        a = e.vertexCacheOptimize,
        o = e.compressVertices,
        s = e.modelMatrix,
        c, f, h = t.length;
    for (c = 0; c < h; ++c)
        if (l(t[c].geometry)) {
            t[c].geometry.primitiveType;
            break
        }
    if (dP(t, s, i), !i)
        for (c = 0; c < h; ++c) l(t[c].geometry) && Qe.splitLongitude(t[c]);
    if (_P(t), a)
        for (c = 0; c < h; ++c) {
            var d = t[c];
            l(d.geometry) ? (Qe.reorderForPostVertexCache(d.geometry), Qe.reorderForPreVertexCache(d.geometry)) : l(d.westHemisphereGeometry) && l(d.eastHemisphereGeometry) && (Qe.reorderForPostVertexCache(d.westHemisphereGeometry), Qe.reorderForPreVertexCache(d.westHemisphereGeometry), Qe.reorderForPostVertexCache(d.eastHemisphereGeometry), Qe.reorderForPreVertexCache(d.eastHemisphereGeometry))
        }
    var _ = Qe.combineInstances(t);
    for (h = _.length, c = 0; c < h; ++c) {
        f = _[c];
        var v = f.attributes,
            m;
        if (i)
            for (m in v) v.hasOwnProperty(m) && v[m].componentDatatype === ee.DOUBLE && Qe.encodeAttribute(f, m, m + "3DHigh", m + "3DLow");
        else
            for (m in v)
                if (v.hasOwnProperty(m) && v[m].componentDatatype === ee.DOUBLE) {
                    var g = m + "3D",
                        y = m + "2D";
                    Qe.projectTo2D(f, m, g, y, n), l(f.boundingSphere) && m === "position" && (f.boundingSphereCV = q.fromVertices(f.attributes.position2D.values)), Qe.encodeAttribute(f, g, g + "High", g + "Low"), Qe.encodeAttribute(f, y, y + "High", y + "Low")
                }
        o && Qe.compressVertices(f)
    }
    if (!r) {
        var E = [];
        for (h = _.length, c = 0; c < h; ++c) f = _[c], E = E.concat(Qe.fitToUnsignedShortIndices(f));
        _ = E
    }
    return _
}

function gh(e, t, n, r) {
    var i, a, o, s = r.length - 1;
    if (s >= 0) {
        var c = r[s];
        i = c.offset + c.count, o = c.index, a = n[o].indices.length
    } else i = 0, o = 0, a = n[o].indices.length;
    for (var f = e.length, h = 0; h < f; ++h) {
        var d = e[h],
            _ = d[t];
        if (!!l(_)) {
            var v = _.indices.length;
            i + v > a && (i = 0, a = n[++o].indices.length), r.push({
                index: o,
                offset: i,
                count: v
            }), i += v
        }
    }
}

function mP(e, t) {
    var n = [];
    return gh(e, "geometry", t, n), gh(e, "westHemisphereGeometry", t, n), gh(e, "eastHemisphereGeometry", t, n), n
}
var Br = {};
Br.combineGeometry = function(e) {
    var t, n, r = e.instances,
        i = r.length,
        a, o, s = !1;
    i > 0 && (t = vP(e), t.length > 0 && (n = Qe.createAttributeLocations(t[0]), e.createPickOffsets && (a = mP(r, t))), l(r[0].attributes) && l(r[0].attributes.offset) && (o = new Array(i), s = !0));
    for (var c = new Array(i), f = new Array(i), h = 0; h < i; ++h) {
        var d = r[h],
            _ = d.geometry;
        l(_) && (c[h] = _.boundingSphere, f[h] = _.boundingSphereCV, s && (o[h] = d.geometry.offsetAttribute));
        var v = d.eastHemisphereGeometry,
            m = d.westHemisphereGeometry;
        l(v) && l(m) && (l(v.boundingSphere) && l(m.boundingSphere) && (c[h] = q.union(v.boundingSphere, m.boundingSphere)), l(v.boundingSphereCV) && l(m.boundingSphereCV) && (f[h] = q.union(v.boundingSphereCV, m.boundingSphereCV)))
    }
    return {
        geometries: t,
        modelMatrix: e.modelMatrix,
        attributeLocations: n,
        pickOffsets: a,
        offsetInstanceExtend: o,
        boundingSpheres: c,
        boundingSpheresCV: f
    }
};

function pP(e, t) {
    var n = e.attributes;
    for (var r in n)
        if (n.hasOwnProperty(r)) {
            var i = n[r];
            l(i) && l(i.values) && t.push(i.values.buffer)
        }
    l(e.indices) && t.push(e.indices.buffer)
}

function gP(e, t) {
    for (var n = e.length, r = 0; r < n; ++r) pP(e[r], t)
}

function yP(e) {
    for (var t = 1, n = e.length, r = 0; r < n; r++) {
        var i = e[r];
        if (++t, !!l(i)) {
            var a = i.attributes;
            t += 7 + 2 * q.packedLength + (l(i.indices) ? i.indices.length : 0);
            for (var o in a)
                if (a.hasOwnProperty(o) && l(a[o])) {
                    var s = a[o];
                    t += 5 + s.values.length
                }
        }
    }
    return t
}
Br.packCreateGeometryResults = function(e, t) {
    var n = new Float64Array(yP(e)),
        r = [],
        i = {},
        a = e.length,
        o = 0;
    n[o++] = a;
    for (var s = 0; s < a; s++) {
        var c = e[s],
            f = l(c);
        if (n[o++] = f ? 1 : 0, !!f) {
            n[o++] = c.primitiveType, n[o++] = c.geometryType, n[o++] = p(c.offsetAttribute, -1);
            var h = l(c.boundingSphere) ? 1 : 0;
            n[o++] = h, h && q.pack(c.boundingSphere, n, o), o += q.packedLength;
            var d = l(c.boundingSphereCV) ? 1 : 0;
            n[o++] = d, d && q.pack(c.boundingSphereCV, n, o), o += q.packedLength;
            var _ = c.attributes,
                v = [];
            for (var m in _) _.hasOwnProperty(m) && l(_[m]) && (v.push(m), l(i[m]) || (i[m] = r.length, r.push(m)));
            n[o++] = v.length;
            for (var g = 0; g < v.length; g++) {
                var y = v[g],
                    E = _[y];
                n[o++] = i[y], n[o++] = E.componentDatatype, n[o++] = E.componentsPerAttribute, n[o++] = E.normalize ? 1 : 0, n[o++] = E.values.length, n.set(E.values, o), o += E.values.length
            }
            var w = l(c.indices) ? c.indices.length : 0;
            n[o++] = w, w > 0 && (n.set(c.indices, o), o += w)
        }
    }
    return t.push(n.buffer), {
        stringTable: r,
        packedData: n
    }
};
Br.unpackCreateGeometryResults = function(e) {
    for (var t = e.stringTable, n = e.packedData, r, i = new Array(n[0]), a = 0, o = 1; o < n.length;) {
        var s = n[o++] === 1;
        if (!s) {
            i[a++] = void 0;
            continue
        }
        var c = n[o++],
            f = n[o++],
            h = n[o++];
        h === -1 && (h = void 0);
        var d, _, v = n[o++] === 1;
        v && (d = q.unpack(n, o)), o += q.packedLength;
        var m = n[o++] === 1;
        m && (_ = q.unpack(n, o)), o += q.packedLength;
        var g, y, E, w = new Va,
            C = n[o++];
        for (r = 0; r < C; r++) {
            var A = t[n[o++]],
                x = n[o++];
            E = n[o++];
            var P = n[o++] !== 0;
            g = n[o++], y = ee.createTypedArray(x, g);
            for (var I = 0; I < g; I++) y[I] = n[o++];
            w[A] = new ze({
                componentDatatype: x,
                componentsPerAttribute: E,
                normalize: P,
                values: y
            })
        }
        var D;
        if (g = n[o++], g > 0) {
            var O = y.length / E;
            for (D = yt.createTypedArray(O, g), r = 0; r < g; r++) D[r] = n[o++]
        }
        i[a++] = new rt({
            primitiveType: c,
            geometryType: f,
            boundingSphere: d,
            boundingSphereCV: _,
            indices: D,
            attributes: w,
            offsetAttribute: h
        })
    }
    return i
};

function TP(e, t) {
    var n = e.length,
        r = new Float64Array(1 + n * 19),
        i = 0;
    r[i++] = n;
    for (var a = 0; a < n; a++) {
        var o = e[a];
        if (S.pack(o.modelMatrix, r, i), i += S.packedLength, l(o.attributes) && l(o.attributes.offset)) {
            var s = o.attributes.offset.value;
            r[i] = s[0], r[i + 1] = s[1], r[i + 2] = s[2]
        }
        i += 3
    }
    return t.push(r.buffer), r
}

function EP(e) {
    for (var t = e, n = new Array(t[0]), r = 0, i = 1; i < t.length;) {
        var a = S.unpack(t, i),
            o;
        i += S.packedLength, l(t[i]) && (o = {
            offset: new xs(t[i], t[i + 1], t[i + 2])
        }), i += 3, n[r++] = {
            modelMatrix: a,
            attributes: o
        }
    }
    return n
}
Br.packCombineGeometryParameters = function(e, t) {
    for (var n = e.createGeometryResults, r = n.length, i = 0; i < r; i++) t.push(n[i].packedData.buffer);
    return {
        createGeometryResults: e.createGeometryResults,
        packedInstances: TP(e.instances, t),
        ellipsoid: e.ellipsoid,
        isGeographic: e.projection instanceof un,
        elementIndexUintSupported: e.elementIndexUintSupported,
        scene3DOnly: e.scene3DOnly,
        vertexCacheOptimize: e.vertexCacheOptimize,
        compressVertices: e.compressVertices,
        modelMatrix: e.modelMatrix,
        createPickOffsets: e.createPickOffsets
    }
};
Br.unpackCombineGeometryParameters = function(e) {
    for (var t = EP(e.packedInstances), n = e.createGeometryResults, r = n.length, i = 0, a = 0; a < r; a++)
        for (var o = Br.unpackCreateGeometryResults(n[a]), s = o.length, c = 0; c < s; c++) {
            var f = o[c],
                h = t[i];
            h.geometry = f, ++i
        }
    var d = ne.clone(e.ellipsoid),
        _ = e.isGeographic ? new un(d) : new st(d);
    return {
        instances: t,
        ellipsoid: d,
        projection: _,
        elementIndexUintSupported: e.elementIndexUintSupported,
        scene3DOnly: e.scene3DOnly,
        vertexCacheOptimize: e.vertexCacheOptimize,
        compressVertices: e.compressVertices,
        modelMatrix: S.clone(e.modelMatrix),
        createPickOffsets: e.createPickOffsets
    }
};

function Vv(e) {
    var t = e.length,
        n = 1 + (q.packedLength + 1) * t,
        r = new Float32Array(n),
        i = 0;
    r[i++] = t;
    for (var a = 0; a < t; ++a) {
        var o = e[a];
        l(o) ? (r[i++] = 1, q.pack(e[a], r, i)) : r[i++] = 0, i += q.packedLength
    }
    return r
}

function Gv(e) {
    for (var t = new Array(e[0]), n = 0, r = 1; r < e.length;) e[r++] === 1 && (t[n] = q.unpack(e, r)), ++n, r += q.packedLength;
    return t
}
Br.packCombineGeometryResults = function(e, t) {
    l(e.geometries) && gP(e.geometries, t);
    var n = Vv(e.boundingSpheres),
        r = Vv(e.boundingSpheresCV);
    return t.push(n.buffer, r.buffer), {
        geometries: e.geometries,
        attributeLocations: e.attributeLocations,
        modelMatrix: e.modelMatrix,
        pickOffsets: e.pickOffsets,
        offsetInstanceExtend: e.offsetInstanceExtend,
        boundingSpheres: n,
        boundingSpheresCV: r
    }
};
Br.unpackCombineGeometryResults = function(e) {
    return {
        geometries: e.geometries,
        attributeLocations: e.attributeLocations,
        modelMatrix: e.modelMatrix,
        pickOffsets: e.pickOffsets,
        offsetInstanceExtend: e.offsetInstanceExtend,
        boundingSpheres: Gv(e.boundingSpheres),
        boundingSpheresCV: Gv(e.boundingSpheresCV)
    }
};
var AP = {
    READY: 0,
    CREATING: 1,
    CREATED: 2,
    COMBINING: 3,
    COMBINED: 4,
    COMPLETE: 5,
    FAILED: 6
};
const Gt = Object.freeze(AP);
var Jn = {
    DISABLED: 0,
    ENABLED: 1,
    CAST_ONLY: 2,
    RECEIVE_ONLY: 3
};
Jn.NUMBER_OF_SHADOW_MODES = 4;
Jn.castShadows = function(e) {
    return e === Jn.ENABLED || e === Jn.CAST_ONLY
};
Jn.receiveShadows = function(e) {
    return e === Jn.ENABLED || e === Jn.RECEIVE_ONLY
};
Jn.fromCastReceive = function(e, t) {
    return e && t ? Jn.ENABLED : e ? Jn.CAST_ONLY : t ? Jn.RECEIVE_ONLY : Jn.DISABLED
};
const Ma = Object.freeze(Jn);

function mt(e) {
    e = p(e, p.EMPTY_OBJECT), this.geometryInstances = e.geometryInstances, this.appearance = e.appearance, this._appearance = void 0, this._material = void 0, this.depthFailAppearance = e.depthFailAppearance, this._depthFailAppearance = void 0, this._depthFailMaterial = void 0, this.modelMatrix = S.clone(p(e.modelMatrix, S.IDENTITY)), this._modelMatrix = new S, this.show = p(e.show, !0), this._vertexCacheOptimize = p(e.vertexCacheOptimize, !1), this._interleave = p(e.interleave, !1), this._releaseGeometryInstances = p(e.releaseGeometryInstances, !0), this._allowPicking = p(e.allowPicking, !0), this._asynchronous = p(e.asynchronous, !0), this._compressVertices = p(e.compressVertices, !0), this.cull = p(e.cull, !0), this.debugShowBoundingVolume = p(e.debugShowBoundingVolume, !1), this.rtcCenter = e.rtcCenter, this.shadows = p(e.shadows, Ma.DISABLED), this._translucent = void 0, this._state = Gt.READY, this._geometries = [], this._error = void 0, this._numberOfInstances = 0, this._boundingSpheres = [], this._boundingSphereWC = [], this._boundingSphereCV = [], this._boundingSphere2D = [], this._boundingSphereMorph = [], this._perInstanceAttributeCache = [], this._instanceIds = [], this._lastPerInstanceAttributeIndex = 0, this._va = [], this._attributeLocations = void 0, this._primitiveType = void 0, this._frontFaceRS = void 0, this._backFaceRS = void 0, this._sp = void 0, this._depthFailAppearance = void 0, this._spDepthFail = void 0, this._frontFaceDepthFailRS = void 0, this._backFaceDepthFailRS = void 0, this._pickIds = [], this._colorCommands = [], this._pickCommands = [], this._createBoundingVolumeFunction = e._createBoundingVolumeFunction, this._createRenderStatesFunction = e._createRenderStatesFunction, this._createShaderProgramFunction = e._createShaderProgramFunction, this._createCommandsFunction = e._createCommandsFunction, this._updateAndQueueCommandsFunction = e._updateAndQueueCommandsFunction, this._createPickOffsets = e._createPickOffsets, this._pickOffsets = void 0, this._createGeometryResults = void 0, this._ready = !1, this._readyPromise = he.defer(), this._batchTable = void 0, this._batchTableAttributeIndices = void 0, this._offsetInstanceExtend = void 0, this._batchTableOffsetAttribute2DIndex = void 0, this._batchTableOffsetsUpdated = !1, this._instanceBoundingSpheres = void 0, this._instanceBoundingSpheresCV = void 0, this._tempBoundingSpheres = void 0, this._recomputeBoundingSpheres = !1, this._batchTableBoundingSpheresUpdated = !1, this._batchTableBoundingSphereAttributeIndices = void 0
}
Object.defineProperties(mt.prototype, {
    vertexCacheOptimize: {
        get: function() {
            return this._vertexCacheOptimize
        }
    },
    interleave: {
        get: function() {
            return this._interleave
        }
    },
    releaseGeometryInstances: {
        get: function() {
            return this._releaseGeometryInstances
        }
    },
    allowPicking: {
        get: function() {
            return this._allowPicking
        }
    },
    asynchronous: {
        get: function() {
            return this._asynchronous
        }
    },
    compressVertices: {
        get: function() {
            return this._compressVertices
        }
    },
    ready: {
        get: function() {
            return this._ready
        }
    },
    readyPromise: {
        get: function() {
            return this._readyPromise.promise
        }
    }
});

function CP(e) {
    var t = e.length,
        n = [],
        r = e[0].attributes,
        i;
    for (i in r)
        if (r.hasOwnProperty(i) && l(r[i])) {
            for (var a = r[i], o = !0, s = 1; s < t; ++s) {
                var c = e[s].attributes[i];
                if (!l(c) || a.componentDatatype !== c.componentDatatype || a.componentsPerAttribute !== c.componentsPerAttribute || a.normalize !== c.normalize) {
                    o = !1;
                    break
                }
            }
            o && n.push(i)
        }
    return n
}
var wP = new R,
    xP = new u,
    oy = new U;

function sy(e) {
    var t = e.length;
    if (t === 1) return e[0];
    if (t === 2) return R.unpack(e, 0, wP);
    if (t === 3) return u.unpack(e, 0, xP);
    if (t === 4) return U.unpack(e, 0, oy)
}

function SP(e, t) {
    var n = e.geometryInstances,
        r = Array.isArray(n) ? n : [n],
        i = r.length;
    if (i !== 0) {
        var a = CP(r),
            o = a.length,
            s = [],
            c = {},
            f = {},
            h, d = r[0],
            _ = d.attributes,
            v, m, g;
        for (v = 0; v < o; ++v) m = a[v], g = _[m], c[m] = v, s.push({
            functionName: "czm_batchTable_" + m,
            componentDatatype: g.componentDatatype,
            componentsPerAttribute: g.componentsPerAttribute,
            normalize: g.normalize
        });
        a.indexOf("distanceDisplayCondition") !== -1 && (s.push({
            functionName: "czm_batchTable_boundingSphereCenter3DHigh",
            componentDatatype: ee.FLOAT,
            componentsPerAttribute: 3
        }, {
            functionName: "czm_batchTable_boundingSphereCenter3DLow",
            componentDatatype: ee.FLOAT,
            componentsPerAttribute: 3
        }, {
            functionName: "czm_batchTable_boundingSphereCenter2DHigh",
            componentDatatype: ee.FLOAT,
            componentsPerAttribute: 3
        }, {
            functionName: "czm_batchTable_boundingSphereCenter2DLow",
            componentDatatype: ee.FLOAT,
            componentsPerAttribute: 3
        }, {
            functionName: "czm_batchTable_boundingSphereRadius",
            componentDatatype: ee.FLOAT,
            componentsPerAttribute: 1
        }), f.center3DHigh = s.length - 5, f.center3DLow = s.length - 4, f.center2DHigh = s.length - 3, f.center2DLow = s.length - 2, f.radius = s.length - 1), a.indexOf("offset") !== -1 && (s.push({
            functionName: "czm_batchTable_offset2D",
            componentDatatype: ee.FLOAT,
            componentsPerAttribute: 3
        }), h = s.length - 1), s.push({
            functionName: "czm_batchTable_pickColor",
            componentDatatype: ee.UNSIGNED_BYTE,
            componentsPerAttribute: 4,
            normalize: !0
        });
        var y = s.length,
            E = new Ni(t, s, i);
        for (v = 0; v < i; ++v) {
            var w = r[v];
            _ = w.attributes;
            for (var C = 0; C < o; ++C) {
                m = a[C], g = _[m];
                var A = sy(g.value),
                    x = c[m];
                E.setBatchedAttribute(v, x, A)
            }
            var P = {
                primitive: p(w.pickPrimitive, e)
            };
            l(w.id) && (P.id = w.id);
            var I = t.createPickId(P);
            e._pickIds.push(I);
            var D = I.color,
                O = oy;
            O.x = H.floatToByte(D.red), O.y = H.floatToByte(D.green), O.z = H.floatToByte(D.blue), O.w = H.floatToByte(D.alpha), E.setBatchedAttribute(v, y - 1, O)
        }
        e._batchTable = E, e._batchTableAttributeIndices = c, e._batchTableBoundingSphereAttributeIndices = f, e._batchTableOffsetAttribute2DIndex = h
    }
}

function RP(e) {
    var t;
    return Array.isArray(e.values) ? t = e.values.slice(0) : t = new e.values.constructor(e.values), new ze({
        componentDatatype: e.componentDatatype,
        componentsPerAttribute: e.componentsPerAttribute,
        normalize: e.normalize,
        values: t
    })
}

function DP(e) {
    var t = e.attributes,
        n = new Va;
    for (var r in t) t.hasOwnProperty(r) && l(t[r]) && (n[r] = RP(t[r]));
    var i;
    if (l(e.indices)) {
        var a = e.indices;
        Array.isArray(a) ? i = a.slice(0) : i = new a.constructor(a)
    }
    return new rt({
        attributes: n,
        indices: i,
        primitiveType: e.primitiveType,
        boundingSphere: q.clone(e.boundingSphere)
    })
}

function IP(e, t) {
    return {
        geometry: t,
        attributes: e.attributes,
        modelMatrix: S.clone(e.modelMatrix),
        pickPrimitive: e.pickPrimitive,
        id: e.id
    }
}
var PP = /attribute\s+vec(?:3|4)\s+(.*)3DHigh;/g;
mt._modifyShaderPosition = function(e, t, n) {
    for (var r, i = "", a = "", o = "";
        (r = PP.exec(t)) !== null;) {
        var s = r[1],
            c = "vec4 czm_compute" + s[0].toUpperCase() + s.substr(1) + "()";
        c !== "vec4 czm_computePosition()" && (i += c + `;
`), l(e.rtcCenter) ? (t = t.replace(/attribute\s+vec(?:3|4)\s+position3DHigh;/g, ""), t = t.replace(/attribute\s+vec(?:3|4)\s+position3DLow;/g, ""), i += `uniform mat4 u_modifiedModelView;
`, a += `attribute vec4 position;
`, o += c + `
{
    return u_modifiedModelView * position;
}

`, t = t.replace(/czm_modelViewRelativeToEye\s+\*\s+/g, ""), t = t.replace(/czm_modelViewProjectionRelativeToEye/g, "czm_projection")) : n ? o += c + `
{
    return czm_translateRelativeToEye(` + s + "3DHigh, " + s + `3DLow);
}

` : (a += "attribute vec3 " + s + `2DHigh;
attribute vec3 ` + s + `2DLow;
`, o += c + `
{
    vec4 p;
    if (czm_morphTime == 1.0)
    {
        p = czm_translateRelativeToEye(` + s + "3DHigh, " + s + `3DLow);
    }
    else if (czm_morphTime == 0.0)
    {
        p = czm_translateRelativeToEye(` + s + "2DHigh.zxy, " + s + `2DLow.zxy);
    }
    else
    {
        p = czm_columbusViewMorph(
                czm_translateRelativeToEye(` + s + "2DHigh.zxy, " + s + `2DLow.zxy),
                czm_translateRelativeToEye(` + s + "3DHigh, " + s + `3DLow),
                czm_morphTime);
    }
    return p;
}

`)
    }
    return [i, a, t, o].join(`
`)
};
mt._appendShowToShader = function(e, t) {
    if (!l(e._batchTableAttributeIndices.show)) return t;
    var n = Re.replaceMain(t, "czm_non_show_main"),
        r = `void main() 
{ 
    czm_non_show_main(); 
    gl_Position *= czm_batchTable_show(batchId); 
}`;
    return n + `
` + r
};
mt._updateColorAttribute = function(e, t, n) {
    if (!l(e._batchTableAttributeIndices.color) && !l(e._batchTableAttributeIndices.depthFailColor) || t.search(/attribute\s+vec4\s+color;/g) === -1) return t;
    var r = t;
    return r = r.replace(/attribute\s+vec4\s+color;/g, ""), n ? r = r.replace(/(\b)color(\b)/g, "$1czm_batchTable_depthFailColor(batchId)$2") : r = r.replace(/(\b)color(\b)/g, "$1czm_batchTable_color(batchId)$2"), r
};

function Hv(e) {
    var t = Re.replaceMain(e, "czm_non_pick_main"),
        n = `varying vec4 v_pickColor; 
void main() 
{ 
    czm_non_pick_main(); 
    v_pickColor = czm_batchTable_pickColor(batchId); 
}`;
    return t + `
` + n
}

function kv(e) {
    return `varying vec4 v_pickColor;
` + e
}
mt._updatePickColorAttribute = function(e) {
    var t = e.replace(/attribute\s+vec4\s+pickColor;/g, "");
    return t = t.replace(/(\b)pickColor(\b)/g, "$1czm_batchTable_pickColor(batchId)$2"), t
};
mt._appendOffsetToShader = function(e, t) {
    if (!l(e._batchTableAttributeIndices.offset)) return t;
    var n = `attribute float batchId;
`;
    n += "attribute float applyOffset;";
    var r = t.replace(/attribute\s+float\s+batchId;/g, n),
        i = `vec4 $1 = czm_computePosition();
`;
    return i += `    if (czm_sceneMode == czm_sceneMode3D)
`, i += `    {
`, i += "        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);", i += `    }
`, i += `    else
`, i += `    {
`, i += "        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);", i += `    }
`, r = r.replace(/vec4\s+([A-Za-z0-9_]+)\s+=\s+czm_computePosition\(\);/g, i), r
};
mt._appendDistanceDisplayConditionToShader = function(e, t, n) {
    if (!l(e._batchTableAttributeIndices.distanceDisplayCondition)) return t;
    var r = Re.replaceMain(t, "czm_non_distanceDisplayCondition_main"),
        i = `void main() 
{ 
    czm_non_distanceDisplayCondition_main(); 
    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);
    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);
    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);
    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);
`;
    return n ? i += `    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);
` : i += `    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);
    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);
    vec4 centerRTE;
    if (czm_morphTime == 1.0)
    {
        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);
    }
    else if (czm_morphTime == 0.0)
    {
        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);
    }
    else
    {
        centerRTE = czm_columbusViewMorph(
                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),
                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),
                czm_morphTime);
    }
`, i += `    float radiusSq = boundingSphereRadius * boundingSphereRadius; 
    float distanceSq; 
    if (czm_sceneMode == czm_sceneMode2D) 
    { 
        distanceSq = czm_eyeHeight2D.y - radiusSq; 
    } 
    else 
    { 
        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; 
    } 
    distanceSq = max(distanceSq, 0.0); 
    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; 
    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; 
    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; 
    gl_Position *= show; 
}`, r + `
` + i
};

function Wv(e, t) {
    if (!e.compressVertices) return t;
    var n = t.search(/attribute\s+vec3\s+normal;/g) !== -1,
        r = t.search(/attribute\s+vec2\s+st;/g) !== -1;
    if (!n && !r) return t;
    var i = t.search(/attribute\s+vec3\s+tangent;/g) !== -1,
        a = t.search(/attribute\s+vec3\s+bitangent;/g) !== -1,
        o = r && n ? 2 : 1;
    o += i || a ? 1 : 0;
    var s = o > 1 ? "vec" + o : "float",
        c = "compressedAttributes",
        f = "attribute " + s + " " + c + ";",
        h = "",
        d = "";
    if (r) {
        h += `vec2 st;
`;
        var _ = o > 1 ? c + ".x" : c;
        d += "    st = czm_decompressTextureCoordinates(" + _ + `);
`
    }
    n && i && a ? (h += `vec3 normal;
vec3 tangent;
vec3 bitangent;
`, d += "    czm_octDecode(" + c + "." + (r ? "yz" : "xy") + `, normal, tangent, bitangent);
`) : (n && (h += `vec3 normal;
`, d += "    normal = czm_octDecode(" + c + (o > 1 ? "." + (r ? "y" : "x") : "") + `);
`), i && (h += `vec3 tangent;
`, d += "    tangent = czm_octDecode(" + c + "." + (r && n ? "z" : "y") + `);
`), a && (h += `vec3 bitangent;
`, d += "    bitangent = czm_octDecode(" + c + "." + (r && n ? "z" : "y") + `);
`));
    var v = t;
    v = v.replace(/attribute\s+vec3\s+normal;/g, ""), v = v.replace(/attribute\s+vec2\s+st;/g, ""), v = v.replace(/attribute\s+vec3\s+tangent;/g, ""), v = v.replace(/attribute\s+vec3\s+bitangent;/g, ""), v = Re.replaceMain(v, "czm_non_compressed_main");
    var m = `void main() 
{ 
` + d + `    czm_non_compressed_main(); 
}`;
    return [f, h, v, m].join(`
`)
}

function OP(e) {
    var t = Re.replaceMain(e, "czm_non_depth_clamp_main");
    return t += `void main() {
    czm_non_depth_clamp_main();
    gl_Position = czm_depthClamp(gl_Position);}
`, t
}

function MP(e) {
    var t = Re.replaceMain(e, "czm_non_depth_clamp_main");
    return t += `void main() {
    czm_non_depth_clamp_main();
#if defined(GL_EXT_frag_depth)
    #if defined(LOG_DEPTH)
        czm_writeLogDepth();
    #else
        czm_writeDepthClamp();
    #endif
#endif
}
`, t = `#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
#endif
` + t, t
}

function qv(e, t) {
    e.vertexAttributes
}

function NP(e, t) {
    return function() {
        return e[t]
    }
}
var yh = Math.max(An.hardwareConcurrency - 1, 1),
    Ru, bP = new Lt("combineGeometry", Number.POSITIVE_INFINITY);

function FP(e, t) {
    var n, r, i, a, o = e._instanceIds;
    if (e._state === Gt.READY) {
        n = Array.isArray(e.geometryInstances) ? e.geometryInstances : [e.geometryInstances];
        var s = e._numberOfInstances = n.length,
            c = [],
            f = [];
        for (i = 0; i < s; ++i) r = n[i].geometry, o.push(n[i].id), f.push({
            moduleName: r._workerName,
            geometry: r
        });
        if (!l(Ru))
            for (Ru = new Array(yh), i = 0; i < yh; i++) Ru[i] = new Lt("createGeometry", Number.POSITIVE_INFINITY);
        var h;
        for (f = QI(f, yh), i = 0; i < f.length; i++) {
            var d = 0,
                _ = f[i],
                v = _.length;
            for (a = 0; a < v; ++a) h = _[a], r = h.geometry, l(r.constructor.pack) && (h.offset = d, d += p(r.constructor.packedLength, r.packedLength));
            var m;
            if (d > 0) {
                var g = new Float64Array(d);
                for (m = [g.buffer], a = 0; a < v; ++a) h = _[a], r = h.geometry, l(r.constructor.pack) && (r.constructor.pack(r, g, h.offset), h.geometry = g)
            }
            c.push(Ru[i].scheduleTask({
                subTasks: f[i]
            }, m))
        }
        e._state = Gt.CREATING, he.all(c, function(A) {
            e._createGeometryResults = A, e._state = Gt.CREATED
        }).otherwise(function(A) {
            Ts(e, t, Gt.FAILED, A)
        })
    } else if (e._state === Gt.CREATED) {
        var y = [];
        n = Array.isArray(e.geometryInstances) ? e.geometryInstances : [e.geometryInstances];
        var E = t.scene3DOnly,
            w = t.mapProjection,
            C = bP.scheduleTask(Br.packCombineGeometryParameters({
                createGeometryResults: e._createGeometryResults,
                instances: n,
                ellipsoid: w.ellipsoid,
                projection: w,
                elementIndexUintSupported: t.context.elementIndexUint,
                scene3DOnly: E,
                vertexCacheOptimize: e.vertexCacheOptimize,
                compressVertices: e.compressVertices,
                modelMatrix: e.modelMatrix,
                createPickOffsets: e._createPickOffsets
            }, y), y);
        e._createGeometryResults = void 0, e._state = Gt.COMBINING, he(C, function(A) {
            var x = Br.unpackCombineGeometryResults(A);
            e._geometries = x.geometries, e._attributeLocations = x.attributeLocations, e.modelMatrix = S.clone(x.modelMatrix, e.modelMatrix), e._pickOffsets = x.pickOffsets, e._offsetInstanceExtend = x.offsetInstanceExtend, e._instanceBoundingSpheres = x.boundingSpheres, e._instanceBoundingSpheresCV = x.boundingSpheresCV, l(e._geometries) && e._geometries.length > 0 ? (e._recomputeBoundingSpheres = !0, e._state = Gt.COMBINED) : Ts(e, t, Gt.FAILED, void 0)
        }).otherwise(function(A) {
            Ts(e, t, Gt.FAILED, A)
        })
    }
}

function LP(e, t) {
    var n = Array.isArray(e.geometryInstances) ? e.geometryInstances : [e.geometryInstances],
        r = e._numberOfInstances = n.length,
        i = new Array(r),
        a = e._instanceIds,
        o, s, c = 0;
    for (s = 0; s < r; s++) {
        o = n[s];
        var f = o.geometry,
            h;
        l(f.attributes) && l(f.primitiveType) ? h = DP(f) : h = f.constructor.createGeometry(f), i[c++] = IP(o, h), a.push(o.id)
    }
    i.length = c;
    var d = t.scene3DOnly,
        _ = t.mapProjection,
        v = Br.combineGeometry({
            instances: i,
            ellipsoid: _.ellipsoid,
            projection: _,
            elementIndexUintSupported: t.context.elementIndexUint,
            scene3DOnly: d,
            vertexCacheOptimize: e.vertexCacheOptimize,
            compressVertices: e.compressVertices,
            modelMatrix: e.modelMatrix,
            createPickOffsets: e._createPickOffsets
        });
    e._geometries = v.geometries, e._attributeLocations = v.attributeLocations, e.modelMatrix = S.clone(v.modelMatrix, e.modelMatrix), e._pickOffsets = v.pickOffsets, e._offsetInstanceExtend = v.offsetInstanceExtend, e._instanceBoundingSpheres = v.boundingSpheres, e._instanceBoundingSpheresCV = v.boundingSpheresCV, l(e._geometries) && e._geometries.length > 0 ? (e._recomputeBoundingSpheres = !0, e._state = Gt.COMBINED) : Ts(e, t, Gt.FAILED, void 0)
}

function UP(e, t) {
    var n = e._batchTableAttributeIndices.offset;
    if (!e._recomputeBoundingSpheres || !l(n)) {
        e._recomputeBoundingSpheres = !1;
        return
    }
    var r, i = e._offsetInstanceExtend,
        a = e._instanceBoundingSpheres,
        o = a.length,
        s = e._tempBoundingSpheres;
    if (!l(s)) {
        for (s = new Array(o), r = 0; r < o; r++) s[r] = new q;
        e._tempBoundingSpheres = s
    }
    for (r = 0; r < o; ++r) {
        var c = s[r],
            f = e._batchTable.getBatchedAttribute(r, n, new u);
        c = a[r].clone(c), hy(c, f, i[r])
    }
    var h = [],
        d = [],
        _ = [];
    for (r = 0; r < o; ++r) {
        var v = s[r],
            m = v.center.x - v.radius;
        m > 0 || q.intersectPlane(v, Ne.ORIGIN_ZX_PLANE) !== nt.INTERSECTING ? h.push(v) : (d.push(v), _.push(v))
    }
    var g = h[0],
        y = _[0],
        E = d[0];
    for (r = 1; r < h.length; r++) g = q.union(g, h[r]);
    for (r = 1; r < _.length; r++) y = q.union(y, _[r]);
    for (r = 1; r < d.length; r++) E = q.union(E, d[r]);
    var w = [];
    for (l(g) && w.push(g), l(y) && w.push(y), l(E) && w.push(E), r = 0; r < w.length; r++) {
        var C = w[r].clone(e._boundingSpheres[r]);
        e._boundingSpheres[r] = C, e._boundingSphereCV[r] = q.projectTo2D(C, t.mapProjection, e._boundingSphereCV[r])
    }
    mt._updateBoundingVolumes(e, t, e.modelMatrix, !0), e._recomputeBoundingSpheres = !1
}
var Yv = new rn,
    uy = new K,
    cy = new u,
    fy = new q;

function zP(e, t) {
    var n = l(e._batchTableAttributeIndices.distanceDisplayCondition);
    if (!(!n || e._batchTableBoundingSpheresUpdated)) {
        for (var r = e._batchTableBoundingSphereAttributeIndices, i = r.center3DHigh, a = r.center3DLow, o = r.center2DHigh, s = r.center2DLow, c = r.radius, f = t.mapProjection, h = f.ellipsoid, d = e._batchTable, _ = e._instanceBoundingSpheres, v = _.length, m = 0; m < v; ++m) {
            var g = _[m];
            if (!!l(g)) {
                var y = e.modelMatrix;
                l(y) && (g = q.transform(g, y, fy));
                var E = g.center,
                    w = g.radius,
                    C = rn.fromCartesian(E, Yv);
                if (d.setBatchedAttribute(m, i, C.high), d.setBatchedAttribute(m, a, C.low), !t.scene3DOnly) {
                    var A = h.cartesianToCartographic(E, uy),
                        x = f.project(A, cy);
                    C = rn.fromCartesian(x, Yv), d.setBatchedAttribute(m, o, C.high), d.setBatchedAttribute(m, s, C.low)
                }
                d.setBatchedAttribute(m, c, w)
            }
        }
        e._batchTableBoundingSpheresUpdated = !0
    }
}
var Th = new u,
    BP = new u;

function Xv(e, t) {
    var n = l(e._batchTableAttributeIndices.offset);
    if (!(!n || e._batchTableOffsetsUpdated || t.scene3DOnly)) {
        for (var r = e._batchTableOffsetAttribute2DIndex, i = t.mapProjection, a = i.ellipsoid, o = e._batchTable, s = e._instanceBoundingSpheres, c = s.length, f = 0; f < c; ++f) {
            var h = s[f];
            if (!!l(h)) {
                var d = o.getBatchedAttribute(f, e._batchTableAttributeIndices.offset);
                if (u.equals(d, u.ZERO)) {
                    o.setBatchedAttribute(f, r, u.ZERO);
                    continue
                }
                var _ = e.modelMatrix;
                l(_) && (h = q.transform(h, _, fy));
                var v = h.center;
                v = a.scaleToGeodeticSurface(v, BP);
                var m = a.cartesianToCartographic(v, uy),
                    g = i.project(m, cy),
                    y = u.add(d, v, Th);
                m = a.cartesianToCartographic(y, m);
                var E = i.project(m, Th),
                    w = u.subtract(E, g, Th),
                    C = w.x;
                w.x = w.z, w.z = w.y, w.y = C, o.setBatchedAttribute(f, r, w)
            }
        }
        e._batchTableOffsetsUpdated = !0
    }
}

function VP(e, t) {
    for (var n = e._attributeLocations, r = e._geometries, i = t.scene3DOnly, a = t.context, o = [], s = r.length, c = 0; c < s; ++c) {
        var f = r[c];
        if (o.push(Cn.fromGeometry({
                context: a,
                geometry: f,
                attributeLocations: n,
                bufferUsage: Ye.STATIC_DRAW,
                interleave: e._interleave
            })), l(e._createBoundingVolumeFunction)) e._createBoundingVolumeFunction(t, f);
        else if (e._boundingSpheres.push(q.clone(f.boundingSphere)), e._boundingSphereWC.push(new q), !i) {
            var h = f.boundingSphereCV.center,
                d = h.x,
                _ = h.y,
                v = h.z;
            h.x = v, h.y = d, h.z = _, e._boundingSphereCV.push(q.clone(f.boundingSphereCV)), e._boundingSphere2D.push(new q), e._boundingSphereMorph.push(new q)
        }
    }
    e._va = o, e._primitiveType = r[0].primitiveType, e.releaseGeometryInstances && (e.geometryInstances = void 0), e._geometries = void 0, Ts(e, t, Gt.COMPLETE, void 0)
}

function GP(e, t, n, r) {
    var i = n.getRenderState(),
        a;
    r ? (a = sn(i, !1), a.cull = {
        enabled: !0,
        face: Qn.BACK
    }, e._frontFaceRS = Ge.fromCache(a), a.cull.face = Qn.FRONT, e._backFaceRS = Ge.fromCache(a)) : (e._frontFaceRS = Ge.fromCache(i), e._backFaceRS = e._frontFaceRS), a = sn(i, !1), l(e._depthFailAppearance) && (a.depthTest.enabled = !1), l(e._depthFailAppearance) && (i = e._depthFailAppearance.getRenderState(), a = sn(i, !1), a.depthTest.func = Tl.GREATER, r ? (a.cull = {
        enabled: !0,
        face: Qn.BACK
    }, e._frontFaceDepthFailRS = Ge.fromCache(a), a.cull.face = Qn.FRONT, e._backFaceDepthFailRS = Ge.fromCache(a)) : (e._frontFaceDepthFailRS = Ge.fromCache(a), e._backFaceDepthFailRS = e._frontFaceRS))
}

function HP(e, t, n) {
    var r = t.context,
        i = e._attributeLocations,
        a = e._batchTable.getVertexShaderCallback()(n.vertexShaderSource);
    a = mt._appendOffsetToShader(e, a), a = mt._appendShowToShader(e, a), a = mt._appendDistanceDisplayConditionToShader(e, a, t.scene3DOnly), a = Hv(a), a = mt._updateColorAttribute(e, a, !1), a = Wv(e, a), a = mt._modifyShaderPosition(e, a, t.scene3DOnly);
    var o = n.getFragmentShaderSource();
    o = kv(o), e._sp = Mt.replaceCache({
        context: r,
        shaderProgram: e._sp,
        vertexShaderSource: a,
        fragmentShaderSource: o,
        attributeLocations: i
    }), qv(e._sp), l(e._depthFailAppearance) && (a = e._batchTable.getVertexShaderCallback()(e._depthFailAppearance.vertexShaderSource), a = mt._appendShowToShader(e, a), a = mt._appendDistanceDisplayConditionToShader(e, a, t.scene3DOnly), a = Hv(a), a = mt._updateColorAttribute(e, a, !0), a = Wv(e, a), a = mt._modifyShaderPosition(e, a, t.scene3DOnly), a = OP(a), o = e._depthFailAppearance.getFragmentShaderSource(), o = kv(o), o = MP(o), e._spDepthFail = Mt.replaceCache({
        context: r,
        shaderProgram: e._spDepthFail,
        vertexShaderSource: a,
        fragmentShaderSource: o,
        attributeLocations: i
    }), qv(e._spDepthFail))
}
var rs = new S,
    jv = new u;

function Zv(e, t, n, r) {
    var i = l(n) ? n._uniforms : void 0,
        a = {},
        o = t.uniforms;
    if (l(o))
        for (var s in o) o.hasOwnProperty(s) && (a[s] = NP(o, s));
    var c = En(a, i);
    return c = e._batchTable.getUniformMapCallback()(c), l(e.rtcCenter) && (c.u_modifiedModelView = function() {
        var f = r.context.uniformState.view;
        return S.multiply(f, e._modelMatrix, rs), S.multiplyByPoint(rs, e.rtcCenter, jv), S.setTranslation(rs, jv, rs), rs
    }), c
}

function kP(e, t, n, r, i, a, o, s) {
    var c = Zv(e, t, n, s),
        f;
    l(e._depthFailAppearance) && (f = Zv(e, e._depthFailAppearance, e._depthFailAppearance.material, s));
    var h = r ? ue.TRANSLUCENT : ue.OPAQUE,
        d = i ? 2 : 1;
    d *= l(e._depthFailAppearance) ? 2 : 1, a.length = e._va.length * d;
    for (var _ = a.length, v = 0, m = 0; m < _; ++m) {
        var g;
        i && (g = a[m], l(g) || (g = a[m] = new an({
            owner: e,
            primitiveType: e._primitiveType
        })), g.vertexArray = e._va[v], g.renderState = e._backFaceRS, g.shaderProgram = e._sp, g.uniformMap = c, g.pass = h, ++m), g = a[m], l(g) || (g = a[m] = new an({
            owner: e,
            primitiveType: e._primitiveType
        })), g.vertexArray = e._va[v], g.renderState = e._frontFaceRS, g.shaderProgram = e._sp, g.uniformMap = c, g.pass = h, l(e._depthFailAppearance) && (i && (++m, g = a[m], l(g) || (g = a[m] = new an({
            owner: e,
            primitiveType: e._primitiveType
        })), g.vertexArray = e._va[v], g.renderState = e._backFaceDepthFailRS, g.shaderProgram = e._spDepthFail, g.uniformMap = f, g.pass = h), ++m, g = a[m], l(g) || (g = a[m] = new an({
            owner: e,
            primitiveType: e._primitiveType
        })), g.vertexArray = e._va[v], g.renderState = e._frontFaceDepthFailRS, g.shaderProgram = e._spDepthFail, g.uniformMap = f, g.pass = h), ++v
    }
}
mt._updateBoundingVolumes = function(e, t, n, r) {
    var i, a, o;
    if (r || !S.equals(n, e._modelMatrix))
        for (S.clone(n, e._modelMatrix), a = e._boundingSpheres.length, i = 0; i < a; ++i) o = e._boundingSpheres[i], l(o) && (e._boundingSphereWC[i] = q.transform(o, n, e._boundingSphereWC[i]), t.scene3DOnly || (e._boundingSphere2D[i] = q.clone(e._boundingSphereCV[i], e._boundingSphere2D[i]), e._boundingSphere2D[i].center.x = 0, e._boundingSphereMorph[i] = q.union(e._boundingSphereWC[i], e._boundingSphereCV[i])));
    var s = e.appearance.pixelSize;
    if (l(s))
        for (a = e._boundingSpheres.length, i = 0; i < a; ++i) {
            o = e._boundingSpheres[i];
            var c = e._boundingSphereWC[i],
                f = t.camera.getPixelSize(o, t.context.drawingBufferWidth, t.context.drawingBufferHeight),
                h = f * s;
            c.radius = o.radius + h
        }
};

function WP(e, t, n, r, i, a, o, s) {
    mt._updateBoundingVolumes(e, t, i);
    var c;
    t.mode === k.SCENE3D ? c = e._boundingSphereWC : t.mode === k.COLUMBUS_VIEW ? c = e._boundingSphereCV : t.mode === k.SCENE2D && l(e._boundingSphere2D) ? c = e._boundingSphere2D : l(e._boundingSphereMorph) && (c = e._boundingSphereMorph);
    var f = t.commandList,
        h = t.passes;
    if (h.render || h.pick) {
        var d = e.allowPicking,
            _ = Ma.castShadows(e.shadows),
            v = Ma.receiveShadows(e.shadows),
            m = n.length,
            g = s ? 2 : 1;
        g *= l(e._depthFailAppearance) ? 2 : 1;
        for (var y = 0; y < m; ++y) {
            var E = Math.floor(y / g),
                w = n[y];
            w.modelMatrix = i, w.boundingVolume = c[E], w.cull = a, w.debugShowBoundingVolume = o, w.castShadows = _, w.receiveShadows = v, d ? w.pickId = "v_pickColor" : w.pickId = void 0, f.push(w)
        }
    }
}
mt.prototype.update = function(e) {
    if (!(!l(this.geometryInstances) && this._va.length === 0 || l(this.geometryInstances) && Array.isArray(this.geometryInstances) && this.geometryInstances.length === 0 || !l(this.appearance) || e.mode !== k.SCENE3D && e.scene3DOnly || !e.passes.render && !e.passes.pick)) {
        if (l(this._error)) throw this._error;
        if (this._state !== Gt.FAILED) {
            var t = e.context;
            if (l(this._batchTable) || SP(this, t), this._batchTable.attributes.length > 0) {
                if (pe.maximumVertexTextureImageUnits === 0) throw new je("Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.");
                this._batchTable.update(e)
            }
            if (this._state !== Gt.COMPLETE && this._state !== Gt.COMBINED && (this.asynchronous ? FP(this, e) : LP(this, e)), this._state === Gt.COMBINED && (zP(this, e), Xv(this, e), VP(this, e)), !(!this.show || this._state !== Gt.COMPLETE)) {
                this._batchTableOffsetsUpdated || Xv(this, e), this._recomputeBoundingSpheres && UP(this, e);
                var n = this.appearance,
                    r = n.material,
                    i = !1,
                    a = !1;
                this._appearance !== n ? (this._appearance = n, this._material = r, i = !0, a = !0) : this._material !== r && (this._material = r, a = !0);
                var o = this.depthFailAppearance,
                    s = l(o) ? o.material : void 0;
                this._depthFailAppearance !== o ? (this._depthFailAppearance = o, this._depthFailMaterial = s, i = !0, a = !0) : this._depthFailMaterial !== s && (this._depthFailMaterial = s, a = !0);
                var c = this._appearance.isTranslucent();
                this._translucent !== c && (this._translucent = c, i = !0), l(this._material) && this._material.update(t);
                var f = n.closed && c;
                if (i) {
                    var h = p(this._createRenderStatesFunction, GP);
                    h(this, t, n, f)
                }
                if (a) {
                    var d = p(this._createShaderProgramFunction, HP);
                    d(this, e, n)
                }
                if (i || a) {
                    var _ = p(this._createCommandsFunction, kP);
                    _(this, n, r, c, f, this._colorCommands, this._pickCommands, e)
                }
                var v = p(this._updateAndQueueCommandsFunction, WP);
                v(this, e, this._colorCommands, this._pickCommands, this.modelMatrix, this.cull, this.debugShowBoundingVolume, f)
            }
        }
    }
};
var qP = new q,
    YP = new q;

function hy(e, t, n) {
    if (n === Di.TOP) {
        var r = q.clone(e, qP),
            i = q.clone(e, YP);
        i.center = u.add(i.center, t, i.center), e = q.union(r, i, e)
    } else n === Di.ALL && (e.center = u.add(e.center, t, e.center));
    return e
}

function XP(e, t, n) {
    return function() {
        var r = e.getBatchedAttribute(t, n),
            i = e.attributes[n],
            a = i.componentsPerAttribute,
            o = ee.createTypedArray(i.componentDatatype, a);
        return l(r.constructor.pack) ? r.constructor.pack(r, o, 0) : o[0] = r, o
    }
}

function jP(e, t, n, r, i) {
    return function(a) {
        var o = sy(a);
        e.setBatchedAttribute(t, n, o), i === "offset" && (r._recomputeBoundingSpheres = !0, r._batchTableOffsetsUpdated = !1)
    }
}
var ZP = new u;

function KP(e, t, n) {
    t.boundingSphere = {
        get: function() {
            var r = e._instanceBoundingSpheres[n];
            if (l(r)) {
                r = r.clone();
                var i = e.modelMatrix,
                    a = t.offset;
                l(a) && hy(r, u.fromArray(a.get(), 0, ZP), e._offsetInstanceExtend[n]), l(i) && (r = q.transform(r, i))
            }
            return r
        }
    }, t.boundingSphereCV = {
        get: function() {
            return e._instanceBoundingSpheresCV[n]
        }
    }
}

function $P(e, t, n) {
    t.pickId = {
        get: function() {
            return e._pickIds[n]
        }
    }
}
mt.prototype.getGeometryInstanceAttributes = function(e) {
    for (var t = -1, n = this._lastPerInstanceAttributeIndex, r = this._instanceIds, i = r.length, a = 0; a < i; ++a) {
        var o = (n + a) % i;
        if (e === r[o]) {
            t = o;
            break
        }
    }
    if (t !== -1) {
        var s = this._perInstanceAttributeCache[t];
        if (l(s)) return s;
        var c = this._batchTable,
            f = this._batchTableAttributeIndices;
        s = {};
        var h = {};
        for (var d in f)
            if (f.hasOwnProperty(d)) {
                var _ = f[d];
                h[d] = {
                    get: XP(c, t, _),
                    set: jP(c, t, _, this, d)
                }
            }
        return KP(this, h, t), $P(this, h, t), Object.defineProperties(s, h), this._lastPerInstanceAttributeIndex = t, this._perInstanceAttributeCache[t] = s, s
    }
};
mt.prototype.isDestroyed = function() {
    return !1
};
mt.prototype.destroy = function() {
    var e, t;
    this._sp = this._sp && this._sp.destroy(), this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();
    var n = this._va;
    for (e = n.length, t = 0; t < e; ++t) n[t].destroy();
    this._va = void 0;
    var r = this._pickIds;
    for (e = r.length, t = 0; t < e; ++t) r[t].destroy();
    return this._pickIds = void 0, this._batchTable = this._batchTable && this._batchTable.destroy(), this._instanceIds = void 0, this._perInstanceAttributeCache = void 0, this._attributeLocations = void 0, Pe(this)
};

function Ts(e, t, n, r) {
    e._error = r, e._state = n, t.afterRender.push(function() {
        e._ready = e._state === Gt.COMPLETE || e._state === Gt.FAILED, l(r) ? e._readyPromise.reject(r) : e._readyPromise.resolve(e)
    })
}

function ia() {
    this._array = [], this._offset = 0, this._length = 0
}
Object.defineProperties(ia.prototype, {
    length: {
        get: function() {
            return this._length
        }
    }
});
ia.prototype.enqueue = function(e) {
    this._array.push(e), this._length++
};
ia.prototype.dequeue = function() {
    if (this._length !== 0) {
        var e = this._array,
            t = this._offset,
            n = e[t];
        return e[t] = void 0, t++, t > 10 && t * 2 > e.length && (this._array = e.slice(t), t = 0), this._offset = t, this._length--, n
    }
};
ia.prototype.peek = function() {
    if (this._length !== 0) return this._array[this._offset]
};
ia.prototype.contains = function(e) {
    return this._array.indexOf(e) !== -1
};
ia.prototype.clear = function() {
    this._array.length = this._offset = this._length = 0
};
ia.prototype.sort = function(e) {
    this._offset > 0 && (this._array = this._array.slice(this._offset), this._offset = 0), this._array.sort(e)
};
var Ce = {
        WEST: 0,
        NORTH: 1,
        EAST: 2,
        SOUTH: 3,
        NORTHWEST: 4,
        NORTHEAST: 5,
        SOUTHWEST: 6,
        SOUTHEAST: 7
    },
    Be = {
        NONE: 0,
        CULLED: 1,
        RENDERED: 2,
        REFINED: 3,
        RENDERED_AND_KICKED: 6,
        REFINED_AND_KICKED: 7,
        CULLED_BUT_NEEDED: 9,
        wasKicked: function(e) {
            return e >= Be.RENDERED_AND_KICKED
        },
        originalResult: function(e) {
            return e & 3
        },
        kick: function(e) {
            return e | 4
        }
    };

function bo(e) {
    this.tile = e, this.frameLastUpdated = void 0, this.westMeshes = [], this.westTiles = [], this.southMeshes = [], this.southTiles = [], this.eastMeshes = [], this.eastTiles = [], this.northMeshes = [], this.northTiles = [], this.southwestMesh = void 0, this.southwestTile = void 0, this.southeastMesh = void 0, this.southeastTile = void 0, this.northwestMesh = void 0, this.northwestTile = void 0, this.northeastMesh = void 0, this.northeastTile = void 0, this.changedThisFrame = !0, this.visitedFrame = void 0, this.enqueuedFrame = void 0, this.mesh = void 0, this.vertexArray = void 0, this.waterMaskTexture = void 0, this.waterMaskTranslationAndScale = new U
}
bo.prototype.update = function(e, t, n) {
    this.changedThisFrame && (ly(e, t, this.tile, n), this.changedThisFrame = !1)
};
bo.prototype.destroy = function(e) {
    l(this.vertexArray) && (l(e) ? e.push(this.vertexArray) : Ct._freeVertexArray(this.vertexArray, e), this.vertexArray = void 0), l(this.waterMaskTexture) && (--this.waterMaskTexture.referenceCount, this.waterMaskTexture.referenceCount === 0 && this.waterMaskTexture.destroy(), this.waterMaskTexture = void 0)
};
var JP = new ia;
bo.updateFillTiles = function(e, t, n, r) {
    var i = e._quadtree,
        a = i._levelZeroTiles,
        o = i._lastSelectionFrameNumber,
        s = JP;
    s.clear();
    for (var c = 0; c < t.length; ++c) {
        var f = t[c];
        l(f.data.vertexArray) && s.enqueue(t[c])
    }
    for (var h = s.dequeue(); h !== void 0;) {
        var d = h.findTileToWest(a),
            _ = h.findTileToSouth(a),
            v = h.findTileToEast(a),
            m = h.findTileToNorth(a);
        Bt(e, n, h, d, o, Ce.EAST, !1, s, r), Bt(e, n, h, _, o, Ce.NORTH, !1, s, r), Bt(e, n, h, v, o, Ce.WEST, !1, s, r), Bt(e, n, h, m, o, Ce.SOUTH, !1, s, r);
        var g = d.findTileToNorth(a),
            y = d.findTileToSouth(a),
            E = v.findTileToNorth(a),
            w = v.findTileToSouth(a);
        Bt(e, n, h, g, o, Ce.SOUTHEAST, !1, s, r), Bt(e, n, h, E, o, Ce.SOUTHWEST, !1, s, r), Bt(e, n, h, y, o, Ce.NORTHEAST, !1, s, r), Bt(e, n, h, w, o, Ce.NORTHWEST, !1, s, r), h = s.dequeue()
    }
};

function Bt(e, t, n, r, i, a, o, s, c) {
    if (r !== void 0) {
        for (var f = r; f && (f._lastSelectionResultFrame !== i || Be.wasKicked(f._lastSelectionResult) || Be.originalResult(f._lastSelectionResult) === Be.CULLED);) {
            if (o) return;
            var h = f.parent;
            if (a >= Ce.NORTHWEST && h !== void 0) switch (a) {
                case Ce.NORTHWEST:
                    f = f === h.northwestChild ? h : void 0;
                    break;
                case Ce.NORTHEAST:
                    f = f === h.northeastChild ? h : void 0;
                    break;
                case Ce.SOUTHWEST:
                    f = f === h.southwestChild ? h : void 0;
                    break;
                case Ce.SOUTHEAST:
                    f = f === h.southeastChild ? h : void 0;
                    break
            } else f = h
        }
        if (f !== void 0) {
            if (f._lastSelectionResult === Be.RENDERED) {
                if (l(f.data.vertexArray)) return;
                QP(e, t, n, f, a, i, s, c);
                return
            }
            if (Be.originalResult(r._lastSelectionResult) !== Be.CULLED) switch (a) {
                case Ce.WEST:
                    Bt(e, t, n, r.northwestChild, i, a, !0, s, c), Bt(e, t, n, r.southwestChild, i, a, !0, s, c);
                    break;
                case Ce.EAST:
                    Bt(e, t, n, r.southeastChild, i, a, !0, s, c), Bt(e, t, n, r.northeastChild, i, a, !0, s, c);
                    break;
                case Ce.SOUTH:
                    Bt(e, t, n, r.southwestChild, i, a, !0, s, c), Bt(e, t, n, r.southeastChild, i, a, !0, s, c);
                    break;
                case Ce.NORTH:
                    Bt(e, t, n, r.northeastChild, i, a, !0, s, c), Bt(e, t, n, r.northwestChild, i, a, !0, s, c);
                    break;
                case Ce.NORTHWEST:
                    Bt(e, t, n, r.northwestChild, i, a, !0, s, c);
                    break;
                case Ce.NORTHEAST:
                    Bt(e, t, n, r.northeastChild, i, a, !0, s, c);
                    break;
                case Ce.SOUTHWEST:
                    Bt(e, t, n, r.southwestChild, i, a, !0, s, c);
                    break;
                case Ce.SOUTHEAST:
                    Bt(e, t, n, r.southeastChild, i, a, !0, s, c);
                    break;
                default:
                    throw new we("Invalid edge")
            }
        }
    }
}

function QP(e, t, n, r, i, a, o, s) {
    var c = r.data;
    if (c.fill === void 0) c.fill = new bo(r);
    else if (c.fill.visitedFrame === a) return;
    c.fill.enqueuedFrame !== a && (c.fill.enqueuedFrame = a, c.fill.changedThisFrame = !1, o.enqueue(r)), eO(e, t, n, r, i, s)
}

function eO(e, t, n, r, i, a) {
    var o = r.data.fill,
        s, c = n.data.fill;
    l(c) ? (c.visitedFrame = t.frameNumber, c.changedThisFrame && (ly(e, t, n, a), c.changedThisFrame = !1), s = n.data.fill.mesh) : s = n.data.mesh;
    var f, h;
    switch (i) {
        case Ce.WEST:
            f = o.westMeshes, h = o.westTiles;
            break;
        case Ce.SOUTH:
            f = o.southMeshes, h = o.southTiles;
            break;
        case Ce.EAST:
            f = o.eastMeshes, h = o.eastTiles;
            break;
        case Ce.NORTH:
            f = o.northMeshes, h = o.northTiles;
            break;
        case Ce.NORTHWEST:
            o.changedThisFrame = o.changedThisFrame || o.northwestMesh !== s, o.northwestMesh = s, o.northwestTile = n;
            return;
        case Ce.NORTHEAST:
            o.changedThisFrame = o.changedThisFrame || o.northeastMesh !== s, o.northeastMesh = s, o.northeastTile = n;
            return;
        case Ce.SOUTHWEST:
            o.changedThisFrame = o.changedThisFrame || o.southwestMesh !== s, o.southwestMesh = s, o.southwestTile = n;
            return;
        case Ce.SOUTHEAST:
            o.changedThisFrame = o.changedThisFrame || o.southeastMesh !== s, o.southeastMesh = s, o.southeastTile = n;
            return
    }
    if (n.level <= r.level) {
        o.changedThisFrame = o.changedThisFrame || f[0] !== s || f.length !== 1, f[0] = s, h[0] = n, f.length = 1, h.length = 1;
        return
    }
    var d, _, v, m, g = n.rectangle,
        y, E = r.rectangle;
    switch (i) {
        case Ce.WEST:
            for (y = (E.north - E.south) * T.EPSILON5, d = 0; d < h.length && (v = h[d], m = v.rectangle, !T.greaterThan(g.north, m.south, y)); ++d);
            for (_ = d; _ < h.length && (v = h[_], m = v.rectangle, !T.greaterThanOrEquals(g.south, m.north, y)); ++_);
            break;
        case Ce.SOUTH:
            for (y = (E.east - E.west) * T.EPSILON5, d = 0; d < h.length && (v = h[d], m = v.rectangle, !T.lessThan(g.west, m.east, y)); ++d);
            for (_ = d; _ < h.length && (v = h[_], m = v.rectangle, !T.lessThanOrEquals(g.east, m.west, y)); ++_);
            break;
        case Ce.EAST:
            for (y = (E.north - E.south) * T.EPSILON5, d = 0; d < h.length && (v = h[d], m = v.rectangle, !T.lessThan(g.south, m.north, y)); ++d);
            for (_ = d; _ < h.length && (v = h[_], m = v.rectangle, !T.lessThanOrEquals(g.north, m.south, y)); ++_);
            break;
        case Ce.NORTH:
            for (y = (E.east - E.west) * T.EPSILON5, d = 0; d < h.length && (v = h[d], m = v.rectangle, !T.greaterThan(g.east, m.west, y)); ++d);
            for (_ = d; _ < h.length && (v = h[_], m = v.rectangle, !T.greaterThanOrEquals(g.west, m.east, y)); ++_);
            break
    }
    _ - d === 1 ? (o.changedThisFrame = o.changedThisFrame || f[d] !== s, f[d] = s, h[d] = n) : (o.changedThisFrame = !0, f.splice(d, _ - d, s), h.splice(d, _ - d, n))
}
var wa = new K,
    tO = new K,
    mo = new u,
    Kv = new u,
    El = new R,
    Al = new R,
    $n = new R;

function Jc() {
    this.height = 0, this.encodedNormal = new R
}

function Du(e, t, n, r, i, a, o, s, c) {
    if (l(i)) return i;
    var f;
    if (l(a) && l(o)) f = (a.height + o.height) * .5;
    else if (l(a)) f = a.height;
    else if (l(o)) f = o.height;
    else if (l(s)) f = s.height;
    else {
        var h = e.tile.data,
            d = h.tileBoundingRegion,
            _ = 0,
            v = 0;
        l(d) && (_ = d.minimumHeight, v = d.maximumHeight), f = (_ + v) * .5
    }
    return dy(e, t, n, r, f, c), c
}
var nO = {
        minimumHeight: 0,
        maximumHeight: 0
    },
    $v = new Jc,
    Jv = new Jc,
    Qv = new Jc,
    em = new Jc,
    rO = typeof Uint8Array < "u" ? new Uint8Array(9 * 9) : void 0;

function ly(e, t, n, r) {
    Ct.initialize(n, e.terrainProvider, e._imageryLayers);
    var i = n.data,
        a = i.fill,
        o = n.rectangle,
        s = n.tilingScheme.ellipsoid,
        c = Pu(a, s, 0, 1, a.northwestTile, a.northwestMesh, a.northTiles, a.northMeshes, a.westTiles, a.westMeshes, Qv),
        f = Pu(a, s, 0, 0, a.southwestTile, a.southwestMesh, a.westTiles, a.westMeshes, a.southTiles, a.southMeshes, $v),
        h = Pu(a, s, 1, 0, a.southeastTile, a.southeastMesh, a.southTiles, a.southMeshes, a.eastTiles, a.eastMeshes, Jv),
        d = Pu(a, s, 1, 1, a.northeastTile, a.northeastMesh, a.eastTiles, a.eastMeshes, a.northTiles, a.northMeshes, em);
    c = Du(a, s, 0, 1, c, f, d, h, Qv), f = Du(a, s, 0, 0, f, c, h, d, $v), h = Du(a, s, 1, 1, h, f, d, c, Jv), d = Du(a, s, 1, 1, d, h, c, f, em);
    var _ = f.height,
        v = h.height,
        m = c.height,
        g = d.height,
        y = Math.min(_, v, m, g),
        E = Math.max(_, v, m, g),
        w = (y + E) * .5,
        C, A, x = e.getLevelMaximumGeometricError(n.level),
        P = s.maximumRadius - x,
        I = Math.acos(P / s.maximumRadius) * 4;
    if (I *= 1.5, o.width > I && E - y <= x) {
        var D = new oi({
            width: 9,
            height: 9,
            buffer: rO,
            structure: {
                heightOffset: E
            }
        });
        a.mesh = D._createMeshSync(n.tilingScheme, n.x, n.y, n.level, 1)
    } else {
        var O = new qn(void 0, void 0, void 0, void 0, !0, !0),
            F = tO;
        F.longitude = (o.east + o.west) * .5, F.latitude = (o.north + o.south) * .5, F.height = w, O.center = s.cartographicToCartesian(F, O.center);
        var z = 5,
            b;
        for (b = a.westMeshes, C = 0, A = b.length; C < A; ++C) z += b[C].eastIndicesNorthToSouth.length;
        for (b = a.southMeshes, C = 0, A = b.length; C < A; ++C) z += b[C].northIndicesWestToEast.length;
        for (b = a.eastMeshes, C = 0, A = b.length; C < A; ++C) z += b[C].westIndicesSouthToNorth.length;
        for (b = a.northMeshes, C = 0, A = b.length; C < A; ++C) z += b[C].southIndicesEastToWest.length;
        var M = nO;
        M.minimumHeight = y, M.maximumHeight = E;
        var G = O.getStride(),
            V = new Float32Array(z * G),
            B = 0,
            Y = B;
        B = Iu(s, o, O, V, B, 0, 1, c.height, c.encodedNormal, 1, M), B = Mu(a, s, O, V, B, a.westTiles, a.westMeshes, Ce.EAST, M);
        var j = B;
        B = Iu(s, o, O, V, B, 0, 0, f.height, f.encodedNormal, 0, M), B = Mu(a, s, O, V, B, a.southTiles, a.southMeshes, Ce.NORTH, M);
        var Z = B;
        B = Iu(s, o, O, V, B, 1, 0, h.height, h.encodedNormal, 0, M), B = Mu(a, s, O, V, B, a.eastTiles, a.eastMeshes, Ce.WEST, M);
        var Q = B;
        B = Iu(s, o, O, V, B, 1, 1, d.height, d.encodedNormal, 1, M), B = Mu(a, s, O, V, B, a.northTiles, a.northMeshes, Ce.SOUTH, M), y = M.minimumHeight, E = M.maximumHeight;
        var ie = $e.fromRectangle(o, y, E, n.tilingScheme.ellipsoid),
            Ae = st.geodeticLatitudeToMercatorAngle(o.south),
            re = 1 / (st.geodeticLatitudeToMercatorAngle(o.north) - Ae),
            ve = (st.geodeticLatitudeToMercatorAngle(F.latitude) - Ae) * re;
        s.geodeticSurfaceNormalCartographic(wa, Kv);
        var qe = Ee.octEncode(Kv, El),
            De = B;
        O.encode(V, B * G, ie.center, R.fromElements(.5, .5, $n), w, qe, ve), ++B;
        var _e = B,
            Oe = _e < 256 ? 1 : 2,
            Fe = (_e - 1) * 3,
            ce = Fe * Oe,
            He = (V.length - _e * G) * Float32Array.BYTES_PER_ELEMENT,
            le;
        if (He >= ce) {
            var ft = _e * G * Float32Array.BYTES_PER_ELEMENT;
            le = _e < 256 ? new Uint8Array(V.buffer, ft, Fe) : new Uint16Array(V.buffer, ft, Fe)
        } else le = _e < 256 ? new Uint8Array(Fe) : new Uint16Array(Fe);
        V = new Float32Array(V.buffer, 0, _e * G);
        var Pt = 0;
        for (C = 0; C < _e - 2; ++C) le[Pt++] = De, le[Pt++] = C, le[Pt++] = C + 1;
        le[Pt++] = De, le[Pt++] = C, le[Pt++] = 0;
        var Ie = [];
        for (C = j; C >= Y; --C) Ie.push(C);
        var xn = [];
        for (C = Z; C >= j; --C) xn.push(C);
        var Sn = [];
        for (C = Q; C >= Z; --C) Sn.push(C);
        var St = [];
        for (St.push(0), C = De - 1; C >= Q; --C) St.push(C);
        a.mesh = new xd(O.center, V, le, Fe, _e, y, E, q.fromOrientedBoundingBox(ie), fO(e, ie.center, o, y, E), O.getStride(), ie, O, t.terrainExaggeration, Ie, xn, Sn, St)
    }
    var rr = t.context;
    l(a.vertexArray) && (l(r) ? r.push(a.vertexArray) : Ct._freeVertexArray(a.vertexArray)), a.vertexArray = Ct._createVertexArrayForMesh(rr, a.mesh), i.processImagery(n, e.terrainProvider, t, !0);
    var bt = a.waterMaskTexture;
    if (a.waterMaskTexture = void 0, e.terrainProvider.hasWaterMask) {
        var cn = i._findAncestorTileWithTerrainData(n);
        l(cn) && l(cn.data.waterMaskTexture) && (a.waterMaskTexture = cn.data.waterMaskTexture, ++a.waterMaskTexture.referenceCount, i._computeWaterMaskTranslationAndScale(n, cn, a.waterMaskTranslationAndScale))
    }
    l(bt) && (--bt.referenceCount, bt.referenceCount === 0 && bt.destroy())
}

function Iu(e, t, n, r, i, a, o, s, c, f, h) {
    var d = wa;
    d.longitude = T.lerp(t.west, t.east, a), d.latitude = T.lerp(t.south, t.north, o), d.height = s;
    var _ = e.cartographicToCartesian(d, mo),
        v = Al;
    return v.x = a, v.y = o, n.encode(r, i * n.getStride(), _, v, s, c, f), h.minimumHeight = Math.min(h.minimumHeight, s), h.maximumHeight = Math.max(h.maximumHeight, s), i + 1
}
var Fc = new W;

function Ss(e, t, n, r) {
    var i = e.rectangle,
        a = t.rectangle;
    t.x === 0 && n.x === 1 && e.x === e.tilingScheme.getNumberOfXTilesAtLevel(e.level) - 1 ? (i = W.clone(e.rectangle, Fc), i.west -= T.TWO_PI, i.east -= T.TWO_PI) : e.x === 0 && n.x === 0 && t.x === t.tilingScheme.getNumberOfXTilesAtLevel(t.level) - 1 && (i = W.clone(e.rectangle, Fc), i.west += T.TWO_PI, i.east += T.TWO_PI);
    var o = i.east - i.west,
        s = (a.west - i.west) / o,
        c = (a.east - i.west) / o,
        f = i.north - i.south,
        h = (a.south - i.south) / f,
        d = (a.north - i.south) / f,
        _ = (n.x - s) / (c - s),
        v = (n.y - h) / (d - h);
    return Math.abs(_) < Math.EPSILON5 ? _ = 0 : Math.abs(_ - 1) < Math.EPSILON5 && (_ = 1), Math.abs(v) < Math.EPSILON5 ? v = 0 : Math.abs(v - 1) < Math.EPSILON5 && (v = 1), r.x = _, r.y = v, r
}
var iO = new R;

function Cl(e, t, n, r, i) {
    var a = e.encoding,
        o = e.vertices;
    if (i.height = a.decodeHeight(o, t), a.hasVertexNormals) a.getOctEncodedNormal(o, t, i.encodedNormal);
    else {
        var s = i.encodedNormal;
        s.x = 0, s.y = 0
    }
}
var aO = new R,
    oO = new u;

function sO(e, t, n, r, i, a, o, s, c, f) {
    var h = r.encoding,
        d = r.vertices,
        _ = Ss(t, n, h.decodeTextureCoordinates(d, i, $n), $n),
        v = Ss(t, n, h.decodeTextureCoordinates(d, a, Al), Al),
        m;
    c ? m = (o - _.x) / (v.x - _.x) : m = (s - _.y) / (v.y - _.y);
    var g = h.decodeHeight(d, i),
        y = h.decodeHeight(d, a),
        E = n.rectangle;
    wa.longitude = T.lerp(E.west, E.east, o), wa.latitude = T.lerp(E.south, E.north, s), f.height = wa.height = T.lerp(g, y, m);
    var w;
    if (h.hasVertexNormals) {
        var C = h.getOctEncodedNormal(d, i, iO),
            A = h.getOctEncodedNormal(d, a, aO),
            x = Ee.octDecode(C.x, C.y, mo),
            P = Ee.octDecode(A.x, A.y, oO);
        w = u.lerp(x, P, m, mo), u.normalize(w, w), Ee.octEncode(w, f.encodedNormal)
    } else w = e.geodeticSurfaceNormalCartographic(wa, mo), Ee.octEncode(w, f.encodedNormal)
}

function dy(e, t, n, r, i, a) {
    a.height = i;
    var o = t.geodeticSurfaceNormalCartographic(wa, mo);
    Ee.octEncode(o, a.encodedNormal)
}

function Pu(e, t, n, r, i, a, o, s, c, f, h) {
    var d = nm(e, t, s, o, !1, n, r, h) || nm(e, t, f, c, !0, n, r, h);
    if (d) return h;
    var _;
    if (Pd(i, a)) return n === 0 ? r === 0 ? _ = a.eastIndicesNorthToSouth[0] : _ = a.southIndicesEastToWest[0] : r === 0 ? _ = a.northIndicesWestToEast[0] : _ = a.westIndicesSouthToNorth[0], Cl(a, _, n, r, h), h;
    var v;
    if (n === 0 ? r === 0 ? v = Ou(e.westMeshes, e.westTiles, Ce.EAST, e.southMeshes, e.southTiles, Ce.NORTH) : v = Ou(e.northMeshes, e.northTiles, Ce.SOUTH, e.westMeshes, e.westTiles, Ce.EAST) : r === 0 ? v = Ou(e.southMeshes, e.southTiles, Ce.NORTH, e.eastMeshes, e.eastTiles, Ce.WEST) : v = Ou(e.eastMeshes, e.eastTiles, Ce.WEST, e.northMeshes, e.northTiles, Ce.SOUTH), l(v)) return dy(e, t, n, r, v, h), h
}

function Ou(e, t, n, r, i, a, o, s) {
    var c = tm(e, t, !1, n),
        f = tm(r, i, !0, a);
    return l(c) && l(f) ? (c + f) * .5 : l(c) ? c : f
}

function Mu(e, t, n, r, i, a, o, s, c) {
    for (var f = 0; f < a.length; ++f) i = uO(e, t, n, r, i, a[f], o[f], s, c);
    return i
}

function uO(e, t, n, r, i, a, o, s, c) {
    var f = a.rectangle;
    s === Ce.EAST && e.tile.x === 0 ? (f = W.clone(a.rectangle, Fc), f.west -= T.TWO_PI, f.east -= T.TWO_PI) : s === Ce.WEST && a.x === 0 && (f = W.clone(a.rectangle, Fc), f.west += T.TWO_PI, f.east += T.TWO_PI);
    var h = e.tile.rectangle,
        d, _;
    i > 0 && (n.decodeTextureCoordinates(r, i - 1, $n), d = $n.x, _ = $n.y);
    var v, m;
    switch (s) {
        case Ce.WEST:
            v = o.westIndicesSouthToNorth, m = !1;
            break;
        case Ce.NORTH:
            v = o.northIndicesWestToEast, m = !0;
            break;
        case Ce.EAST:
            v = o.eastIndicesNorthToSouth, m = !1;
            break;
        case Ce.SOUTH:
            v = o.southIndicesEastToWest, m = !0;
            break
    }
    var g = a,
        y = e.tile,
        E = o.encoding,
        w = o.vertices,
        C = n.getStride(),
        A, x;
    E.hasWebMercatorT && (A = st.geodeticLatitudeToMercatorAngle(h.south), x = 1 / (st.geodeticLatitudeToMercatorAngle(h.north) - A));
    for (var P = 0; P < v.length; ++P) {
        var I = v[P],
            D = E.decodeTextureCoordinates(w, I, $n);
        Ss(g, y, D, D);
        var O = D.x,
            F = D.y,
            z = m ? O : F;
        if (!(z < 0 || z > 1) && !(Math.abs(O - d) < T.EPSILON5 && Math.abs(F - _) < T.EPSILON5)) {
            var b = Math.abs(O) < T.EPSILON5 || Math.abs(O - 1) < T.EPSILON5,
                M = Math.abs(F) < T.EPSILON5 || Math.abs(F - 1) < T.EPSILON5;
            if (!(b && M)) {
                var G = E.decodePosition(w, I, mo),
                    V = E.decodeHeight(w, I),
                    B;
                E.hasVertexNormals ? B = E.getOctEncodedNormal(w, I, El) : (B = El, B.x = 0, B.y = 0);
                var Y = F;
                if (E.hasWebMercatorT) {
                    var j = T.lerp(h.south, h.north, F);
                    Y = (st.geodeticLatitudeToMercatorAngle(j) - A) * x
                }
                n.encode(r, i * C, G, D, V, B, Y), c.minimumHeight = Math.min(c.minimumHeight, V), c.maximumHeight = Math.max(c.maximumHeight, V), ++i
            }
        }
    }
    return i
}

function tm(e, t, n, r, i, a) {
    var o, s, c;
    n ? (o = 0, s = e.length, c = 1) : (o = e.length - 1, s = -1, c = -1);
    for (var f = o; f !== s; f += c) {
        var h = e[f],
            d = t[f];
        if (!!Pd(d, h)) {
            var _;
            switch (r) {
                case Ce.WEST:
                    _ = h.westIndicesSouthToNorth;
                    break;
                case Ce.SOUTH:
                    _ = h.southIndicesEastToWest;
                    break;
                case Ce.EAST:
                    _ = h.eastIndicesNorthToSouth;
                    break;
                case Ce.NORTH:
                    _ = h.northIndicesWestToEast;
                    break
            }
            var v = _[n ? 0 : _.length - 1];
            if (l(v)) return h.encoding.decodeHeight(h.vertices, v)
        }
    }
}

function Pd(e, t) {
    return l(t) && (!l(e.data.fill) || !e.data.fill.changedThisFrame)
}

function nm(e, t, n, r, i, a, o, s) {
    var c, f, h, d, _, v = r[i ? 0 : n.length - 1],
        m = n[i ? 0 : n.length - 1];
    if (Pd(v, m) && (a === 0 ? o === 0 ? (c = i ? m.northIndicesWestToEast : m.eastIndicesNorthToSouth, f = i, h = i) : (c = i ? m.eastIndicesNorthToSouth : m.southIndicesEastToWest, f = !i, h = !1) : o === 0 ? (c = i ? m.westIndicesSouthToNorth : m.northIndicesWestToEast, f = !i, h = !0) : (c = i ? m.southIndicesEastToWest : m.westIndicesSouthToNorth, f = i, h = !i), c.length > 0)) {
        d = i ? 0 : c.length - 1, _ = c[d], m.encoding.decodeTextureCoordinates(m.vertices, _, $n);
        var g = Ss(v, e.tile, $n, $n);
        if (g.x === a && g.y === o) return Cl(m, _, a, o, s), !0;
        if (d = Po(c, f ? a : o, function(y, E) {
                m.encoding.decodeTextureCoordinates(m.vertices, y, $n);
                var w = Ss(v, e.tile, $n, $n);
                return h ? f ? w.x - a : w.y - o : f ? a - w.x : o - w.y
            }), d < 0) {
            if (d = ~d, d > 0 && d < c.length) return sO(t, v, e.tile, m, c[d - 1], c[d], a, o, f, s), !0
        } else return Cl(m, c[d], a, o, s), !0
    }
    return !1
}
var cO = [new u, new u, new u, new u];

function fO(e, t, n, r, i, a) {
    var o = e.quadtree._occluders.ellipsoid,
        s = o.ellipsoid,
        c = cO;
    return u.fromRadians(n.west, n.south, i, s, c[0]), u.fromRadians(n.east, n.south, i, s, c[1]), u.fromRadians(n.west, n.north, i, s, c[2]), u.fromRadians(n.east, n.north, i, s, c[3]), o.computeHorizonCullingPointPossiblyUnderEllipsoid(t, c, r, a)
}

function Od(e, t, n) {
    n = n || 2;
    var r = t && t.length,
        i = r ? t[0] * n : e.length,
        a = _y(e, 0, i, n, !0),
        o = [];
    if (!a || a.next === a.prev) return o;
    var s, c, f, h, d, _, v;
    if (r && (a = vO(e, t, a, n)), e.length > 80 * n) {
        s = f = e[0], c = h = e[1];
        for (var m = n; m < i; m += n) d = e[m], _ = e[m + 1], d < s && (s = d), _ < c && (c = _), d > f && (f = d), _ > h && (h = _);
        v = Math.max(f - s, h - c), v = v !== 0 ? 1 / v : 0
    }
    return Rs(a, o, n, s, c, v), o
}

function _y(e, t, n, r, i) {
    var a, o;
    if (i === Sl(e, t, n, r) > 0)
        for (a = t; a < n; a += r) o = rm(a, e[a], e[a + 1], o);
    else
        for (a = n - r; a >= t; a -= r) o = rm(a, e[a], e[a + 1], o);
    return o && Qc(o, o.next) && (Is(o), o = o.next), o
}

function Na(e, t) {
    if (!e) return e;
    t || (t = e);
    var n = e,
        r;
    do
        if (r = !1, !n.steiner && (Qc(n, n.next) || Dt(n.prev, n, n.next) === 0)) {
            if (Is(n), n = t = n.prev, n === n.next) break;
            r = !0
        } else n = n.next; while (r || n !== t);
    return t
}

function Rs(e, t, n, r, i, a, o) {
    if (!!e) {
        !o && a && TO(e, r, i, a);
        for (var s = e, c, f; e.prev !== e.next;) {
            if (c = e.prev, f = e.next, a ? lO(e, r, i, a) : hO(e)) {
                t.push(c.i / n), t.push(e.i / n), t.push(f.i / n), Is(e), e = f.next, s = f.next;
                continue
            }
            if (e = f, e === s) {
                o ? o === 1 ? (e = dO(Na(e), t, n), Rs(e, t, n, r, i, a, 2)) : o === 2 && _O(e, t, n, r, i, a) : Rs(Na(e), t, n, r, i, a, 1);
                break
            }
        }
    }
}

function hO(e) {
    var t = e.prev,
        n = e,
        r = e.next;
    if (Dt(t, n, r) >= 0) return !1;
    for (var i = e.next.next; i !== e.prev;) {
        if (_o(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && Dt(i.prev, i, i.next) >= 0) return !1;
        i = i.next
    }
    return !0
}

function lO(e, t, n, r) {
    var i = e.prev,
        a = e,
        o = e.next;
    if (Dt(i, a, o) >= 0) return !1;
    for (var s = i.x < a.x ? i.x < o.x ? i.x : o.x : a.x < o.x ? a.x : o.x, c = i.y < a.y ? i.y < o.y ? i.y : o.y : a.y < o.y ? a.y : o.y, f = i.x > a.x ? i.x > o.x ? i.x : o.x : a.x > o.x ? a.x : o.x, h = i.y > a.y ? i.y > o.y ? i.y : o.y : a.y > o.y ? a.y : o.y, d = wl(s, c, t, n, r), _ = wl(f, h, t, n, r), v = e.prevZ, m = e.nextZ; v && v.z >= d && m && m.z <= _;) {
        if (v !== e.prev && v !== e.next && _o(i.x, i.y, a.x, a.y, o.x, o.y, v.x, v.y) && Dt(v.prev, v, v.next) >= 0 || (v = v.prevZ, m !== e.prev && m !== e.next && _o(i.x, i.y, a.x, a.y, o.x, o.y, m.x, m.y) && Dt(m.prev, m, m.next) >= 0)) return !1;
        m = m.nextZ
    }
    for (; v && v.z >= d;) {
        if (v !== e.prev && v !== e.next && _o(i.x, i.y, a.x, a.y, o.x, o.y, v.x, v.y) && Dt(v.prev, v, v.next) >= 0) return !1;
        v = v.prevZ
    }
    for (; m && m.z <= _;) {
        if (m !== e.prev && m !== e.next && _o(i.x, i.y, a.x, a.y, o.x, o.y, m.x, m.y) && Dt(m.prev, m, m.next) >= 0) return !1;
        m = m.nextZ
    }
    return !0
}

function dO(e, t, n) {
    var r = e;
    do {
        var i = r.prev,
            a = r.next.next;
        !Qc(i, a) && vy(i, r, r.next, a) && Ds(i, a) && Ds(a, i) && (t.push(i.i / n), t.push(r.i / n), t.push(a.i / n), Is(r), Is(r.next), r = e = a), r = r.next
    } while (r !== e);
    return Na(r)
}

function _O(e, t, n, r, i, a) {
    var o = e;
    do {
        for (var s = o.next.next; s !== o.prev;) {
            if (o.i !== s.i && CO(o, s)) {
                var c = my(o, s);
                o = Na(o, o.next), c = Na(c, c.next), Rs(o, t, n, r, i, a), Rs(c, t, n, r, i, a);
                return
            }
            s = s.next
        }
        o = o.next
    } while (o !== e)
}

function vO(e, t, n, r) {
    var i = [],
        a, o, s, c, f;
    for (a = 0, o = t.length; a < o; a++) s = t[a] * r, c = a < o - 1 ? t[a + 1] * r : e.length, f = _y(e, s, c, r, !1), f === f.next && (f.steiner = !0), i.push(AO(f));
    for (i.sort(mO), a = 0; a < i.length; a++) pO(i[a], n), n = Na(n, n.next);
    return n
}

function mO(e, t) {
    return e.x - t.x
}

function pO(e, t) {
    if (t = gO(e, t), t) {
        var n = my(t, e);
        Na(n, n.next)
    }
}

function gO(e, t) {
    var n = t,
        r = e.x,
        i = e.y,
        a = -1 / 0,
        o;
    do {
        if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
            var s = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
            if (s <= r && s > a) {
                if (a = s, s === r) {
                    if (i === n.y) return n;
                    if (i === n.next.y) return n.next
                }
                o = n.x < n.next.x ? n : n.next
            }
        }
        n = n.next
    } while (n !== t);
    if (!o) return null;
    if (r === a) return o;
    var c = o,
        f = o.x,
        h = o.y,
        d = 1 / 0,
        _;
    n = o;
    do r >= n.x && n.x >= f && r !== n.x && _o(i < h ? r : a, i, f, h, i < h ? a : r, i, n.x, n.y) && (_ = Math.abs(i - n.y) / (r - n.x), Ds(n, e) && (_ < d || _ === d && (n.x > o.x || n.x === o.x && yO(o, n))) && (o = n, d = _)), n = n.next; while (n !== c);
    return o
}

function yO(e, t) {
    return Dt(e.prev, e, t.prev) < 0 && Dt(t.next, e, e.next) < 0
}

function TO(e, t, n, r) {
    var i = e;
    do i.z === null && (i.z = wl(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== e);
    i.prevZ.nextZ = null, i.prevZ = null, EO(i)
}

function EO(e) {
    var t, n, r, i, a, o, s, c, f = 1;
    do {
        for (n = e, e = null, a = null, o = 0; n;) {
            for (o++, r = n, s = 0, t = 0; t < f && (s++, r = r.nextZ, !!r); t++);
            for (c = f; s > 0 || c > 0 && r;) s !== 0 && (c === 0 || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, c--), a ? a.nextZ = i : e = i, i.prevZ = a, a = i;
            n = r
        }
        a.nextZ = null, f *= 2
    } while (o > 1);
    return e
}

function wl(e, t, n, r, i) {
    return e = 32767 * (e - n) * i, t = 32767 * (t - r) * i, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1
}

function AO(e) {
    var t = e,
        n = e;
    do(t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next; while (t !== e);
    return n
}

function _o(e, t, n, r, i, a, o, s) {
    return (i - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (r - s) - (n - o) * (t - s) >= 0 && (n - o) * (a - s) - (i - o) * (r - s) >= 0
}

function CO(e, t) {
    return e.next.i !== t.i && e.prev.i !== t.i && !wO(e, t) && (Ds(e, t) && Ds(t, e) && xO(e, t) && (Dt(e.prev, e, t.prev) || Dt(e, t.prev, t)) || Qc(e, t) && Dt(e.prev, e, e.next) > 0 && Dt(t.prev, t, t.next) > 0)
}

function Dt(e, t, n) {
    return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
}

function Qc(e, t) {
    return e.x === t.x && e.y === t.y
}

function vy(e, t, n, r) {
    var i = bu(Dt(e, t, n)),
        a = bu(Dt(e, t, r)),
        o = bu(Dt(n, r, e)),
        s = bu(Dt(n, r, t));
    return !!(i !== a && o !== s || i === 0 && Nu(e, n, t) || a === 0 && Nu(e, r, t) || o === 0 && Nu(n, e, r) || s === 0 && Nu(n, t, r))
}

function Nu(e, t, n) {
    return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
}

function bu(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0
}

function wO(e, t) {
    var n = e;
    do {
        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && vy(n, n.next, e, t)) return !0;
        n = n.next
    } while (n !== e);
    return !1
}

function Ds(e, t) {
    return Dt(e.prev, e, e.next) < 0 ? Dt(e, t, e.next) >= 0 && Dt(e, e.prev, t) >= 0 : Dt(e, t, e.prev) < 0 || Dt(e, e.next, t) < 0
}

function xO(e, t) {
    var n = e,
        r = !1,
        i = (e.x + t.x) / 2,
        a = (e.y + t.y) / 2;
    do n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; while (n !== e);
    return r
}

function my(e, t) {
    var n = new xl(e.i, e.x, e.y),
        r = new xl(t.i, t.x, t.y),
        i = e.next,
        a = t.prev;
    return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, r.prev = a, r
}

function rm(e, t, n, r) {
    var i = new xl(e, t, n);
    return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
}

function Is(e) {
    e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
}

function xl(e, t, n) {
    this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
}
Od.deviation = function(e, t, n, r) {
    var i = t && t.length,
        a = i ? t[0] * n : e.length,
        o = Math.abs(Sl(e, 0, a, n));
    if (i)
        for (var s = 0, c = t.length; s < c; s++) {
            var f = t[s] * n,
                h = s < c - 1 ? t[s + 1] * n : e.length;
            o -= Math.abs(Sl(e, f, h, n))
        }
    var d = 0;
    for (s = 0; s < r.length; s += 3) {
        var _ = r[s] * n,
            v = r[s + 1] * n,
            m = r[s + 2] * n;
        d += Math.abs((e[_] - e[m]) * (e[v + 1] - e[_ + 1]) - (e[_] - e[v]) * (e[m + 1] - e[_ + 1]))
    }
    return o === 0 && d === 0 ? 0 : Math.abs((d - o) / o)
};

function Sl(e, t, n, r) {
    for (var i = 0, a = t, o = n - r; a < n; a += r) i += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a;
    return i
}
Od.flatten = function(e) {
    for (var t = e[0][0].length, n = {
            vertices: [],
            holes: [],
            dimensions: t
        }, r = 0, i = 0; i < e.length; i++) {
        for (var a = 0; a < e[i].length; a++)
            for (var o = 0; o < t; o++) n.vertices.push(e[i][a][o]);
        i > 0 && (r += e[i - 1].length, n.holes.push(r))
    }
    return n
};

function Rl(e, t, n) {
    if (e === 0) return t * n;
    var r = e * e,
        i = r * r,
        a = i * r,
        o = a * r,
        s = o * r,
        c = s * r,
        f = n,
        h = Math.sin(2 * f),
        d = Math.sin(4 * f),
        _ = Math.sin(6 * f),
        v = Math.sin(8 * f),
        m = Math.sin(10 * f),
        g = Math.sin(12 * f);
    return t * ((1 - r / 4 - 3 * i / 64 - 5 * a / 256 - 175 * o / 16384 - 441 * s / 65536 - 4851 * c / 1048576) * f - (3 * r / 8 + 3 * i / 32 + 45 * a / 1024 + 105 * o / 4096 + 2205 * s / 131072 + 6237 * c / 524288) * h + (15 * i / 256 + 45 * a / 1024 + 525 * o / 16384 + 1575 * s / 65536 + 155925 * c / 8388608) * d - (35 * a / 3072 + 175 * o / 12288 + 3675 * s / 262144 + 13475 * c / 1048576) * _ + (315 * o / 131072 + 2205 * s / 524288 + 43659 * c / 8388608) * v - (693 * s / 1310720 + 6237 * c / 5242880) * m + 1001 * c / 8388608 * g)
}

function SO(e, t, n) {
    var r = e / n;
    if (t === 0) return r;
    var i = r * r,
        a = i * r,
        o = a * r,
        s = t,
        c = s * s,
        f = c * c,
        h = f * c,
        d = h * c,
        _ = d * c,
        v = _ * c,
        m = Math.sin(2 * r),
        g = Math.cos(2 * r),
        y = Math.sin(4 * r),
        E = Math.cos(4 * r),
        w = Math.sin(6 * r),
        C = Math.cos(6 * r),
        A = Math.sin(8 * r),
        x = Math.cos(8 * r),
        P = Math.sin(10 * r),
        I = Math.cos(10 * r),
        D = Math.sin(12 * r);
    return r + r * c / 4 + 7 * r * f / 64 + 15 * r * h / 256 + 579 * r * d / 16384 + 1515 * r * _ / 65536 + 16837 * r * v / 1048576 + (3 * r * f / 16 + 45 * r * h / 256 - r * (32 * i - 561) * d / 4096 - r * (232 * i - 1677) * _ / 16384 + r * (399985 - 90560 * i + 512 * o) * v / 5242880) * g + (21 * r * h / 256 + 483 * r * d / 4096 - r * (224 * i - 1969) * _ / 16384 - r * (33152 * i - 112599) * v / 1048576) * E + (151 * r * d / 4096 + 4681 * r * _ / 65536 + 1479 * r * v / 16384 - 453 * a * v / 32768) * C + (1097 * r * _ / 65536 + 42783 * r * v / 1048576) * x + 8011 * r * v / 1048576 * I + (3 * c / 8 + 3 * f / 16 + 213 * h / 2048 - 3 * i * h / 64 + 255 * d / 4096 - 33 * i * d / 512 + 20861 * _ / 524288 - 33 * i * _ / 512 + o * _ / 1024 + 28273 * v / 1048576 - 471 * i * v / 8192 + 9 * o * v / 4096) * m + (21 * f / 256 + 21 * h / 256 + 533 * d / 8192 - 21 * i * d / 512 + 197 * _ / 4096 - 315 * i * _ / 4096 + 584039 * v / 16777216 - 12517 * i * v / 131072 + 7 * o * v / 2048) * y + (151 * h / 6144 + 151 * d / 4096 + 5019 * _ / 131072 - 453 * i * _ / 16384 + 26965 * v / 786432 - 8607 * i * v / 131072) * w + (1097 * d / 131072 + 1097 * _ / 65536 + 225797 * v / 10485760 - 1097 * i * v / 65536) * A + (8011 * _ / 2621440 + 8011 * v / 1048576) * P + 293393 * v / 251658240 * D
}

function So(e, t) {
    if (e === 0) return Math.log(Math.tan(.5 * (T.PI_OVER_TWO + t)));
    var n = e * Math.sin(t);
    return Math.log(Math.tan(.5 * (T.PI_OVER_TWO + t))) - e / 2 * Math.log((1 + n) / (1 - n))
}

function RO(e, t, n, r, i) {
    var a = So(e._ellipticity, n),
        o = So(e._ellipticity, i);
    return Math.atan2(T.negativePiToPi(r - t), o - a)
}

function DO(e, t, n, r, i, a, o) {
    var s = e._heading,
        c = a - r,
        f = 0;
    if (T.equalsEpsilon(Math.abs(s), T.PI_OVER_TWO, T.EPSILON8))
        if (t === n) f = t * Math.cos(i) * T.negativePiToPi(c);
        else {
            var h = Math.sin(i);
            f = t * Math.cos(i) * T.negativePiToPi(c) / Math.sqrt(1 - e._ellipticitySquared * h * h)
        }
    else {
        var d = Rl(e._ellipticity, t, i),
            _ = Rl(e._ellipticity, t, o);
        f = (_ - d) / Math.cos(s)
    }
    return Math.abs(f)
}
var IO = new u,
    Eh = new u;

function py(e, t, n, r) {
    u.normalize(r.cartographicToCartesian(t, Eh), IO), u.normalize(r.cartographicToCartesian(n, Eh), Eh);
    var i = r.maximumRadius,
        a = r.minimumRadius,
        o = i * i,
        s = a * a;
    e._ellipticitySquared = (o - s) / o, e._ellipticity = Math.sqrt(e._ellipticitySquared), e._start = K.clone(t, e._start), e._start.height = 0, e._end = K.clone(n, e._end), e._end.height = 0, e._heading = RO(e, t.longitude, t.latitude, n.longitude, n.latitude), e._distance = DO(e, r.maximumRadius, r.minimumRadius, t.longitude, t.latitude, n.longitude, n.latitude)
}

function gy(e, t, n, r, i, a) {
    var o = i * i,
        s, c, f;
    if (Math.abs(T.PI_OVER_TWO - Math.abs(t)) > T.EPSILON8) {
        var h = Rl(i, r, e.latitude),
            d = n * Math.cos(t),
            _ = h + d;
        c = SO(_, i, r);
        var v = So(i, e.latitude),
            m = So(i, c);
        f = Math.tan(t) * (m - v), s = T.negativePiToPi(e.longitude + f)
    } else {
        c = e.latitude;
        var g;
        if (i === 0) g = r * Math.cos(e.latitude);
        else {
            var y = Math.sin(e.latitude);
            g = r * Math.cos(e.latitude) / Math.sqrt(1 - o * y * y)
        }
        f = n / g, t > 0 ? s = T.negativePiToPi(e.longitude + f) : s = T.negativePiToPi(e.longitude - f)
    }
    return l(a) ? (a.longitude = s, a.latitude = c, a.height = 0, a) : new K(s, c, 0)
}

function Ur(e, t, n) {
    var r = p(n, ne.WGS84);
    this._ellipsoid = r, this._start = new K, this._end = new K, this._heading = void 0, this._distance = void 0, this._ellipticity = void 0, this._ellipticitySquared = void 0, l(e) && l(t) && py(this, e, t, r)
}
Object.defineProperties(Ur.prototype, {
    ellipsoid: {
        get: function() {
            return this._ellipsoid
        }
    },
    surfaceDistance: {
        get: function() {
            return this._distance
        }
    },
    start: {
        get: function() {
            return this._start
        }
    },
    end: {
        get: function() {
            return this._end
        }
    },
    heading: {
        get: function() {
            return this._heading
        }
    }
});
Ur.fromStartHeadingDistance = function(e, t, n, r, i) {
    var a = p(r, ne.WGS84),
        o = a.maximumRadius,
        s = a.minimumRadius,
        c = o * o,
        f = s * s,
        h = Math.sqrt((c - f) / c);
    t = T.negativePiToPi(t);
    var d = gy(e, t, n, a.maximumRadius, h);
    return !l(i) || l(r) && !r.equals(i.ellipsoid) ? new Ur(e, d, a) : (i.setEndPoints(e, d), i)
};
Ur.prototype.setEndPoints = function(e, t) {
    py(this, e, t, this._ellipsoid)
};
Ur.prototype.interpolateUsingFraction = function(e, t) {
    return this.interpolateUsingSurfaceDistance(e * this._distance, t)
};
Ur.prototype.interpolateUsingSurfaceDistance = function(e, t) {
    return gy(this._start, this._heading, e, this._ellipsoid.maximumRadius, this._ellipticity, t)
};
Ur.prototype.findIntersectionWithLongitude = function(e, t) {
    var n = this._ellipticity,
        r = this._heading,
        i = Math.abs(r),
        a = this._start;
    if (e = T.negativePiToPi(e), T.equalsEpsilon(Math.abs(e), Math.PI, T.EPSILON14) && (e = T.sign(a.longitude) * Math.PI), l(t) || (t = new K), Math.abs(T.PI_OVER_TWO - i) <= T.EPSILON8) return t.longitude = e, t.latitude = a.latitude, t.height = 0, t;
    if (T.equalsEpsilon(Math.abs(T.PI_OVER_TWO - i), T.PI_OVER_TWO, T.EPSILON8)) return T.equalsEpsilon(e, a.longitude, T.EPSILON12) ? void 0 : (t.longitude = e, t.latitude = T.PI_OVER_TWO * T.sign(T.PI_OVER_TWO - r), t.height = 0, t);
    var o = a.latitude,
        s = n * Math.sin(o),
        c = Math.tan(.5 * (T.PI_OVER_TWO + o)) * Math.exp((e - a.longitude) / Math.tan(r)),
        f = (1 + s) / (1 - s),
        h = a.latitude,
        d;
    do {
        d = h;
        var _ = n * Math.sin(d),
            v = (1 + _) / (1 - _);
        h = 2 * Math.atan(c * Math.pow(v / f, n / 2)) - T.PI_OVER_TWO
    } while (!T.equalsEpsilon(h, d, T.EPSILON12));
    return t.longitude = e, t.latitude = h, t.height = 0, t
};
Ur.prototype.findIntersectionWithLatitude = function(e, t) {
    var n = this._ellipticity,
        r = this._heading,
        i = this._start;
    if (!T.equalsEpsilon(Math.abs(r), T.PI_OVER_TWO, T.EPSILON8)) {
        var a = So(n, i.latitude),
            o = So(n, e),
            s = Math.tan(r) * (o - a),
            c = T.negativePiToPi(i.longitude + s);
        return l(t) ? (t.longitude = c, t.latitude = e, t.height = 0, t) : new K(c, e, 0)
    }
};
var PO = new u,
    OO = new u,
    ci = {};
ci.computeArea2D = function(e) {
    for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) {
        var a = e[r],
            o = e[i];
        n += a.x * o.y - o.x * a.y
    }
    return n * .5
};
ci.computeWindingOrder2D = function(e) {
    var t = ci.computeArea2D(e);
    return t > 0 ? ll.COUNTER_CLOCKWISE : ll.CLOCKWISE
};
ci.triangulate = function(e, t) {
    var n = R.packArray(e);
    return Od(n, t, 2)
};
var yy = new u,
    Ty = new u,
    Ey = new u,
    im = new u,
    am = new u,
    om = new u,
    Ai = new u;
ci.computeSubdivision = function(e, t, n, r) {
    r = p(r, T.RADIANS_PER_DEGREE);
    var i = n.slice(0),
        a, o = t.length,
        s = new Array(o * 3),
        c = 0;
    for (a = 0; a < o; a++) {
        var f = t[a];
        s[c++] = f.x, s[c++] = f.y, s[c++] = f.z
    }
    for (var h = [], d = {}, _ = e.maximumRadius, v = T.chordLength(r, _), m = v * v; i.length > 0;) {
        var g = i.pop(),
            y = i.pop(),
            E = i.pop(),
            w = u.fromArray(s, E * 3, yy),
            C = u.fromArray(s, y * 3, Ty),
            A = u.fromArray(s, g * 3, Ey),
            x = u.multiplyByScalar(u.normalize(w, im), _, im),
            P = u.multiplyByScalar(u.normalize(C, am), _, am),
            I = u.multiplyByScalar(u.normalize(A, om), _, om),
            D = u.magnitudeSquared(u.subtract(x, P, Ai)),
            O = u.magnitudeSquared(u.subtract(P, I, Ai)),
            F = u.magnitudeSquared(u.subtract(I, x, Ai)),
            z = Math.max(D, O, F),
            b, M;
        z > m ? D === z ? (b = Math.min(E, y) + " " + Math.max(E, y), a = d[b], l(a) || (M = u.add(w, C, Ai), u.multiplyByScalar(M, .5, M), s.push(M.x, M.y, M.z), a = s.length / 3 - 1, d[b] = a), i.push(E, a, g), i.push(a, y, g)) : O === z ? (b = Math.min(y, g) + " " + Math.max(y, g), a = d[b], l(a) || (M = u.add(C, A, Ai), u.multiplyByScalar(M, .5, M), s.push(M.x, M.y, M.z), a = s.length / 3 - 1, d[b] = a), i.push(y, a, E), i.push(a, g, E)) : F === z && (b = Math.min(g, E) + " " + Math.max(g, E), a = d[b], l(a) || (M = u.add(A, w, Ai), u.multiplyByScalar(M, .5, M), s.push(M.x, M.y, M.z), a = s.length / 3 - 1, d[b] = a), i.push(g, a, y), i.push(a, E, y)) : (h.push(E), h.push(y), h.push(g))
    }
    return new rt({
        attributes: {
            position: new ze({
                componentDatatype: ee.DOUBLE,
                componentsPerAttribute: 3,
                values: s
            })
        },
        indices: h,
        primitiveType: Ve.TRIANGLES
    })
};
var MO = new K,
    NO = new K,
    bO = new K,
    Ah = new K;
ci.computeRhumbLineSubdivision = function(e, t, n, r) {
    r = p(r, T.RADIANS_PER_DEGREE);
    var i = n.slice(0),
        a, o = t.length,
        s = new Array(o * 3),
        c = 0;
    for (a = 0; a < o; a++) {
        var f = t[a];
        s[c++] = f.x, s[c++] = f.y, s[c++] = f.z
    }
    for (var h = [], d = {}, _ = e.maximumRadius, v = T.chordLength(r, _), m = new Ur(void 0, void 0, e), g = new Ur(void 0, void 0, e), y = new Ur(void 0, void 0, e); i.length > 0;) {
        var E = i.pop(),
            w = i.pop(),
            C = i.pop(),
            A = u.fromArray(s, C * 3, yy),
            x = u.fromArray(s, w * 3, Ty),
            P = u.fromArray(s, E * 3, Ey),
            I = e.cartesianToCartographic(A, MO),
            D = e.cartesianToCartographic(x, NO),
            O = e.cartesianToCartographic(P, bO);
        m.setEndPoints(I, D);
        var F = m.surfaceDistance;
        g.setEndPoints(D, O);
        var z = g.surfaceDistance;
        y.setEndPoints(O, I);
        var b = y.surfaceDistance,
            M = Math.max(F, z, b),
            G, V, B, Y;
        M > v ? F === M ? (G = Math.min(C, w) + " " + Math.max(C, w), a = d[G], l(a) || (V = m.interpolateUsingFraction(.5, Ah), B = (I.height + D.height) * .5, Y = u.fromRadians(V.longitude, V.latitude, B, e, Ai), s.push(Y.x, Y.y, Y.z), a = s.length / 3 - 1, d[G] = a), i.push(C, a, E), i.push(a, w, E)) : z === M ? (G = Math.min(w, E) + " " + Math.max(w, E), a = d[G], l(a) || (V = g.interpolateUsingFraction(.5, Ah), B = (D.height + O.height) * .5, Y = u.fromRadians(V.longitude, V.latitude, B, e, Ai), s.push(Y.x, Y.y, Y.z), a = s.length / 3 - 1, d[G] = a), i.push(w, a, C), i.push(a, E, C)) : b === M && (G = Math.min(E, C) + " " + Math.max(E, C), a = d[G], l(a) || (V = y.interpolateUsingFraction(.5, Ah), B = (O.height + I.height) * .5, Y = u.fromRadians(V.longitude, V.latitude, B, e, Ai), s.push(Y.x, Y.y, Y.z), a = s.length / 3 - 1, d[G] = a), i.push(E, a, w), i.push(a, C, w)) : (h.push(C), h.push(w), h.push(E))
    }
    return new rt({
        attributes: {
            position: new ze({
                componentDatatype: ee.DOUBLE,
                componentsPerAttribute: 3,
                values: s
            })
        },
        indices: h,
        primitiveType: Ve.TRIANGLES
    })
};
ci.scaleToGeodeticHeight = function(e, t, n, r) {
    n = p(n, ne.WGS84);
    var i = PO,
        a = OO;
    if (t = p(t, 0), r = p(r, !0), l(e))
        for (var o = e.length, s = 0; s < o; s += 3) u.fromArray(e, s, a), r && (a = n.scaleToGeodeticSurface(a, a)), t !== 0 && (i = n.geodeticSurfaceNormal(a, i), u.multiplyByScalar(i, t, i), u.add(a, i, a)), e[s] = a.x, e[s + 1] = a.y, e[s + 2] = a.z;
    return e
};
var sm = Math.cos,
    um = Math.sin,
    FO = Math.sqrt,
    qi = {};
qi.computePosition = function(e, t, n, r, i, a, o) {
    var s = t.radiiSquared,
        c = e.nwCorner,
        f = e.boundingRectangle,
        h = c.latitude - e.granYCos * r + i * e.granXSin,
        d = sm(h),
        _ = um(h),
        v = s.z * _,
        m = c.longitude + r * e.granYSin + i * e.granXCos,
        g = d * sm(m),
        y = d * um(m),
        E = s.x * g,
        w = s.y * y,
        C = FO(E * g + w * y + v * _);
    if (a.x = E / C, a.y = w / C, a.z = v / C, n) {
        var A = e.stNwCorner;
        l(A) ? (h = A.latitude - e.stGranYCos * r + i * e.stGranXSin, m = A.longitude + r * e.stGranYSin + i * e.stGranXCos, o.x = (m - e.stWest) * e.lonScalar, o.y = (h - e.stSouth) * e.latScalar) : (o.x = (m - f.west) * e.lonScalar, o.y = (h - f.south) * e.latScalar)
    }
};
var LO = new fe,
    dr = new u,
    UO = new K,
    Lc = new u,
    Dl = new un;

function cm(e, t, n, r, i, a, o) {
    var s = Math.cos(t),
        c = r * s,
        f = n * s,
        h = Math.sin(t),
        d = r * h,
        _ = n * h;
    dr = Dl.project(e, dr), dr = u.subtract(dr, Lc, dr);
    var v = fe.fromRotation(t, LO);
    dr = fe.multiplyByVector(v, dr, dr), dr = u.add(dr, Lc, dr), e = Dl.unproject(dr, e), a -= 1, o -= 1;
    var m = e.latitude,
        g = m + a * _,
        y = m - c * o,
        E = m - c * o + a * _,
        w = Math.max(m, g, y, E),
        C = Math.min(m, g, y, E),
        A = e.longitude,
        x = A + a * f,
        P = A + o * d,
        I = A + o * d + a * f,
        D = Math.max(A, x, P, I),
        O = Math.min(A, x, P, I);
    return {
        north: w,
        south: C,
        east: D,
        west: O,
        granYCos: c,
        granYSin: d,
        granXCos: f,
        granXSin: _,
        nwCorner: e
    }
}
qi.computeOptions = function(e, t, n, r, i, a, o) {
    var s = e.east,
        c = e.west,
        f = e.north,
        h = e.south,
        d = !1,
        _ = !1;
    f === T.PI_OVER_TWO && (d = !0), h === -T.PI_OVER_TWO && (_ = !0);
    var v, m, g, y, E, w = f - h;
    c > s ? E = T.TWO_PI - c + s : E = s - c, v = Math.ceil(E / t) + 1, m = Math.ceil(w / t) + 1, g = E / (v - 1), y = w / (m - 1);
    var C = W.northwest(e, a),
        A = W.center(e, UO);
    (n !== 0 || r !== 0) && (A.longitude < C.longitude && (A.longitude += T.TWO_PI), Lc = Dl.project(A, Lc));
    var x = y,
        P = g,
        I = 0,
        D = 0,
        O = W.clone(e, i),
        F = {
            granYCos: x,
            granYSin: I,
            granXCos: P,
            granXSin: D,
            nwCorner: C,
            boundingRectangle: O,
            width: v,
            height: m,
            northCap: d,
            southCap: _
        };
    if (n !== 0) {
        var z = cm(C, n, g, y, A, v, m);
        f = z.north, h = z.south, s = z.east, c = z.west, F.granYCos = z.granYCos, F.granYSin = z.granYSin, F.granXCos = z.granXCos, F.granXSin = z.granXSin, O.north = f, O.south = h, O.east = s, O.west = c
    }
    if (r !== 0) {
        n = n - r;
        var b = W.northwest(O, o),
            M = cm(b, n, g, y, A, v, m);
        F.stGranYCos = M.granYCos, F.stGranXCos = M.granXCos, F.stGranYSin = M.granYSin, F.stGranXSin = M.granXSin, F.stNwCorner = b, F.stWest = M.west, F.stSouth = M.south
    }
    return F
};
var zO = new q,
    BO = new q,
    VO = new u,
    GO = new W;

function Ay(e, t) {
    var n = e._ellipsoid,
        r = t.height,
        i = t.width,
        a = t.northCap,
        o = t.southCap,
        s = r,
        c = 2,
        f = 0,
        h = 4;
    a && (c -= 1, s -= 1, f += 1, h -= 2), o && (c -= 1, s -= 1, f += 1, h -= 2), f += c * i + 2 * s - h;
    var d = new Float64Array(f * 3),
        _ = 0,
        v = 0,
        m, g = VO;
    if (a) qi.computePosition(t, n, !1, v, 0, g), d[_++] = g.x, d[_++] = g.y, d[_++] = g.z;
    else
        for (m = 0; m < i; m++) qi.computePosition(t, n, !1, v, m, g), d[_++] = g.x, d[_++] = g.y, d[_++] = g.z;
    for (m = i - 1, v = 1; v < r; v++) qi.computePosition(t, n, !1, v, m, g), d[_++] = g.x, d[_++] = g.y, d[_++] = g.z;
    if (v = r - 1, !o)
        for (m = i - 2; m >= 0; m--) qi.computePosition(t, n, !1, v, m, g), d[_++] = g.x, d[_++] = g.y, d[_++] = g.z;
    for (m = 0, v = r - 2; v > 0; v--) qi.computePosition(t, n, !1, v, m, g), d[_++] = g.x, d[_++] = g.y, d[_++] = g.z;
    for (var y = d.length / 3 * 2, E = yt.createTypedArray(d.length / 3, y), w = 0, C = 0; C < d.length / 3 - 1; C++) E[w++] = C, E[w++] = C + 1;
    E[w++] = d.length / 3 - 1, E[w++] = 0;
    var A = new rt({
        attributes: new Va,
        primitiveType: Ve.LINES
    });
    return A.attributes.position = new ze({
        componentDatatype: ee.DOUBLE,
        componentsPerAttribute: 3,
        values: d
    }), A.indices = E, A
}

function HO(e, t) {
    var n = e._surfaceHeight,
        r = e._extrudedHeight,
        i = e._ellipsoid,
        a = r,
        o = n,
        s = Ay(e, t),
        c = t.height,
        f = t.width,
        h = ci.scaleToGeodeticHeight(s.attributes.position.values, o, i, !1),
        d = h.length,
        _ = new Float64Array(d * 2);
    _.set(h);
    var v = ci.scaleToGeodeticHeight(s.attributes.position.values, a, i);
    _.set(v, d), s.attributes.position.values = _;
    var m = t.northCap,
        g = t.southCap,
        y = 4;
    m && (y -= 1), g && (y -= 1);
    var E = (_.length / 3 + y) * 2,
        w = yt.createTypedArray(_.length / 3, E);
    d = _.length / 6;
    for (var C = 0, A = 0; A < d - 1; A++) w[C++] = A, w[C++] = A + 1, w[C++] = A + d, w[C++] = A + d + 1;
    w[C++] = d - 1, w[C++] = 0, w[C++] = d + d - 1, w[C++] = d, w[C++] = 0, w[C++] = d;
    var x;
    if (m) x = c - 1;
    else {
        var P = f - 1;
        w[C++] = P, w[C++] = P + d, x = f + c - 2
    }
    if (w[C++] = x, w[C++] = x + d, !g) {
        var I = f + x - 1;
        w[C++] = I, w[C] = I + d
    }
    return s.indices = w, s
}

function Ro(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.rectangle,
        n = p(e.granularity, T.RADIANS_PER_DEGREE),
        r = p(e.ellipsoid, ne.WGS84),
        i = p(e.rotation, 0),
        a = p(e.height, 0),
        o = p(e.extrudedHeight, a);
    this._rectangle = W.clone(t), this._granularity = n, this._ellipsoid = r, this._surfaceHeight = Math.max(a, o), this._rotation = i, this._extrudedHeight = Math.min(a, o), this._offsetAttribute = e.offsetAttribute, this._workerName = "createRectangleOutlineGeometry"
}
Ro.packedLength = W.packedLength + ne.packedLength + 5;
Ro.pack = function(e, t, n) {
    return n = p(n, 0), W.pack(e._rectangle, t, n), n += W.packedLength, ne.pack(e._ellipsoid, t, n), n += ne.packedLength, t[n++] = e._granularity, t[n++] = e._surfaceHeight, t[n++] = e._rotation, t[n++] = e._extrudedHeight, t[n] = p(e._offsetAttribute, -1), t
};
var Cy = new W,
    wy = ne.clone(ne.UNIT_SPHERE),
    so = {
        rectangle: Cy,
        ellipsoid: wy,
        granularity: void 0,
        height: void 0,
        rotation: void 0,
        extrudedHeight: void 0,
        offsetAttribute: void 0
    };
Ro.unpack = function(e, t, n) {
    t = p(t, 0);
    var r = W.unpack(e, t, Cy);
    t += W.packedLength;
    var i = ne.unpack(e, t, wy);
    t += ne.packedLength;
    var a = e[t++],
        o = e[t++],
        s = e[t++],
        c = e[t++],
        f = e[t];
    return l(n) ? (n._rectangle = W.clone(r, n._rectangle), n._ellipsoid = ne.clone(i, n._ellipsoid), n._surfaceHeight = o, n._rotation = s, n._extrudedHeight = c, n._offsetAttribute = f === -1 ? void 0 : f, n) : (so.granularity = a, so.height = o, so.rotation = s, so.extrudedHeight = c, so.offsetAttribute = f === -1 ? void 0 : f, new Ro(so))
};
var kO = new K;
Ro.createGeometry = function(e) {
    var t = e._rectangle,
        n = e._ellipsoid,
        r = qi.computeOptions(t, e._granularity, e._rotation, 0, GO, kO),
        i, a;
    if (!(T.equalsEpsilon(t.north, t.south, T.EPSILON10) || T.equalsEpsilon(t.east, t.west, T.EPSILON10))) {
        var o = e._surfaceHeight,
            s = e._extrudedHeight,
            c = !T.equalsEpsilon(o, s, 0, T.EPSILON2),
            f;
        if (c) {
            if (i = HO(e, r), l(e._offsetAttribute)) {
                var h = i.attributes.position.values.length / 3,
                    d = new Uint8Array(h);
                e._offsetAttribute === Di.TOP ? d = Ri(d, 1, 0, h / 2) : (f = e._offsetAttribute === Di.NONE ? 0 : 1, d = Ri(d, f)), i.attributes.applyOffset = new ze({
                    componentDatatype: ee.UNSIGNED_BYTE,
                    componentsPerAttribute: 1,
                    values: d
                })
            }
            var _ = q.fromRectangle3D(t, n, o, BO),
                v = q.fromRectangle3D(t, n, s, zO);
            a = q.union(_, v)
        } else {
            if (i = Ay(e, r), i.attributes.position.values = ci.scaleToGeodeticHeight(i.attributes.position.values, o, n, !1), l(e._offsetAttribute)) {
                var m = i.attributes.position.values.length,
                    g = new Uint8Array(m / 3);
                f = e._offsetAttribute === Di.NONE ? 0 : 1, Ri(g, f), i.attributes.applyOffset = new ze({
                    componentDatatype: ee.UNSIGNED_BYTE,
                    componentsPerAttribute: 1,
                    values: g
                })
            }
            a = q.fromRectangle3D(t, n, o)
        }
        return new rt({
            attributes: i.attributes,
            indices: i.indices,
            primitiveType: Ve.LINES,
            boundingSphere: a,
            offsetAttribute: e._offsetAttribute
        })
    }
};

function zs(e) {
    this.rectangle = W.clone(e.rectangle), this.minimumHeight = p(e.minimumHeight, 0), this.maximumHeight = p(e.maximumHeight, 0), this.southwestCornerCartesian = new u, this.northeastCornerCartesian = new u, this.westNormal = new u, this.southNormal = new u, this.eastNormal = new u, this.northNormal = new u;
    var t = p(e.ellipsoid, ne.WGS84);
    XO(this, e.rectangle, t), p(e.computeBoundingVolumes, !0) && (this._orientedBoundingBox = $e.fromRectangle(this.rectangle, this.minimumHeight, this.maximumHeight, t), this._boundingSphere = q.fromOrientedBoundingBox(this._orientedBoundingBox))
}
Object.defineProperties(zs.prototype, {
    boundingVolume: {
        get: function() {
            return this._orientedBoundingBox
        }
    },
    boundingSphere: {
        get: function() {
            return this._boundingSphere
        }
    }
});
var Ch = new u,
    Fu = new u,
    fm = new u,
    WO = new u,
    qO = new u,
    YO = new u,
    _r = new K,
    hm = new Ne(u.UNIT_X, 0),
    uo = new Ke;

function XO(e, t, n) {
    n.cartographicToCartesian(W.southwest(t), e.southwestCornerCartesian), n.cartographicToCartesian(W.northeast(t), e.northeastCornerCartesian), _r.longitude = t.west, _r.latitude = (t.south + t.north) * .5, _r.height = 0;
    var r = n.cartographicToCartesian(_r, qO),
        i = u.cross(r, u.UNIT_Z, Ch);
    u.normalize(i, e.westNormal), _r.longitude = t.east;
    var a = n.cartographicToCartesian(_r, YO),
        o = u.cross(u.UNIT_Z, a, Ch);
    u.normalize(o, e.eastNormal);
    var s = u.subtract(r, a, Ch),
        c = u.normalize(s, WO),
        f = t.south,
        h;
    if (f > 0) {
        _r.longitude = (t.west + t.east) * .5, _r.latitude = f;
        var d = n.cartographicToCartesian(_r, uo.origin);
        u.clone(c, uo.direction);
        var _ = Ne.fromPointNormal(e.southwestCornerCartesian, e.westNormal, hm);
        Me.rayPlane(uo, _, e.southwestCornerCartesian), h = n.geodeticSurfaceNormal(d, Fu)
    } else h = n.geodeticSurfaceNormalCartographic(W.southeast(t), Fu);
    var v = u.cross(h, s, fm);
    u.normalize(v, e.southNormal);
    var m = t.north,
        g;
    if (m < 0) {
        _r.longitude = (t.west + t.east) * .5, _r.latitude = m;
        var y = n.cartographicToCartesian(_r, uo.origin);
        u.negate(c, uo.direction);
        var E = Ne.fromPointNormal(e.northeastCornerCartesian, e.eastNormal, hm);
        Me.rayPlane(uo, E, e.northeastCornerCartesian), g = n.geodeticSurfaceNormal(y, Fu)
    } else g = n.geodeticSurfaceNormalCartographic(W.northwest(t), Fu);
    var w = u.cross(s, g, fm);
    u.normalize(w, e.northNormal)
}
var jO = new u,
    ZO = new u,
    KO = new u(0, -1, 0),
    $O = new u(0, 0, -1),
    lm = new u;
zs.prototype.distanceToCamera = function(e) {
    var t = e.camera,
        n = t.positionWC,
        r = t.positionCartographic,
        i = 0;
    if (!W.contains(this.rectangle, r)) {
        var a = this.southwestCornerCartesian,
            o = this.northeastCornerCartesian,
            s = this.westNormal,
            c = this.southNormal,
            f = this.eastNormal,
            h = this.northNormal;
        e.mode !== k.SCENE3D && (a = e.mapProjection.project(W.southwest(this.rectangle), jO), a.z = a.y, a.y = a.x, a.x = 0, o = e.mapProjection.project(W.northeast(this.rectangle), ZO), o.z = o.y, o.y = o.x, o.x = 0, s = KO, f = u.UNIT_Y, c = $O, h = u.UNIT_Z);
        var d = u.subtract(n, a, lm),
            _ = u.dot(d, s),
            v = u.dot(d, c),
            m = u.subtract(n, o, lm),
            g = u.dot(m, f),
            y = u.dot(m, h);
        _ > 0 ? i += _ * _ : g > 0 && (i += g * g), v > 0 ? i += v * v : y > 0 && (i += y * y)
    }
    var E, w, C;
    if (e.mode === k.SCENE3D ? (E = r.height, w = this.minimumHeight, C = this.maximumHeight) : (E = n.x, w = 0, C = 0), E > C) {
        var A = E - C;
        i += A * A
    } else if (E < w) {
        var x = w - E;
        i += x * x
    }
    return Math.sqrt(i)
};
zs.prototype.intersectPlane = function(e) {
    return this._orientedBoundingBox.intersectPlane(e)
};
zs.prototype.createDebugVolume = function(e) {
    var t = new S.clone(S.IDENTITY),
        n = new Ro({
            rectangle: this.rectangle,
            height: this.minimumHeight,
            extrudedHeight: this.maximumHeight
        }),
        r = new ws({
            geometry: n,
            id: "outline",
            modelMatrix: t,
            attributes: {
                color: ui.fromColor(e)
            }
        });
    return new mt({
        geometryInstances: r,
        appearance: new Gn({
            translucent: !1,
            flat: !0
        }),
        asynchronous: !1
    })
};

function At(e) {
    this.lightingFadeOutDistance = 65e5, this.lightingFadeInDistance = 9e6, this.hasWaterMask = !1, this.oceanNormalMap = void 0, this.zoomedOutOceanSpecularIntensity = .5, this.enableLighting = !1, this.dynamicAtmosphereLighting = !1, this.dynamicAtmosphereLightingFromSun = !1, this.showGroundAtmosphere = !1, this.shadows = Ma.RECEIVE_ONLY, this.fillHighlightColor = void 0, this.hueShift = 0, this.saturationShift = 0, this.brightnessShift = 0, this.showSkirts = !0, this.backFaceCulling = !0, this.undergroundColor = void 0, this.undergroundColorAlphaByDistance = void 0, this.materialUniformMap = void 0, this._materialUniformMap = void 0, this._quadtree = void 0, this._terrainProvider = e.terrainProvider, this._imageryLayers = e.imageryLayers, this._surfaceShaderSet = e.surfaceShaderSet, this._renderState = void 0, this._blendRenderState = void 0, this._disableCullingRenderState = void 0, this._disableCullingBlendRenderState = void 0, this._errorEvent = new ht, this._imageryLayers.layerAdded.addEventListener(At.prototype._onLayerAdded, this), this._imageryLayers.layerRemoved.addEventListener(At.prototype._onLayerRemoved, this), this._imageryLayers.layerMoved.addEventListener(At.prototype._onLayerMoved, this), this._imageryLayers.layerShownOrHidden.addEventListener(At.prototype._onLayerShownOrHidden, this), this._imageryLayersUpdatedEvent = new ht, this._layerOrderChanged = !1, this._tilesToRenderByTextureCount = [], this._drawCommands = [], this._uniformMaps = [], this._usedDrawCommands = 0, this._vertexArraysToDestroy = [], this._debug = {
        wireframe: !1,
        boundingSphereTile: void 0
    }, this._baseColor = void 0, this._firstPassInitialColor = void 0, this.baseColor = new H(0, 0, .5, 1), this._clippingPlanes = void 0, this.cartographicLimitRectangle = W.clone(W.MAX_VALUE), this._hasLoadedTilesThisFrame = !1, this._hasFillTilesThisFrame = !1
}
Object.defineProperties(At.prototype, {
    baseColor: {
        get: function() {
            return this._baseColor
        },
        set: function(e) {
            this._baseColor = e, this._firstPassInitialColor = U.fromColor(e, this._firstPassInitialColor)
        }
    },
    quadtree: {
        get: function() {
            return this._quadtree
        },
        set: function(e) {
            this._quadtree = e
        }
    },
    ready: {
        get: function() {
            return this._terrainProvider.ready && (this._imageryLayers.length === 0 || this._imageryLayers.get(0).imageryProvider.ready)
        }
    },
    tilingScheme: {
        get: function() {
            return this._terrainProvider.tilingScheme
        }
    },
    errorEvent: {
        get: function() {
            return this._errorEvent
        }
    },
    imageryLayersUpdatedEvent: {
        get: function() {
            return this._imageryLayersUpdatedEvent
        }
    },
    terrainProvider: {
        get: function() {
            return this._terrainProvider
        },
        set: function(e) {
            this._terrainProvider !== e && (this._terrainProvider = e, l(this._quadtree) && this._quadtree.invalidateAllTiles())
        }
    },
    clippingPlanes: {
        get: function() {
            return this._clippingPlanes
        },
        set: function(e) {
            Qt.setOwner(e, this, "_clippingPlanes")
        }
    }
});

function JO(e, t) {
    var n = e.loadingImagery;
    l(n) || (n = e.readyImagery);
    var r = t.loadingImagery;
    return l(r) || (r = t.readyImagery), n.imageryLayer._layerIndex - r.imageryLayer._layerIndex
}
At.prototype.update = function(e) {
    this._imageryLayers._update()
};

function QO(e, t) {
    var n = t.creditDisplay;
    e._terrainProvider.ready && l(e._terrainProvider.credit) && n.addCredit(e._terrainProvider.credit);
    for (var r = e._imageryLayers, i = 0, a = r.length; i < a; ++i) {
        var o = r.get(i).imageryProvider;
        o.ready && l(o.credit) && n.addCredit(o.credit)
    }
}
At.prototype.initialize = function(e) {
    this._imageryLayers.queueReprojectionCommands(e), this._layerOrderChanged && (this._layerOrderChanged = !1, this._quadtree.forEachLoadedTile(function(i) {
        i.data.imagery.sort(JO)
    })), QO(this, e);
    for (var t = this._vertexArraysToDestroy, n = t.length, r = 0; r < n; ++r) Ct._freeVertexArray(t[r]);
    t.length = 0
};
At.prototype.beginUpdate = function(e) {
    for (var t = this._tilesToRenderByTextureCount, n = 0, r = t.length; n < r; ++n) {
        var i = t[n];
        l(i) && (i.length = 0)
    }
    var a = this._clippingPlanes;
    l(a) && a.enabled && a.update(e), this._usedDrawCommands = 0, this._hasLoadedTilesThisFrame = !1, this._hasFillTilesThisFrame = !1
};
At.prototype.endUpdate = function(e) {
    if (!l(this._renderState)) {
        this._renderState = Ge.fromCache({
            cull: {
                enabled: !0
            },
            depthTest: {
                enabled: !0,
                func: Tl.LESS
            }
        }), this._blendRenderState = Ge.fromCache({
            cull: {
                enabled: !0
            },
            depthTest: {
                enabled: !0,
                func: Tl.LESS_OR_EQUAL
            },
            blending: fi.ALPHA_BLEND
        });
        var t = sn(this._renderState, !0);
        t.cull.enabled = !1, this._disableCullingRenderState = Ge.fromCache(t), t = sn(this._blendRenderState, !0), t.cull.enabled = !1, this._disableCullingBlendRenderState = Ge.fromCache(t)
    }
    this._hasFillTilesThisFrame && this._hasLoadedTilesThisFrame && bo.updateFillTiles(this, this._quadtree._tilesToRender, e, this._vertexArraysToDestroy);
    for (var n = this._tilesToRenderByTextureCount, r = 0, i = n.length; r < i; ++r) {
        var a = n[r];
        if (!!l(a))
            for (var o = 0, s = a.length; o < s; ++o) {
                var c = a[o],
                    f = c.data.tileBoundingRegion;
                wM(this, c, e), e.minimumTerrainHeight = Math.min(e.minimumTerrainHeight, f.minimumHeight)
            }
    }
};

function xy(e, t) {
    var n = t.globeTranslucencyState;
    if (n.translucent) {
        var r = e.renderState.blending.enabled;
        n.pushDerivedCommands(e, r, t)
    } else t.commandList.push(e)
}
At.prototype.updateForPick = function(e) {
    for (var t = this._drawCommands, n = 0, r = this._usedDrawCommands; n < r; ++n) xy(t[n], e)
};
At.prototype.cancelReprojections = function() {
    this._imageryLayers.cancelReprojections()
};
At.prototype.getLevelMaximumGeometricError = function(e) {
    return this._terrainProvider.getLevelMaximumGeometricError(e)
};
At.prototype.loadTile = function(e, t) {
    var n = t.data,
        r = !0,
        i;
    l(n) && (r = n.boundingVolumeSourceTile !== t || t._lastSelectionResult === Be.CULLED_BUT_NEEDED, i = n.terrainState), Ct.processStateMachine(t, e, this.terrainProvider, this._imageryLayers, this._vertexArraysToDestroy, r), n = t.data, r && i !== t.data.terrainState && this.computeTileVisibility(t, e, this.quadtree.occluders) !== qt.NONE && n.boundingVolumeSourceTile === t && (r = !1, Ct.processStateMachine(t, e, this.terrainProvider, this._imageryLayers, this._vertexArraysToDestroy, r))
};
var eM = new q,
    Sy = new W,
    tM = new W,
    nM = new K;

function hc(e, t) {
    if (t.west < t.east) return t;
    var n = W.clone(t, tM),
        r = W.center(e, nM);
    return r.longitude > 0 ? n.east = T.PI : n.west = -T.PI, n
}

function Ry(e, t) {
    if (t.cameraUnderground || t.globeTranslucencyState.translucent) return !0;
    if (e.backFaceCulling) return !1;
    var n = e._clippingPlanes;
    return !!(l(n) && n.enabled || !W.equals(e.cartographicLimitRectangle, W.MAX_VALUE))
}
At.prototype.computeTileVisibility = function(e, t, n) {
    var r = this.computeDistanceToTile(e, t);
    e._distance = r;
    var i = Ry(this, t);
    if (t.fog.enabled && !i && T.fog(r, t.fog.density) >= 1) return qt.NONE;
    var a = e.data,
        o = a.tileBoundingRegion;
    if (a.boundingVolumeSourceTile === void 0) return qt.PARTIAL;
    var s = t.cullingVolume,
        c = a.orientedBoundingBox;
    !l(c) && l(a.renderedMesh) && (c = a.renderedMesh.boundingSphere3D), a.clippedByBoundaries = !1;
    var f = hc(e.rectangle, this.cartographicLimitRectangle),
        h = W.simpleIntersection(f, e.rectangle, Sy);
    if (!l(h)) return qt.NONE;
    if (W.equals(h, e.rectangle) || (a.clippedByBoundaries = !0), t.mode !== k.SCENE3D && (c = eM, q.fromRectangleWithHeights2D(e.rectangle, t.mapProjection, o.minimumHeight, o.maximumHeight, c), u.fromElements(c.center.z, c.center.x, c.center.y, c.center), t.mode === k.MORPHING && l(a.renderedMesh) && (c = q.union(a.renderedMesh.boundingSphere3D, c, c))), !l(c)) return qt.PARTIAL;
    var d = this._clippingPlanes;
    if (l(d) && d.enabled) {
        var _ = d.computeIntersectionWithBoundingVolume(c);
        if (e.isClipped = _ !== nt.INSIDE, _ === nt.OUTSIDE) return qt.NONE
    }
    var v, m = s.computeVisibility(c);
    if (m === nt.OUTSIDE ? v = qt.NONE : m === nt.INTERSECTING ? v = qt.PARTIAL : m === nt.INSIDE && (v = qt.FULL), v === qt.NONE) return v;
    var g = t.mode === k.SCENE3D && t.camera.frustum instanceof lt;
    if (t.mode === k.SCENE3D && !g && l(n) && !i) {
        var y = a.occludeePointInScaledSpace;
        return !l(y) || n.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(y, o.minimumHeight) ? v : qt.NONE
    }
    return v
};
At.prototype.canRefine = function(e) {
    if (l(e.data.terrainData)) return !0;
    var t = this.terrainProvider.getTileDataAvailable(e.x * 2, e.y * 2, e.level + 1);
    return t !== void 0
};
var rM = [],
    iM = [];
At.prototype.canRenderWithoutLosingDetail = function(e, t) {
    var n = e.data,
        r = rM;
    r.length = this._imageryLayers.length;
    var i = !1,
        a = !1,
        o;
    l(n) && (i = n.terrainState === Tt.READY, a = !0, o = n.imagery);
    var s, c;
    for (s = 0, c = r.length; s < c; ++s) r[s] = a;
    if (l(o))
        for (s = 0, c = o.length; s < c; ++s) {
            var f = o[s],
                h = f.loadingImagery,
                d = !l(h) || h.state === Ze.FAILED || h.state === Ze.INVALID,
                _ = (f.loadingImagery || f.readyImagery).imageryLayer._layerIndex;
            r[_] = d && r[_]
        }
    var v = this.quadtree._lastSelectionFrameNumber,
        m = iM;
    for (m.length = 0, m.push(e.southwestChild, e.southeastChild, e.northwestChild, e.northeastChild); m.length > 0;) {
        var g = m.pop(),
            y = g._lastSelectionResultFrame === v ? g._lastSelectionResult : Be.NONE;
        if (y === Be.RENDERED) {
            var E = g.data;
            if (!l(E)) continue;
            if (!i && g.data.terrainState === Tt.READY) return !1;
            var w = g.data.imagery;
            for (s = 0, c = w.length; s < c; ++s) {
                var C = w[s],
                    A = C.loadingImagery,
                    x = !l(A) || A.state === Ze.FAILED || A.state === Ze.INVALID,
                    P = (C.loadingImagery || C.readyImagery).imageryLayer._layerIndex;
                if (x && !r[P]) return !1
            }
        } else y === Be.REFINED && m.push(g.southwestChild, g.southeastChild, g.northwestChild, g.northeastChild)
    }
    return !0
};
var aM = new u;
At.prototype.computeTileLoadPriority = function(e, t) {
    var n = e.data;
    if (n === void 0) return 0;
    var r = n.orientedBoundingBox;
    if (r === void 0) return 0;
    var i = t.camera.positionWC,
        a = t.camera.directionWC,
        o = u.subtract(r.center, i, aM),
        s = u.magnitude(o);
    return s < T.EPSILON5 ? 0 : (u.divideByScalar(o, s, o), (1 - u.dot(o, a)) * e._distance)
};
var dm = new S,
    Lu = new S,
    oM = new U,
    sM = new U,
    uM = new U,
    cM = new u,
    _m = new u,
    fM = new u,
    hM = new u;
At.prototype.showTileThisFrame = function(e, t) {
    for (var n = 0, r = e.data.imagery, i = 0, a = r.length; i < a; ++i) {
        var o = r[i];
        l(o.readyImagery) && o.readyImagery.imageryLayer.alpha !== 0 && ++n
    }
    var s = this._tilesToRenderByTextureCount[n];
    l(s) || (s = [], this._tilesToRenderByTextureCount[n] = s), s.push(e);
    var c = e.data;
    l(c.vertexArray) ? this._hasLoadedTilesThisFrame = !0 : this._hasFillTilesThisFrame = !0;
    var f = this._debug;
    ++f.tilesRendered, f.texturesRendered += n
};
var lM = [new u, new u, new u, new u];

function dM(e, t, n, r, i, a) {
    var o = e.quadtree._occluders.ellipsoid,
        s = o.ellipsoid,
        c = lM;
    return u.fromRadians(n.west, n.south, i, s, c[0]), u.fromRadians(n.east, n.south, i, s, c[1]), u.fromRadians(n.west, n.north, i, s, c[2]), u.fromRadians(n.east, n.north, i, s, c[3]), o.computeHorizonCullingPointPossiblyUnderEllipsoid(t, c, r, a)
}
At.prototype.computeDistanceToTile = function(e, t) {
    var n = _M(e, this.terrainProvider, t),
        r = e.data,
        i = r.tileBoundingRegion;
    if (n === void 0) return 9999999999;
    if (r.boundingVolumeSourceTile !== n) {
        r.boundingVolumeSourceTile = n;
        var a = e.rectangle;
        l(a) && (r.orientedBoundingBox = $e.fromRectangle(e.rectangle, i.minimumHeight, i.maximumHeight, e.tilingScheme.ellipsoid, r.orientedBoundingBox), r.occludeePointInScaledSpace = dM(this, r.orientedBoundingBox.center, e.rectangle, i.minimumHeight, i.maximumHeight, r.occludeePointInScaledSpace))
    }
    var o = i.minimumHeight,
        s = i.maximumHeight;
    if (r.boundingVolumeSourceTile !== e) {
        var c = t.camera.positionCartographic.height,
            f = Math.abs(c - o),
            h = Math.abs(c - s);
        f > h ? (i.minimumHeight = o, i.maximumHeight = o) : (i.minimumHeight = s, i.maximumHeight = s)
    }
    var d = i.distanceToCamera(t);
    return i.minimumHeight = o, i.maximumHeight = s, d
};

function _M(e, t, n) {
    var r = e.data;
    r === void 0 && (r = e.data = new Ct), r.tileBoundingRegion === void 0 && (r.tileBoundingRegion = new zs({
        computeBoundingVolumes: !1,
        rectangle: e.rectangle,
        ellipsoid: e.tilingScheme.ellipsoid,
        minimumHeight: 0,
        maximumHeight: 0
    }));
    var i = r.terrainData,
        a = r.mesh,
        o = r.tileBoundingRegion;
    if (a !== void 0 && a.minimumHeight !== void 0 && a.maximumHeight !== void 0) return o.minimumHeight = a.minimumHeight, o.maximumHeight = a.maximumHeight, e;
    if (i !== void 0 && i._minimumHeight !== void 0 && i._maximumHeight !== void 0) return o.minimumHeight = i._minimumHeight * n.terrainExaggeration, o.maximumHeight = i._maximumHeight * n.terrainExaggeration, e;
    o.minimumHeight = Number.NaN, o.maximumHeight = Number.NaN;
    for (var s = e.parent; s !== void 0;) {
        var c = s.data;
        if (c !== void 0) {
            var f = c.mesh;
            if (f !== void 0 && f.minimumHeight !== void 0 && f.maximumHeight !== void 0) return o.minimumHeight = f.minimumHeight, o.maximumHeight = f.maximumHeight, s;
            var h = c.terrainData;
            if (h !== void 0 && h._minimumHeight !== void 0 && h._maximumHeight !== void 0) return o.minimumHeight = h._minimumHeight * n.terrainExaggeration, o.maximumHeight = h._maximumHeight * n.terrainExaggeration, s
        }
        s = s.parent
    }
}
At.prototype.isDestroyed = function() {
    return !1
};
At.prototype.destroy = function() {
    return this._tileProvider = this._tileProvider && this._tileProvider.destroy(), this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy(), Pe(this)
};

function vM(e, t, n) {
    return function(r) {
        var i, a, o = -1,
            s = r.data.imagery,
            c = s.length,
            f;
        for (f = 0; f < c; ++f)
            if (i = s[f], a = p(i.readyImagery, i.loadingImagery), a.imageryLayer === t) {
                o = f;
                break
            }
        if (o !== -1) {
            var h = o + e;
            if (i = s[h], a = l(i) ? p(i.readyImagery, i.loadingImagery) : void 0, !l(a) || a.imageryLayer !== t) return !t._createTileImagerySkeletons(r, n, h);
            for (f = o; f < h; ++f) s[f].freeResources();
            s.splice(o, e)
        }
        return !0
    }
}
At.prototype._onLayerAdded = function(e, t) {
    if (e.show) {
        var n = this._terrainProvider,
            r = this,
            i = e.imageryProvider,
            a = this._imageryLayersUpdatedEvent;
        i._reload = function() {
            e._imageryCache = {}, r._quadtree.forEachLoadedTile(function(o) {
                if (!l(o._loadedCallbacks[e._layerIndex])) {
                    var s, c = o.data.imagery,
                        f = c.length,
                        h = -1,
                        d = 0;
                    for (s = 0; s < f; ++s) {
                        var _ = c[s],
                            v = p(_.readyImagery, _.loadingImagery);
                        if (v.imageryLayer === e) h === -1 && (h = s), ++d;
                        else if (h !== -1) break
                    }
                    if (h !== -1) {
                        var m = h + d;
                        e._createTileImagerySkeletons(o, n, m) && (o._loadedCallbacks[e._layerIndex] = vM(d, e, n), o.state = Tr.LOADING)
                    }
                }
            })
        }, this._quadtree.forEachLoadedTile(function(o) {
            e._createTileImagerySkeletons(o, n) && (o.state = Tr.LOADING, o.level !== 0 && (o._lastSelectionResultFrame !== r.quadtree._lastSelectionFrameNumber || o._lastSelectionResult !== Be.RENDERED) && (o.renderable = !1))
        }), this._layerOrderChanged = !0, a.raiseEvent()
    }
};
At.prototype._onLayerRemoved = function(e, t) {
    this._quadtree.forEachLoadedTile(function(n) {
        for (var r = n.data.imagery, i = -1, a = 0, o = 0, s = r.length; o < s; ++o) {
            var c = r[o],
                f = c.loadingImagery;
            if (l(f) || (f = c.readyImagery), f.imageryLayer === e) i === -1 && (i = o), c.freeResources(), ++a;
            else if (i !== -1) break
        }
        i !== -1 && r.splice(i, a)
    }), l(e.imageryProvider) && (e.imageryProvider._reload = void 0), this._imageryLayersUpdatedEvent.raiseEvent()
};
At.prototype._onLayerMoved = function(e, t, n) {
    this._layerOrderChanged = !0, this._imageryLayersUpdatedEvent.raiseEvent()
};
At.prototype._onLayerShownOrHidden = function(e, t, n) {
    n ? this._onLayerAdded(e, t) : this._onLayerRemoved(e, t)
};
var mM = new S,
    pM = new S;

function vm(e, t) {
    var n = {
        u_initialColor: function() {
            return this.properties.initialColor
        },
        u_fillHighlightColor: function() {
            return this.properties.fillHighlightColor
        },
        u_zoomedOutOceanSpecularIntensity: function() {
            return this.properties.zoomedOutOceanSpecularIntensity
        },
        u_oceanNormalMap: function() {
            return this.properties.oceanNormalMap
        },
        u_lightingFadeDistance: function() {
            return this.properties.lightingFadeDistance
        },
        u_nightFadeDistance: function() {
            return this.properties.nightFadeDistance
        },
        u_center3D: function() {
            return this.properties.center3D
        },
        u_tileRectangle: function() {
            return this.properties.tileRectangle
        },
        u_modifiedModelView: function() {
            var r = e.context.uniformState.view,
                i = S.multiplyByPoint(r, this.properties.rtc, _m);
            return S.setTranslation(r, i, dm), dm
        },
        u_modifiedModelViewProjection: function() {
            var r = e.context.uniformState.view,
                i = e.context.uniformState.projection,
                a = S.multiplyByPoint(r, this.properties.rtc, _m);
            return S.setTranslation(r, a, Lu), S.multiply(i, Lu, Lu), Lu
        },
        u_dayTextures: function() {
            return this.properties.dayTextures
        },
        u_dayTextureTranslationAndScale: function() {
            return this.properties.dayTextureTranslationAndScale
        },
        u_dayTextureTexCoordsRectangle: function() {
            return this.properties.dayTextureTexCoordsRectangle
        },
        u_dayTextureUseWebMercatorT: function() {
            return this.properties.dayTextureUseWebMercatorT
        },
        u_dayTextureAlpha: function() {
            return this.properties.dayTextureAlpha
        },
        u_dayTextureNightAlpha: function() {
            return this.properties.dayTextureNightAlpha
        },
        u_dayTextureDayAlpha: function() {
            return this.properties.dayTextureDayAlpha
        },
        u_dayTextureBrightness: function() {
            return this.properties.dayTextureBrightness
        },
        u_dayTextureContrast: function() {
            return this.properties.dayTextureContrast
        },
        u_dayTextureHue: function() {
            return this.properties.dayTextureHue
        },
        u_dayTextureSaturation: function() {
            return this.properties.dayTextureSaturation
        },
        u_dayTextureOneOverGamma: function() {
            return this.properties.dayTextureOneOverGamma
        },
        u_dayIntensity: function() {
            return this.properties.dayIntensity
        },
        u_southAndNorthLatitude: function() {
            return this.properties.southAndNorthLatitude
        },
        u_southMercatorYAndOneOverHeight: function() {
            return this.properties.southMercatorYAndOneOverHeight
        },
        u_waterMask: function() {
            return this.properties.waterMask
        },
        u_waterMaskTranslationAndScale: function() {
            return this.properties.waterMaskTranslationAndScale
        },
        u_minMaxHeight: function() {
            return this.properties.minMaxHeight
        },
        u_scaleAndBias: function() {
            return this.properties.scaleAndBias
        },
        u_dayTextureSplit: function() {
            return this.properties.dayTextureSplit
        },
        u_dayTextureCutoutRectangles: function() {
            return this.properties.dayTextureCutoutRectangles
        },
        u_clippingPlanes: function() {
            var r = t._clippingPlanes;
            return l(r) && l(r.texture) ? r.texture : e.context.defaultTexture
        },
        u_cartographicLimitRectangle: function() {
            return this.properties.localizedCartographicLimitRectangle
        },
        u_clippingPlanesMatrix: function() {
            var r = t._clippingPlanes,
                i = l(r) ? S.multiply(e.context.uniformState.view, r.modelMatrix, mM) : S.IDENTITY;
            return S.inverseTranspose(i, pM)
        },
        u_clippingPlanesEdgeStyle: function() {
            var r = this.properties.clippingPlanesEdgeColor;
            return r.alpha = this.properties.clippingPlanesEdgeWidth, r
        },
        u_minimumBrightness: function() {
            return e.fog.minimumBrightness
        },
        u_hsbShift: function() {
            return this.properties.hsbShift
        },
        u_colorsToAlpha: function() {
            return this.properties.colorsToAlpha
        },
        u_frontFaceAlphaByDistance: function() {
            return this.properties.frontFaceAlphaByDistance
        },
        u_backFaceAlphaByDistance: function() {
            return this.properties.backFaceAlphaByDistance
        },
        u_translucencyRectangle: function() {
            return this.properties.localizedTranslucencyRectangle
        },
        u_undergroundColor: function() {
            return this.properties.undergroundColor
        },
        u_undergroundColorAlphaByDistance: function() {
            return this.properties.undergroundColorAlphaByDistance
        },
        properties: {
            initialColor: new U(0, 0, .5, 1),
            fillHighlightColor: new H(0, 0, 0, 0),
            zoomedOutOceanSpecularIntensity: .5,
            oceanNormalMap: void 0,
            lightingFadeDistance: new R(65e5, 9e6),
            nightFadeDistance: new R(1e7, 4e7),
            hsbShift: new u,
            center3D: void 0,
            rtc: new u,
            modifiedModelView: new S,
            tileRectangle: new U,
            dayTextures: [],
            dayTextureTranslationAndScale: [],
            dayTextureTexCoordsRectangle: [],
            dayTextureUseWebMercatorT: [],
            dayTextureAlpha: [],
            dayTextureNightAlpha: [],
            dayTextureDayAlpha: [],
            dayTextureBrightness: [],
            dayTextureContrast: [],
            dayTextureHue: [],
            dayTextureSaturation: [],
            dayTextureOneOverGamma: [],
            dayTextureSplit: [],
            dayTextureCutoutRectangles: [],
            dayIntensity: 0,
            colorsToAlpha: [],
            southAndNorthLatitude: new R,
            southMercatorYAndOneOverHeight: new R,
            waterMask: void 0,
            waterMaskTranslationAndScale: new U,
            minMaxHeight: new R,
            scaleAndBias: new S,
            clippingPlanesEdgeColor: H.clone(H.WHITE),
            clippingPlanesEdgeWidth: 0,
            localizedCartographicLimitRectangle: new U,
            frontFaceAlphaByDistance: new U,
            backFaceAlphaByDistance: new U,
            localizedTranslucencyRectangle: new U,
            undergroundColor: H.clone(H.TRANSPARENT),
            undergroundColorAlphaByDistance: new U
        }
    };
    return l(t.materialUniformMap) ? En(n, t.materialUniformMap) : n
}

function gM(e, t, n) {
    var r = n.data,
        i, a;
    if (l(r.vertexArray) ? (i = r.mesh, a = r.vertexArray) : l(r.fill) && l(r.fill.vertexArray) && (i = r.fill.mesh, a = r.fill.vertexArray), !(!l(i) || !l(a))) {
        if (l(r.wireframeVertexArray)) {
            if (r.wireframeVertexArray.mesh === i) return;
            r.wireframeVertexArray.destroy(), r.wireframeVertexArray = void 0
        }
        r.wireframeVertexArray = yM(e, a, i), r.wireframeVertexArray.mesh = i
    }
}

function yM(e, t, n) {
    var r = n.indices,
        i = {
            indices: r,
            primitiveType: Ve.TRIANGLES
        };
    Qe.toWireframe(i);
    var a = i.indices,
        o = _t.createIndexBuffer({
            context: e,
            typedArray: a,
            usage: Ye.STATIC_DRAW,
            indexDatatype: yt.fromSizeInBytes(a.BYTES_PER_ELEMENT)
        });
    return new Cn({
        context: e,
        attributes: t._attributes,
        indexBuffer: o
    })
}
var Dy, Iy, lc;
(function() {
    var e = new ws({
            geometry: si.fromDimensions({
                dimensions: new u(2, 2, 2)
            })
        }),
        t = new ws({
            geometry: new wo({
                radius: 1
            })
        }),
        n = new S,
        r, i;

    function a(o) {
        return new mt({
            geometryInstances: o,
            appearance: new Gn({
                translucent: !1,
                flat: !0
            }),
            asynchronous: !1
        })
    }
    Dy = function(o, s) {
        return o === r || (lc(), r = o, n = S.fromRotationTranslation(o.halfAxes, o.center, n), e.modelMatrix = n, e.attributes.color = ui.fromColor(s), i = a(e)), i
    }, Iy = function(o, s) {
        return o === r || (lc(), r = o, n = S.fromTranslation(o.center, n), n = S.multiplyByUniformScale(n, o.radius, n), t.modelMatrix = n, t.attributes.color = ui.fromColor(s), i = a(t)), i
    }, lc = function() {
        l(i) && (i.destroy(), i = void 0, r = void 0)
    }
})();
var TM = new U(0, 0, 0, 0),
    EM = {
        frameState: void 0,
        surfaceTile: void 0,
        numberOfDayTextures: void 0,
        applyBrightness: void 0,
        applyContrast: void 0,
        applyHue: void 0,
        applySaturation: void 0,
        applyGamma: void 0,
        applyAlpha: void 0,
        applyDayNightAlpha: void 0,
        applySplit: void 0,
        showReflectiveOcean: void 0,
        showOceanWaves: void 0,
        enableLighting: void 0,
        dynamicAtmosphereLighting: void 0,
        dynamicAtmosphereLightingFromSun: void 0,
        showGroundAtmosphere: void 0,
        perFragmentGroundAtmosphere: void 0,
        hasVertexNormals: void 0,
        useWebMercatorProjection: void 0,
        enableFog: void 0,
        enableClippingPlanes: void 0,
        clippingPlanes: void 0,
        clippedByBoundaries: void 0,
        hasImageryLayerCutout: void 0,
        colorCorrect: void 0,
        colorToAlpha: void 0
    },
    AM = H.TRANSPARENT,
    CM = new at;

function wM(e, t, n) {
    var r = t.data;
    l(r.vertexArray) || (r.fill === void 0 && (r.fill = new bo(t)), r.fill.update(e, n));
    var i = n.creditDisplay,
        a = r.terrainData;
    if (l(a) && l(a.credits))
        for (var o = a.credits, s = 0, c = o.length; s < c; ++s) i.addCredit(o[s]);
    var f = pe.maximumTextureImageUnits,
        h = r.waterMaskTexture,
        d = r.waterMaskTranslationAndScale;
    !l(h) && l(r.fill) && (h = r.fill.waterMaskTexture, d = r.fill.waterMaskTranslationAndScale);
    var _ = n.cameraUnderground,
        v = n.globeTranslucencyState,
        m = v.translucent,
        g = v.frontFaceAlphaByDistance,
        y = v.backFaceAlphaByDistance,
        E = v.rectangle,
        w = p(e.undergroundColor, AM),
        C = p(e.undergroundColorAlphaByDistance, CM),
        A = Ry(e, n) && n.mode === k.SCENE3D && w.alpha > 0 && (C.nearValue > 0 || C.farValue > 0),
        x = e.hasWaterMask && l(h),
        P = e.oceanNormalMap,
        I = x && l(P),
        D = e.terrainProvider.ready && e.terrainProvider.hasVertexNormals,
        O = n.fog.enabled && !_,
        F = e.showGroundAtmosphere && n.mode === k.SCENE3D,
        z = Ma.castShadows(e.shadows) && !m,
        b = Ma.receiveShadows(e.shadows) && !m,
        M = e.hueShift,
        G = e.saturationShift,
        V = e.brightnessShift,
        B = !(T.equalsEpsilon(M, 0, T.EPSILON7) && T.equalsEpsilon(G, 0, T.EPSILON7) && T.equalsEpsilon(V, 0, T.EPSILON7)),
        Y = !1;
    if (F) {
        var j = u.magnitude(n.camera.positionWC),
            Z = e.nightFadeOutDistance;
        Y = j > Z
    }
    x && --f, I && --f, l(n.shadowState) && n.shadowState.shadowsEnabled && --f, l(e.clippingPlanes) && e.clippingPlanes.enabled && --f, f -= v.numberOfTextureUniforms;
    var Q = r.renderedMesh,
        ie = Q.center,
        Ae = Q.encoding,
        re = oM,
        ve = 0,
        qe = 0,
        De = 0,
        _e = 0,
        Oe = !1;
    if (n.mode !== k.SCENE3D) {
        var Fe = n.mapProjection,
            ce = Fe.project(W.southwest(t.rectangle), fM),
            He = Fe.project(W.northeast(t.rectangle), hM);
        if (re.x = ce.x, re.y = ce.y, re.z = He.x, re.w = He.y, n.mode !== k.MORPHING && (ie = cM, ie.x = 0, ie.y = (re.z + re.x) * .5, ie.z = (re.w + re.y) * .5, re.x -= ie.y, re.y -= ie.z, re.z -= ie.y, re.w -= ie.z), n.mode === k.SCENE2D && Ae.quantization === er.BITS12) {
            var le = 1 / (Math.pow(2, 12) - 1) * .5,
                ft = (re.z - re.x) * le,
                Pt = (re.w - re.y) * le;
            re.x -= ft, re.y -= Pt, re.z += ft, re.w += Pt
        }
        Fe instanceof st && (ve = t.rectangle.south, qe = t.rectangle.north, De = st.geodeticLatitudeToMercatorAngle(ve), _e = 1 / (st.geodeticLatitudeToMercatorAngle(qe) - De), Oe = !0)
    }
    var Ie = EM;
    Ie.frameState = n, Ie.surfaceTile = r, Ie.showReflectiveOcean = x, Ie.showOceanWaves = I, Ie.enableLighting = e.enableLighting, Ie.dynamicAtmosphereLighting = e.dynamicAtmosphereLighting, Ie.dynamicAtmosphereLightingFromSun = e.dynamicAtmosphereLightingFromSun, Ie.showGroundAtmosphere = F, Ie.perFragmentGroundAtmosphere = Y, Ie.hasVertexNormals = D, Ie.useWebMercatorProjection = Oe, Ie.clippedByBoundaries = r.clippedByBoundaries;
    var xn = r.imagery,
        Sn = 0,
        St = xn.length,
        rr = e.showSkirts && !_ && !m,
        bt = e.backFaceCulling && !_ && !m,
        cn = bt ? e._renderState : e._disableCullingRenderState,
        Rr = bt ? e._blendRenderState : e._disableCullingBlendRenderState,
        fn = cn,
        ir = e._firstPassInitialColor,
        hn = n.context;
    l(e._debug.boundingSphereTile) || lc();
    var Yn = e._materialUniformMap !== e.materialUniformMap;
    if (Yn) {
        e._materialUniformMap = e.materialUniformMap;
        for (var ar = e._drawCommands.length, sa = 0; sa < ar; ++sa) e._uniformMaps[sa] = vm(n, e)
    }
    do {
        var Xe = 0,
            et, bi;
        if (e._drawCommands.length <= e._usedDrawCommands ? (et = new an, et.owner = t, et.cull = !1, et.boundingVolume = new q, et.orientedBoundingBox = void 0, bi = vm(n, e), e._drawCommands.push(et), e._uniformMaps.push(bi)) : (et = e._drawCommands[e._usedDrawCommands], bi = e._uniformMaps[e._usedDrawCommands]), et.owner = t, ++e._usedDrawCommands, t === e._debug.boundingSphereTile) {
            var qa = r.orientedBoundingBox;
            l(qa) ? Dy(qa, H.RED).update(n) : l(Q) && l(Q.boundingSphere3D) && Iy(Q.boundingSphere3D, H.RED).update(n)
        }
        var me = bi.properties;
        U.clone(ir, me.initialColor), me.oceanNormalMap = P, me.lightingFadeDistance.x = e.lightingFadeOutDistance, me.lightingFadeDistance.y = e.lightingFadeInDistance, me.nightFadeDistance.x = e.nightFadeOutDistance, me.nightFadeDistance.y = e.nightFadeInDistance, me.zoomedOutOceanSpecularIntensity = e.zoomedOutOceanSpecularIntensity;
        var Fi = _ ? y : g,
            qr = _ ? g : y;
        l(Fi) && (U.fromElements(Fi.near, Fi.nearValue, Fi.far, Fi.farValue, me.frontFaceAlphaByDistance), U.fromElements(qr.near, qr.nearValue, qr.far, qr.farValue, me.backFaceAlphaByDistance)), U.fromElements(C.near, C.nearValue, C.far, C.farValue, me.undergroundColorAlphaByDistance), H.clone(w, me.undergroundColor);
        var or = !l(r.vertexArray) && l(e.fillHighlightColor) && e.fillHighlightColor.alpha > 0;
        or && H.clone(e.fillHighlightColor, me.fillHighlightColor), me.center3D = Q.center, u.clone(ie, me.rtc), U.clone(re, me.tileRectangle), me.southAndNorthLatitude.x = ve, me.southAndNorthLatitude.y = qe, me.southMercatorYAndOneOverHeight.x = De, me.southMercatorYAndOneOverHeight.y = _e;
        var di = sM,
            Ft = hc(t.rectangle, e.cartographicLimitRectangle),
            Ln = uM,
            Un = hc(t.rectangle, E);
        u.fromElements(M, G, V, me.hsbShift);
        var Ut = t.rectangle,
            Rn = 1 / Ut.width,
            Yr = 1 / Ut.height;
        di.x = (Ft.west - Ut.west) * Rn, di.y = (Ft.south - Ut.south) * Yr, di.z = (Ft.east - Ut.west) * Rn, di.w = (Ft.north - Ut.south) * Yr, U.clone(di, me.localizedCartographicLimitRectangle), Ln.x = (Un.west - Ut.west) * Rn, Ln.y = (Un.south - Ut.south) * Yr, Ln.z = (Un.east - Ut.west) * Rn, Ln.w = (Un.north - Ut.south) * Yr, U.clone(Ln, me.localizedTranslucencyRectangle);
        var Ya = O && T.fog(t._distance, n.fog.density) > T.EPSILON3;
        B = B && (Ya || F);
        for (var Bo = !1, Vo = !1, ua = !1, ca = !1, Xa = !1, ja = !1, fa = !1, ha = !1, Go = !1, Ho = !1; Xe < f && Sn < St;) {
            var Xr = xn[Sn],
                Xn = Xr.readyImagery;
            if (++Sn, !(!l(Xn) || Xn.imageryLayer.alpha === 0)) {
                var df = Xr.useWebMercatorT ? Xn.textureWebMercator : Xn.texture,
                    kt = Xn.imageryLayer;
                l(Xr.textureTranslationAndScale) || (Xr.textureTranslationAndScale = kt._calculateTextureTranslationAndScale(t, Xr)), me.dayTextures[Xe] = df, me.dayTextureTranslationAndScale[Xe] = Xr.textureTranslationAndScale, me.dayTextureTexCoordsRectangle[Xe] = Xr.textureCoordinateRectangle, me.dayTextureUseWebMercatorT[Xe] = Xr.useWebMercatorT, me.dayTextureAlpha[Xe] = kt.alpha, ja = ja || me.dayTextureAlpha[Xe] !== 1, me.dayTextureNightAlpha[Xe] = kt.nightAlpha, fa = fa || me.dayTextureNightAlpha[Xe] !== 1, me.dayTextureDayAlpha[Xe] = kt.dayAlpha, fa = fa || me.dayTextureDayAlpha[Xe] !== 1, me.dayTextureBrightness[Xe] = kt.brightness, Bo = Bo || me.dayTextureBrightness[Xe] !== Ue.DEFAULT_BRIGHTNESS, me.dayTextureContrast[Xe] = kt.contrast, Vo = Vo || me.dayTextureContrast[Xe] !== Ue.DEFAULT_CONTRAST, me.dayTextureHue[Xe] = kt.hue, ua = ua || me.dayTextureHue[Xe] !== Ue.DEFAULT_HUE, me.dayTextureSaturation[Xe] = kt.saturation, ca = ca || me.dayTextureSaturation[Xe] !== Ue.DEFAULT_SATURATION, me.dayTextureOneOverGamma[Xe] = 1 / kt.gamma, Xa = Xa || me.dayTextureOneOverGamma[Xe] !== 1 / Ue.DEFAULT_GAMMA, me.dayTextureSplit[Xe] = kt.splitDirection, ha = ha || me.dayTextureSplit[Xe] !== 0;
                var jr = me.dayTextureCutoutRectangles[Xe];
                if (l(jr) || (jr = me.dayTextureCutoutRectangles[Xe] = new U), U.clone(U.ZERO, jr), l(kt.cutoutRectangle)) {
                    var la = hc(Ut, kt.cutoutRectangle),
                        _f = W.simpleIntersection(la, Ut, Sy);
                    Go = l(_f) || Go, jr.x = (la.west - Ut.west) * Rn, jr.y = (la.south - Ut.south) * Yr, jr.z = (la.east - Ut.west) * Rn, jr.w = (la.north - Ut.south) * Yr
                }
                var Dr = me.colorsToAlpha[Xe];
                l(Dr) || (Dr = me.colorsToAlpha[Xe] = new U);
                var ko = l(kt.colorToAlpha) && kt.colorToAlphaThreshold > 0;
                if (Ho = Ho || ko, ko) {
                    var Za = kt.colorToAlpha;
                    Dr.x = Za.red, Dr.y = Za.green, Dr.z = Za.blue, Dr.w = kt.colorToAlphaThreshold
                } else Dr.w = -1;
                if (l(Xn.credits))
                    for (var _i = Xn.credits, vf = 0, ZT = _i.length; vf < ZT; ++vf) i.addCredit(_i[vf]);
                ++Xe
            }
        }
        me.dayTextures.length = Xe, me.waterMask = h, U.clone(d, me.waterMaskTranslationAndScale), me.minMaxHeight.x = Ae.minimumHeight, me.minMaxHeight.y = Ae.maximumHeight, S.clone(Ae.matrix, me.scaleAndBias);
        var Wo = e._clippingPlanes,
            Xd = l(Wo) && Wo.enabled && t.isClipped;
        Xd && (me.clippingPlanesEdgeColor = H.clone(Wo.edgeColor, me.clippingPlanesEdgeColor), me.clippingPlanesEdgeWidth = Wo.edgeWidth), Ie.numberOfDayTextures = Xe, Ie.applyBrightness = Bo, Ie.applyContrast = Vo, Ie.applyHue = ua, Ie.applySaturation = ca, Ie.applyGamma = Xa, Ie.applyAlpha = ja, Ie.applyDayNightAlpha = fa, Ie.applySplit = ha, Ie.enableFog = Ya, Ie.enableClippingPlanes = Xd, Ie.clippingPlanes = Wo, Ie.hasImageryLayerCutout = Go, Ie.colorCorrect = B, Ie.highlightFillTile = or, Ie.colorToAlpha = Ho, Ie.showUndergroundColor = A, Ie.translucent = m;
        var mf = r.renderedMesh.indices.length;
        rr || (mf = r.renderedMesh.indexCountWithoutSkirts), et.shaderProgram = e._surfaceShaderSet.getShaderProgram(Ie), et.castShadows = z, et.receiveShadows = b, et.renderState = fn, et.primitiveType = Ve.TRIANGLES, et.vertexArray = r.vertexArray || r.fill.vertexArray, et.count = mf, et.uniformMap = bi, et.pass = ue.GLOBE, e._debug.wireframe && (gM(hn, e, t), l(r.wireframeVertexArray) && (et.vertexArray = r.wireframeVertexArray, et.primitiveType = Ve.LINES, et.count = mf * 2));
        var vi = et.boundingVolume,
            KT = et.orientedBoundingBox;
        if (n.mode !== k.SCENE3D) {
            var jd = r.tileBoundingRegion;
            q.fromRectangleWithHeights2D(t.rectangle, n.mapProjection, jd.minimumHeight, jd.maximumHeight, vi), u.fromElements(vi.center.z, vi.center.x, vi.center.y, vi.center), n.mode === k.MORPHING && (vi = q.union(Q.boundingSphere3D, vi, vi))
        } else et.boundingVolume = q.clone(Q.boundingSphere3D, vi), et.orientedBoundingBox = $e.clone(r.orientedBoundingBox, KT);
        et.dirty = !0, m && v.updateDerivedCommands(et, n), xy(et, n), fn = Rr, ir = TM
    } while (Sn < St)
}

function Py() {
    this._enabled = !1, this._frontFaceAlpha = 1, this._frontFaceAlphaByDistance = void 0, this._backFaceAlpha = 1, this._backFaceAlphaByDistance = void 0, this._rectangle = W.clone(W.MAX_VALUE)
}
Object.defineProperties(Py.prototype, {
    enabled: {
        get: function() {
            return this._enabled
        },
        set: function(e) {
            this._enabled = e
        }
    },
    frontFaceAlpha: {
        get: function() {
            return this._frontFaceAlpha
        },
        set: function(e) {
            this._frontFaceAlpha = e
        }
    },
    frontFaceAlphaByDistance: {
        get: function() {
            return this._frontFaceAlphaByDistance
        },
        set: function(e) {
            this._frontFaceAlphaByDistance = at.clone(e, this._frontFaceAlphaByDistance)
        }
    },
    backFaceAlpha: {
        get: function() {
            return this._backFaceAlpha
        },
        set: function(e) {
            this._backFaceAlpha = e
        }
    },
    backFaceAlphaByDistance: {
        get: function() {
            return this._backFaceAlphaByDistance
        },
        set: function(e) {
            this._backFaceAlphaByDistance = at.clone(e, this._backFaceAlphaByDistance)
        }
    },
    rectangle: {
        get: function() {
            return this._rectangle
        },
        set: function(e) {
            l(e) || (e = W.clone(W.MAX_VALUE)), W.clone(e, this._rectangle)
        }
    }
});

function Zt() {
    this._layers = [], this.layerAdded = new ht, this.layerRemoved = new ht, this.layerMoved = new ht, this.layerShownOrHidden = new ht
}
Object.defineProperties(Zt.prototype, {
    length: {
        get: function() {
            return this._layers.length
        }
    }
});
Zt.prototype.add = function(e, t) {
    var n = l(t);
    n ? this._layers.splice(t, 0, e) : (t = this._layers.length, this._layers.push(e)), this._update(), this.layerAdded.raiseEvent(e, t)
};
Zt.prototype.addImageryProvider = function(e, t) {
    var n = new Ue(e);
    return this.add(n, t), n
};
Zt.prototype.remove = function(e, t) {
    t = p(t, !0);
    var n = this._layers.indexOf(e);
    return n !== -1 ? (this._layers.splice(n, 1), this._update(), this.layerRemoved.raiseEvent(e, n), t && e.destroy(), !0) : !1
};
Zt.prototype.removeAll = function(e) {
    e = p(e, !0);
    for (var t = this._layers, n = 0, r = t.length; n < r; n++) {
        var i = t[n];
        this.layerRemoved.raiseEvent(i, n), e && i.destroy()
    }
    this._layers = []
};
Zt.prototype.contains = function(e) {
    return this.indexOf(e) !== -1
};
Zt.prototype.indexOf = function(e) {
    return this._layers.indexOf(e)
};
Zt.prototype.get = function(e) {
    return this._layers[e]
};

function ef(e, t) {
    var n = e.indexOf(t);
    return n
}

function Oy(e, t, n) {
    var r = e._layers;
    if (t = T.clamp(t, 0, r.length - 1), n = T.clamp(n, 0, r.length - 1), t !== n) {
        var i = r[t];
        r[t] = r[n], r[n] = i, e._update(), e.layerMoved.raiseEvent(i, n, t)
    }
}
Zt.prototype.raise = function(e) {
    var t = ef(this._layers, e);
    Oy(this, t, t + 1)
};
Zt.prototype.lower = function(e) {
    var t = ef(this._layers, e);
    Oy(this, t, t - 1)
};
Zt.prototype.raiseToTop = function(e) {
    var t = ef(this._layers, e);
    t !== this._layers.length - 1 && (this._layers.splice(t, 1), this._layers.push(e), this._update(), this.layerMoved.raiseEvent(e, this._layers.length - 1, t))
};
Zt.prototype.lowerToBottom = function(e) {
    var t = ef(this._layers, e);
    t !== 0 && (this._layers.splice(t, 1), this._layers.splice(0, 0, e), this._update(), this.layerMoved.raiseEvent(e, 0, t))
};
var xM = new W;
Zt.prototype.pickImageryLayerFeatures = function(e, t) {
    var n = t.globe.pick(e, t);
    if (!!l(n)) {
        for (var r = t.globe.ellipsoid.cartesianToCartographic(n), i = t.globe._surface._tilesToRender, a, o = 0; !l(a) && o < i.length; ++o) {
            var s = i[o];
            W.contains(s.rectangle, r) && (a = s)
        }
        if (!!l(a)) {
            for (var c = a.data.imagery, f = [], h = [], d = c.length - 1; d >= 0; --d) {
                var _ = c[d],
                    v = _.readyImagery;
                if (!!l(v)) {
                    var m = v.imageryLayer.imageryProvider;
                    if (!!l(m.pickFeatures) && !!W.contains(v.rectangle, r)) {
                        var g = xM,
                            y = 1 / 1024;
                        if (g.west = T.lerp(a.rectangle.west, a.rectangle.east, _.textureCoordinateRectangle.x - y), g.east = T.lerp(a.rectangle.west, a.rectangle.east, _.textureCoordinateRectangle.z + y), g.south = T.lerp(a.rectangle.south, a.rectangle.north, _.textureCoordinateRectangle.y - y), g.north = T.lerp(a.rectangle.south, a.rectangle.north, _.textureCoordinateRectangle.w + y), !!W.contains(g, r)) {
                            var E = m.pickFeatures(v.x, v.y, v.level, r.longitude, r.latitude);
                            !l(E) || (f.push(E), h.push(v.imageryLayer))
                        }
                    }
                }
            }
            if (f.length !== 0) return he.all(f, function(w) {
                for (var C = [], A = 0; A < w.length; ++A) {
                    var x = w[A],
                        P = h[A];
                    if (l(x) && x.length > 0)
                        for (var I = 0; I < x.length; ++I) {
                            var D = x[I];
                            D.imageryLayer = P, l(D.position) || (D.position = r), C.push(D)
                        }
                }
                return C
            })
        }
    }
};
Zt.prototype.queueReprojectionCommands = function(e) {
    for (var t = this._layers, n = 0, r = t.length; n < r; ++n) t[n].queueReprojectionCommands(e)
};
Zt.prototype.cancelReprojections = function() {
    for (var e = this._layers, t = 0, n = e.length; t < n; ++t) e[t].cancelReprojections()
};
Zt.prototype.isDestroyed = function() {
    return !1
};
Zt.prototype.destroy = function() {
    return this.removeAll(!0), Pe(this)
};
Zt.prototype._update = function() {
    var e = !0,
        t = this._layers,
        n, r, i, a;
    for (i = 0, a = t.length; i < a; ++i) r = t[i], r._layerIndex = i, r.show ? (r._isBaseLayer = e, e = !1) : r._isBaseLayer = !1, r.show !== r._show && (l(r._show) && (l(n) || (n = []), n.push(r)), r._show = r.show);
    if (l(n))
        for (i = 0, a = n.length; i < a; ++i) r = n[i], this.layerShownOrHidden.raiseEvent(r, r._layerIndex, r.show)
};

function My(e) {
    this._ellipsoid = new Hr(e.ellipsoid, u.ZERO)
}
Object.defineProperties(My.prototype, {
    ellipsoid: {
        get: function() {
            return this._ellipsoid
        }
    }
});

function Mn(e) {
    this._tilingScheme = e.tilingScheme, this._x = e.x, this._y = e.y, this._level = e.level, this._parent = e.parent, this._rectangle = this._tilingScheme.tileXYToRectangle(this._x, this._y, this._level), this._southwestChild = void 0, this._southeastChild = void 0, this._northwestChild = void 0, this._northeastChild = void 0, this.replacementPrevious = void 0, this.replacementNext = void 0, this._distance = 0, this._loadPriority = 0, this._customData = [], this._frameUpdated = void 0, this._lastSelectionResult = Be.NONE, this._lastSelectionResultFrame = void 0, this._loadedCallbacks = {}, this.state = Tr.START, this.renderable = !1, this.upsampledFromParent = !1, this.data = void 0
}
Mn.createLevelZeroTiles = function(e) {
    for (var t = e.getNumberOfXTilesAtLevel(0), n = e.getNumberOfYTilesAtLevel(0), r = new Array(t * n), i = 0, a = 0; a < n; ++a)
        for (var o = 0; o < t; ++o) r[i++] = new Mn({
            tilingScheme: e,
            x: o,
            y: a,
            level: 0
        });
    return r
};
Mn.prototype._updateCustomData = function(e, t, n) {
    var r = this.customData,
        i, a, o;
    if (l(t) && l(n)) {
        for (r = r.filter(function(f) {
                return n.indexOf(f) === -1
            }), this._customData = r, o = this._rectangle, i = 0; i < t.length; ++i) a = t[i], W.contains(o, a.positionCartographic) && r.push(a);
        this._frameUpdated = e
    } else {
        var s = this._parent;
        if (l(s) && this._frameUpdated !== s._frameUpdated) {
            r.length = 0, o = this._rectangle;
            var c = s.customData;
            for (i = 0; i < c.length; ++i) a = c[i], W.contains(o, a.positionCartographic) && r.push(a);
            this._frameUpdated = s._frameUpdated
        }
    }
};
Object.defineProperties(Mn.prototype, {
    tilingScheme: {
        get: function() {
            return this._tilingScheme
        }
    },
    x: {
        get: function() {
            return this._x
        }
    },
    y: {
        get: function() {
            return this._y
        }
    },
    level: {
        get: function() {
            return this._level
        }
    },
    parent: {
        get: function() {
            return this._parent
        }
    },
    rectangle: {
        get: function() {
            return this._rectangle
        }
    },
    children: {
        get: function() {
            return [this.northwestChild, this.northeastChild, this.southwestChild, this.southeastChild]
        }
    },
    southwestChild: {
        get: function() {
            return l(this._southwestChild) || (this._southwestChild = new Mn({
                tilingScheme: this.tilingScheme,
                x: this.x * 2,
                y: this.y * 2 + 1,
                level: this.level + 1,
                parent: this
            })), this._southwestChild
        }
    },
    southeastChild: {
        get: function() {
            return l(this._southeastChild) || (this._southeastChild = new Mn({
                tilingScheme: this.tilingScheme,
                x: this.x * 2 + 1,
                y: this.y * 2 + 1,
                level: this.level + 1,
                parent: this
            })), this._southeastChild
        }
    },
    northwestChild: {
        get: function() {
            return l(this._northwestChild) || (this._northwestChild = new Mn({
                tilingScheme: this.tilingScheme,
                x: this.x * 2,
                y: this.y * 2,
                level: this.level + 1,
                parent: this
            })), this._northwestChild
        }
    },
    northeastChild: {
        get: function() {
            return l(this._northeastChild) || (this._northeastChild = new Mn({
                tilingScheme: this.tilingScheme,
                x: this.x * 2 + 1,
                y: this.y * 2,
                level: this.level + 1,
                parent: this
            })), this._northeastChild
        }
    },
    customData: {
        get: function() {
            return this._customData
        }
    },
    needsLoading: {
        get: function() {
            return this.state < Tr.DONE
        }
    },
    eligibleForUnloading: {
        get: function() {
            var e = !0;
            return l(this.data) && (e = this.data.eligibleForUnloading, l(e) || (e = !0)), e
        }
    }
});
Mn.prototype.findLevelZeroTile = function(e, t, n) {
    var r = this.tilingScheme.getNumberOfXTilesAtLevel(0);
    if (t < 0 ? t += r : t >= r && (t -= r), !(n < 0 || n >= this.tilingScheme.getNumberOfYTilesAtLevel(0))) return e.filter(function(i) {
        return i.x === t && i.y === n
    })[0]
};
Mn.prototype.findTileToWest = function(e) {
    var t = this.parent;
    if (t === void 0) return this.findLevelZeroTile(e, this.x - 1, this.y);
    if (t.southeastChild === this) return t.southwestChild;
    if (t.northeastChild === this) return t.northwestChild;
    var n = t.findTileToWest(e);
    if (n !== void 0) return t.southwestChild === this ? n.southeastChild : n.northeastChild
};
Mn.prototype.findTileToEast = function(e) {
    var t = this.parent;
    if (t === void 0) return this.findLevelZeroTile(e, this.x + 1, this.y);
    if (t.southwestChild === this) return t.southeastChild;
    if (t.northwestChild === this) return t.northeastChild;
    var n = t.findTileToEast(e);
    if (n !== void 0) return t.southeastChild === this ? n.southwestChild : n.northwestChild
};
Mn.prototype.findTileToSouth = function(e) {
    var t = this.parent;
    if (t === void 0) return this.findLevelZeroTile(e, this.x, this.y + 1);
    if (t.northwestChild === this) return t.southwestChild;
    if (t.northeastChild === this) return t.southeastChild;
    var n = t.findTileToSouth(e);
    if (n !== void 0) return t.southwestChild === this ? n.northwestChild : n.northeastChild
};
Mn.prototype.findTileToNorth = function(e) {
    var t = this.parent;
    if (t === void 0) return this.findLevelZeroTile(e, this.x, this.y - 1);
    if (t.southwestChild === this) return t.northwestChild;
    if (t.southeastChild === this) return t.northeastChild;
    var n = t.findTileToNorth(e);
    if (n !== void 0) return t.northwestChild === this ? n.southwestChild : n.southeastChild
};
Mn.prototype.freeResources = function() {
    this.state = Tr.START, this.renderable = !1, this.upsampledFromParent = !1, l(this.data) && l(this.data.freeResources) && this.data.freeResources(), Uu(this._southwestChild), this._southwestChild = void 0, Uu(this._southeastChild), this._southeastChild = void 0, Uu(this._northwestChild), this._northwestChild = void 0, Uu(this._northeastChild), this._northeastChild = void 0
};

function Uu(e) {
    l(e) && e.freeResources()
}

function tf() {
    this.head = void 0, this.tail = void 0, this.count = 0, this._lastBeforeStartOfFrame = void 0
}
tf.prototype.markStartOfRenderFrame = function() {
    this._lastBeforeStartOfFrame = this.head
};
tf.prototype.trimTiles = function(e) {
    for (var t = this.tail, n = !0; n && l(this._lastBeforeStartOfFrame) && this.count > e && l(t);) {
        n = t !== this._lastBeforeStartOfFrame;
        var r = t.replacementPrevious;
        t.eligibleForUnloading && (t.freeResources(), Ny(this, t)), t = r
    }
};

function Ny(e, t) {
    var n = t.replacementPrevious,
        r = t.replacementNext;
    t === e._lastBeforeStartOfFrame && (e._lastBeforeStartOfFrame = r), t === e.head ? e.head = r : n.replacementNext = r, t === e.tail ? e.tail = n : r.replacementPrevious = n, t.replacementPrevious = void 0, t.replacementNext = void 0, --e.count
}
tf.prototype.markTileRendered = function(e) {
    var t = this.head;
    if (t === e) {
        e === this._lastBeforeStartOfFrame && (this._lastBeforeStartOfFrame = e.replacementNext);
        return
    }
    if (++this.count, !l(t)) {
        e.replacementPrevious = void 0, e.replacementNext = void 0, this.head = e, this.tail = e;
        return
    }(l(e.replacementPrevious) || l(e.replacementNext)) && Ny(this, e), e.replacementPrevious = void 0, e.replacementNext = t, t.replacementPrevious = e, this.head = e
};

function Cr(e) {
    this._tileProvider = e.tileProvider, this._tileProvider.quadtree = this, this._debug = {
        enableDebugOutput: !1,
        maxDepth: 0,
        maxDepthVisited: 0,
        tilesVisited: 0,
        tilesCulled: 0,
        tilesRendered: 0,
        tilesWaitingForChildren: 0,
        lastMaxDepth: -1,
        lastMaxDepthVisited: -1,
        lastTilesVisited: -1,
        lastTilesCulled: -1,
        lastTilesRendered: -1,
        lastTilesWaitingForChildren: -1,
        suspendLodUpdate: !1
    };
    var t = this._tileProvider.tilingScheme,
        n = t.ellipsoid;
    this._tilesToRender = [], this._tileLoadQueueHigh = [], this._tileLoadQueueMedium = [], this._tileLoadQueueLow = [], this._tileReplacementQueue = new tf, this._levelZeroTiles = void 0, this._loadQueueTimeSlice = 5, this._tilesInvalidated = !1, this._addHeightCallbacks = [], this._removeHeightCallbacks = [], this._tileToUpdateHeights = [], this._lastTileIndex = 0, this._updateHeightsTimeSlice = 2, this._cameraPositionCartographic = void 0, this._cameraReferenceFrameOriginCartographic = void 0, this.maximumScreenSpaceError = p(e.maximumScreenSpaceError, 2), this.tileCacheSize = p(e.tileCacheSize, 100), this.loadingDescendantLimit = 20, this.preloadAncestors = !0, this.preloadSiblings = !1, this._occluders = new My({
        ellipsoid: n
    }), this._tileLoadProgressEvent = new ht, this._lastTileLoadQueueLength = 0, this._lastSelectionFrameNumber = void 0
}
Object.defineProperties(Cr.prototype, {
    tileProvider: {
        get: function() {
            return this._tileProvider
        }
    },
    tileLoadProgressEvent: {
        get: function() {
            return this._tileLoadProgressEvent
        }
    },
    occluders: {
        get: function() {
            return this._occluders
        }
    }
});
Cr.prototype.invalidateAllTiles = function() {
    this._tilesInvalidated = !0
};

function SM(e) {
    var t = e._tileReplacementQueue;
    t.head = void 0, t.tail = void 0, t.count = 0, by(e);
    var n = e._levelZeroTiles;
    if (l(n))
        for (var r = 0; r < n.length; ++r) {
            for (var i = n[r], a = i.customData, o = a.length, s = 0; s < o; ++s) {
                var c = a[s];
                c.level = 0, e._addHeightCallbacks.push(c)
            }
            n[r].freeResources()
        }
    e._levelZeroTiles = void 0, e._tileProvider.cancelReprojections()
}
Cr.prototype.forEachLoadedTile = function(e) {
    for (var t = this._tileReplacementQueue.head; l(t);) t.state !== Tr.START && e(t), t = t.replacementNext
};
Cr.prototype.forEachRenderedTile = function(e) {
    for (var t = this._tilesToRender, n = 0, r = t.length; n < r; ++n) e(t[n])
};
Cr.prototype.updateHeight = function(e, t) {
    var n = this,
        r = {
            positionOnEllipsoidSurface: void 0,
            positionCartographic: e,
            level: -1,
            callback: t
        };
    return r.removeFunc = function() {
        for (var i = n._addHeightCallbacks, a = i.length, o = 0; o < a; ++o)
            if (i[o] === r) {
                i.splice(o, 1);
                break
            }
        n._removeHeightCallbacks.push(r)
    }, n._addHeightCallbacks.push(r), r.removeFunc
};
Cr.prototype.update = function(e) {
    l(this._tileProvider.update) && this._tileProvider.update(e)
};

function by(e) {
    var t = e._debug;
    t.maxDepth = 0, t.maxDepthVisited = 0, t.tilesVisited = 0, t.tilesCulled = 0, t.tilesRendered = 0, t.tilesWaitingForChildren = 0, e._tileLoadQueueHigh.length = 0, e._tileLoadQueueMedium.length = 0, e._tileLoadQueueLow.length = 0
}
Cr.prototype.beginFrame = function(e) {
    var t = e.passes;
    !t.render || (this._tilesInvalidated && (SM(this), this._tilesInvalidated = !1), this._tileProvider.initialize(e), by(this), !this._debug.suspendLodUpdate && this._tileReplacementQueue.markStartOfRenderFrame())
};
Cr.prototype.render = function(e) {
    var t = e.passes,
        n = this._tileProvider;
    t.render && (n.beginUpdate(e), PM(this, e), VM(this, e), n.endUpdate(e)), t.pick && this._tilesToRender.length > 0 && n.updateForPick(e)
};

function RM(e, t) {
    var n = e._tileLoadQueueHigh.length + e._tileLoadQueueMedium.length + e._tileLoadQueueLow.length;
    (n !== e._lastTileLoadQueueLength || e._tilesInvalidated) && (t.afterRender.push(ht.prototype.raiseEvent.bind(e._tileLoadProgressEvent, n)), e._lastTileLoadQueueLength = n);
    var r = e._debug;
    r.enableDebugOutput && !r.suspendLodUpdate && (r.maxDepth = e._tilesToRender.reduce(function(i, a) {
        return Math.max(i, a.level)
    }, -1), r.tilesRendered = e._tilesToRender.length, (r.tilesVisited !== r.lastTilesVisited || r.tilesRendered !== r.lastTilesRendered || r.tilesCulled !== r.lastTilesCulled || r.maxDepth !== r.lastMaxDepth || r.tilesWaitingForChildren !== r.lastTilesWaitingForChildren || r.maxDepthVisited !== r.lastMaxDepthVisited) && (console.log("Visited " + r.tilesVisited + ", Rendered: " + r.tilesRendered + ", Culled: " + r.tilesCulled + ", Max Depth Rendered: " + r.maxDepth + ", Max Depth Visited: " + r.maxDepthVisited + ", Waiting for children: " + r.tilesWaitingForChildren), r.lastTilesVisited = r.tilesVisited, r.lastTilesRendered = r.tilesRendered, r.lastTilesCulled = r.tilesCulled, r.lastMaxDepth = r.maxDepth, r.lastTilesWaitingForChildren = r.tilesWaitingForChildren, r.lastMaxDepthVisited = r.maxDepthVisited))
}
Cr.prototype.endFrame = function(e) {
    var t = e.passes;
    !t.render || e.mode === k.MORPHING || (LM(this, e), BM(this, e), RM(this, e))
};
Cr.prototype.isDestroyed = function() {
    return !1
};
Cr.prototype.destroy = function() {
    this._tileProvider = this._tileProvider && this._tileProvider.destroy()
};
var _s, mm = new K;

function DM(e, t) {
    var n = W.center(e.rectangle, mm),
        r = n.longitude - _s.longitude,
        i = n.latitude - _s.latitude;
    n = W.center(t.rectangle, mm);
    var a = n.longitude - _s.longitude,
        o = n.latitude - _s.latitude;
    return r * r + i * i - (a * a + o * o)
}
var IM = new u,
    is = [];

function PM(e, t) {
    var n = e._debug;
    if (!n.suspendLodUpdate) {
        var r = e._tilesToRender;
        r.length = 0;
        var i, a = e._tileProvider;
        if (!l(e._levelZeroTiles))
            if (a.ready) {
                var o = a.tilingScheme;
                e._levelZeroTiles = Mn.createLevelZeroTiles(o);
                var s = e._levelZeroTiles.length;
                if (is.length < s)
                    for (is = new Array(s), i = 0; i < s; ++i) is[i] === void 0 && (is[i] = new vs)
            } else return;
        e._occluders.ellipsoid.cameraPosition = t.camera.positionWC;
        var c, f = e._levelZeroTiles,
            h = f.length > 1 ? e._occluders : void 0;
        _s = t.camera.positionCartographic, f.sort(DM);
        var d = e._addHeightCallbacks,
            _ = e._removeHeightCallbacks,
            v = t.frameNumber,
            m;
        if (d.length > 0 || _.length > 0) {
            for (i = 0, m = f.length; i < m; ++i) c = f[i], c._updateCustomData(v, d, _);
            d.length = 0, _.length = 0
        }
        var g = t.camera;
        e._cameraPositionCartographic = g.positionCartographic;
        var y = S.getTranslation(g.transform, IM);
        for (e._cameraReferenceFrameOriginCartographic = e.tileProvider.tilingScheme.ellipsoid.cartesianToCartographic(y, e._cameraReferenceFrameOriginCartographic), i = 0, m = f.length; i < m; ++i) c = f[i], e._tileReplacementQueue.markTileRendered(c), c.renderable ? nn(e, c, a, t, h, !1, is[i]) : (Ci(e, e._tileLoadQueueHigh, c, t), ++n.tilesWaitingForChildren);
        e._lastSelectionFrameNumber = v
    }
}

function Ci(e, t, n, r) {
    !n.needsLoading || (e.tileProvider.computeTileLoadPriority !== void 0 && (n._loadPriority = e.tileProvider.computeTileLoadPriority(n, r)), t.push(n))
}

function vs() {
    this.allAreRenderable = !0, this.anyWereRenderedLastFrame = !1, this.notYetRenderableCount = 0
}

function Fy() {
    this.southwest = new vs, this.southeast = new vs, this.northwest = new vs, this.northeast = new vs
}
Fy.prototype.combine = function(e) {
    var t = this.southwest,
        n = this.southeast,
        r = this.northwest,
        i = this.northeast;
    e.allAreRenderable = t.allAreRenderable && n.allAreRenderable && r.allAreRenderable && i.allAreRenderable, e.anyWereRenderedLastFrame = t.anyWereRenderedLastFrame || n.anyWereRenderedLastFrame || r.anyWereRenderedLastFrame || i.anyWereRenderedLastFrame, e.notYetRenderableCount = t.notYetRenderableCount + n.notYetRenderableCount + r.notYetRenderableCount + i.notYetRenderableCount
};
var Il = new Array(31);
for (var wh = 0; wh < Il.length; ++wh) Il[wh] = new Fy;

function OM(e, t, n, r, i) {
    var a = e._debug;
    ++a.tilesVisited, e._tileReplacementQueue.markTileRendered(n), n._updateCustomData(t.frameNumber), n.level > a.maxDepthVisited && (a.maxDepthVisited = n.level);
    var o = bM(e, t, n) < e.maximumScreenSpaceError,
        s = n.southwestChild,
        c = n.southeastChild,
        f = n.northwestChild,
        h = n.northeastChild,
        d = e._lastSelectionFrameNumber,
        _ = n._lastSelectionResultFrame === d ? n._lastSelectionResult : Be.NONE,
        v = e.tileProvider;
    if (o || r) {
        var m = Be.originalResult(_) === Be.RENDERED,
            g = Be.originalResult(_) === Be.CULLED || _ === Be.NONE,
            y = n.state === Tr.DONE,
            E = m || g || y;
        if (E || l(v.canRenderWithoutLosingDetail) && (E = v.canRenderWithoutLosingDetail(n)), E) {
            o && Ci(e, e._tileLoadQueueMedium, n, t), zu(e, n), i.allAreRenderable = n.renderable, i.anyWereRenderedLastFrame = _ === Be.RENDERED, i.notYetRenderableCount = n.renderable ? 0 : 1, n._lastSelectionResultFrame = t.frameNumber, n._lastSelectionResult = Be.RENDERED, i.anyWereRenderedLastFrame || e._tileToUpdateHeights.push(n);
            return
        }
        r = !0, o && Ci(e, e._tileLoadQueueHigh, n, t)
    }
    if (v.canRefine(n)) {
        var w = s.upsampledFromParent && c.upsampledFromParent && f.upsampledFromParent && h.upsampledFromParent;
        if (w) {
            zu(e, n), Ci(e, e._tileLoadQueueMedium, n, t), e._tileReplacementQueue.markTileRendered(s), e._tileReplacementQueue.markTileRendered(c), e._tileReplacementQueue.markTileRendered(f), e._tileReplacementQueue.markTileRendered(h), i.allAreRenderable = n.renderable, i.anyWereRenderedLastFrame = _ === Be.RENDERED, i.notYetRenderableCount = n.renderable ? 0 : 1, n._lastSelectionResultFrame = t.frameNumber, n._lastSelectionResult = Be.RENDERED, i.anyWereRenderedLastFrame || e._tileToUpdateHeights.push(n);
            return
        }
        n._lastSelectionResultFrame = t.frameNumber, n._lastSelectionResult = Be.REFINED;
        var C = e._tilesToRender.length,
            A = e._tileLoadQueueLow.length,
            x = e._tileLoadQueueMedium.length,
            P = e._tileLoadQueueHigh.length,
            I = e._tileToUpdateHeights.length;
        if (MM(e, s, c, f, h, t, r, i), C !== e._tilesToRender.length) {
            var D = i.allAreRenderable,
                O = i.anyWereRenderedLastFrame,
                F = i.notYetRenderableCount,
                z = !1;
            if (!D && !O) {
                for (var b = e._tilesToRender, M = C; M < b.length; ++M)
                    for (var G = b[M]; G !== void 0 && G._lastSelectionResult !== Be.KICKED && G !== n;) G._lastSelectionResult = Be.kick(G._lastSelectionResult), G = G.parent;
                e._tilesToRender.length = C, e._tileToUpdateHeights.length = I, zu(e, n), n._lastSelectionResult = Be.RENDERED;
                var V = _ === Be.RENDERED;
                !V && F > e.loadingDescendantLimit && (e._tileLoadQueueLow.length = A, e._tileLoadQueueMedium.length = x, e._tileLoadQueueHigh.length = P, Ci(e, e._tileLoadQueueMedium, n, t), i.notYetRenderableCount = n.renderable ? 0 : 1, z = !0), i.allAreRenderable = n.renderable, i.anyWereRenderedLastFrame = V, V || e._tileToUpdateHeights.push(n), ++a.tilesWaitingForChildren
            }
            e.preloadAncestors && !z && Ci(e, e._tileLoadQueueLow, n, t)
        }
        return
    }
    n._lastSelectionResultFrame = t.frameNumber, n._lastSelectionResult = Be.RENDERED, zu(e, n), Ci(e, e._tileLoadQueueHigh, n, t), i.allAreRenderable = n.renderable, i.anyWereRenderedLastFrame = _ === Be.RENDERED, i.notYetRenderableCount = n.renderable ? 0 : 1
}

function MM(e, t, n, r, i, a, o, s) {
    var c = a.camera.positionCartographic,
        f = e._tileProvider,
        h = e._occluders,
        d = Il[t.level],
        _ = d.southwest,
        v = d.southeast,
        m = d.northwest,
        g = d.northeast;
    c.longitude < t.rectangle.east ? c.latitude < t.rectangle.north ? (nn(e, t, f, a, h, o, _), nn(e, n, f, a, h, o, v), nn(e, r, f, a, h, o, m), nn(e, i, f, a, h, o, g)) : (nn(e, r, f, a, h, o, m), nn(e, t, f, a, h, o, _), nn(e, i, f, a, h, o, g), nn(e, n, f, a, h, o, v)) : c.latitude < t.rectangle.north ? (nn(e, n, f, a, h, o, v), nn(e, t, f, a, h, o, _), nn(e, i, f, a, h, o, g), nn(e, r, f, a, h, o, m)) : (nn(e, i, f, a, h, o, g), nn(e, r, f, a, h, o, m), nn(e, n, f, a, h, o, v), nn(e, t, f, a, h, o, _)), d.combine(s)
}

function NM(e, t) {
    var n = t.rectangle;
    return l(e._cameraPositionCartographic) && W.contains(n, e._cameraPositionCartographic) || l(e._cameraReferenceFrameOriginCartographic) && W.contains(n, e._cameraReferenceFrameOriginCartographic)
}

function nn(e, t, n, r, i, a, o) {
    if (n.computeTileVisibility(t, r, i) !== qt.NONE) return OM(e, r, t, a, o);
    if (++e._debug.tilesCulled, e._tileReplacementQueue.markTileRendered(t), o.allAreRenderable = !0, o.anyWereRenderedLastFrame = !1, o.notYetRenderableCount = 0, NM(e, t)) {
        (!l(t.data) || !l(t.data.vertexArray)) && Ci(e, e._tileLoadQueueMedium, t, r);
        var s = e._lastSelectionFrameNumber,
            c = t._lastSelectionResultFrame === s ? t._lastSelectionResult : Be.NONE;
        c !== Be.CULLED_BUT_NEEDED && c !== Be.RENDERED && e._tileToUpdateHeights.push(t), t._lastSelectionResult = Be.CULLED_BUT_NEEDED
    } else(e.preloadSiblings || t.level === 0) && Ci(e, e._tileLoadQueueLow, t, r), t._lastSelectionResult = Be.CULLED;
    t._lastSelectionResultFrame = r.frameNumber
}

function bM(e, t, n) {
    if (t.mode === k.SCENE2D || t.camera.frustum instanceof lt || t.camera.frustum instanceof Wn) return FM(e, t, n);
    var r = e._tileProvider.getLevelMaximumGeometricError(n.level),
        i = n._distance,
        a = t.context.drawingBufferHeight,
        o = t.camera.frustum.sseDenominator,
        s = r * a / (i * o);
    return t.fog.enabled && (s -= T.fog(i, t.fog.density) * t.fog.sse), s /= t.pixelRatio, s
}

function FM(e, t, n) {
    var r = t.camera,
        i = r.frustum;
    l(i._offCenterFrustum) && (i = i._offCenterFrustum);
    var a = t.context,
        o = a.drawingBufferWidth,
        s = a.drawingBufferHeight,
        c = e._tileProvider.getLevelMaximumGeometricError(n.level),
        f = Math.max(i.top - i.bottom, i.right - i.left) / Math.max(o, s),
        h = c / f;
    return t.fog.enabled && t.mode !== k.SCENE2D && (h -= T.fog(n._distance, t.fog.density) * t.fog.sse), h /= t.pixelRatio, h
}

function zu(e, t) {
    e._tilesToRender.push(t)
}

function LM(e, t) {
    var n = e._tileLoadQueueHigh,
        r = e._tileLoadQueueMedium,
        i = e._tileLoadQueueLow;
    if (!(n.length === 0 && r.length === 0 && i.length === 0)) {
        e._tileReplacementQueue.trimTiles(e.tileCacheSize);
        var a = bn() + e._loadQueueTimeSlice,
            o = e._tileProvider,
            s = xh(e, t, o, a, n, !1);
        s = xh(e, t, o, a, r, s), xh(e, t, o, a, i, s)
    }
}

function UM(e, t) {
    return e._loadPriority - t._loadPriority
}

function xh(e, t, n, r, i, a) {
    n.computeTileLoadPriority !== void 0 && i.sort(UM);
    for (var o = 0, s = i.length; o < s && (bn() < r || !a); ++o) {
        var c = i[o];
        e._tileReplacementQueue.markTileRendered(c), n.loadTile(t, c), a = !0
    }
    return a
}
var co = new Ke,
    Sh = new K,
    Gi = new u,
    zM = [];

function BM(e, t) {
    if (!!e.tileProvider.ready) {
        var n = zM;
        n.length = 0;
        for (var r = e._tileToUpdateHeights, i = e._tileProvider.terrainProvider, a = bn(), o = e._updateHeightsTimeSlice, s = a + o, c = t.mode, f = t.mapProjection, h = e.tileProvider.tilingScheme.ellipsoid, d; r.length > 0;) {
            var _ = r[0];
            if (!l(_.data) || !l(_.data.mesh)) {
                var v = _._lastSelectionResultFrame === e._lastSelectionFrameNumber ? _._lastSelectionResult : Be.NONE;
                (v === Be.RENDERED || v === Be.CULLED_BUT_NEEDED) && n.push(_), r.shift(), e._lastTileIndex = 0;
                continue
            }
            var m = _.customData,
                g = m.length,
                y = !1;
            for (d = e._lastTileIndex; d < g; ++d) {
                var E = m[d];
                if (_.level > E.level) {
                    if (l(E.positionOnEllipsoidSurface) || (E.positionOnEllipsoidSurface = u.fromRadians(E.positionCartographic.longitude, E.positionCartographic.latitude, 0, h)), c === k.SCENE3D) {
                        var w = h.geodeticSurfaceNormal(E.positionOnEllipsoidSurface, co.direction),
                            C = h.getSurfaceNormalIntersectionWithZAxis(E.positionOnEllipsoidSurface, 11500, co.origin);
                        if (!l(C)) {
                            var A;
                            l(_.data.tileBoundingRegion) && (A = _.data.tileBoundingRegion.minimumHeight);
                            var x = Math.min(p(A, 0), -11500),
                                P = u.multiplyByScalar(w, Math.abs(x) + 1, Gi);
                            u.subtract(E.positionOnEllipsoidSurface, P, co.origin)
                        }
                    } else K.clone(E.positionCartographic, Sh), Sh.height = -11500, f.project(Sh, Gi), u.fromElements(Gi.z, Gi.x, Gi.y, Gi), u.clone(Gi, co.origin), u.clone(u.UNIT_X, co.direction);
                    var I = _.data.pick(co, c, f, !1, Gi);
                    l(I) && (E.callback(I), E.level = _.level)
                } else if (_.level === E.level) {
                    for (var D = _.children, O = D.length, F, z = 0; z < O && (F = D[z], !W.contains(F.rectangle, E.positionCartographic)); ++z);
                    var b = i.getTileDataAvailable(F.x, F.y, F.level),
                        M = _.parent;
                    (l(b) && !b || l(M) && l(M.data) && l(M.data.terrainData) && !M.data.terrainData.isChildAvailable(M.x, M.y, F.x, F.y)) && E.removeFunc()
                }
                if (bn() >= s) {
                    y = !0;
                    break
                }
            }
            if (y) {
                e._lastTileIndex = d;
                break
            } else e._lastTileIndex = 0, r.shift()
        }
        for (d = 0; d < n.length; d++) r.push(n[d])
    }
}

function VM(e, t) {
    for (var n = e._tileProvider, r = e._tilesToRender, i = 0, a = r.length; i < a; ++i) {
        var o = r[i];
        n.showTileThisFrame(o, t)
    }
}

function hi(e) {
    e = p(e, ne.WGS84);
    var t = new No({
            ellipsoid: e
        }),
        n = new Zt;
    this._ellipsoid = e, this._imageryLayerCollection = n, this._surfaceShaderSet = new Sd, this._material = void 0, this._surface = new Cr({
        tileProvider: new At({
            terrainProvider: t,
            imageryLayers: n,
            surfaceShaderSet: this._surfaceShaderSet
        })
    }), this._terrainProvider = t, this._terrainProviderChanged = new ht, this._undergroundColor = H.clone(H.BLACK), this._undergroundColorAlphaByDistance = new at(e.maximumRadius / 1e3, 0, e.maximumRadius / 5, 1), this._translucency = new Py, Pl(this), this.show = !0, this._oceanNormalMapResourceDirty = !0, this._oceanNormalMapResource = new J({
        url: Hn("Assets/Textures/waterNormalsSmall.jpg")
    }), this.maximumScreenSpaceError = 2, this.tileCacheSize = 100, this.loadingDescendantLimit = 20, this.preloadAncestors = !0, this.preloadSiblings = !1, this.fillHighlightColor = void 0, this.enableLighting = !1, this.dynamicAtmosphereLighting = !0, this.dynamicAtmosphereLightingFromSun = !1, this.showGroundAtmosphere = !0, this.lightingFadeOutDistance = 1e7, this.lightingFadeInDistance = 2e7, this.nightFadeOutDistance = 1e7, this.nightFadeInDistance = 5e7, this.showWaterEffect = !0, this.depthTestAgainstTerrain = !1, this.shadows = Ma.RECEIVE_ONLY, this.atmosphereHueShift = 0, this.atmosphereSaturationShift = 0, this.atmosphereBrightnessShift = 0, this.showSkirts = !0, this.backFaceCulling = !0, this._oceanNormalMap = void 0, this._zoomedOutOceanSpecularIntensity = void 0
}
Object.defineProperties(hi.prototype, {
    ellipsoid: {
        get: function() {
            return this._ellipsoid
        }
    },
    imageryLayers: {
        get: function() {
            return this._imageryLayerCollection
        }
    },
    imageryLayersUpdatedEvent: {
        get: function() {
            return this._surface.tileProvider.imageryLayersUpdatedEvent
        }
    },
    tilesLoaded: {
        get: function() {
            return l(this._surface) ? this._surface.tileProvider.ready && this._surface._tileLoadQueueHigh.length === 0 && this._surface._tileLoadQueueMedium.length === 0 && this._surface._tileLoadQueueLow.length === 0 : !0
        }
    },
    baseColor: {
        get: function() {
            return this._surface.tileProvider.baseColor
        },
        set: function(e) {
            this._surface.tileProvider.baseColor = e
        }
    },
    clippingPlanes: {
        get: function() {
            return this._surface.tileProvider.clippingPlanes
        },
        set: function(e) {
            this._surface.tileProvider.clippingPlanes = e
        }
    },
    cartographicLimitRectangle: {
        get: function() {
            return this._surface.tileProvider.cartographicLimitRectangle
        },
        set: function(e) {
            l(e) || (e = W.clone(W.MAX_VALUE)), this._surface.tileProvider.cartographicLimitRectangle = e
        }
    },
    oceanNormalMapUrl: {
        get: function() {
            return this._oceanNormalMapResource.url
        },
        set: function(e) {
            this._oceanNormalMapResource.url = e, this._oceanNormalMapResourceDirty = !0
        }
    },
    terrainProvider: {
        get: function() {
            return this._terrainProvider
        },
        set: function(e) {
            e !== this._terrainProvider && (this._terrainProvider = e, this._terrainProviderChanged.raiseEvent(e), l(this._material) && Pl(this))
        }
    },
    terrainProviderChanged: {
        get: function() {
            return this._terrainProviderChanged
        }
    },
    tileLoadProgressEvent: {
        get: function() {
            return this._surface.tileLoadProgressEvent
        }
    },
    material: {
        get: function() {
            return this._material
        },
        set: function(e) {
            this._material !== e && (this._material = e, Pl(this))
        }
    },
    undergroundColor: {
        get: function() {
            return this._undergroundColor
        },
        set: function(e) {
            this._undergroundColor = H.clone(e, this._undergroundColor)
        }
    },
    undergroundColorAlphaByDistance: {
        get: function() {
            return this._undergroundColorAlphaByDistance
        },
        set: function(e) {
            this._undergroundColorAlphaByDistance = at.clone(e, this._undergroundColorAlphaByDistance)
        }
    },
    translucency: {
        get: function() {
            return this._translucency
        }
    }
});

function Pl(e) {
    var t = [],
        n = l(e._material) && (e._material.shaderSource.match(/slope/) || e._material.shaderSource.match("normalEC")),
        r = [mv];
    l(e._material) && (!n || e._terrainProvider.requestVertexNormals) ? (r.push(e._material.shaderSource), t.push("APPLY_MATERIAL"), e._surface._tileProvider.materialUniformMap = e._material._uniforms) : e._surface._tileProvider.materialUniformMap = void 0, r.push(RD), e._surfaceShaderSet.baseVertexShaderSource = new Re({
        sources: [mv, DD],
        defines: t
    }), e._surfaceShaderSet.baseFragmentShaderSource = new Re({
        sources: r,
        defines: t
    }), e._surfaceShaderSet.material = e._material
}

function GM(e) {
    return function(t, n) {
        var r = q.distanceSquaredTo(t.pickBoundingSphere, e),
            i = q.distanceSquaredTo(n.pickBoundingSphere, e);
        return r - i
    }
}
var HM = [],
    kM = {
        start: 0,
        stop: 0
    };
hi.prototype.pickWorldCoordinates = function(e, t, n, r) {
    n = p(n, !0);
    var i = t.mode,
        a = t.mapProjection,
        o = HM;
    o.length = 0;
    var s = this._surface._tilesToRender,
        c = s.length,
        f, h;
    for (h = 0; h < c; ++h) {
        f = s[h];
        var d = f.data;
        if (!!l(d)) {
            var _ = d.pickBoundingSphere;
            if (i !== k.SCENE3D) d.pickBoundingSphere = _ = q.fromRectangleWithHeights2D(f.rectangle, a, d.tileBoundingRegion.minimumHeight, d.tileBoundingRegion.maximumHeight, _), u.fromElements(_.center.z, _.center.x, _.center.y, _.center);
            else if (l(d.renderedMesh)) q.clone(d.renderedMesh.boundingSphere3D, _);
            else continue;
            var v = Me.raySphere(e, _, kM);
            l(v) && o.push(d)
        }
    }
    o.sort(GM(e.origin));
    var m;
    for (c = o.length, h = 0; h < c && (m = o[h].pick(e, t.mode, t.mapProjection, n, r), !l(m)); ++h);
    return m
};
var WM = new K;
hi.prototype.pick = function(e, t, n) {
    if (n = this.pickWorldCoordinates(e, t, !0, n), l(n) && t.mode !== k.SCENE3D) {
        n = u.fromElements(n.y, n.z, n.x, n);
        var r = t.mapProjection.unproject(n, WM);
        n = t.globe.ellipsoid.cartographicToCartesian(r, n)
    }
    return n
};
var qM = new u,
    pm = new u,
    YM = new K,
    XM = new Ke;

function Rh(e, t) {
    return l(e) && W.contains(e.rectangle, t) ? e : void 0
}
hi.prototype.getHeight = function(e) {
    var t = this._surface._levelZeroTiles;
    if (!!l(t)) {
        var n, r, i = t.length;
        for (r = 0; r < i && (n = t[r], !W.contains(n.rectangle, e)); ++r);
        if (!(r >= i)) {
            for (var a = n; l(n);) n = Rh(n._southwestChild, e) || Rh(n._southeastChild, e) || Rh(n._northwestChild, e) || n._northeastChild, l(n) && l(n.data) && l(n.data.renderedMesh) && (a = n);
            if (n = a, !(!l(n) || !l(n.data) || !l(n.data.renderedMesh))) {
                var o = this._surface._tileProvider.tilingScheme.ellipsoid,
                    s = u.fromRadians(e.longitude, e.latitude, 0, o, qM),
                    c = XM,
                    f = o.geodeticSurfaceNormal(s, c.direction),
                    h = o.getSurfaceNormalIntersectionWithZAxis(s, 11500, c.origin);
                if (!l(h)) {
                    var d;
                    l(n.data.tileBoundingRegion) && (d = n.data.tileBoundingRegion.minimumHeight);
                    var _ = Math.min(p(d, 0), -11500),
                        v = u.multiplyByScalar(f, Math.abs(_) + 1, pm);
                    u.subtract(s, v, c.origin)
                }
                var m = n.data.pick(c, void 0, void 0, !1, pm);
                if (!!l(m)) return o.cartesianToCartographic(m, YM).height
            }
        }
    }
};
hi.prototype.update = function(e) {
    !this.show || e.passes.render && this._surface.update(e)
};
hi.prototype.beginFrame = function(e) {
    var t = this._surface,
        n = t.tileProvider,
        r = this.terrainProvider,
        i = this.showWaterEffect && r.ready && r.hasWaterMask;
    if (i && this._oceanNormalMapResourceDirty) {
        this._oceanNormalMapResourceDirty = !1;
        var a = this._oceanNormalMapResource,
            o = a.url;
        if (l(o)) {
            var s = this;
            he(a.fetchImage(), function(h) {
                o === s._oceanNormalMapResource.url && (s._oceanNormalMap = s._oceanNormalMap && s._oceanNormalMap.destroy(), s._oceanNormalMap = new be({
                    context: e.context,
                    source: h
                }))
            })
        } else this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy()
    }
    var c = e.passes,
        f = e.mode;
    c.render && (this.showGroundAtmosphere ? this._zoomedOutOceanSpecularIntensity = .4 : this._zoomedOutOceanSpecularIntensity = .5, t.maximumScreenSpaceError = this.maximumScreenSpaceError, t.tileCacheSize = this.tileCacheSize, t.loadingDescendantLimit = this.loadingDescendantLimit, t.preloadAncestors = this.preloadAncestors, t.preloadSiblings = this.preloadSiblings, n.terrainProvider = this.terrainProvider, n.lightingFadeOutDistance = this.lightingFadeOutDistance, n.lightingFadeInDistance = this.lightingFadeInDistance, n.nightFadeOutDistance = this.nightFadeOutDistance, n.nightFadeInDistance = this.nightFadeInDistance, n.zoomedOutOceanSpecularIntensity = f === k.SCENE3D ? this._zoomedOutOceanSpecularIntensity : 0, n.hasWaterMask = i, n.oceanNormalMap = this._oceanNormalMap, n.enableLighting = this.enableLighting, n.dynamicAtmosphereLighting = this.dynamicAtmosphereLighting, n.dynamicAtmosphereLightingFromSun = this.dynamicAtmosphereLightingFromSun, n.showGroundAtmosphere = this.showGroundAtmosphere, n.shadows = this.shadows, n.hueShift = this.atmosphereHueShift, n.saturationShift = this.atmosphereSaturationShift, n.brightnessShift = this.atmosphereBrightnessShift, n.fillHighlightColor = this.fillHighlightColor, n.showSkirts = this.showSkirts, n.backFaceCulling = this.backFaceCulling, n.undergroundColor = this._undergroundColor, n.undergroundColorAlphaByDistance = this._undergroundColorAlphaByDistance, t.beginFrame(e))
};
hi.prototype.render = function(e) {
    !this.show || (l(this._material) && this._material.update(e.context), this._surface.render(e))
};
hi.prototype.endFrame = function(e) {
    !this.show || e.passes.render && this._surface.endFrame(e)
};
hi.prototype.isDestroyed = function() {
    return !1
};
hi.prototype.destroy = function() {
    return this._surfaceShaderSet = this._surfaceShaderSet && this._surfaceShaderSet.destroy(), this._surface = this._surface && this._surface.destroy(), this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy(), Pe(this)
};
var jM = new u;

function kn(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.minimum,
        n = e.maximum,
        r = p(e.vertexFormat, Le.DEFAULT);
    this._minimum = u.clone(t), this._maximum = u.clone(n), this._vertexFormat = r, this._offsetAttribute = e.offsetAttribute, this._workerName = "createBoxGeometry"
}
kn.fromDimensions = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.dimensions,
        n = u.multiplyByScalar(t, .5, new u);
    return new kn({
        minimum: u.negate(n, new u),
        maximum: n,
        vertexFormat: e.vertexFormat,
        offsetAttribute: e.offsetAttribute
    })
};
kn.fromAxisAlignedBoundingBox = function(e) {
    return new kn({
        minimum: e.minimum,
        maximum: e.maximum
    })
};
kn.packedLength = 2 * u.packedLength + Le.packedLength + 1;
kn.pack = function(e, t, n) {
    return n = p(n, 0), u.pack(e._minimum, t, n), u.pack(e._maximum, t, n + u.packedLength), Le.pack(e._vertexFormat, t, n + 2 * u.packedLength), t[n + 2 * u.packedLength + Le.packedLength] = p(e._offsetAttribute, -1), t
};
var Ly = new u,
    Uy = new u,
    zy = new Le,
    gm = {
        minimum: Ly,
        maximum: Uy,
        vertexFormat: zy,
        offsetAttribute: void 0
    };
kn.unpack = function(e, t, n) {
    t = p(t, 0);
    var r = u.unpack(e, t, Ly),
        i = u.unpack(e, t + u.packedLength, Uy),
        a = Le.unpack(e, t + 2 * u.packedLength, zy),
        o = e[t + 2 * u.packedLength + Le.packedLength];
    return l(n) ? (n._minimum = u.clone(r, n._minimum), n._maximum = u.clone(i, n._maximum), n._vertexFormat = Le.clone(a, n._vertexFormat), n._offsetAttribute = o === -1 ? void 0 : o, n) : (gm.offsetAttribute = o === -1 ? void 0 : o, new kn(gm))
};
kn.createGeometry = function(e) {
    var t = e._minimum,
        n = e._maximum,
        r = e._vertexFormat;
    if (!u.equals(t, n)) {
        var i = new Va,
            a, o;
        if (r.position && (r.st || r.normal || r.tangent || r.bitangent)) {
            if (r.position && (o = new Float64Array(6 * 4 * 3), o[0] = t.x, o[1] = t.y, o[2] = n.z, o[3] = n.x, o[4] = t.y, o[5] = n.z, o[6] = n.x, o[7] = n.y, o[8] = n.z, o[9] = t.x, o[10] = n.y, o[11] = n.z, o[12] = t.x, o[13] = t.y, o[14] = t.z, o[15] = n.x, o[16] = t.y, o[17] = t.z, o[18] = n.x, o[19] = n.y, o[20] = t.z, o[21] = t.x, o[22] = n.y, o[23] = t.z, o[24] = n.x, o[25] = t.y, o[26] = t.z, o[27] = n.x, o[28] = n.y, o[29] = t.z, o[30] = n.x, o[31] = n.y, o[32] = n.z, o[33] = n.x, o[34] = t.y, o[35] = n.z, o[36] = t.x, o[37] = t.y, o[38] = t.z, o[39] = t.x, o[40] = n.y, o[41] = t.z, o[42] = t.x, o[43] = n.y, o[44] = n.z, o[45] = t.x, o[46] = t.y, o[47] = n.z, o[48] = t.x, o[49] = n.y, o[50] = t.z, o[51] = n.x, o[52] = n.y, o[53] = t.z, o[54] = n.x, o[55] = n.y, o[56] = n.z, o[57] = t.x, o[58] = n.y, o[59] = n.z, o[60] = t.x, o[61] = t.y, o[62] = t.z, o[63] = n.x, o[64] = t.y, o[65] = t.z, o[66] = n.x, o[67] = t.y, o[68] = n.z, o[69] = t.x, o[70] = t.y, o[71] = n.z, i.position = new ze({
                    componentDatatype: ee.DOUBLE,
                    componentsPerAttribute: 3,
                    values: o
                })), r.normal) {
                var s = new Float32Array(72);
                s[0] = 0, s[1] = 0, s[2] = 1, s[3] = 0, s[4] = 0, s[5] = 1, s[6] = 0, s[7] = 0, s[8] = 1, s[9] = 0, s[10] = 0, s[11] = 1, s[12] = 0, s[13] = 0, s[14] = -1, s[15] = 0, s[16] = 0, s[17] = -1, s[18] = 0, s[19] = 0, s[20] = -1, s[21] = 0, s[22] = 0, s[23] = -1, s[24] = 1, s[25] = 0, s[26] = 0, s[27] = 1, s[28] = 0, s[29] = 0, s[30] = 1, s[31] = 0, s[32] = 0, s[33] = 1, s[34] = 0, s[35] = 0, s[36] = -1, s[37] = 0, s[38] = 0, s[39] = -1, s[40] = 0, s[41] = 0, s[42] = -1, s[43] = 0, s[44] = 0, s[45] = -1, s[46] = 0, s[47] = 0, s[48] = 0, s[49] = 1, s[50] = 0, s[51] = 0, s[52] = 1, s[53] = 0, s[54] = 0, s[55] = 1, s[56] = 0, s[57] = 0, s[58] = 1, s[59] = 0, s[60] = 0, s[61] = -1, s[62] = 0, s[63] = 0, s[64] = -1, s[65] = 0, s[66] = 0, s[67] = -1, s[68] = 0, s[69] = 0, s[70] = -1, s[71] = 0, i.normal = new ze({
                    componentDatatype: ee.FLOAT,
                    componentsPerAttribute: 3,
                    values: s
                })
            }
            if (r.st) {
                var c = new Float32Array(48);
                c[0] = 0, c[1] = 0, c[2] = 1, c[3] = 0, c[4] = 1, c[5] = 1, c[6] = 0, c[7] = 1, c[8] = 1, c[9] = 0, c[10] = 0, c[11] = 0, c[12] = 0, c[13] = 1, c[14] = 1, c[15] = 1, c[16] = 0, c[17] = 0, c[18] = 1, c[19] = 0, c[20] = 1, c[21] = 1, c[22] = 0, c[23] = 1, c[24] = 1, c[25] = 0, c[26] = 0, c[27] = 0, c[28] = 0, c[29] = 1, c[30] = 1, c[31] = 1, c[32] = 1, c[33] = 0, c[34] = 0, c[35] = 0, c[36] = 0, c[37] = 1, c[38] = 1, c[39] = 1, c[40] = 0, c[41] = 0, c[42] = 1, c[43] = 0, c[44] = 1, c[45] = 1, c[46] = 0, c[47] = 1, i.st = new ze({
                    componentDatatype: ee.FLOAT,
                    componentsPerAttribute: 2,
                    values: c
                })
            }
            if (r.tangent) {
                var f = new Float32Array(72);
                f[0] = 1, f[1] = 0, f[2] = 0, f[3] = 1, f[4] = 0, f[5] = 0, f[6] = 1, f[7] = 0, f[8] = 0, f[9] = 1, f[10] = 0, f[11] = 0, f[12] = -1, f[13] = 0, f[14] = 0, f[15] = -1, f[16] = 0, f[17] = 0, f[18] = -1, f[19] = 0, f[20] = 0, f[21] = -1, f[22] = 0, f[23] = 0, f[24] = 0, f[25] = 1, f[26] = 0, f[27] = 0, f[28] = 1, f[29] = 0, f[30] = 0, f[31] = 1, f[32] = 0, f[33] = 0, f[34] = 1, f[35] = 0, f[36] = 0, f[37] = -1, f[38] = 0, f[39] = 0, f[40] = -1, f[41] = 0, f[42] = 0, f[43] = -1, f[44] = 0, f[45] = 0, f[46] = -1, f[47] = 0, f[48] = -1, f[49] = 0, f[50] = 0, f[51] = -1, f[52] = 0, f[53] = 0, f[54] = -1, f[55] = 0, f[56] = 0, f[57] = -1, f[58] = 0, f[59] = 0, f[60] = 1, f[61] = 0, f[62] = 0, f[63] = 1, f[64] = 0, f[65] = 0, f[66] = 1, f[67] = 0, f[68] = 0, f[69] = 1, f[70] = 0, f[71] = 0, i.tangent = new ze({
                    componentDatatype: ee.FLOAT,
                    componentsPerAttribute: 3,
                    values: f
                })
            }
            if (r.bitangent) {
                var h = new Float32Array(72);
                h[0] = 0, h[1] = 1, h[2] = 0, h[3] = 0, h[4] = 1, h[5] = 0, h[6] = 0, h[7] = 1, h[8] = 0, h[9] = 0, h[10] = 1, h[11] = 0, h[12] = 0, h[13] = 1, h[14] = 0, h[15] = 0, h[16] = 1, h[17] = 0, h[18] = 0, h[19] = 1, h[20] = 0, h[21] = 0, h[22] = 1, h[23] = 0, h[24] = 0, h[25] = 0, h[26] = 1, h[27] = 0, h[28] = 0, h[29] = 1, h[30] = 0, h[31] = 0, h[32] = 1, h[33] = 0, h[34] = 0, h[35] = 1, h[36] = 0, h[37] = 0, h[38] = 1, h[39] = 0, h[40] = 0, h[41] = 1, h[42] = 0, h[43] = 0, h[44] = 1, h[45] = 0, h[46] = 0, h[47] = 1, h[48] = 0, h[49] = 0, h[50] = 1, h[51] = 0, h[52] = 0, h[53] = 1, h[54] = 0, h[55] = 0, h[56] = 1, h[57] = 0, h[58] = 0, h[59] = 1, h[60] = 0, h[61] = 0, h[62] = 1, h[63] = 0, h[64] = 0, h[65] = 1, h[66] = 0, h[67] = 0, h[68] = 1, h[69] = 0, h[70] = 0, h[71] = 1, i.bitangent = new ze({
                    componentDatatype: ee.FLOAT,
                    componentsPerAttribute: 3,
                    values: h
                })
            }
            a = new Uint16Array(6 * 2 * 3), a[0] = 0, a[1] = 1, a[2] = 2, a[3] = 0, a[4] = 2, a[5] = 3, a[6] = 4 + 2, a[7] = 4 + 1, a[8] = 4 + 0, a[9] = 4 + 3, a[10] = 4 + 2, a[11] = 4 + 0, a[12] = 8 + 0, a[13] = 8 + 1, a[14] = 8 + 2, a[15] = 8 + 0, a[16] = 8 + 2, a[17] = 8 + 3, a[18] = 12 + 2, a[19] = 12 + 1, a[20] = 12 + 0, a[21] = 12 + 3, a[22] = 12 + 2, a[23] = 12 + 0, a[24] = 16 + 2, a[25] = 16 + 1, a[26] = 16 + 0, a[27] = 16 + 3, a[28] = 16 + 2, a[29] = 16 + 0, a[30] = 20 + 0, a[31] = 20 + 1, a[32] = 20 + 2, a[33] = 20 + 0, a[34] = 20 + 2, a[35] = 20 + 3
        } else o = new Float64Array(8 * 3), o[0] = t.x, o[1] = t.y, o[2] = t.z, o[3] = n.x, o[4] = t.y, o[5] = t.z, o[6] = n.x, o[7] = n.y, o[8] = t.z, o[9] = t.x, o[10] = n.y, o[11] = t.z, o[12] = t.x, o[13] = t.y, o[14] = n.z, o[15] = n.x, o[16] = t.y, o[17] = n.z, o[18] = n.x, o[19] = n.y, o[20] = n.z, o[21] = t.x, o[22] = n.y, o[23] = n.z, i.position = new ze({
            componentDatatype: ee.DOUBLE,
            componentsPerAttribute: 3,
            values: o
        }), a = new Uint16Array(6 * 2 * 3), a[0] = 4, a[1] = 5, a[2] = 6, a[3] = 4, a[4] = 6, a[5] = 7, a[6] = 1, a[7] = 0, a[8] = 3, a[9] = 1, a[10] = 3, a[11] = 2, a[12] = 1, a[13] = 6, a[14] = 5, a[15] = 1, a[16] = 2, a[17] = 6, a[18] = 2, a[19] = 3, a[20] = 7, a[21] = 2, a[22] = 7, a[23] = 6, a[24] = 3, a[25] = 0, a[26] = 4, a[27] = 3, a[28] = 4, a[29] = 7, a[30] = 0, a[31] = 1, a[32] = 5, a[33] = 0, a[34] = 5, a[35] = 4;
        var d = u.subtract(n, t, jM),
            _ = u.magnitude(d) * .5;
        if (l(e._offsetAttribute)) {
            var v = o.length,
                m = new Uint8Array(v / 3),
                g = e._offsetAttribute === Di.NONE ? 0 : 1;
            Ri(m, g), i.applyOffset = new ze({
                componentDatatype: ee.UNSIGNED_BYTE,
                componentsPerAttribute: 1,
                values: m
            })
        }
        return new rt({
            attributes: i,
            indices: a,
            primitiveType: Ve.TRIANGLES,
            boundingSphere: new q(u.ZERO, _),
            offsetAttribute: e._offsetAttribute
        })
    }
};
var Dh;
kn.getUnitBox = function() {
    return l(Dh) || (Dh = kn.createGeometry(kn.fromDimensions({
        dimensions: new u(1, 1, 1),
        vertexFormat: Le.POSITION_ONLY
    }))), Dh
};
var ZM = new u,
    KM = new u,
    $M = new u,
    JM = new u,
    QM = new u,
    eN = new u(1, 1, 1),
    ym = Math.cos,
    Tm = Math.sin;

function ri(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = p(e.radii, eN),
        n = p(e.innerRadii, t),
        r = p(e.minimumClock, 0),
        i = p(e.maximumClock, T.TWO_PI),
        a = p(e.minimumCone, 0),
        o = p(e.maximumCone, T.PI),
        s = Math.round(p(e.stackPartitions, 64)),
        c = Math.round(p(e.slicePartitions, 64)),
        f = p(e.vertexFormat, Le.DEFAULT);
    this._radii = u.clone(t), this._innerRadii = u.clone(n), this._minimumClock = r, this._maximumClock = i, this._minimumCone = a, this._maximumCone = o, this._stackPartitions = s, this._slicePartitions = c, this._vertexFormat = Le.clone(f), this._offsetAttribute = e.offsetAttribute, this._workerName = "createEllipsoidGeometry"
}
ri.packedLength = 2 * u.packedLength + Le.packedLength + 7;
ri.pack = function(e, t, n) {
    return n = p(n, 0), u.pack(e._radii, t, n), n += u.packedLength, u.pack(e._innerRadii, t, n), n += u.packedLength, Le.pack(e._vertexFormat, t, n), n += Le.packedLength, t[n++] = e._minimumClock, t[n++] = e._maximumClock, t[n++] = e._minimumCone, t[n++] = e._maximumCone, t[n++] = e._stackPartitions, t[n++] = e._slicePartitions, t[n] = p(e._offsetAttribute, -1), t
};
var By = new u,
    Vy = new u,
    Gy = new Le,
    Hi = {
        radii: By,
        innerRadii: Vy,
        vertexFormat: Gy,
        minimumClock: void 0,
        maximumClock: void 0,
        minimumCone: void 0,
        maximumCone: void 0,
        stackPartitions: void 0,
        slicePartitions: void 0,
        offsetAttribute: void 0
    };
ri.unpack = function(e, t, n) {
    t = p(t, 0);
    var r = u.unpack(e, t, By);
    t += u.packedLength;
    var i = u.unpack(e, t, Vy);
    t += u.packedLength;
    var a = Le.unpack(e, t, Gy);
    t += Le.packedLength;
    var o = e[t++],
        s = e[t++],
        c = e[t++],
        f = e[t++],
        h = e[t++],
        d = e[t++],
        _ = e[t];
    return l(n) ? (n._radii = u.clone(r, n._radii), n._innerRadii = u.clone(i, n._innerRadii), n._vertexFormat = Le.clone(a, n._vertexFormat), n._minimumClock = o, n._maximumClock = s, n._minimumCone = c, n._maximumCone = f, n._stackPartitions = h, n._slicePartitions = d, n._offsetAttribute = _ === -1 ? void 0 : _, n) : (Hi.minimumClock = o, Hi.maximumClock = s, Hi.minimumCone = c, Hi.maximumCone = f, Hi.stackPartitions = h, Hi.slicePartitions = d, Hi.offsetAttribute = _ === -1 ? void 0 : _, new ri(Hi))
};
ri.createGeometry = function(e) {
    var t = e._radii;
    if (!(t.x <= 0 || t.y <= 0 || t.z <= 0)) {
        var n = e._innerRadii;
        if (!(n.x <= 0 || n.y <= 0 || n.z <= 0)) {
            var r = e._minimumClock,
                i = e._maximumClock,
                a = e._minimumCone,
                o = e._maximumCone,
                s = e._vertexFormat,
                c = e._slicePartitions + 1,
                f = e._stackPartitions + 1;
            c = Math.round(c * Math.abs(i - r) / T.TWO_PI), f = Math.round(f * Math.abs(o - a) / T.PI), c < 2 && (c = 2), f < 2 && (f = 2);
            var h, d, _ = 0,
                v = [a],
                m = [r];
            for (h = 0; h < f; h++) v.push(a + h * (o - a) / (f - 1));
            for (v.push(o), d = 0; d < c; d++) m.push(r + d * (i - r) / (c - 1));
            m.push(i);
            var g = v.length,
                y = m.length,
                E = 0,
                w = 1,
                C = n.x !== t.x || n.y !== t.y || n.z !== t.z,
                A = !1,
                x = !1,
                P = !1;
            C && (w = 2, a > 0 && (A = !0, E += c - 1), o < Math.PI && (x = !0, E += c - 1), (i - r) % T.TWO_PI ? (P = !0, E += (f - 1) * 2 + 1) : E += 1);
            var I = y * g * w,
                D = new Float64Array(I * 3),
                O = Ri(new Array(I), !1),
                F = Ri(new Array(I), !1),
                z = c * f * w,
                b = 6 * (z + E + 1 - (c + f) * w),
                M = yt.createTypedArray(z, b),
                G = s.normal ? new Float32Array(I * 3) : void 0,
                V = s.tangent ? new Float32Array(I * 3) : void 0,
                B = s.bitangent ? new Float32Array(I * 3) : void 0,
                Y = s.st ? new Float32Array(I * 2) : void 0,
                j = new Array(g),
                Z = new Array(g);
            for (h = 0; h < g; h++) j[h] = Tm(v[h]), Z[h] = ym(v[h]);
            var Q = new Array(y),
                ie = new Array(y);
            for (d = 0; d < y; d++) ie[d] = ym(m[d]), Q[d] = Tm(m[d]);
            for (h = 0; h < g; h++)
                for (d = 0; d < y; d++) D[_++] = t.x * j[h] * ie[d], D[_++] = t.y * j[h] * Q[d], D[_++] = t.z * Z[h];
            var Ae = I / 2;
            if (C)
                for (h = 0; h < g; h++)
                    for (d = 0; d < y; d++) D[_++] = n.x * j[h] * ie[d], D[_++] = n.y * j[h] * Q[d], D[_++] = n.z * Z[h], O[Ae] = !0, h > 0 && h !== g - 1 && d !== 0 && d !== y - 1 && (F[Ae] = !0), Ae++;
            _ = 0;
            var re, ve;
            for (h = 1; h < g - 2; h++)
                for (re = h * y, ve = (h + 1) * y, d = 1; d < y - 2; d++) M[_++] = ve + d, M[_++] = ve + d + 1, M[_++] = re + d + 1, M[_++] = ve + d, M[_++] = re + d + 1, M[_++] = re + d;
            if (C) {
                var qe = g * y;
                for (h = 1; h < g - 2; h++)
                    for (re = qe + h * y, ve = qe + (h + 1) * y, d = 1; d < y - 2; d++) M[_++] = ve + d, M[_++] = re + d, M[_++] = re + d + 1, M[_++] = ve + d, M[_++] = re + d + 1, M[_++] = ve + d + 1
            }
            var De, _e;
            if (C) {
                if (A)
                    for (_e = g * y, h = 1; h < y - 2; h++) M[_++] = h, M[_++] = h + 1, M[_++] = _e + h + 1, M[_++] = h, M[_++] = _e + h + 1, M[_++] = _e + h;
                if (x)
                    for (De = g * y - y, _e = g * y * w - y, h = 1; h < y - 2; h++) M[_++] = De + h + 1, M[_++] = De + h, M[_++] = _e + h, M[_++] = De + h + 1, M[_++] = _e + h, M[_++] = _e + h + 1
            }
            if (P) {
                for (h = 1; h < g - 2; h++) _e = y * g + y * h, De = y * h, M[_++] = _e, M[_++] = De + y, M[_++] = De, M[_++] = _e, M[_++] = _e + y, M[_++] = De + y;
                for (h = 1; h < g - 2; h++) _e = y * g + y * (h + 1) - 1, De = y * (h + 1) - 1, M[_++] = De + y, M[_++] = _e, M[_++] = De, M[_++] = De + y, M[_++] = _e + y, M[_++] = _e
            }
            var Oe = new Va;
            s.position && (Oe.position = new ze({
                componentDatatype: ee.DOUBLE,
                componentsPerAttribute: 3,
                values: D
            }));
            var Fe = 0,
                ce = 0,
                He = 0,
                le = 0,
                ft = I / 2,
                Pt, Ie = ne.fromCartesian3(t),
                xn = ne.fromCartesian3(n);
            if (s.st || s.normal || s.tangent || s.bitangent) {
                for (h = 0; h < I; h++) {
                    Pt = O[h] ? xn : Ie;
                    var Sn = u.fromArray(D, h * 3, ZM),
                        St = Pt.geodeticSurfaceNormal(Sn, KM);
                    if (F[h] && u.negate(St, St), s.st) {
                        var rr = R.negate(St, QM);
                        Y[Fe++] = Math.atan2(rr.y, rr.x) / T.TWO_PI + .5, Y[Fe++] = Math.asin(St.z) / Math.PI + .5
                    }
                    if (s.normal && (G[ce++] = St.x, G[ce++] = St.y, G[ce++] = St.z), s.tangent || s.bitangent) {
                        var bt = $M,
                            cn = 0,
                            Rr;
                        if (O[h] && (cn = ft), !A && h >= cn && h < cn + y * 2 ? Rr = u.UNIT_X : Rr = u.UNIT_Z, u.cross(Rr, St, bt), u.normalize(bt, bt), s.tangent && (V[He++] = bt.x, V[He++] = bt.y, V[He++] = bt.z), s.bitangent) {
                            var fn = u.cross(St, bt, JM);
                            u.normalize(fn, fn), B[le++] = fn.x, B[le++] = fn.y, B[le++] = fn.z
                        }
                    }
                }
                s.st && (Oe.st = new ze({
                    componentDatatype: ee.FLOAT,
                    componentsPerAttribute: 2,
                    values: Y
                })), s.normal && (Oe.normal = new ze({
                    componentDatatype: ee.FLOAT,
                    componentsPerAttribute: 3,
                    values: G
                })), s.tangent && (Oe.tangent = new ze({
                    componentDatatype: ee.FLOAT,
                    componentsPerAttribute: 3,
                    values: V
                })), s.bitangent && (Oe.bitangent = new ze({
                    componentDatatype: ee.FLOAT,
                    componentsPerAttribute: 3,
                    values: B
                }))
            }
            if (l(e._offsetAttribute)) {
                var ir = D.length,
                    hn = new Uint8Array(ir / 3),
                    Yn = e._offsetAttribute === Di.NONE ? 0 : 1;
                Ri(hn, Yn), Oe.applyOffset = new ze({
                    componentDatatype: ee.UNSIGNED_BYTE,
                    componentsPerAttribute: 1,
                    values: hn
                })
            }
            return new rt({
                attributes: Oe,
                indices: M,
                primitiveType: Ve.TRIANGLES,
                boundingSphere: q.fromEllipsoid(Ie),
                offsetAttribute: e._offsetAttribute
            })
        }
    }
};
var Ih;
ri.getUnitEllipsoid = function() {
    return l(Ih) || (Ih = ri.createGeometry(new ri({
        radii: new u(1, 1, 1),
        vertexFormat: Le.POSITION_ONLY
    }))), Ih
};
var Ol = [],
    Ml = [];

function tN(e, t, n, r, i, a) {
    var o = i - r + 1,
        s = a - i,
        c = Ol,
        f = Ml,
        h, d;
    for (h = 0; h < o; ++h) c[h] = e[r + h];
    for (d = 0; d < s; ++d) f[d] = e[i + d + 1];
    h = 0, d = 0;
    for (var _ = r; _ <= a; ++_) {
        var v = c[h],
            m = f[d];
        h < o && (d >= s || t(v, m, n) <= 0) ? (e[_] = v, ++h) : d < s && (e[_] = m, ++d)
    }
}

function Nl(e, t, n, r, i) {
    if (!(r >= i)) {
        var a = Math.floor((r + i) * .5);
        Nl(e, t, n, r, a), Nl(e, t, n, a + 1, i), tN(e, t, n, r, a, i)
    }
}

function Hy(e, t, n) {
    var r = e.length,
        i = Math.ceil(r * .5);
    Ol.length = i, Ml.length = i, Nl(e, t, n, 0, r - 1), Ol.length = 0, Ml.length = 0
}

function Tn(e, t) {
    this._occluderPosition = u.clone(e.center), this._occluderRadius = e.radius, this._horizonDistance = 0, this._horizonPlaneNormal = void 0, this._horizonPlanePosition = void 0, this._cameraPosition = void 0, this.cameraPosition = t
}
var Bu = new u;
Object.defineProperties(Tn.prototype, {
    position: {
        get: function() {
            return this._occluderPosition
        }
    },
    radius: {
        get: function() {
            return this._occluderRadius
        }
    },
    cameraPosition: {
        set: function(e) {
            e = u.clone(e, this._cameraPosition);
            var t = u.subtract(this._occluderPosition, e, Bu),
                n = u.magnitudeSquared(t),
                r = this._occluderRadius * this._occluderRadius,
                i, a, o;
            if (n > r) {
                i = Math.sqrt(n - r), n = 1 / Math.sqrt(n), a = u.multiplyByScalar(t, n, Bu);
                var s = i * i * n;
                o = u.add(e, u.multiplyByScalar(a, s, Bu), Bu)
            } else i = Number.MAX_VALUE;
            this._horizonDistance = i, this._horizonPlaneNormal = a, this._horizonPlanePosition = o, this._cameraPosition = e
        }
    }
});
Tn.fromBoundingSphere = function(e, t, n) {
    return l(n) ? (u.clone(e.center, n._occluderPosition), n._occluderRadius = e.radius, n.cameraPosition = t, n) : new Tn(e, t)
};
var ky = new u;
Tn.prototype.isPointVisible = function(e) {
    if (this._horizonDistance !== Number.MAX_VALUE) {
        var t = u.subtract(e, this._occluderPosition, ky),
            n = this._occluderRadius;
        if (n = u.magnitudeSquared(t) - n * n, n > 0) return n = Math.sqrt(n) + this._horizonDistance, t = u.subtract(e, this._cameraPosition, t), n * n > u.magnitudeSquared(t)
    }
    return !1
};
var nN = new u;
Tn.prototype.isBoundingSphereVisible = function(e) {
    var t = u.clone(e.center, nN),
        n = e.radius;
    if (this._horizonDistance !== Number.MAX_VALUE) {
        var r = u.subtract(t, this._occluderPosition, ky),
            i = this._occluderRadius - n;
        if (i = u.magnitudeSquared(r) - i * i, n < this._occluderRadius) return i > 0 ? (i = Math.sqrt(i) + this._horizonDistance, r = u.subtract(t, this._cameraPosition, r), i * i + n * n > u.magnitudeSquared(r)) : !1;
        if (i > 0) {
            r = u.subtract(t, this._cameraPosition, r);
            var a = u.magnitudeSquared(r),
                o = this._occluderRadius * this._occluderRadius,
                s = n * n;
            return (this._horizonDistance * this._horizonDistance + o) * s > a * o ? !0 : (i = Math.sqrt(i) + this._horizonDistance, i * i + s > a)
        }
        return !0
    }
    return !1
};
var rN = new u;
Tn.prototype.computeVisibility = function(e) {
    var t = u.clone(e.center),
        n = e.radius;
    if (n > this._occluderRadius) return qt.FULL;
    if (this._horizonDistance !== Number.MAX_VALUE) {
        var r = u.subtract(t, this._occluderPosition, rN),
            i = this._occluderRadius - n,
            a = u.magnitudeSquared(r);
        if (i = a - i * i, i > 0) {
            i = Math.sqrt(i) + this._horizonDistance, r = u.subtract(t, this._cameraPosition, r);
            var o = u.magnitudeSquared(r);
            return i * i + n * n < o ? qt.NONE : (i = this._occluderRadius + n, i = a - i * i, i > 0 ? (i = Math.sqrt(i) + this._horizonDistance, o < i * i + n * n ? qt.FULL : qt.PARTIAL) : (r = u.subtract(t, this._horizonPlanePosition, r), u.dot(r, this._horizonPlaneNormal) > -n ? qt.PARTIAL : qt.FULL))
        }
    }
    return qt.NONE
};
var Vu = new u;
Tn.computeOccludeePoint = function(e, t, n) {
    var r = u.clone(t),
        i = u.clone(e.center),
        a = e.radius,
        o = n.length,
        s = u.normalize(u.subtract(r, i, Vu), Vu),
        c = -u.dot(s, i),
        f = Tn._anyRotationVector(i, s, c),
        h = Tn._horizonToPlaneNormalDotProduct(e, s, c, f, n[0]);
    if (!!h) {
        for (var d, _ = 1; _ < o; ++_) {
            if (d = Tn._horizonToPlaneNormalDotProduct(e, s, c, f, n[_]), !d) return;
            d < h && (h = d)
        }
        if (!(h < .0017453283658983088)) {
            var v = a / h;
            return u.add(i, u.multiplyByScalar(s, v, Vu), Vu)
        }
    }
};
var iN = [];
Tn.computeOccludeePointFromRectangle = function(e, t) {
    t = p(t, ne.WGS84);
    var n = W.subsample(e, t, 0, iN),
        r = q.fromPoints(n),
        i = u.ZERO;
    if (!u.equals(i, r.center)) return Tn.computeOccludeePoint(new q(i, t.minimumRadius), r.center, n)
};
var aN = new u;
Tn._anyRotationVector = function(e, t, n) {
    var r = u.abs(t, aN),
        i = r.x > r.y ? 0 : 1;
    (i === 0 && r.z > r.x || i === 1 && r.z > r.y) && (i = 2);
    var a = new u,
        o;
    i === 0 ? (r.x = e.x, r.y = e.y + 1, r.z = e.z + 1, o = u.UNIT_X) : i === 1 ? (r.x = e.x + 1, r.y = e.y, r.z = e.z + 1, o = u.UNIT_Y) : (r.x = e.x + 1, r.y = e.y + 1, r.z = e.z, o = u.UNIT_Z);
    var s = (u.dot(t, r) + n) / -u.dot(t, o);
    return u.normalize(u.subtract(u.add(r, u.multiplyByScalar(o, s, a), r), e, r), r)
};
var oN = new u;
Tn._rotationVector = function(e, t, n, r, i) {
    var a = u.subtract(r, e, oN);
    if (a = u.normalize(a, a), u.dot(t, a) < .9999999847691291) {
        var o = u.cross(t, a, a),
            s = u.magnitude(o);
        if (s > T.EPSILON13) return u.normalize(o, new u)
    }
    return i
};
var Ph = new u,
    sN = new u,
    Gu = new u,
    Em = new u;
Tn._horizonToPlaneNormalDotProduct = function(e, t, n, r, i) {
    var a = u.clone(i, Ph),
        o = u.clone(e.center, sN),
        s = e.radius,
        c = u.subtract(o, a, Gu),
        f = u.magnitudeSquared(c),
        h = s * s;
    if (f < h) return !1;
    var d = f - h,
        _ = Math.sqrt(d),
        v = Math.sqrt(f),
        m = 1 / v,
        g = _ * m,
        y = g * _;
    c = u.normalize(c, c);
    var E = u.add(a, u.multiplyByScalar(c, y, Em), Em),
        w = Math.sqrt(d - y * y),
        C = this._rotationVector(o, t, n, a, r),
        A = u.fromElements(C.x * C.x * c.x + (C.x * C.y - C.z) * c.y + (C.x * C.z + C.y) * c.z, (C.x * C.y + C.z) * c.x + C.y * C.y * c.y + (C.y * C.z - C.x) * c.z, (C.x * C.z - C.y) * c.x + (C.y * C.z + C.x) * c.y + C.z * C.z * c.z, Ph);
    A = u.normalize(A, A);
    var x = u.multiplyByScalar(A, w, Ph);
    C = u.normalize(u.subtract(u.add(E, x, Gu), o, Gu), Gu);
    var P = u.dot(t, C);
    C = u.normalize(u.subtract(u.subtract(E, x, C), o, C), C);
    var I = u.dot(t, C);
    return P < I ? P : I
};

function Er(e) {
    e = p(e, p.EMPTY_OBJECT), this.left = e.left, this._left = void 0, this.right = e.right, this._right = void 0, this.top = e.top, this._top = void 0, this.bottom = e.bottom, this._bottom = void 0, this.near = p(e.near, 1), this._near = this.near, this.far = p(e.far, 5e8), this._far = this.far, this._cullingVolume = new Pn, this._perspectiveMatrix = new S, this._infinitePerspective = new S
}

function bl(e) {
    var t = e.top,
        n = e.bottom,
        r = e.right,
        i = e.left,
        a = e.near,
        o = e.far;
    (t !== e._top || n !== e._bottom || i !== e._left || r !== e._right || a !== e._near || o !== e._far) && (e._left = i, e._right = r, e._top = t, e._bottom = n, e._near = a, e._far = o, e._perspectiveMatrix = S.computePerspectiveOffCenter(i, r, n, t, a, o, e._perspectiveMatrix), e._infinitePerspective = S.computeInfinitePerspectiveOffCenter(i, r, n, t, a, e._infinitePerspective))
}
Object.defineProperties(Er.prototype, {
    projectionMatrix: {
        get: function() {
            return bl(this), this._perspectiveMatrix
        }
    },
    infiniteProjectionMatrix: {
        get: function() {
            return bl(this), this._infinitePerspective
        }
    }
});
var uN = new u,
    cN = new u,
    fN = new u,
    hN = new u;
Er.prototype.computeCullingVolume = function(e, t, n) {
    var r = this._cullingVolume.planes,
        i = this.top,
        a = this.bottom,
        o = this.right,
        s = this.left,
        c = this.near,
        f = this.far,
        h = u.cross(t, n, uN),
        d = cN;
    u.multiplyByScalar(t, c, d), u.add(e, d, d);
    var _ = fN;
    u.multiplyByScalar(t, f, _), u.add(e, _, _);
    var v = hN;
    u.multiplyByScalar(h, s, v), u.add(d, v, v), u.subtract(v, e, v), u.normalize(v, v), u.cross(v, n, v), u.normalize(v, v);
    var m = r[0];
    return l(m) || (m = r[0] = new U), m.x = v.x, m.y = v.y, m.z = v.z, m.w = -u.dot(v, e), u.multiplyByScalar(h, o, v), u.add(d, v, v), u.subtract(v, e, v), u.cross(n, v, v), u.normalize(v, v), m = r[1], l(m) || (m = r[1] = new U), m.x = v.x, m.y = v.y, m.z = v.z, m.w = -u.dot(v, e), u.multiplyByScalar(n, a, v), u.add(d, v, v), u.subtract(v, e, v), u.cross(h, v, v), u.normalize(v, v), m = r[2], l(m) || (m = r[2] = new U), m.x = v.x, m.y = v.y, m.z = v.z, m.w = -u.dot(v, e), u.multiplyByScalar(n, i, v), u.add(d, v, v), u.subtract(v, e, v), u.cross(v, h, v), u.normalize(v, v), m = r[3], l(m) || (m = r[3] = new U), m.x = v.x, m.y = v.y, m.z = v.z, m.w = -u.dot(v, e), m = r[4], l(m) || (m = r[4] = new U), m.x = t.x, m.y = t.y, m.z = t.z, m.w = -u.dot(t, d), u.negate(t, v), m = r[5], l(m) || (m = r[5] = new U), m.x = v.x, m.y = v.y, m.z = v.z, m.w = -u.dot(v, _), this._cullingVolume
};
Er.prototype.getPixelDimensions = function(e, t, n, r, i) {
    bl(this);
    var a = 1 / this.near,
        o = this.top * a,
        s = 2 * r * n * o / t;
    o = this.right * a;
    var c = 2 * r * n * o / e;
    return i.x = c, i.y = s, i
};
Er.prototype.clone = function(e) {
    return l(e) || (e = new Er), e.right = this.right, e.left = this.left, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e._left = void 0, e._right = void 0, e._top = void 0, e._bottom = void 0, e._near = void 0, e._far = void 0, e
};
Er.prototype.equals = function(e) {
    return l(e) && e instanceof Er && this.right === e.right && this.left === e.left && this.top === e.top && this.bottom === e.bottom && this.near === e.near && this.far === e.far
};
Er.prototype.equalsEpsilon = function(e, t, n) {
    return e === this || l(e) && e instanceof Er && T.equalsEpsilon(this.right, e.right, t, n) && T.equalsEpsilon(this.left, e.left, t, n) && T.equalsEpsilon(this.top, e.top, t, n) && T.equalsEpsilon(this.bottom, e.bottom, t, n) && T.equalsEpsilon(this.near, e.near, t, n) && T.equalsEpsilon(this.far, e.far, t, n)
};

function en(e) {
    e = p(e, p.EMPTY_OBJECT), this._offCenterFrustum = new Er, this.fov = e.fov, this._fov = void 0, this._fovy = void 0, this._sseDenominator = void 0, this.aspectRatio = e.aspectRatio, this._aspectRatio = void 0, this.near = p(e.near, 1), this._near = this.near, this.far = p(e.far, 5e8), this._far = this.far, this.xOffset = p(e.xOffset, 0), this._xOffset = this.xOffset, this.yOffset = p(e.yOffset, 0), this._yOffset = this.yOffset
}
en.packedLength = 6;
en.pack = function(e, t, n) {
    return n = p(n, 0), t[n++] = e.fov, t[n++] = e.aspectRatio, t[n++] = e.near, t[n++] = e.far, t[n++] = e.xOffset, t[n] = e.yOffset, t
};
en.unpack = function(e, t, n) {
    return t = p(t, 0), l(n) || (n = new en), n.fov = e[t++], n.aspectRatio = e[t++], n.near = e[t++], n.far = e[t++], n.xOffset = e[t++], n.yOffset = e[t], n
};

function ei(e) {
    var t = e._offCenterFrustum;
    (e.fov !== e._fov || e.aspectRatio !== e._aspectRatio || e.near !== e._near || e.far !== e._far || e.xOffset !== e._xOffset || e.yOffset !== e._yOffset) && (e._aspectRatio = e.aspectRatio, e._fov = e.fov, e._fovy = e.aspectRatio <= 1 ? e.fov : Math.atan(Math.tan(e.fov * .5) / e.aspectRatio) * 2, e._near = e.near, e._far = e.far, e._sseDenominator = 2 * Math.tan(.5 * e._fovy), e._xOffset = e.xOffset, e._yOffset = e.yOffset, t.top = e.near * Math.tan(.5 * e._fovy), t.bottom = -t.top, t.right = e.aspectRatio * t.top, t.left = -t.right, t.near = e.near, t.far = e.far, t.right += e.xOffset, t.left += e.xOffset, t.top += e.yOffset, t.bottom += e.yOffset)
}
Object.defineProperties(en.prototype, {
    projectionMatrix: {
        get: function() {
            return ei(this), this._offCenterFrustum.projectionMatrix
        }
    },
    infiniteProjectionMatrix: {
        get: function() {
            return ei(this), this._offCenterFrustum.infiniteProjectionMatrix
        }
    },
    fovy: {
        get: function() {
            return ei(this), this._fovy
        }
    },
    sseDenominator: {
        get: function() {
            return ei(this), this._sseDenominator
        }
    }
});
en.prototype.computeCullingVolume = function(e, t, n) {
    return ei(this), this._offCenterFrustum.computeCullingVolume(e, t, n)
};
en.prototype.getPixelDimensions = function(e, t, n, r, i) {
    return ei(this), this._offCenterFrustum.getPixelDimensions(e, t, n, r, i)
};
en.prototype.clone = function(e) {
    return l(e) || (e = new en), e.aspectRatio = this.aspectRatio, e.fov = this.fov, e.near = this.near, e.far = this.far, e._aspectRatio = void 0, e._fov = void 0, e._near = void 0, e._far = void 0, this._offCenterFrustum.clone(e._offCenterFrustum), e
};
en.prototype.equals = function(e) {
    return !l(e) || !(e instanceof en) ? !1 : (ei(this), ei(e), this.fov === e.fov && this.aspectRatio === e.aspectRatio && this._offCenterFrustum.equals(e._offCenterFrustum))
};
en.prototype.equalsEpsilon = function(e, t, n) {
    return !l(e) || !(e instanceof en) ? !1 : (ei(this), ei(e), T.equalsEpsilon(this.fov, e.fov, t, n) && T.equalsEpsilon(this.aspectRatio, e.aspectRatio, t, n) && this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum, t, n))
};

function on(e) {
    e = p(e, p.EMPTY_OBJECT), this.color = e.color, this.depth = e.depth, this.stencil = e.stencil, this.renderState = e.renderState, this.framebuffer = e.framebuffer, this.owner = e.owner, this.pass = e.pass
}
on.ALL = Object.freeze(new on({
    color: new H(0, 0, 0, 0),
    depth: 1,
    stencil: 0
}));
on.prototype.execute = function(e, t) {
    e.clear(this, t)
};
const Wy = `attribute vec4 position;
attribute vec2 textureCoordinates;
varying vec2 v_textureCoordinates;
void main()
{
gl_Position = position;
v_textureCoordinates = textureCoordinates;
}
`;

function nf(e) {
    this._context = e
}
var as, lN = new an({
        primitiveType: Ve.TRIANGLES
    }),
    dN = new on({
        color: new H(0, 0, 0, 0)
    });

function _N(e, t) {
    return new xt({
        context: e,
        colorTextures: [t],
        destroyAttachments: !1
    })
}

function vN(e, t) {
    return Mt.fromCache({
        context: e,
        vertexShaderSource: Wy,
        fragmentShaderSource: t,
        attributeLocations: {
            position: 0,
            textureCoordinates: 1
        }
    })
}

function mN(e, t) {
    return (!l(as) || as.viewport.width !== e || as.viewport.height !== t) && (as = Ge.fromCache({
        viewport: new ge(0, 0, e, t)
    })), as
}
nf.prototype.execute = function(e) {
    l(e.preExecute) && e.preExecute(e);
    var t = e.outputTexture,
        n = t.width,
        r = t.height,
        i = this._context,
        a = l(e.vertexArray) ? e.vertexArray : i.getViewportQuadVertexArray(),
        o = l(e.shaderProgram) ? e.shaderProgram : vN(i, e.fragmentShaderSource),
        s = _N(i, t),
        c = mN(n, r),
        f = e.uniformMap,
        h = dN;
    h.framebuffer = s, h.renderState = c, h.execute(i);
    var d = lN;
    d.vertexArray = a, d.renderState = c, d.shaderProgram = o, d.uniformMap = f, d.framebuffer = s, d.execute(i), s.destroy(), e.persists || (o.destroy(), l(e.vertexArray) && a.destroy()), l(e.postExecute) && e.postExecute(t)
};
nf.prototype.isDestroyed = function() {
    return !1
};
nf.prototype.destroy = function() {
    return Pe(this)
};

function wi(e, t, n, r, i, a, o, s, c, f, h) {
    this._context = e, this._texture = t, this._textureTarget = n, this._targetFace = r, this._pixelDatatype = o, this._internalFormat = i, this._pixelFormat = a, this._size = s, this._preMultiplyAlpha = c, this._flipY = f, this._initialized = h
}
Object.defineProperties(wi.prototype, {
    pixelFormat: {
        get: function() {
            return this._pixelFormat
        }
    },
    pixelDatatype: {
        get: function() {
            return this._pixelDatatype
        }
    },
    _target: {
        get: function() {
            return this._targetFace
        }
    }
});
wi.prototype.copyFrom = function(e, t, n) {
    t = p(t, 0), n = p(n, 0);
    var r = this._context._gl,
        i = this._textureTarget,
        a = this._targetFace;
    r.activeTexture(r.TEXTURE0), r.bindTexture(i, this._texture);
    var o = e.width,
        s = e.height,
        c = e.arrayBufferView,
        f = this._size,
        h = this._pixelFormat,
        d = this._internalFormat,
        _ = this._pixelDatatype,
        v = this._preMultiplyAlpha,
        m = this._flipY,
        g = 4;
    l(c) && (g = de.alignmentInBytes(h, _, o)), r.pixelStorei(r.UNPACK_ALIGNMENT, g);
    var y = !1;
    if (!this._initialized) {
        if (t === 0 && n === 0 && o === f && s === f) l(c) ? (r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1), m && (c = de.flipY(c, h, _, f, f)), r.texImage2D(a, 0, d, f, f, 0, h, ae.toWebGLConstant(_, this._context), c)) : (r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, m), r.texImage2D(a, 0, d, h, ae.toWebGLConstant(_, this._context), e)), y = !0;
        else {
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1);
            var E = de.createTypedArray(h, _, f, f);
            r.texImage2D(a, 0, d, f, f, 0, h, ae.toWebGLConstant(_, this._context), E)
        }
        this._initialized = !0
    }
    y || (l(c) ? (r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1), m && (c = de.flipY(c, h, _, o, s)), r.texSubImage2D(a, 0, t, n, o, s, h, ae.toWebGLConstant(_, this._context), c)) : (r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, m), r.texSubImage2D(a, 0, t, n, h, ae.toWebGLConstant(_, this._context), e))), r.bindTexture(i, null)
};
wi.prototype.copyFromFramebuffer = function(e, t, n, r, i, a) {
    e = p(e, 0), t = p(t, 0), n = p(n, 0), r = p(r, 0), i = p(i, this._size), a = p(a, this._size);
    var o = this._context._gl,
        s = this._textureTarget;
    o.activeTexture(o.TEXTURE0), o.bindTexture(s, this._texture), o.copyTexSubImage2D(this._targetFace, 0, e, t, n, r, i, a), o.bindTexture(s, null), this._initialized = !0
};

function Fo(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.context,
        n = e.source,
        r;
    if (l(n)) {
        var i = [n.positiveX, n.negativeX, n.positiveY, n.negativeY, n.positiveZ, n.negativeZ];
        r = i[0].width, i[0].height
    } else r = e.width, e.height;
    var a = r,
        o = p(e.pixelDatatype, ae.UNSIGNED_BYTE),
        s = p(e.pixelFormat, de.RGBA),
        c = de.toInternalFormat(s, o, t),
        f = de.textureSizeInBytes(s, o, a, a) * 6,
        h = e.preMultiplyAlpha || s === de.RGB || s === de.LUMINANCE,
        d = p(e.flipY, !0),
        _ = t._gl,
        v = _.TEXTURE_CUBE_MAP,
        m = _.createTexture();
    _.activeTexture(_.TEXTURE0), _.bindTexture(v, m);

    function g(E, w, C, A) {
        var x = w.arrayBufferView;
        l(x) || (x = w.bufferView);
        var P = 4;
        l(x) && (P = de.alignmentInBytes(s, o, r)), _.pixelStorei(_.UNPACK_ALIGNMENT, P), l(x) ? (_.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), _.pixelStorei(_.UNPACK_FLIP_Y_WEBGL, !1), A && (x = de.flipY(x, s, o, a, a)), _.texImage2D(E, 0, c, a, a, 0, s, ae.toWebGLConstant(o, t), x)) : (_.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, C), _.pixelStorei(_.UNPACK_FLIP_Y_WEBGL, A), _.texImage2D(E, 0, c, s, ae.toWebGLConstant(o, t), w))
    }
    l(n) ? (g(_.TEXTURE_CUBE_MAP_POSITIVE_X, n.positiveX, h, d), g(_.TEXTURE_CUBE_MAP_NEGATIVE_X, n.negativeX, h, d), g(_.TEXTURE_CUBE_MAP_POSITIVE_Y, n.positiveY, h, d), g(_.TEXTURE_CUBE_MAP_NEGATIVE_Y, n.negativeY, h, d), g(_.TEXTURE_CUBE_MAP_POSITIVE_Z, n.positiveZ, h, d), g(_.TEXTURE_CUBE_MAP_NEGATIVE_Z, n.negativeZ, h, d)) : (_.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_X, 0, c, a, a, 0, s, ae.toWebGLConstant(o, t), null), _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, c, a, a, 0, s, ae.toWebGLConstant(o, t), null), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, c, a, a, 0, s, ae.toWebGLConstant(o, t), null), _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, c, a, a, 0, s, ae.toWebGLConstant(o, t), null), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, c, a, a, 0, s, ae.toWebGLConstant(o, t), null), _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, c, a, a, 0, s, ae.toWebGLConstant(o, t), null)), _.bindTexture(v, null), this._context = t, this._textureFilterAnisotropic = t._textureFilterAnisotropic, this._textureTarget = v, this._texture = m, this._pixelFormat = s, this._pixelDatatype = o, this._size = a, this._hasMipmap = !1, this._sizeInBytes = f, this._preMultiplyAlpha = h, this._flipY = d, this._sampler = void 0;
    var y = l(n);
    this._positiveX = new wi(t, m, v, _.TEXTURE_CUBE_MAP_POSITIVE_X, c, s, o, a, h, d, y), this._negativeX = new wi(t, m, v, _.TEXTURE_CUBE_MAP_NEGATIVE_X, c, s, o, a, h, d, y), this._positiveY = new wi(t, m, v, _.TEXTURE_CUBE_MAP_POSITIVE_Y, c, s, o, a, h, d, y), this._negativeY = new wi(t, m, v, _.TEXTURE_CUBE_MAP_NEGATIVE_Y, c, s, o, a, h, d, y), this._positiveZ = new wi(t, m, v, _.TEXTURE_CUBE_MAP_POSITIVE_Z, c, s, o, a, h, d, y), this._negativeZ = new wi(t, m, v, _.TEXTURE_CUBE_MAP_NEGATIVE_Z, c, s, o, a, h, d, y), this.sampler = l(e.sampler) ? e.sampler : new gt
}
Object.defineProperties(Fo.prototype, {
    positiveX: {
        get: function() {
            return this._positiveX
        }
    },
    negativeX: {
        get: function() {
            return this._negativeX
        }
    },
    positiveY: {
        get: function() {
            return this._positiveY
        }
    },
    negativeY: {
        get: function() {
            return this._negativeY
        }
    },
    positiveZ: {
        get: function() {
            return this._positiveZ
        }
    },
    negativeZ: {
        get: function() {
            return this._negativeZ
        }
    },
    sampler: {
        get: function() {
            return this._sampler
        },
        set: function(e) {
            var t = e.minificationFilter,
                n = e.magnificationFilter,
                r = t === Ot.NEAREST_MIPMAP_NEAREST || t === Ot.NEAREST_MIPMAP_LINEAR || t === Ot.LINEAR_MIPMAP_NEAREST || t === Ot.LINEAR_MIPMAP_LINEAR,
                i = this._context,
                a = this._pixelDatatype;
            (a === ae.FLOAT && !i.textureFloatLinear || a === ae.HALF_FLOAT && !i.textureHalfFloatLinear) && (t = r ? Ot.NEAREST_MIPMAP_NEAREST : Ot.NEAREST, n = zr.NEAREST);
            var o = i._gl,
                s = this._textureTarget;
            o.activeTexture(o.TEXTURE0), o.bindTexture(s, this._texture), o.texParameteri(s, o.TEXTURE_MIN_FILTER, t), o.texParameteri(s, o.TEXTURE_MAG_FILTER, n), o.texParameteri(s, o.TEXTURE_WRAP_S, e.wrapS), o.texParameteri(s, o.TEXTURE_WRAP_T, e.wrapT), l(this._textureFilterAnisotropic) && o.texParameteri(s, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.maximumAnisotropy), o.bindTexture(s, null), this._sampler = e
        }
    },
    pixelFormat: {
        get: function() {
            return this._pixelFormat
        }
    },
    pixelDatatype: {
        get: function() {
            return this._pixelDatatype
        }
    },
    width: {
        get: function() {
            return this._size
        }
    },
    height: {
        get: function() {
            return this._size
        }
    },
    sizeInBytes: {
        get: function() {
            return this._hasMipmap ? Math.floor(this._sizeInBytes * 4 / 3) : this._sizeInBytes
        }
    },
    preMultiplyAlpha: {
        get: function() {
            return this._preMultiplyAlpha
        }
    },
    flipY: {
        get: function() {
            return this._flipY
        }
    },
    _target: {
        get: function() {
            return this._textureTarget
        }
    }
});
Fo.prototype.generateMipmap = function(e) {
    e = p(e, Kc.DONT_CARE), this._hasMipmap = !0;
    var t = this._context._gl,
        n = this._textureTarget;
    t.hint(t.GENERATE_MIPMAP_HINT, e), t.activeTexture(t.TEXTURE0), t.bindTexture(n, this._texture), t.generateMipmap(n), t.bindTexture(n, null)
};
Fo.prototype.isDestroyed = function() {
    return !1
};
Fo.prototype.destroy = function() {
    return this._context._gl.deleteTexture(this._texture), this._positiveX = Pe(this._positiveX), this._negativeX = Pe(this._negativeX), this._positiveY = Pe(this._positiveY), this._negativeY = Pe(this._negativeY), this._positiveZ = Pe(this._positiveZ), this._negativeZ = Pe(this._negativeZ), Pe(this)
};

function rf(e) {
    this.context = e, this.framebuffer = void 0, this.blendingEnabled = void 0, this.scissorTest = void 0, this.viewport = void 0
}

function kr(e) {
    this._context = e, this._shaders = {}, this._numberOfShaders = 0, this._shadersToRelease = {}
}
Object.defineProperties(kr.prototype, {
    numberOfShaders: {
        get: function() {
            return this._numberOfShaders
        }
    }
});
kr.prototype.replaceShaderProgram = function(e) {
    return l(e.shaderProgram) && e.shaderProgram.destroy(), this.getShaderProgram(e)
};
kr.prototype.getShaderProgram = function(e) {
    var t = e.vertexShaderSource,
        n = e.fragmentShaderSource,
        r = e.attributeLocations;
    typeof t == "string" && (t = new Re({
        sources: [t]
    })), typeof n == "string" && (n = new Re({
        sources: [n]
    }));
    var i = t.createCombinedVertexShader(this._context),
        a = n.createCombinedFragmentShader(this._context),
        o = i + a + JSON.stringify(r),
        s;
    if (l(this._shaders[o])) s = this._shaders[o], delete this._shadersToRelease[o];
    else {
        var c = this._context,
            f = new Mt({
                gl: c._gl,
                logShaderCompilation: c.logShaderCompilation,
                debugShaders: c.debugShaders,
                vertexShaderSource: t,
                vertexShaderText: i,
                fragmentShaderSource: n,
                fragmentShaderText: a,
                attributeLocations: r
            });
        s = {
            cache: this,
            shaderProgram: f,
            keyword: o,
            derivedKeywords: [],
            count: 0
        }, f._cachedShader = s, this._shaders[o] = s, ++this._numberOfShaders
    }
    return ++s.count, s.shaderProgram
};
kr.prototype.replaceDerivedShaderProgram = function(e, t, n) {
    var r = e._cachedShader,
        i = t + r.keyword,
        a = this._shaders[i];
    if (l(a)) {
        Md(this, a);
        var o = r.derivedKeywords.indexOf(t);
        o > -1 && r.derivedKeywords.splice(o, 1)
    }
    return this.createDerivedShaderProgram(e, t, n)
};
kr.prototype.getDerivedShaderProgram = function(e, t) {
    var n = e._cachedShader,
        r = t + n.keyword,
        i = this._shaders[r];
    if (!!l(i)) return i.shaderProgram
};
kr.prototype.createDerivedShaderProgram = function(e, t, n) {
    var r = e._cachedShader,
        i = t + r.keyword,
        a = n.vertexShaderSource,
        o = n.fragmentShaderSource,
        s = n.attributeLocations;
    typeof a == "string" && (a = new Re({
        sources: [a]
    })), typeof o == "string" && (o = new Re({
        sources: [o]
    }));
    var c = this._context,
        f = a.createCombinedVertexShader(c),
        h = o.createCombinedFragmentShader(c),
        d = new Mt({
            gl: c._gl,
            logShaderCompilation: c.logShaderCompilation,
            debugShaders: c.debugShaders,
            vertexShaderSource: a,
            vertexShaderText: f,
            fragmentShaderSource: o,
            fragmentShaderText: h,
            attributeLocations: s
        }),
        _ = {
            cache: this,
            shaderProgram: d,
            keyword: i,
            derivedKeywords: [],
            count: 0
        };
    return r.derivedKeywords.push(t), d._cachedShader = _, this._shaders[i] = _, d
};

function Md(e, t) {
    for (var n = t.derivedKeywords, r = n.length, i = 0; i < r; ++i) {
        var a = n[i] + t.keyword,
            o = e._shaders[a];
        Md(e, o)
    }
    delete e._shaders[t.keyword], t.shaderProgram.finalDestroy()
}
kr.prototype.destroyReleasedShaderPrograms = function() {
    var e = this._shadersToRelease;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var n = e[t];
            Md(this, n), --this._numberOfShaders
        }
    this._shadersToRelease = {}
};
kr.prototype.releaseShaderProgram = function(e) {
    if (l(e)) {
        var t = e._cachedShader;
        t && --t.count === 0 && (this._shadersToRelease[t.keyword] = t)
    }
};
kr.prototype.isDestroyed = function() {
    return !1
};
kr.prototype.destroy = function() {
    var e = this._shaders;
    for (var t in e) e.hasOwnProperty(t) && e[t].shaderProgram.finalDestroy();
    return Pe(this)
};

function Ga() {
    this._textures = {}, this._numberOfTextures = 0, this._texturesToRelease = {}
}
Object.defineProperties(Ga.prototype, {
    numberOfTextures: {
        get: function() {
            return this._numberOfTextures
        }
    }
});
Ga.prototype.getTexture = function(e) {
    var t = this._textures[e];
    if (!!l(t)) return delete this._texturesToRelease[e], ++t.count, t.texture
};
Ga.prototype.addTexture = function(e, t) {
    var n = {
        texture: t,
        count: 1
    };
    t.finalDestroy = t.destroy;
    var r = this;
    t.destroy = function() {
        --n.count === 0 && (r._texturesToRelease[e] = n)
    }, this._textures[e] = n, ++this._numberOfTextures
};
Ga.prototype.destroyReleasedTextures = function() {
    var e = this._texturesToRelease;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var n = e[t];
            delete this._textures[t], n.texture.finalDestroy(), --this._numberOfTextures
        }
    this._texturesToRelease = {}
};
Ga.prototype.isDestroyed = function() {
    return !1
};
Ga.prototype.destroy = function() {
    var e = this._textures;
    for (var t in e) e.hasOwnProperty(t) && e[t].texture.finalDestroy();
    return Pe(this)
};

function qy(e) {
    e = p(e, p.EMPTY_OBJECT), this.color = H.clone(p(e.color, H.WHITE)), this.intensity = p(e.intensity, 2)
}

function Lo() {
    this.globeDepthTexture = void 0, this.gamma = void 0, this._viewport = new ge, this._viewportCartesian4 = new U, this._viewportDirty = !1, this._viewportOrthographicMatrix = S.clone(S.IDENTITY), this._viewportTransformation = S.clone(S.IDENTITY), this._model = S.clone(S.IDENTITY), this._view = S.clone(S.IDENTITY), this._inverseView = S.clone(S.IDENTITY), this._projection = S.clone(S.IDENTITY), this._infiniteProjection = S.clone(S.IDENTITY), this._entireFrustum = new R, this._currentFrustum = new R, this._frustumPlanes = new U, this._farDepthFromNearPlusOne = void 0, this._log2FarDepthFromNearPlusOne = void 0, this._oneOverLog2FarDepthFromNearPlusOne = void 0, this._frameState = void 0, this._temeToPseudoFixed = N.clone(S.IDENTITY), this._view3DDirty = !0, this._view3D = new S, this._inverseView3DDirty = !0, this._inverseView3D = new S, this._inverseModelDirty = !0, this._inverseModel = new S, this._inverseTransposeModelDirty = !0, this._inverseTransposeModel = new N, this._viewRotation = new N, this._inverseViewRotation = new N, this._viewRotation3D = new N, this._inverseViewRotation3D = new N, this._inverseProjectionDirty = !0, this._inverseProjection = new S, this._modelViewDirty = !0, this._modelView = new S, this._modelView3DDirty = !0, this._modelView3D = new S, this._modelViewRelativeToEyeDirty = !0, this._modelViewRelativeToEye = new S, this._inverseModelViewDirty = !0, this._inverseModelView = new S, this._inverseModelView3DDirty = !0, this._inverseModelView3D = new S, this._viewProjectionDirty = !0, this._viewProjection = new S, this._inverseViewProjectionDirty = !0, this._inverseViewProjection = new S, this._modelViewProjectionDirty = !0, this._modelViewProjection = new S, this._inverseModelViewProjectionDirty = !0, this._inverseModelViewProjection = new S, this._modelViewProjectionRelativeToEyeDirty = !0, this._modelViewProjectionRelativeToEye = new S, this._modelViewInfiniteProjectionDirty = !0, this._modelViewInfiniteProjection = new S, this._normalDirty = !0, this._normal = new N, this._normal3DDirty = !0, this._normal3D = new N, this._inverseNormalDirty = !0, this._inverseNormal = new N, this._inverseNormal3DDirty = !0, this._inverseNormal3D = new N, this._encodedCameraPositionMCDirty = !0, this._encodedCameraPositionMC = new rn, this._cameraPosition = new u, this._sunPositionWC = new u, this._sunPositionColumbusView = new u, this._sunDirectionWC = new u, this._sunDirectionEC = new u, this._moonDirectionEC = new u, this._lightDirectionWC = new u, this._lightDirectionEC = new u, this._lightColor = new u, this._lightColorHdr = new u, this._pass = void 0, this._mode = void 0, this._mapProjection = void 0, this._ellipsoid = void 0, this._cameraDirection = new u, this._cameraRight = new u, this._cameraUp = new u, this._frustum2DWidth = 0, this._eyeHeight = 0, this._eyeHeight2D = new R, this._pixelRatio = 1, this._orthographicIn3D = !1, this._backgroundColor = new H, this._brdfLut = void 0, this._environmentMap = void 0, this._sphericalHarmonicCoefficients = void 0, this._specularEnvironmentMaps = void 0, this._specularEnvironmentMapsDimensions = new R, this._specularEnvironmentMapsMaximumLOD = void 0, this._fogDensity = void 0, this._invertClassificationColor = void 0, this._imagerySplitPosition = 0, this._pixelSizePerMeter = void 0, this._geometricToleranceOverMeter = void 0, this._minimumDisableDepthTestDistance = void 0
}
Object.defineProperties(Lo.prototype, {
    frameState: {
        get: function() {
            return this._frameState
        }
    },
    viewport: {
        get: function() {
            return this._viewport
        },
        set: function(e) {
            if (!ge.equals(e, this._viewport)) {
                ge.clone(e, this._viewport);
                var t = this._viewport,
                    n = this._viewportCartesian4;
                n.x = t.x, n.y = t.y, n.z = t.width, n.w = t.height, this._viewportDirty = !0
            }
        }
    },
    viewportCartesian4: {
        get: function() {
            return this._viewportCartesian4
        }
    },
    viewportOrthographic: {
        get: function() {
            return Am(this), this._viewportOrthographicMatrix
        }
    },
    viewportTransformation: {
        get: function() {
            return Am(this), this._viewportTransformation
        }
    },
    model: {
        get: function() {
            return this._model
        },
        set: function(e) {
            S.clone(e, this._model), this._modelView3DDirty = !0, this._inverseModelView3DDirty = !0, this._inverseModelDirty = !0, this._inverseTransposeModelDirty = !0, this._modelViewDirty = !0, this._inverseModelViewDirty = !0, this._modelViewRelativeToEyeDirty = !0, this._inverseModelViewDirty = !0, this._modelViewProjectionDirty = !0, this._inverseModelViewProjectionDirty = !0, this._modelViewProjectionRelativeToEyeDirty = !0, this._modelViewInfiniteProjectionDirty = !0, this._normalDirty = !0, this._inverseNormalDirty = !0, this._normal3DDirty = !0, this._inverseNormal3DDirty = !0, this._encodedCameraPositionMCDirty = !0
        }
    },
    inverseModel: {
        get: function() {
            return this._inverseModelDirty && (this._inverseModelDirty = !1, S.inverse(this._model, this._inverseModel)), this._inverseModel
        }
    },
    inverseTransposeModel: {
        get: function() {
            var e = this._inverseTransposeModel;
            return this._inverseTransposeModelDirty && (this._inverseTransposeModelDirty = !1, S.getMatrix3(this.inverseModel, e), N.transpose(e, e)), e
        }
    },
    view: {
        get: function() {
            return this._view
        }
    },
    view3D: {
        get: function() {
            return Oh(this), this._view3D
        }
    },
    viewRotation: {
        get: function() {
            return Oh(this), this._viewRotation
        }
    },
    viewRotation3D: {
        get: function() {
            return Oh(this), this._viewRotation3D
        }
    },
    inverseView: {
        get: function() {
            return this._inverseView
        }
    },
    inverseView3D: {
        get: function() {
            return xm(this), this._inverseView3D
        }
    },
    inverseViewRotation: {
        get: function() {
            return this._inverseViewRotation
        }
    },
    inverseViewRotation3D: {
        get: function() {
            return xm(this), this._inverseViewRotation3D
        }
    },
    projection: {
        get: function() {
            return this._projection
        }
    },
    inverseProjection: {
        get: function() {
            return wN(this), this._inverseProjection
        }
    },
    infiniteProjection: {
        get: function() {
            return this._infiniteProjection
        }
    },
    modelView: {
        get: function() {
            return xN(this), this._modelView
        }
    },
    modelView3D: {
        get: function() {
            return SN(this), this._modelView3D
        }
    },
    modelViewRelativeToEye: {
        get: function() {
            return MN(this), this._modelViewRelativeToEye
        }
    },
    inverseModelView: {
        get: function() {
            return RN(this), this._inverseModelView
        }
    },
    inverseModelView3D: {
        get: function() {
            return DN(this), this._inverseModelView3D
        }
    },
    viewProjection: {
        get: function() {
            return IN(this), this._viewProjection
        }
    },
    inverseViewProjection: {
        get: function() {
            return PN(this), this._inverseViewProjection
        }
    },
    modelViewProjection: {
        get: function() {
            return ON(this), this._modelViewProjection
        }
    },
    inverseModelViewProjection: {
        get: function() {
            return NN(this), this._inverseModelViewProjection
        }
    },
    modelViewProjectionRelativeToEye: {
        get: function() {
            return bN(this), this._modelViewProjectionRelativeToEye
        }
    },
    modelViewInfiniteProjection: {
        get: function() {
            return FN(this), this._modelViewInfiniteProjection
        }
    },
    normal: {
        get: function() {
            return LN(this), this._normal
        }
    },
    normal3D: {
        get: function() {
            return UN(this), this._normal3D
        }
    },
    inverseNormal: {
        get: function() {
            return zN(this), this._inverseNormal
        }
    },
    inverseNormal3D: {
        get: function() {
            return BN(this), this._inverseNormal3D
        }
    },
    entireFrustum: {
        get: function() {
            return this._entireFrustum
        }
    },
    currentFrustum: {
        get: function() {
            return this._currentFrustum
        }
    },
    frustumPlanes: {
        get: function() {
            return this._frustumPlanes
        }
    },
    farDepthFromNearPlusOne: {
        get: function() {
            return this._farDepthFromNearPlusOne
        }
    },
    log2FarDepthFromNearPlusOne: {
        get: function() {
            return this._log2FarDepthFromNearPlusOne
        }
    },
    oneOverLog2FarDepthFromNearPlusOne: {
        get: function() {
            return this._oneOverLog2FarDepthFromNearPlusOne
        }
    },
    eyeHeight: {
        get: function() {
            return this._eyeHeight
        }
    },
    eyeHeight2D: {
        get: function() {
            return this._eyeHeight2D
        }
    },
    sunPositionWC: {
        get: function() {
            return this._sunPositionWC
        }
    },
    sunPositionColumbusView: {
        get: function() {
            return this._sunPositionColumbusView
        }
    },
    sunDirectionWC: {
        get: function() {
            return this._sunDirectionWC
        }
    },
    sunDirectionEC: {
        get: function() {
            return this._sunDirectionEC
        }
    },
    moonDirectionEC: {
        get: function() {
            return this._moonDirectionEC
        }
    },
    lightDirectionWC: {
        get: function() {
            return this._lightDirectionWC
        }
    },
    lightDirectionEC: {
        get: function() {
            return this._lightDirectionEC
        }
    },
    lightColor: {
        get: function() {
            return this._lightColor
        }
    },
    lightColorHdr: {
        get: function() {
            return this._lightColorHdr
        }
    },
    encodedCameraPositionMCHigh: {
        get: function() {
            return wm(this), this._encodedCameraPositionMC.high
        }
    },
    encodedCameraPositionMCLow: {
        get: function() {
            return wm(this), this._encodedCameraPositionMC.low
        }
    },
    temeToPseudoFixedMatrix: {
        get: function() {
            return this._temeToPseudoFixed
        }
    },
    pixelRatio: {
        get: function() {
            return this._pixelRatio
        }
    },
    fogDensity: {
        get: function() {
            return this._fogDensity
        }
    },
    geometricToleranceOverMeter: {
        get: function() {
            return this._geometricToleranceOverMeter
        }
    },
    pass: {
        get: function() {
            return this._pass
        }
    },
    backgroundColor: {
        get: function() {
            return this._backgroundColor
        }
    },
    brdfLut: {
        get: function() {
            return this._brdfLut
        }
    },
    environmentMap: {
        get: function() {
            return this._environmentMap
        }
    },
    sphericalHarmonicCoefficients: {
        get: function() {
            return this._sphericalHarmonicCoefficients
        }
    },
    specularEnvironmentMaps: {
        get: function() {
            return this._specularEnvironmentMaps
        }
    },
    specularEnvironmentMapsDimensions: {
        get: function() {
            return this._specularEnvironmentMapsDimensions
        }
    },
    specularEnvironmentMapsMaximumLOD: {
        get: function() {
            return this._specularEnvironmentMapsMaximumLOD
        }
    },
    imagerySplitPosition: {
        get: function() {
            return this._imagerySplitPosition
        }
    },
    minimumDisableDepthTestDistance: {
        get: function() {
            return this._minimumDisableDepthTestDistance
        }
    },
    invertClassificationColor: {
        get: function() {
            return this._invertClassificationColor
        }
    },
    orthographicIn3D: {
        get: function() {
            return this._orthographicIn3D
        }
    },
    ellipsoid: {
        get: function() {
            return p(this._ellipsoid, ne.WGS84)
        }
    }
});

function pN(e, t) {
    S.clone(t, e._view), S.getMatrix3(t, e._viewRotation), e._view3DDirty = !0, e._inverseView3DDirty = !0, e._modelViewDirty = !0, e._modelView3DDirty = !0, e._modelViewRelativeToEyeDirty = !0, e._inverseModelViewDirty = !0, e._inverseModelView3DDirty = !0, e._viewProjectionDirty = !0, e._inverseViewProjectionDirty = !0, e._modelViewProjectionDirty = !0, e._modelViewProjectionRelativeToEyeDirty = !0, e._modelViewInfiniteProjectionDirty = !0, e._normalDirty = !0, e._inverseNormalDirty = !0, e._normal3DDirty = !0, e._inverseNormal3DDirty = !0
}

function gN(e, t) {
    S.clone(t, e._inverseView), S.getMatrix3(t, e._inverseViewRotation)
}

function yN(e, t) {
    S.clone(t, e._projection), e._inverseProjectionDirty = !0, e._viewProjectionDirty = !0, e._inverseViewProjectionDirty = !0, e._modelViewProjectionDirty = !0, e._modelViewProjectionRelativeToEyeDirty = !0
}

function TN(e, t) {
    S.clone(t, e._infiniteProjection), e._modelViewInfiniteProjectionDirty = !0
}

function EN(e, t) {
    u.clone(t.positionWC, e._cameraPosition), u.clone(t.directionWC, e._cameraDirection), u.clone(t.rightWC, e._cameraRight), u.clone(t.upWC, e._cameraUp);
    var n = t.positionCartographic;
    l(n) ? e._eyeHeight = n.height : e._eyeHeight = -e._ellipsoid.maximumRadius, e._encodedCameraPositionMCDirty = !0
}
Lo.prototype.updateCamera = function(e) {
    pN(this, e.viewMatrix), gN(this, e.inverseViewMatrix), EN(this, e), this._entireFrustum.x = e.frustum.near, this._entireFrustum.y = e.frustum.far, this.updateFrustum(e.frustum), this._orthographicIn3D = this._mode !== k.SCENE2D && e.frustum instanceof lt
};
Lo.prototype.updateFrustum = function(e) {
    yN(this, e.projectionMatrix), l(e.infiniteProjectionMatrix) && TN(this, e.infiniteProjectionMatrix), this._currentFrustum.x = e.near, this._currentFrustum.y = e.far, this._farDepthFromNearPlusOne = e.far - e.near + 1, this._log2FarDepthFromNearPlusOne = T.log2(this._farDepthFromNearPlusOne), this._oneOverLog2FarDepthFromNearPlusOne = 1 / this._log2FarDepthFromNearPlusOne, l(e._offCenterFrustum) && (e = e._offCenterFrustum), this._frustumPlanes.x = e.top, this._frustumPlanes.y = e.bottom, this._frustumPlanes.z = e.left, this._frustumPlanes.w = e.right
};
Lo.prototype.updatePass = function(e) {
    this._pass = e
};
var AN = [],
    CN = new qy;
Lo.prototype.update = function(e) {
    this._mode = e.mode, this._mapProjection = e.mapProjection, this._ellipsoid = e.mapProjection.ellipsoid, this._pixelRatio = e.pixelRatio;
    var t = e.camera;
    this.updateCamera(t), e.mode === k.SCENE2D ? (this._frustum2DWidth = t.frustum.right - t.frustum.left, this._eyeHeight2D.x = this._frustum2DWidth * .5, this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x) : (this._frustum2DWidth = 0, this._eyeHeight2D.x = 0, this._eyeHeight2D.y = 0);
    var n = p(e.light, CN);
    n instanceof qy ? (this._lightDirectionWC = u.clone(this._sunDirectionWC, this._lightDirectionWC), this._lightDirectionEC = u.clone(this._sunDirectionEC, this._lightDirectionEC)) : (this._lightDirectionWC = u.normalize(u.negate(n.direction, this._lightDirectionWC), this._lightDirectionWC), this._lightDirectionEC = N.multiplyByVector(this.viewRotation3D, this._lightDirectionWC, this._lightDirectionEC));
    var r = n.color,
        i = u.fromElements(r.red, r.green, r.blue, this._lightColorHdr);
    i = u.multiplyByScalar(i, n.intensity, i);
    var a = u.maximumComponent(i);
    a > 1 ? u.divideByScalar(i, a, this._lightColor) : u.clone(i, this._lightColor);
    var o = e.brdfLutGenerator,
        s = l(o) ? o.colorTexture : void 0;
    this._brdfLut = s, this._environmentMap = p(e.environmentMap, e.context.defaultCubeMap), this._sphericalHarmonicCoefficients = p(e.sphericalHarmonicCoefficients, AN), this._specularEnvironmentMaps = e.specularEnvironmentMaps, this._specularEnvironmentMapsMaximumLOD = e.specularEnvironmentMapsMaximumLOD, l(this._specularEnvironmentMaps) && R.clone(this._specularEnvironmentMaps.dimensions, this._specularEnvironmentMapsDimensions), this._fogDensity = e.fog.density, this._invertClassificationColor = e.invertClassificationColor, this._frameState = e, this._temeToPseudoFixed = xe.computeTemeToPseudoFixedMatrix(e.time, this._temeToPseudoFixed), this._imagerySplitPosition = e.imagerySplitPosition * e.context.drawingBufferWidth;
    var c = t.frustum.fov,
        f = this._viewport,
        h;
    l(c) ? f.height > f.width ? h = Math.tan(.5 * c) * 2 / f.height : h = Math.tan(.5 * c) * 2 / f.width : h = 1 / Math.max(f.width, f.height), this._geometricToleranceOverMeter = h * e.maximumScreenSpaceError, H.clone(e.backgroundColor, this._backgroundColor), this._minimumDisableDepthTestDistance = e.minimumDisableDepthTestDistance, this._minimumDisableDepthTestDistance *= this._minimumDisableDepthTestDistance, this._minimumDisableDepthTestDistance === Number.POSITIVE_INFINITY && (this._minimumDisableDepthTestDistance = -1)
};

function Am(e) {
    if (e._viewportDirty) {
        var t = e._viewport;
        S.computeOrthographicOffCenter(t.x, t.x + t.width, t.y, t.y + t.height, 0, 1, e._viewportOrthographicMatrix), S.computeViewportTransformation(t, 0, 1, e._viewportTransformation), e._viewportDirty = !1
    }
}

function wN(e) {
    e._inverseProjectionDirty && (e._inverseProjectionDirty = !1, e._mode !== k.SCENE2D && e._mode !== k.MORPHING && !e._orthographicIn3D ? S.inverse(e._projection, e._inverseProjection) : S.clone(S.ZERO, e._inverseProjection))
}

function xN(e) {
    e._modelViewDirty && (e._modelViewDirty = !1, S.multiplyTransformation(e._view, e._model, e._modelView))
}

function SN(e) {
    e._modelView3DDirty && (e._modelView3DDirty = !1, S.multiplyTransformation(e.view3D, e._model, e._modelView3D))
}

function RN(e) {
    e._inverseModelViewDirty && (e._inverseModelViewDirty = !1, S.inverse(e.modelView, e._inverseModelView))
}

function DN(e) {
    e._inverseModelView3DDirty && (e._inverseModelView3DDirty = !1, S.inverse(e.modelView3D, e._inverseModelView3D))
}

function IN(e) {
    e._viewProjectionDirty && (e._viewProjectionDirty = !1, S.multiply(e._projection, e._view, e._viewProjection))
}

function PN(e) {
    e._inverseViewProjectionDirty && (e._inverseViewProjectionDirty = !1, S.inverse(e.viewProjection, e._inverseViewProjection))
}

function ON(e) {
    e._modelViewProjectionDirty && (e._modelViewProjectionDirty = !1, S.multiply(e._projection, e.modelView, e._modelViewProjection))
}

function MN(e) {
    if (e._modelViewRelativeToEyeDirty) {
        e._modelViewRelativeToEyeDirty = !1;
        var t = e.modelView,
            n = e._modelViewRelativeToEye;
        n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = 0, n[13] = 0, n[14] = 0, n[15] = t[15]
    }
}

function NN(e) {
    e._inverseModelViewProjectionDirty && (e._inverseModelViewProjectionDirty = !1, S.inverse(e.modelViewProjection, e._inverseModelViewProjection))
}

function bN(e) {
    e._modelViewProjectionRelativeToEyeDirty && (e._modelViewProjectionRelativeToEyeDirty = !1, S.multiply(e._projection, e.modelViewRelativeToEye, e._modelViewProjectionRelativeToEye))
}

function FN(e) {
    e._modelViewInfiniteProjectionDirty && (e._modelViewInfiniteProjectionDirty = !1, S.multiply(e._infiniteProjection, e.modelView, e._modelViewInfiniteProjection))
}

function LN(e) {
    if (e._normalDirty) {
        e._normalDirty = !1;
        var t = e._normal;
        S.getMatrix3(e.inverseModelView, t), N.getRotation(t, t), N.transpose(t, t)
    }
}

function UN(e) {
    if (e._normal3DDirty) {
        e._normal3DDirty = !1;
        var t = e._normal3D;
        S.getMatrix3(e.inverseModelView3D, t), N.getRotation(t, t), N.transpose(t, t)
    }
}

function zN(e) {
    e._inverseNormalDirty && (e._inverseNormalDirty = !1, S.getMatrix3(e.inverseModelView, e._inverseNormal), N.getRotation(e._inverseNormal, e._inverseNormal))
}

function BN(e) {
    e._inverseNormal3DDirty && (e._inverseNormal3DDirty = !1, S.getMatrix3(e.inverseModelView3D, e._inverseNormal3D), N.getRotation(e._inverseNormal3D, e._inverseNormal3D))
}
var Cm = new u;

function wm(e) {
    e._encodedCameraPositionMCDirty && (e._encodedCameraPositionMCDirty = !1, S.multiplyByPoint(e.inverseModel, e._cameraPosition, Cm), rn.fromCartesian(Cm, e._encodedCameraPositionMC))
}
var VN = new u,
    GN = new u,
    HN = new u,
    kN = new u,
    WN = new K,
    qN = new u,
    YN = new S;

function XN(e, t, n, r, i, a, o, s) {
    var c = VN;
    c.x = e.y, c.y = e.z, c.z = e.x;
    var f = GN;
    f.x = n.y, f.y = n.z, f.z = n.x;
    var h = HN;
    h.x = r.y, h.y = r.z, h.z = r.x;
    var d = kN;
    d.x = t.y, d.y = t.z, d.z = t.x, a === k.SCENE2D && (c.z = i * .5);
    var _ = o.unproject(c, WN);
    _.longitude = T.clamp(_.longitude, -Math.PI, Math.PI), _.latitude = T.clamp(_.latitude, -T.PI_OVER_TWO, T.PI_OVER_TWO);
    var v = o.ellipsoid,
        m = v.cartographicToCartesian(_, qN),
        g = xe.eastNorthUpToFixedFrame(m, v, YN);
    return S.multiplyByPointAsVector(g, f, f), S.multiplyByPointAsVector(g, h, h), S.multiplyByPointAsVector(g, d, d), l(s) || (s = new S), s[0] = f.x, s[1] = h.x, s[2] = -d.x, s[3] = 0, s[4] = f.y, s[5] = h.y, s[6] = -d.y, s[7] = 0, s[8] = f.z, s[9] = h.z, s[10] = -d.z, s[11] = 0, s[12] = -u.dot(f, m), s[13] = -u.dot(h, m), s[14] = u.dot(d, m), s[15] = 1, s
}

function Oh(e) {
    e._view3DDirty && (e._mode === k.SCENE3D ? S.clone(e._view, e._view3D) : XN(e._cameraPosition, e._cameraDirection, e._cameraRight, e._cameraUp, e._frustum2DWidth, e._mode, e._mapProjection, e._view3D), S.getMatrix3(e._view3D, e._viewRotation3D), e._view3DDirty = !1)
}

function xm(e) {
    e._inverseView3DDirty && (S.inverseTransformation(e.view3D, e._inverseView3D), S.getMatrix3(e._inverseView3D, e._inverseViewRotation3D), e._inverseView3DDirty = !1)
}

function jN(e, t) {
    var n = "WebGL Error:  ";
    switch (t) {
        case e.INVALID_ENUM:
            n += "INVALID_ENUM";
            break;
        case e.INVALID_VALUE:
            n += "INVALID_VALUE";
            break;
        case e.INVALID_OPERATION:
            n += "INVALID_OPERATION";
            break;
        case e.OUT_OF_MEMORY:
            n += "OUT_OF_MEMORY";
            break;
        case e.CONTEXT_LOST_WEBGL:
            n += "CONTEXT_LOST_WEBGL lost";
            break;
        default:
            n += "Unknown (" + t + ")"
    }
    return n
}

function ZN(e, t, n, r) {
    for (var i = jN(e, r) + ": " + t.name + "(", a = 0; a < n.length; ++a) a !== 0 && (i += ", "), i += n[a];
    return i += ");", i
}

function KN(e, t, n) {
    var r = e.getError();
    if (r !== e.NO_ERROR) throw new je(ZN(e, t, n, r))
}

function $N(e, t, n) {
    return {
        get: function() {
            var r = e[t];
            return n(e, "get: " + t, r), e[t]
        },
        set: function(r) {
            e[t] = r, n(e, "set: " + t, r)
        }
    }
}

function JN(e, t) {
    if (!l(t)) return e;

    function n(o) {
        return function() {
            var s = o.apply(e, arguments);
            return t(e, o, arguments), s
        }
    }
    var r = {};
    for (var i in e) {
        var a = e[i];
        a instanceof Function ? r[i] = n(a) : Object.defineProperty(r, i, $N(e, i, t))
    }
    return r
}

function zt(e, t) {
    for (var n = t.length, r = 0; r < n; ++r) {
        var i = e.getExtension(t[r]);
        if (i) return i
    }
}

function wr(e, t) {
    if (typeof WebGLRenderingContext > "u") throw new je("The browser does not support WebGL.  Visit http://get.webgl.org.");
    this._canvas = e, t = sn(t, !0), t = p(t, {}), t.allowTextureFilterAnisotropic = p(t.allowTextureFilterAnisotropic, !0);
    var n = p(t.webgl, {});
    n.alpha = p(n.alpha, !1), n.stencil = p(n.stencil, !0);
    var r = p(t.requestWebgl2, !1) && typeof WebGL2RenderingContext < "u",
        i = !1,
        a, o = t.getWebGLStub;
    if (l(o)) a = o(e, n);
    else if (r && (a = e.getContext("webgl2", n) || e.getContext("experimental-webgl2", n) || void 0, l(a) && (i = !0)), l(a) || (a = e.getContext("webgl", n) || e.getContext("experimental-webgl", n) || void 0), !l(a)) throw new je("The browser supports WebGL, but initialization failed.");
    this._originalGLContext = a, this._gl = a, this._webgl2 = i, this._id = Oi(), this.validateFramebuffer = !1, this.validateShaderProgram = !1, this.logShaderCompilation = !1, this._throwOnWebGLError = !1, this._shaderCache = new kr(this), this._textureCache = new Ga;
    var s = a;
    this._stencilBits = s.getParameter(s.STENCIL_BITS), pe._maximumCombinedTextureImageUnits = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS), pe._maximumCubeMapSize = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), pe._maximumFragmentUniformVectors = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), pe._maximumTextureImageUnits = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), pe._maximumRenderbufferSize = s.getParameter(s.MAX_RENDERBUFFER_SIZE), pe._maximumTextureSize = s.getParameter(s.MAX_TEXTURE_SIZE), pe._maximumVaryingVectors = s.getParameter(s.MAX_VARYING_VECTORS), pe._maximumVertexAttributes = s.getParameter(s.MAX_VERTEX_ATTRIBS), pe._maximumVertexTextureImageUnits = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), pe._maximumVertexUniformVectors = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS);
    var c = s.getParameter(s.ALIASED_LINE_WIDTH_RANGE);
    pe._minimumAliasedLineWidth = c[0], pe._maximumAliasedLineWidth = c[1];
    var f = s.getParameter(s.ALIASED_POINT_SIZE_RANGE);
    pe._minimumAliasedPointSize = f[0], pe._maximumAliasedPointSize = f[1];
    var h = s.getParameter(s.MAX_VIEWPORT_DIMS);
    pe._maximumViewportWidth = h[0], pe._maximumViewportHeight = h[1];
    var d = s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT);
    pe._highpFloatSupported = d.precision !== 0;
    var _ = s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_INT);
    pe._highpIntSupported = _.rangeMax !== 0, this._antialias = s.getContextAttributes().antialias, this._standardDerivatives = !!zt(s, ["OES_standard_derivatives"]), this._blendMinmax = !!zt(s, ["EXT_blend_minmax"]), this._elementIndexUint = !!zt(s, ["OES_element_index_uint"]), this._depthTexture = !!zt(s, ["WEBGL_depth_texture", "WEBKIT_WEBGL_depth_texture"]), this._fragDepth = !!zt(s, ["EXT_frag_depth"]), this._debugShaders = zt(s, ["WEBGL_debug_shaders"]), this._textureFloat = !!zt(s, ["OES_texture_float"]), this._textureHalfFloat = !!zt(s, ["OES_texture_half_float"]), this._textureFloatLinear = !!zt(s, ["OES_texture_float_linear"]), this._textureHalfFloatLinear = !!zt(s, ["OES_texture_half_float_linear"]), this._colorBufferFloat = !!zt(s, ["EXT_color_buffer_float", "WEBGL_color_buffer_float"]), this._floatBlend = !!zt(s, ["EXT_float_blend"]), this._colorBufferHalfFloat = !!zt(s, ["EXT_color_buffer_half_float"]), this._s3tc = !!zt(s, ["WEBGL_compressed_texture_s3tc", "MOZ_WEBGL_compressed_texture_s3tc", "WEBKIT_WEBGL_compressed_texture_s3tc"]), this._pvrtc = !!zt(s, ["WEBGL_compressed_texture_pvrtc", "WEBKIT_WEBGL_compressed_texture_pvrtc"]), this._etc1 = !!zt(s, ["WEBGL_compressed_texture_etc1"]);
    var v = t.allowTextureFilterAnisotropic ? zt(s, ["EXT_texture_filter_anisotropic", "WEBKIT_EXT_texture_filter_anisotropic"]) : void 0;
    this._textureFilterAnisotropic = v, pe._maximumTextureFilterAnisotropy = l(v) ? s.getParameter(v.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
    var m, g, y, E, w, C, A, x, P, I;
    if (i) {
        var D = this;
        m = function() {
            return D._gl.createVertexArray()
        }, g = function(M) {
            D._gl.bindVertexArray(M)
        }, y = function(M) {
            D._gl.deleteVertexArray(M)
        }, E = function(M, G, V, B, Y) {
            s.drawElementsInstanced(M, G, V, B, Y)
        }, w = function(M, G, V, B) {
            s.drawArraysInstanced(M, G, V, B)
        }, C = function(M, G) {
            s.vertexAttribDivisor(M, G)
        }, A = function(M) {
            s.drawBuffers(M)
        }
    } else x = zt(s, ["OES_vertex_array_object"]), l(x) && (m = function() {
        return x.createVertexArrayOES()
    }, g = function(M) {
        x.bindVertexArrayOES(M)
    }, y = function(M) {
        x.deleteVertexArrayOES(M)
    }), P = zt(s, ["ANGLE_instanced_arrays"]), l(P) && (E = function(M, G, V, B, Y) {
        P.drawElementsInstancedANGLE(M, G, V, B, Y)
    }, w = function(M, G, V, B) {
        P.drawArraysInstancedANGLE(M, G, V, B)
    }, C = function(M, G) {
        P.vertexAttribDivisorANGLE(M, G)
    }), I = zt(s, ["WEBGL_draw_buffers"]), l(I) && (A = function(M) {
        I.drawBuffersWEBGL(M)
    });
    this.glCreateVertexArray = m, this.glBindVertexArray = g, this.glDeleteVertexArray = y, this.glDrawElementsInstanced = E, this.glDrawArraysInstanced = w, this.glVertexAttribDivisor = C, this.glDrawBuffers = A, this._vertexArrayObject = !!x, this._instancedArrays = !!P, this._drawBuffers = !!I, pe._maximumDrawBuffers = this.drawBuffers ? s.getParameter(L.MAX_DRAW_BUFFERS) : 1, pe._maximumColorAttachments = this.drawBuffers ? s.getParameter(L.MAX_COLOR_ATTACHMENTS) : 1, this._clearColor = new H(0, 0, 0, 0), this._clearDepth = 1, this._clearStencil = 0;
    var O = new Lo,
        F = new rf(this),
        z = Ge.fromCache();
    this._defaultPassState = F, this._defaultRenderState = z, this._defaultTexture = void 0, this._defaultCubeMap = void 0, this._us = O, this._currentRenderState = z, this._currentPassState = F, this._currentFramebuffer = void 0, this._maxFrameTextureUnitIndex = 0, this._vertexAttribDivisors = [], this._previousDrawInstanced = !1;
    for (var b = 0; b < pe._maximumVertexAttributes; b++) this._vertexAttribDivisors.push(0);
    this._pickObjects = {}, this._nextPickColor = new Uint32Array(1), this.options = t, this.cache = {}, Ge.apply(s, z, F)
}
var QN = {};
Object.defineProperties(wr.prototype, {
    id: {
        get: function() {
            return this._id
        }
    },
    webgl2: {
        get: function() {
            return this._webgl2
        }
    },
    canvas: {
        get: function() {
            return this._canvas
        }
    },
    shaderCache: {
        get: function() {
            return this._shaderCache
        }
    },
    textureCache: {
        get: function() {
            return this._textureCache
        }
    },
    uniformState: {
        get: function() {
            return this._us
        }
    },
    stencilBits: {
        get: function() {
            return this._stencilBits
        }
    },
    stencilBuffer: {
        get: function() {
            return this._stencilBits >= 8
        }
    },
    antialias: {
        get: function() {
            return this._antialias
        }
    },
    standardDerivatives: {
        get: function() {
            return this._standardDerivatives || this._webgl2
        }
    },
    floatBlend: {
        get: function() {
            return this._floatBlend
        }
    },
    blendMinmax: {
        get: function() {
            return this._blendMinmax || this._webgl2
        }
    },
    elementIndexUint: {
        get: function() {
            return this._elementIndexUint || this._webgl2
        }
    },
    depthTexture: {
        get: function() {
            return this._depthTexture || this._webgl2
        }
    },
    floatingPointTexture: {
        get: function() {
            return this._webgl2 || this._textureFloat
        }
    },
    halfFloatingPointTexture: {
        get: function() {
            return this._webgl2 || this._textureHalfFloat
        }
    },
    textureFloatLinear: {
        get: function() {
            return this._textureFloatLinear
        }
    },
    textureHalfFloatLinear: {
        get: function() {
            return this._webgl2 && this._textureFloatLinear || !this._webgl2 && this._textureHalfFloatLinear
        }
    },
    textureFilterAnisotropic: {
        get: function() {
            return !!this._textureFilterAnisotropic
        }
    },
    s3tc: {
        get: function() {
            return this._s3tc
        }
    },
    pvrtc: {
        get: function() {
            return this._pvrtc
        }
    },
    etc1: {
        get: function() {
            return this._etc1
        }
    },
    vertexArrayObject: {
        get: function() {
            return this._vertexArrayObject || this._webgl2
        }
    },
    fragmentDepth: {
        get: function() {
            return this._fragDepth || this._webgl2
        }
    },
    instancedArrays: {
        get: function() {
            return this._instancedArrays || this._webgl2
        }
    },
    colorBufferFloat: {
        get: function() {
            return this._colorBufferFloat
        }
    },
    colorBufferHalfFloat: {
        get: function() {
            return this._webgl2 && this._colorBufferFloat || !this._webgl2 && this._colorBufferHalfFloat
        }
    },
    drawBuffers: {
        get: function() {
            return this._drawBuffers || this._webgl2
        }
    },
    debugShaders: {
        get: function() {
            return this._debugShaders
        }
    },
    throwOnWebGLError: {
        get: function() {
            return this._throwOnWebGLError
        },
        set: function(e) {
            this._throwOnWebGLError = e, this._gl = JN(this._originalGLContext, e ? KN : void 0)
        }
    },
    defaultTexture: {
        get: function() {
            return this._defaultTexture === void 0 && (this._defaultTexture = new be({
                context: this,
                source: {
                    width: 1,
                    height: 1,
                    arrayBufferView: new Uint8Array([255, 255, 255, 255])
                },
                flipY: !1
            })), this._defaultTexture
        }
    },
    defaultCubeMap: {
        get: function() {
            if (this._defaultCubeMap === void 0) {
                var e = {
                    width: 1,
                    height: 1,
                    arrayBufferView: new Uint8Array([255, 255, 255, 255])
                };
                this._defaultCubeMap = new Fo({
                    context: this,
                    source: {
                        positiveX: e,
                        negativeX: e,
                        positiveY: e,
                        negativeY: e,
                        positiveZ: e,
                        negativeZ: e
                    },
                    flipY: !1
                })
            }
            return this._defaultCubeMap
        }
    },
    drawingBufferHeight: {
        get: function() {
            return this._gl.drawingBufferHeight
        }
    },
    drawingBufferWidth: {
        get: function() {
            return this._gl.drawingBufferWidth
        }
    },
    defaultFramebuffer: {
        get: function() {
            return QN
        }
    }
});

function Yy(e, t, n, r) {
    var i = e._currentRenderState,
        a = e._currentPassState;
    e._currentRenderState = t, e._currentPassState = n, Ge.partialApply(e._gl, i, t, a, n, r)
}
var Nd;
typeof WebGLRenderingContext < "u" && (Nd = [L.BACK]);

function bd(e, t) {
    if (t !== e._currentFramebuffer) {
        e._currentFramebuffer = t;
        var n = Nd;
        if (l(t)) t._bind(), n = t._getActiveColorAttachments();
        else {
            var r = e._gl;
            r.bindFramebuffer(r.FRAMEBUFFER, null)
        }
        e.drawBuffers && e.glDrawBuffers(n)
    }
}
var eb = new on;
wr.prototype.clear = function(e, t) {
    e = p(e, eb), t = p(t, this._defaultPassState);
    var n = this._gl,
        r = 0,
        i = e.color,
        a = e.depth,
        o = e.stencil;
    l(i) && (H.equals(this._clearColor, i) || (H.clone(i, this._clearColor), n.clearColor(i.red, i.green, i.blue, i.alpha)), r |= n.COLOR_BUFFER_BIT), l(a) && (a !== this._clearDepth && (this._clearDepth = a, n.clearDepth(a)), r |= n.DEPTH_BUFFER_BIT), l(o) && (o !== this._clearStencil && (this._clearStencil = o, n.clearStencil(o)), r |= n.STENCIL_BUFFER_BIT);
    var s = p(e.renderState, this._defaultRenderState);
    Yy(this, s, t, !0);
    var c = p(e.framebuffer, t.framebuffer);
    bd(this, c), n.clear(r)
};

function tb(e, t, n, r, i) {
    bd(e, t), Yy(e, i, n, !1), r._bind(), e._maxFrameTextureUnitIndex = Math.max(e._maxFrameTextureUnitIndex, r.maximumTextureUnitIndex)
}

function nb(e, t, n, r) {
    var i = t._primitiveType,
        a = t._vertexArray,
        o = t._offset,
        s = t._count,
        c = t.instanceCount;
    e._us.model = p(t._modelMatrix, S.IDENTITY), n._setUniforms(r, e._us, e.validateShaderProgram), a._bind();
    var f = a.indexBuffer;
    l(f) ? (o = o * f.bytesPerIndex, s = p(s, f.numberOfIndices), c === 0 ? e._gl.drawElements(i, s, f.indexDatatype, o) : e.glDrawElementsInstanced(i, s, f.indexDatatype, o, c)) : (s = p(s, a.numberOfVertices), c === 0 ? e._gl.drawArrays(i, o, s) : e.glDrawArraysInstanced(i, o, s, c)), a._unBind()
}
wr.prototype.draw = function(e, t, n, r) {
    t = p(t, this._defaultPassState);
    var i = p(e._framebuffer, t.framebuffer),
        a = p(e._renderState, this._defaultRenderState);
    n = p(n, e._shaderProgram), r = p(r, e._uniformMap), tb(this, i, t, n, a), nb(this, e, n, r)
};
wr.prototype.endFrame = function() {
    var e = this._gl;
    e.useProgram(null), this._currentFramebuffer = void 0, e.bindFramebuffer(e.FRAMEBUFFER, null);
    var t = Nd;
    this.drawBuffers && this.glDrawBuffers(t);
    var n = this._maxFrameTextureUnitIndex;
    this._maxFrameTextureUnitIndex = 0;
    for (var r = 0; r < n; ++r) e.activeTexture(e.TEXTURE0 + r), e.bindTexture(e.TEXTURE_2D, null), e.bindTexture(e.TEXTURE_CUBE_MAP, null)
};
wr.prototype.readPixels = function(e) {
    var t = this._gl;
    e = p(e, p.EMPTY_OBJECT);
    var n = Math.max(p(e.x, 0), 0),
        r = Math.max(p(e.y, 0), 0),
        i = p(e.width, t.drawingBufferWidth),
        a = p(e.height, t.drawingBufferHeight),
        o = e.framebuffer,
        s = ae.UNSIGNED_BYTE;
    l(o) && o.numberOfColorAttachments > 0 && (s = o.getColorTexture(0).pixelDatatype);
    var c = de.createTypedArray(de.RGBA, s, i, a);
    return bd(this, o), t.readPixels(n, r, i, a, de.RGBA, ae.toWebGLConstant(s, this), c), c
};
var Xy = {
    position: 0,
    textureCoordinates: 1
};
wr.prototype.getViewportQuadVertexArray = function() {
    var e = this.cache.viewportQuad_vertexArray;
    if (!l(e)) {
        var t = new rt({
            attributes: {
                position: new ze({
                    componentDatatype: ee.FLOAT,
                    componentsPerAttribute: 2,
                    values: [-1, -1, 1, -1, 1, 1, -1, 1]
                }),
                textureCoordinates: new ze({
                    componentDatatype: ee.FLOAT,
                    componentsPerAttribute: 2,
                    values: [0, 0, 1, 0, 1, 1, 0, 1]
                })
            },
            indices: new Uint16Array([0, 1, 2, 0, 2, 3]),
            primitiveType: Ve.TRIANGLES
        });
        e = Cn.fromGeometry({
            context: this,
            geometry: t,
            attributeLocations: Xy,
            bufferUsage: Ye.STATIC_DRAW,
            interleave: !0
        }), this.cache.viewportQuad_vertexArray = e
    }
    return e
};
wr.prototype.createViewportQuadCommand = function(e, t) {
    return t = p(t, p.EMPTY_OBJECT), new an({
        vertexArray: this.getViewportQuadVertexArray(),
        primitiveType: Ve.TRIANGLES,
        renderState: t.renderState,
        shaderProgram: Mt.fromCache({
            context: this,
            vertexShaderSource: Wy,
            fragmentShaderSource: e,
            attributeLocations: Xy
        }),
        uniformMap: t.uniformMap,
        owner: t.owner,
        framebuffer: t.framebuffer,
        pass: t.pass
    })
};
wr.prototype.getObjectByPickColor = function(e) {
    return this._pickObjects[e.toRgba()]
};

function Fd(e, t, n) {
    this._pickObjects = e, this.key = t, this.color = n
}
Object.defineProperties(Fd.prototype, {
    object: {
        get: function() {
            return this._pickObjects[this.key]
        },
        set: function(e) {
            this._pickObjects[this.key] = e
        }
    }
});
Fd.prototype.destroy = function() {
    delete this._pickObjects[this.key]
};
wr.prototype.createPickId = function(e) {
    ++this._nextPickColor[0];
    var t = this._nextPickColor[0];
    if (t === 0) throw new je("Out of unique Pick IDs.");
    return this._pickObjects[t] = e, new Fd(this._pickObjects, t, H.fromRgba(t))
};
wr.prototype.isDestroyed = function() {
    return !1
};
wr.prototype.destroy = function() {
    var e = this.cache;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var n = e[t];
            l(n.destroy) && n.destroy()
        }
    return this._shaderCache = this._shaderCache.destroy(), this._textureCache = this._textureCache.destroy(), this._defaultTexture = this._defaultTexture && this._defaultTexture.destroy(), this._defaultCubeMap = this._defaultCubeMap && this._defaultCubeMap.destroy(), Pe(this)
};
const rb = `varying vec2 v_textureCoordinates;
const float M_PI = 3.141592653589793;
float vdcRadicalInverse(int i)
{
float r;
float base = 2.0;
float value = 0.0;
float invBase = 1.0 / base;
float invBi = invBase;
for (int x = 0; x < 100; x++)
{
if (i <= 0)
{
break;
}
r = mod(float(i), base);
value += r * invBi;
invBi *= invBase;
i = int(float(i) * invBase);
}
return value;
}
vec2 hammersley2D(int i, int N)
{
return vec2(float(i) / float(N), vdcRadicalInverse(i));
}
vec3 importanceSampleGGX(vec2 xi, float roughness, vec3 N)
{
float a = roughness * roughness;
float phi = 2.0 * M_PI * xi.x;
float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));
float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
vec3 upVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
vec3 tangentX = normalize(cross(upVector, N));
vec3 tangentY = cross(N, tangentX);
return tangentX * H.x + tangentY * H.y + N * H.z;
}
float G1_Smith(float NdotV, float k)
{
return NdotV / (NdotV * (1.0 - k) + k);
}
float G_Smith(float roughness, float NdotV, float NdotL)
{
float k = roughness * roughness / 2.0;
return G1_Smith(NdotV, k) * G1_Smith(NdotL, k);
}
vec2 integrateBrdf(float roughness, float NdotV)
{
vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);
float A = 0.0;
float B = 0.0;
const int NumSamples = 1024;
for (int i = 0; i < NumSamples; i++)
{
vec2 xi = hammersley2D(i, NumSamples);
vec3 H = importanceSampleGGX(xi, roughness, vec3(0.0, 0.0, 1.0));
vec3 L = 2.0 * dot(V, H) * H - V;
float NdotL = clamp(L.z, 0.0, 1.0);
float NdotH = clamp(H.z, 0.0, 1.0);
float VdotH = clamp(dot(V, H), 0.0, 1.0);
if (NdotL > 0.0)
{
float G = G_Smith(roughness, NdotV, NdotL);
float G_Vis = G * VdotH / (NdotH * NdotV);
float Fc = pow(1.0 - VdotH, 5.0);
A += (1.0 - Fc) * G_Vis;
B += Fc * G_Vis;
}
}
return vec2(A, B) / float(NumSamples);
}
void main()
{
gl_FragColor = vec4(integrateBrdf(v_textureCoordinates.y, v_textureCoordinates.x), 0.0, 1.0);
}
`;

function Bs() {
    this._framebuffer = void 0, this._colorTexture = void 0, this._drawCommand = void 0
}
Object.defineProperties(Bs.prototype, {
    colorTexture: {
        get: function() {
            return this._colorTexture
        }
    }
});

function ib(e, t) {
    var n = e._framebuffer,
        r = t.createViewportQuadCommand(rb, {
            framebuffer: n,
            renderState: Ge.fromCache({
                viewport: new ge(0, 0, 256, 256)
            })
        });
    e._drawCommand = r
}

function ab(e, t) {
    var n = new be({
        context: t,
        width: 256,
        height: 256,
        pixelFormat: de.RGBA,
        pixelDatatype: ae.UNSIGNED_BYTE,
        sampler: gt.NEAREST
    });
    e._colorTexture = n;
    var r = new xt({
        context: t,
        colorTextures: [n],
        destroyAttachments: !1
    });
    e._framebuffer = r
}
Bs.prototype.update = function(e) {
    if (!l(this._colorTexture)) {
        var t = e.context;
        ab(this, t), ib(this, t), this._drawCommand.execute(t), this._framebuffer = this._framebuffer && this._framebuffer.destroy(), this._drawCommand.shaderProgram = this._drawCommand.shaderProgram && this._drawCommand.shaderProgram.destroy()
    }
};
Bs.prototype.isDestroyed = function() {
    return !1
};
Bs.prototype.destroy = function() {
    return this._colorTexture = this._colorTexture && this._colorTexture.destroy(), Pe(this)
};
Date.now === void 0 && (Date.now = function() {
    return new Date().valueOf()
});
var Se = Se || function() {
    var e = [];
    return {
        REVISION: "13",
        getAll: function() {
            return e
        },
        removeAll: function() {
            e = []
        },
        add: function(t) {
            e.push(t)
        },
        remove: function(t) {
            var n = e.indexOf(t);
            n !== -1 && e.splice(n, 1)
        },
        update: function(t) {
            if (e.length === 0) return !1;
            var n = 0;
            for (t = t !== void 0 ? t : typeof window < "u" && window.performance !== void 0 && window.performance.now !== void 0 ? window.performance.now() : Date.now(); n < e.length;) e[n].update(t) ? n++ : e.splice(n, 1);
            return !0
        }
    }
}();
Se.Tween = function(e) {
    var t = e,
        n = {},
        r = {},
        i = {},
        a = 1e3,
        o = 0,
        s = !1,
        c = !1,
        f = 0,
        h = null,
        d = Se.Easing.Linear.None,
        _ = Se.Interpolation.Linear,
        v = [],
        m = null,
        g = !1,
        y = null,
        E = null,
        w = null;
    for (var C in e) n[C] = parseFloat(e[C], 10);
    this.to = function(A, x) {
        return x !== void 0 && (a = x), r = A, this
    }, this.start = function(A) {
        Se.add(this), c = !0, g = !1, h = A !== void 0 ? A : typeof window < "u" && window.performance !== void 0 && window.performance.now !== void 0 ? window.performance.now() : Date.now(), h += f;
        for (var x in r) {
            if (r[x] instanceof Array) {
                if (r[x].length === 0) continue;
                r[x] = [t[x]].concat(r[x])
            }
            n[x] = t[x], n[x] instanceof Array || (n[x] *= 1), i[x] = n[x] || 0
        }
        return this
    }, this.stop = function() {
        return c ? (Se.remove(this), c = !1, w !== null && w.call(t), this.stopChainedTweens(), this) : this
    }, this.stopChainedTweens = function() {
        for (var A = 0, x = v.length; A < x; A++) v[A].stop()
    }, this.delay = function(A) {
        return f = A, this
    }, this.repeat = function(A) {
        return o = A, this
    }, this.yoyo = function(A) {
        return s = A, this
    }, this.easing = function(A) {
        return d = A, this
    }, this.interpolation = function(A) {
        return _ = A, this
    }, this.chain = function() {
        return v = arguments, this
    }, this.onStart = function(A) {
        return m = A, this
    }, this.onUpdate = function(A) {
        return y = A, this
    }, this.onComplete = function(A) {
        return E = A, this
    }, this.onStop = function(A) {
        return w = A, this
    }, this.update = function(A) {
        var x;
        if (A < h) return !0;
        g === !1 && (m !== null && m.call(t), g = !0);
        var P = (A - h) / a;
        P = P > 1 ? 1 : P;
        var I = d(P);
        for (x in r) {
            var D = n[x] || 0,
                O = r[x];
            O instanceof Array ? t[x] = _(O, I) : (typeof O == "string" && (O = D + parseFloat(O, 10)), typeof O == "number" && (t[x] = D + (O - D) * I))
        }
        if (y !== null && y.call(t, I), P == 1)
            if (o > 0) {
                isFinite(o) && o--;
                for (x in i) {
                    if (typeof r[x] == "string" && (i[x] = i[x] + parseFloat(r[x], 10)), s) {
                        var F = i[x];
                        i[x] = r[x], r[x] = F
                    }
                    n[x] = i[x]
                }
                return h = A + f, !0
            } else {
                E !== null && E.call(t);
                for (var z = 0, b = v.length; z < b; z++) v[z].start(A);
                return !1
            }
        return !0
    }
};
Se.Easing = {
    Linear: {
        None: function(e) {
            return e
        }
    },
    Quadratic: {
        In: function(e) {
            return e * e
        },
        Out: function(e) {
            return e * (2 - e)
        },
        InOut: function(e) {
            return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
        }
    },
    Cubic: {
        In: function(e) {
            return e * e * e
        },
        Out: function(e) {
            return --e * e * e + 1
        },
        InOut: function(e) {
            return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
        }
    },
    Quartic: {
        In: function(e) {
            return e * e * e * e
        },
        Out: function(e) {
            return 1 - --e * e * e * e
        },
        InOut: function(e) {
            return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
        }
    },
    Quintic: {
        In: function(e) {
            return e * e * e * e * e
        },
        Out: function(e) {
            return --e * e * e * e * e + 1
        },
        InOut: function(e) {
            return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
        }
    },
    Sinusoidal: {
        In: function(e) {
            return 1 - Math.cos(e * Math.PI / 2)
        },
        Out: function(e) {
            return Math.sin(e * Math.PI / 2)
        },
        InOut: function(e) {
            return .5 * (1 - Math.cos(Math.PI * e))
        }
    },
    Exponential: {
        In: function(e) {
            return e === 0 ? 0 : Math.pow(1024, e - 1)
        },
        Out: function(e) {
            return e === 1 ? 1 : 1 - Math.pow(2, -10 * e)
        },
        InOut: function(e) {
            return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (-Math.pow(2, -10 * (e - 1)) + 2)
        }
    },
    Circular: {
        In: function(e) {
            return 1 - Math.sqrt(1 - e * e)
        },
        Out: function(e) {
            return Math.sqrt(1 - --e * e)
        },
        InOut: function(e) {
            return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
        }
    },
    Elastic: {
        In: function(e) {
            var t, n = .1,
                r = .4;
            return e === 0 ? 0 : e === 1 ? 1 : (!n || n < 1 ? (n = 1, t = r / 4) : t = r * Math.asin(1 / n) / (2 * Math.PI), -(n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / r)))
        },
        Out: function(e) {
            var t, n = .1,
                r = .4;
            return e === 0 ? 0 : e === 1 ? 1 : (!n || n < 1 ? (n = 1, t = r / 4) : t = r * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * e) * Math.sin((e - t) * (2 * Math.PI) / r) + 1)
        },
        InOut: function(e) {
            var t, n = .1,
                r = .4;
            return e === 0 ? 0 : e === 1 ? 1 : (!n || n < 1 ? (n = 1, t = r / 4) : t = r * Math.asin(1 / n) / (2 * Math.PI), (e *= 2) < 1 ? -.5 * (n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / r)) : n * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / r) * .5 + 1)
        }
    },
    Back: {
        In: function(e) {
            var t = 1.70158;
            return e * e * ((t + 1) * e - t)
        },
        Out: function(e) {
            var t = 1.70158;
            return --e * e * ((t + 1) * e + t) + 1
        },
        InOut: function(e) {
            var t = 2.5949095;
            return (e *= 2) < 1 ? .5 * (e * e * ((t + 1) * e - t)) : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
        }
    },
    Bounce: {
        In: function(e) {
            return 1 - Se.Easing.Bounce.Out(1 - e)
        },
        Out: function(e) {
            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
        },
        InOut: function(e) {
            return e < .5 ? Se.Easing.Bounce.In(e * 2) * .5 : Se.Easing.Bounce.Out(e * 2 - 1) * .5 + .5
        }
    }
};
Se.Interpolation = {
    Linear: function(e, t) {
        var n = e.length - 1,
            r = n * t,
            i = Math.floor(r),
            a = Se.Interpolation.Utils.Linear;
        return t < 0 ? a(e[0], e[1], r) : t > 1 ? a(e[n], e[n - 1], n - r) : a(e[i], e[i + 1 > n ? n : i + 1], r - i)
    },
    Bezier: function(e, t) {
        var n = 0,
            r = e.length - 1,
            i = Math.pow,
            a = Se.Interpolation.Utils.Bernstein,
            o;
        for (o = 0; o <= r; o++) n += i(1 - t, r - o) * i(t, o) * e[o] * a(r, o);
        return n
    },
    CatmullRom: function(e, t) {
        var n = e.length - 1,
            r = n * t,
            i = Math.floor(r),
            a = Se.Interpolation.Utils.CatmullRom;
        return e[0] === e[n] ? (t < 0 && (i = Math.floor(r = n * (1 + t))), a(e[(i - 1 + n) % n], e[i], e[(i + 1) % n], e[(i + 2) % n], r - i)) : t < 0 ? e[0] - (a(e[0], e[0], e[1], e[1], -r) - e[0]) : t > 1 ? e[n] - (a(e[n], e[n], e[n - 1], e[n - 1], r - n) - e[n]) : a(e[i ? i - 1 : 0], e[i], e[n < i + 1 ? n : i + 1], e[n < i + 2 ? n : i + 2], r - i)
    },
    Utils: {
        Linear: function(e, t, n) {
            return (t - e) * n + e
        },
        Bernstein: function(e, t) {
            var n = Se.Interpolation.Utils.Factorial;
            return n(e) / n(t) / n(e - t)
        },
        Factorial: function() {
            var e = [1];
            return function(t) {
                var n = 1,
                    r;
                if (e[t]) return e[t];
                for (r = t; r > 1; r--) n *= r;
                return e[t] = n
            }
        }(),
        CatmullRom: function(e, t, n, r, i) {
            var a = (n - e) * .5,
                o = (r - t) * .5,
                s = i * i,
                c = i * s;
            return (2 * t - 2 * n + a + o) * c + (-3 * t + 3 * n - 2 * a - o) * s + a * i + t
        }
    }
};
var Sm = {};

function Vs(e, t) {
    l(Sm[e]) || (Sm[e] = !0, console.warn(p(t, e)))
}
Vs.geometryOutlines = "Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.";
Vs.geometryZIndex = "Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored";
Vs.geometryHeightReference = "Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored";
Vs.geometryExtrudedHeightReference = "Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored";

function Mh(e, t) {
    Vs(e, t)
}
var jy = {
    LINEAR_NONE: Se.Easing.Linear.None,
    QUADRATIC_IN: Se.Easing.Quadratic.In,
    QUADRATIC_OUT: Se.Easing.Quadratic.Out,
    QUADRATIC_IN_OUT: Se.Easing.Quadratic.InOut,
    CUBIC_IN: Se.Easing.Cubic.In,
    CUBIC_OUT: Se.Easing.Cubic.Out,
    CUBIC_IN_OUT: Se.Easing.Cubic.InOut,
    QUARTIC_IN: Se.Easing.Quartic.In,
    QUARTIC_OUT: Se.Easing.Quartic.Out,
    QUARTIC_IN_OUT: Se.Easing.Quartic.InOut,
    QUINTIC_IN: Se.Easing.Quintic.In,
    QUINTIC_OUT: Se.Easing.Quintic.Out,
    QUINTIC_IN_OUT: Se.Easing.Quintic.InOut,
    SINUSOIDAL_IN: Se.Easing.Sinusoidal.In,
    SINUSOIDAL_OUT: Se.Easing.Sinusoidal.Out,
    SINUSOIDAL_IN_OUT: Se.Easing.Sinusoidal.InOut,
    EXPONENTIAL_IN: Se.Easing.Exponential.In,
    EXPONENTIAL_OUT: Se.Easing.Exponential.Out,
    EXPONENTIAL_IN_OUT: Se.Easing.Exponential.InOut,
    CIRCULAR_IN: Se.Easing.Circular.In,
    CIRCULAR_OUT: Se.Easing.Circular.Out,
    CIRCULAR_IN_OUT: Se.Easing.Circular.InOut,
    ELASTIC_IN: Se.Easing.Elastic.In,
    ELASTIC_OUT: Se.Easing.Elastic.Out,
    ELASTIC_IN_OUT: Se.Easing.Elastic.InOut,
    BACK_IN: Se.Easing.Back.In,
    BACK_OUT: Se.Easing.Back.Out,
    BACK_IN_OUT: Se.Easing.Back.InOut,
    BOUNCE_IN: Se.Easing.Bounce.In,
    BOUNCE_OUT: Se.Easing.Bounce.Out,
    BOUNCE_IN_OUT: Se.Easing.Bounce.InOut
};
Object.defineProperties(jy, {
    QUADRACTIC_IN: {
        get: function() {
            return Mh("QUADRACTIC_IN", "QUADRACTIC_IN is deprecated and will be removed in Cesium 1.79. Use QUADRATIC_IN instead."), Se.Easing.Quadratic.In
        }
    },
    QUADRACTIC_OUT: {
        get: function() {
            return Mh("QUADRACTIC_OUT", "QUADRACTIC_OUT is deprecated and will be removed in Cesium 1.79. Use QUADRATIC_OUT instead."), Se.Easing.Quadratic.Out
        }
    },
    QUADRACTIC_IN_OUT: {
        get: function() {
            return Mh("QUADRACTIC_IN_OUT", "QUADRACTIC_IN_OUT is deprecated and will be removed in Cesium 1.79. Use QUADRATIC_IN_OUT instead."), Se.Easing.Quadratic.InOut
        }
    }
});
const Uc = Object.freeze(jy);

function ob(e) {
    var t = e._uSquared,
        n = e._ellipsoid.maximumRadius,
        r = e._ellipsoid.minimumRadius,
        i = (n - r) / n,
        a = Math.cos(e._startHeading),
        o = Math.sin(e._startHeading),
        s = (1 - i) * Math.tan(e._start.latitude),
        c = 1 / Math.sqrt(1 + s * s),
        f = c * s,
        h = Math.atan2(s, a),
        d = c * o,
        _ = d * d,
        v = 1 - _,
        m = Math.sqrt(v),
        g = t / 4,
        y = g * g,
        E = y * g,
        w = y * y,
        C = 1 + g - 3 * y / 4 + 5 * E / 4 - 175 * w / 64,
        A = 1 - g + 15 * y / 8 - 35 * E / 8,
        x = 1 - 3 * g + 35 * y / 4,
        P = 1 - 5 * g,
        I = C * h - A * Math.sin(2 * h) * g / 2 - x * Math.sin(4 * h) * y / 16 - P * Math.sin(6 * h) * E / 48 - Math.sin(8 * h) * 5 * w / 512,
        D = e._constants;
    D.a = n, D.b = r, D.f = i, D.cosineHeading = a, D.sineHeading = o, D.tanU = s, D.cosineU = c, D.sineU = f, D.sigma = h, D.sineAlpha = d, D.sineSquaredAlpha = _, D.cosineSquaredAlpha = v, D.cosineAlpha = m, D.u2Over4 = g, D.u4Over16 = y, D.u6Over64 = E, D.u8Over256 = w, D.a0 = C, D.a1 = A, D.a2 = x, D.a3 = P, D.distanceRatio = I
}

function sb(e, t) {
    return e * t * (4 + e * (4 - 3 * t)) / 16
}

function Zy(e, t, n, r, i, a, o) {
    var s = sb(e, n);
    return (1 - s) * e * t * (r + s * i * (o + s * a * (2 * o * o - 1)))
}

function ub(e, t, n, r, i, a, o) {
    var s = (t - n) / t,
        c = a - r,
        f = Math.atan((1 - s) * Math.tan(i)),
        h = Math.atan((1 - s) * Math.tan(o)),
        d = Math.cos(f),
        _ = Math.sin(f),
        v = Math.cos(h),
        m = Math.sin(h),
        g = d * v,
        y = d * m,
        E = _ * m,
        w = _ * v,
        C = c,
        A = T.TWO_PI,
        x = Math.cos(C),
        P = Math.sin(C),
        I, D, O, F, z;
    do {
        x = Math.cos(C), P = Math.sin(C);
        var b = y - w * x;
        O = Math.sqrt(v * v * P * P + b * b), D = E + g * x, I = Math.atan2(O, D);
        var M;
        O === 0 ? (M = 0, F = 1) : (M = g * P / O, F = 1 - M * M), A = C, z = D - 2 * E / F, isNaN(z) && (z = 0), C = c + Zy(s, M, F, I, O, D, z)
    } while (Math.abs(C - A) > T.EPSILON12);
    var G = F * (t * t - n * n) / (n * n),
        V = 1 + G * (4096 + G * (G * (320 - 175 * G) - 768)) / 16384,
        B = G * (256 + G * (G * (74 - 47 * G) - 128)) / 1024,
        Y = z * z,
        j = B * O * (z + B * (D * (2 * Y - 1) - B * z * (4 * O * O - 3) * (4 * Y - 3) / 6) / 4),
        Z = n * V * (I - j),
        Q = Math.atan2(v * P, y - w * x),
        ie = Math.atan2(d * P, y * x - w);
    e._distance = Z, e._startHeading = Q, e._endHeading = ie, e._uSquared = G
}
var cb = new u,
    Nh = new u;

function Ky(e, t, n, r) {
    u.normalize(r.cartographicToCartesian(t, Nh), cb), u.normalize(r.cartographicToCartesian(n, Nh), Nh), ub(e, r.maximumRadius, r.minimumRadius, t.longitude, t.latitude, n.longitude, n.latitude), e._start = K.clone(t, e._start), e._end = K.clone(n, e._end), e._start.height = 0, e._end.height = 0, ob(e)
}

function Gs(e, t, n) {
    var r = p(n, ne.WGS84);
    this._ellipsoid = r, this._start = new K, this._end = new K, this._constants = {}, this._startHeading = void 0, this._endHeading = void 0, this._distance = void 0, this._uSquared = void 0, l(e) && l(t) && Ky(this, e, t, r)
}
Object.defineProperties(Gs.prototype, {
    ellipsoid: {
        get: function() {
            return this._ellipsoid
        }
    },
    surfaceDistance: {
        get: function() {
            return this._distance
        }
    },
    start: {
        get: function() {
            return this._start
        }
    },
    end: {
        get: function() {
            return this._end
        }
    },
    startHeading: {
        get: function() {
            return this._startHeading
        }
    },
    endHeading: {
        get: function() {
            return this._endHeading
        }
    }
});
Gs.prototype.setEndPoints = function(e, t) {
    Ky(this, e, t, this._ellipsoid)
};
Gs.prototype.interpolateUsingFraction = function(e, t) {
    return this.interpolateUsingSurfaceDistance(this._distance * e, t)
};
Gs.prototype.interpolateUsingSurfaceDistance = function(e, t) {
    var n = this._constants,
        r = n.distanceRatio + e / n.b,
        i = Math.cos(2 * r),
        a = Math.cos(4 * r),
        o = Math.cos(6 * r),
        s = Math.sin(2 * r),
        c = Math.sin(4 * r),
        f = Math.sin(6 * r),
        h = Math.sin(8 * r),
        d = r * r,
        _ = r * d,
        v = n.u8Over256,
        m = n.u2Over4,
        g = n.u6Over64,
        y = n.u4Over16,
        E = 2 * _ * v * i / 3 + r * (1 - m + 7 * y / 4 - 15 * g / 4 + 579 * v / 64 - (y - 15 * g / 4 + 187 * v / 16) * i - (5 * g / 4 - 115 * v / 16) * a - 29 * v * o / 16) + (m / 2 - y + 71 * g / 32 - 85 * v / 16) * s + (5 * y / 16 - 5 * g / 4 + 383 * v / 96) * c - d * ((g - 11 * v / 2) * s + 5 * v * c / 2) + (29 * g / 96 - 29 * v / 16) * f + 539 * v * h / 1536,
        w = Math.asin(Math.sin(E) * n.cosineAlpha),
        C = Math.atan(n.a / n.b * Math.tan(w));
    E = E - n.sigma;
    var A = Math.cos(2 * n.sigma + E),
        x = Math.sin(E),
        P = Math.cos(E),
        I = n.cosineU * P,
        D = n.sineU * x,
        O = Math.atan2(x * n.sineHeading, I - D * n.cosineHeading),
        F = O - Zy(n.f, n.sineAlpha, n.cosineSquaredAlpha, E, x, P, A);
    return l(t) ? (t.longitude = this._start.longitude + F, t.latitude = C, t.height = 0, t) : new K(this._start.longitude + F, C, 0)
};

function zc(e, t, n) {
    this.heading = p(e, 0), this.pitch = p(t, 0), this.range = p(n, 0)
}
zc.clone = function(e, t) {
    if (!!l(e)) return l(t) || (t = new zc), t.heading = e.heading, t.pitch = e.pitch, t.range = e.range, t
};
var $y = {};

function fb(e, t, n) {
    var r, i, a;
    if (e instanceof en) {
        var o = Math.tan(.5 * e.fovy);
        return r = e.near, i = e.near * o, a = e.aspectRatio * i, Math.max(t * r / a, n * r / i)
    } else if (e instanceof Er) return r = e.near, i = e.top, a = e.right, Math.max(t * r / a, n * r / i);
    return Math.max(t, n)
}
var hb = new u,
    Rm = new u;

function lb(e, t, n, r) {
    if (l(r) && n(.5) > r) {
        var i = n(0),
            a = n(1),
            o = n(.5),
            s = o - i,
            c = o - a;
        return function(f) {
            var h = n(f);
            if (f <= .5) {
                var d = (h - i) / s;
                return T.lerp(e, -T.PI_OVER_TWO, d)
            }
            var _ = (h - a) / c;
            return T.lerp(-T.PI_OVER_TWO, t, 1 - _)
        }
    }
    return function(f) {
        return T.lerp(e, t, f)
    }
}

function Ld(e, t, n, r, i) {
    var a = i,
        o = Math.max(n, r);
    if (!l(a)) {
        var s = e.position,
            c = t,
            f = e.up,
            h = e.right,
            d = e.frustum,
            _ = u.subtract(s, c, hb),
            v = u.magnitude(u.multiplyByScalar(f, u.dot(_, f), Rm)),
            m = u.magnitude(u.multiplyByScalar(h, u.dot(_, h), Rm));
        a = Math.min(fb(d, v, m) * .2, 1e9)
    }
    if (o < a) {
        var g = 8,
            y = 1e6,
            E = -Math.pow((a - n) * y, 1 / g),
            w = Math.pow((a - r) * y, 1 / g);
        return function(C) {
            var A = C * (w - E) + E;
            return -Math.pow(A, g) / y + a
        }
    }
    return function(C) {
        return T.lerp(n, r, C)
    }
}

function Ps(e, t) {
    return T.equalsEpsilon(e, T.TWO_PI, T.EPSILON11) && (e = 0), t > e + Math.PI ? e += T.TWO_PI : t < e - Math.PI && (e -= T.TWO_PI), e
}
var Jy = new u;

function db(e, t, n, r, i, a, o) {
    var s = e.camera,
        c = u.clone(s.position, Jy),
        f = s.pitch,
        h = Ps(s.heading, r),
        d = Ps(s.roll, a),
        _ = Ld(s, n, c.z, n.z, o);

    function v(m) {
        var g = m.time / t;
        s.setView({
            orientation: {
                heading: T.lerp(h, r, g),
                pitch: T.lerp(f, i, g),
                roll: T.lerp(d, a, g)
            }
        }), R.lerp(c, n, g, s.position), s.position.z = _(g)
    }
    return v
}

function _b(e, t) {
    e.longitude < t.longitude ? e.longitude += T.TWO_PI : t.longitude += T.TWO_PI
}

function vb(e, t) {
    var n = e.longitude - t.longitude;
    n < -T.PI ? e.longitude += T.TWO_PI : n > T.PI && (t.longitude += T.TWO_PI)
}
var mb = new K,
    pb = new K;

function gb(e, t, n, r, i, a, o, s, c, f) {
    var h = e.camera,
        d = e.mapProjection,
        _ = d.ellipsoid,
        v = K.clone(h.positionCartographic, mb),
        m = h.pitch,
        g = Ps(h.heading, r),
        y = Ps(h.roll, a),
        E = _.cartesianToCartographic(n, pb);
    v.longitude = T.zeroToTwoPi(v.longitude), E.longitude = T.zeroToTwoPi(E.longitude);
    var w = !1;
    if (l(s)) {
        var C = T.zeroToTwoPi(s),
            A = Math.min(v.longitude, E.longitude),
            x = Math.max(v.longitude, E.longitude),
            P = C >= A && C <= x;
        if (l(c)) {
            var I = Math.abs(v.longitude - E.longitude),
                D = T.TWO_PI - I,
                O = P ? I : D,
                F = P ? D : I;
            O < F * c && !P && (w = !0)
        } else P || (w = !0)
    }
    w ? _b(v, E) : vb(v, E);
    var z = Ld(h, n, v.height, E.height, o),
        b = lb(m, i, z, f);

    function M() {
        var G = v.longitude,
            V = E.longitude,
            B = v.latitude,
            Y = E.latitude;
        return function(Z) {
            var Q = Z.time / t,
                ie = u.fromRadians(T.lerp(G, V, Q), T.lerp(B, Y, Q), z(Q));
            h.setView({
                destination: ie,
                orientation: {
                    heading: T.lerp(g, r, Q),
                    pitch: b(Q),
                    roll: T.lerp(y, a, Q)
                }
            })
        }
    }
    return M()
}

function yb(e, t, n, r, i, a, o) {
    var s = e.camera,
        c = u.clone(s.position, Jy),
        f = Ps(s.heading, r),
        h = s.frustum.right - s.frustum.left,
        d = Ld(s, n, h, n.z, o);

    function _(v) {
        var m = v.time / t;
        s.setView({
            orientation: {
                heading: T.lerp(f, r, m)
            }
        }), R.lerp(c, n, m, s.position);
        var g = d(m),
            y = s.frustum,
            E = y.top / y.right,
            w = (g - (y.right - y.left)) * .5;
        y.right += w, y.left -= w, y.top = E * y.right, y.bottom = -y.top
    }
    return _
}
var Dm = new K,
    Tb = new u;

function bh(e, t) {
    return {
        startObject: {},
        stopObject: {},
        duration: 0,
        complete: e,
        cancel: t
    }
}

function Im(e, t) {
    function n() {
        typeof t == "function" && t(), e.enableInputs = !0
    }
    return n
}
$y.createTween = function(e, t) {
    t = p(t, p.EMPTY_OBJECT);
    var n = t.destination,
        r = e.mode;
    if (r === k.MORPHING) return bh();
    var i = p(t.convert, !0),
        a = e.mapProjection,
        o = a.ellipsoid,
        s = t.maximumHeight,
        c = t.flyOverLongitude,
        f = t.flyOverLongitudeWeight,
        h = t.pitchAdjustHeight,
        d = t.easingFunction;
    i && r !== k.SCENE3D && (o.cartesianToCartographic(n, Dm), n = a.project(Dm, Tb));
    var _ = e.camera,
        v = t.endTransform;
    l(v) && _._setTransform(v);
    var m = t.duration;
    l(m) || (m = Math.ceil(u.distance(_.position, n) / 1e6) + 2, m = Math.min(m, 3));
    var g = p(t.heading, 0),
        y = p(t.pitch, -T.PI_OVER_TWO),
        E = p(t.roll, 0),
        w = e.screenSpaceCameraController;
    w.enableInputs = !1;
    var C = Im(w, t.complete),
        A = Im(w, t.cancel),
        x = _.frustum,
        P = e.mode === k.SCENE2D;
    if (P = P && R.equalsEpsilon(_.position, n, T.EPSILON6), P = P && T.equalsEpsilon(Math.max(x.right - x.left, x.top - x.bottom), n.z, T.EPSILON6), P = P || e.mode !== k.SCENE2D && u.equalsEpsilon(n, _.position, T.EPSILON10), P = P && T.equalsEpsilon(T.negativePiToPi(g), T.negativePiToPi(_.heading), T.EPSILON10) && T.equalsEpsilon(T.negativePiToPi(y), T.negativePiToPi(_.pitch), T.EPSILON10) && T.equalsEpsilon(T.negativePiToPi(E), T.negativePiToPi(_.roll), T.EPSILON10), P) return bh(C, A);
    var I = new Array(4);
    if (I[k.SCENE2D] = yb, I[k.SCENE3D] = gb, I[k.COLUMBUS_VIEW] = db, m <= 0) {
        var D = function() {
            var b = I[r](e, 1, n, g, y, E, s, c, f, h);
            b({
                time: 1
            }), typeof C == "function" && C()
        };
        return bh(D, A)
    }
    var O = I[r](e, m, n, g, y, E, s, c, f, h);
    if (!l(d)) {
        var F = _.positionCartographic.height,
            z = r === k.SCENE3D ? o.cartesianToCartographic(n).height : n.z;
        F > z && F > 11500 ? d = Uc.CUBIC_OUT : d = Uc.QUINTIC_IN_OUT
    }
    return {
        duration: m,
        easingFunction: d,
        startObject: {
            time: 0
        },
        stopObject: {
            time: m
        },
        update: O,
        complete: C,
        cancel: A
    }
};
var Eb = {
    ROTATE: 0,
    INFINITE_SCROLL: 1
};
const Do = Object.freeze(Eb);

function se(e) {
    this._scene = e, this._transform = S.clone(S.IDENTITY), this._invTransform = S.clone(S.IDENTITY), this._actualTransform = S.clone(S.IDENTITY), this._actualInvTransform = S.clone(S.IDENTITY), this._transformChanged = !1, this.position = new u, this._position = new u, this._positionWC = new u, this._positionCartographic = new K, this._oldPositionWC = void 0, this.positionWCDeltaMagnitude = 0, this.positionWCDeltaMagnitudeLastFrame = 0, this.timeSinceMoved = 0, this._lastMovedTimestamp = 0, this.direction = new u, this._direction = new u, this._directionWC = new u, this.up = new u, this._up = new u, this._upWC = new u, this.right = new u, this._right = new u, this._rightWC = new u, this.frustum = new en, this.frustum.aspectRatio = e.drawingBufferWidth / e.drawingBufferHeight, this.frustum.fov = T.toRadians(60), this.defaultMoveAmount = 1e5, this.defaultLookAmount = Math.PI / 60, this.defaultRotateAmount = Math.PI / 3600, this.defaultZoomAmount = 1e5, this.constrainedAxis = void 0, this.maximumZoomFactor = 1.5, this._moveStart = new ht, this._moveEnd = new ht, this._changed = new ht, this._changedPosition = void 0, this._changedDirection = void 0, this._changedFrustum = void 0, this.percentageChanged = .5, this._viewMatrix = new S, this._invViewMatrix = new S, Qy(this), this._mode = k.SCENE3D, this._modeChanged = !0;
    var t = e.mapProjection;
    this._projection = t, this._maxCoord = t.project(new K(Math.PI, T.PI_OVER_TWO)), this._max2Dfrustum = void 0, hT(this, se.DEFAULT_VIEW_RECTANGLE, this.position, !0);
    var n = u.magnitude(this.position);
    n += n * se.DEFAULT_VIEW_FACTOR, u.normalize(this.position, this.position), u.multiplyByScalar(this.position, n, this.position)
}
se.TRANSFORM_2D = new S(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
se.TRANSFORM_2D_INVERSE = S.inverseTransformation(se.TRANSFORM_2D, new S);
se.DEFAULT_VIEW_RECTANGLE = W.fromDegrees(-95, -20, -70, 90);
se.DEFAULT_VIEW_FACTOR = .5;
se.DEFAULT_OFFSET = new zc(0, -T.PI_OVER_FOUR, 0);

function Qy(e) {
    S.computeView(e._position, e._direction, e._up, e._right, e._viewMatrix), S.multiply(e._viewMatrix, e._actualInvTransform, e._viewMatrix), S.inverseTransformation(e._viewMatrix, e._invViewMatrix)
}

function Ab(e) {
    if (!l(e._oldPositionWC)) e._oldPositionWC = u.clone(e.positionWC, e._oldPositionWC);
    else {
        e.positionWCDeltaMagnitudeLastFrame = e.positionWCDeltaMagnitude;
        var t = u.subtract(e.positionWC, e._oldPositionWC, e._oldPositionWC);
        e.positionWCDeltaMagnitude = u.magnitude(t), e._oldPositionWC = u.clone(e.positionWC, e._oldPositionWC), e.positionWCDeltaMagnitude > 0 ? (e.timeSinceMoved = 0, e._lastMovedTimestamp = bn()) : e.timeSinceMoved = Math.max(bn() - e._lastMovedTimestamp, 0) / 1e3
    }
}
se.prototype.canPreloadFlight = function() {
    return l(this._currentFlight) && this._mode !== k.SCENE2D
};
se.prototype._updateCameraChanged = function() {
    var e = this;
    if (Ab(e), e._changed.numberOfListeners !== 0) {
        var t = e.percentageChanged;
        if (e._mode === k.SCENE2D) {
            if (!l(e._changedFrustum)) {
                e._changedPosition = u.clone(e.position, e._changedPosition), e._changedFrustum = e.frustum.clone();
                return
            }
            var n = e.position,
                r = e._changedPosition,
                i = e.frustum,
                a = e._changedFrustum,
                o = n.x + i.left,
                s = n.x + i.right,
                c = r.x + a.left,
                f = r.x + a.right,
                h = n.y + i.bottom,
                d = n.y + i.top,
                _ = r.y + a.bottom,
                v = r.y + a.top,
                m = Math.max(o, c),
                g = Math.min(s, f),
                y = Math.max(h, _),
                E = Math.min(d, v),
                w;
            if (m >= g || y >= d) w = 1;
            else {
                var C = a;
                o < c && s > f && h < _ && d > v && (C = i), w = 1 - (g - m) * (E - y) / ((C.right - C.left) * (C.top - C.bottom))
            }
            w > t && (e._changed.raiseEvent(w), e._changedPosition = u.clone(e.position, e._changedPosition), e._changedFrustum = e.frustum.clone(e._changedFrustum));
            return
        }
        if (!l(e._changedDirection)) {
            e._changedPosition = u.clone(e.positionWC, e._changedPosition), e._changedDirection = u.clone(e.directionWC, e._changedDirection);
            return
        }
        var A = T.acosClamped(u.dot(e.directionWC, e._changedDirection)),
            x;
        l(e.frustum.fovy) ? x = A / (e.frustum.fovy * .5) : x = A;
        var P = u.distance(e.positionWC, e._changedPosition),
            I = P / e.positionCartographic.height;
        (x > t || I > t) && (e._changed.raiseEvent(Math.max(x, I)), e._changedPosition = u.clone(e.positionWC, e._changedPosition), e._changedDirection = u.clone(e.directionWC, e._changedDirection))
    }
};

function Cb(e) {
    xe.basisTo2D(e._projection, e._transform, e._actualTransform)
}
var wb = new K,
    xb = new u,
    Hu = new u,
    Sb = new U,
    Rb = new U,
    Db = new U,
    Ib = new U,
    Pb = new U;

function Ob(e) {
    var t = e._projection,
        n = t.ellipsoid,
        r = S.getColumn(e._transform, 3, Sb),
        i = n.cartesianToCartographic(r, wb),
        a = t.project(i, xb),
        o = Rb;
    o.x = a.z, o.y = a.x, o.z = a.y, o.w = 1;
    var s = U.clone(U.UNIT_X, Pb),
        c = U.add(S.getColumn(e._transform, 0, Hu), r, Hu);
    n.cartesianToCartographic(c, i), t.project(i, a);
    var f = Db;
    f.x = a.z, f.y = a.x, f.z = a.y, f.w = 0, u.subtract(f, o, f), f.x = 0;
    var h = Ib;
    if (u.magnitudeSquared(f) > T.EPSILON10) u.cross(s, f, h);
    else {
        var d = U.add(S.getColumn(e._transform, 1, Hu), r, Hu);
        n.cartesianToCartographic(d, i), t.project(i, a), h.x = a.z, h.y = a.x, h.z = a.y, h.w = 0, u.subtract(h, o, h), h.x = 0, u.magnitudeSquared(h) < T.EPSILON10 && (U.clone(U.UNIT_Y, f), U.clone(U.UNIT_Z, h))
    }
    u.cross(h, s, f), u.normalize(f, f), u.cross(s, f, h), u.normalize(h, h), S.setColumn(e._actualTransform, 0, f, e._actualTransform), S.setColumn(e._actualTransform, 1, h, e._actualTransform), S.setColumn(e._actualTransform, 2, s, e._actualTransform), S.setColumn(e._actualTransform, 3, o, e._actualTransform)
}
var Fh = new u;

function mn(e) {
    var t = e._mode,
        n = !1,
        r = 0;
    t === k.SCENE2D && (r = e.frustum.right - e.frustum.left, n = r !== e._positionCartographic.height);
    var i = e._position,
        a = !u.equals(i, e.position) || n;
    a && (i = u.clone(e.position, e._position));
    var o = e._direction,
        s = !u.equals(o, e.direction);
    s && (u.normalize(e.direction, e.direction), o = u.clone(e.direction, e._direction));
    var c = e._up,
        f = !u.equals(c, e.up);
    f && (u.normalize(e.up, e.up), c = u.clone(e.up, e._up));
    var h = e._right,
        d = !u.equals(h, e.right);
    d && (u.normalize(e.right, e.right), h = u.clone(e.right, e._right));
    var _ = e._transformChanged || e._modeChanged;
    e._transformChanged = !1, _ && (S.inverseTransformation(e._transform, e._invTransform), e._mode === k.COLUMBUS_VIEW || e._mode === k.SCENE2D ? S.equals(S.IDENTITY, e._transform) ? S.clone(se.TRANSFORM_2D, e._actualTransform) : e._mode === k.COLUMBUS_VIEW ? Cb(e) : Ob(e) : S.clone(e._transform, e._actualTransform), S.inverseTransformation(e._actualTransform, e._actualInvTransform), e._modeChanged = !1);
    var v = e._actualTransform;
    if (a || _)
        if (e._positionWC = S.multiplyByPoint(v, i, e._positionWC), t === k.SCENE3D || t === k.MORPHING) e._positionCartographic = e._projection.ellipsoid.cartesianToCartographic(e._positionWC, e._positionCartographic);
        else {
            var m = Fh;
            m.x = e._positionWC.y, m.y = e._positionWC.z, m.z = e._positionWC.x, t === k.SCENE2D && (m.z = r), e._projection.unproject(m, e._positionCartographic)
        }
    if (s || f || d) {
        var g = u.dot(o, u.cross(c, h, Fh));
        if (Math.abs(1 - g) > T.EPSILON2) {
            var y = 1 / u.magnitudeSquared(c),
                E = u.dot(c, o) * y,
                w = u.multiplyByScalar(o, E, Fh);
            c = u.normalize(u.subtract(c, w, e._up), e._up), u.clone(c, e.up), h = u.cross(o, c, e._right), u.clone(h, e.right)
        }
    }(s || _) && (e._directionWC = S.multiplyByPointAsVector(v, o, e._directionWC), u.normalize(e._directionWC, e._directionWC)), (f || _) && (e._upWC = S.multiplyByPointAsVector(v, c, e._upWC), u.normalize(e._upWC, e._upWC)), (d || _) && (e._rightWC = S.multiplyByPointAsVector(v, h, e._rightWC), u.normalize(e._rightWC, e._rightWC)), (a || s || f || d || _) && Qy(e)
}

function eT(e, t) {
    var n;
    return T.equalsEpsilon(Math.abs(e.z), 1, T.EPSILON3) ? n = Math.atan2(t.y, t.x) - T.PI_OVER_TWO : n = Math.atan2(e.y, e.x) - T.PI_OVER_TWO, T.TWO_PI - T.zeroToTwoPi(n)
}

function tT(e) {
    return T.PI_OVER_TWO - T.acosClamped(e.z)
}

function nT(e, t, n) {
    var r = 0;
    return T.equalsEpsilon(Math.abs(e.z), 1, T.EPSILON3) || (r = Math.atan2(-n.z, t.z), r = T.zeroToTwoPi(r + T.TWO_PI)), r
}
var dc = new S,
    _c = new S;
Object.defineProperties(se.prototype, {
    transform: {
        get: function() {
            return this._transform
        }
    },
    inverseTransform: {
        get: function() {
            return mn(this), this._invTransform
        }
    },
    viewMatrix: {
        get: function() {
            return mn(this), this._viewMatrix
        }
    },
    inverseViewMatrix: {
        get: function() {
            return mn(this), this._invViewMatrix
        }
    },
    positionCartographic: {
        get: function() {
            return mn(this), this._positionCartographic
        }
    },
    positionWC: {
        get: function() {
            return mn(this), this._positionWC
        }
    },
    directionWC: {
        get: function() {
            return mn(this), this._directionWC
        }
    },
    upWC: {
        get: function() {
            return mn(this), this._upWC
        }
    },
    rightWC: {
        get: function() {
            return mn(this), this._rightWC
        }
    },
    heading: {
        get: function() {
            if (this._mode !== k.MORPHING) {
                var e = this._projection.ellipsoid,
                    t = S.clone(this._transform, dc),
                    n = xe.eastNorthUpToFixedFrame(this.positionWC, e, _c);
                this._setTransform(n);
                var r = eT(this.direction, this.up);
                return this._setTransform(t), r
            }
        }
    },
    pitch: {
        get: function() {
            if (this._mode !== k.MORPHING) {
                var e = this._projection.ellipsoid,
                    t = S.clone(this._transform, dc),
                    n = xe.eastNorthUpToFixedFrame(this.positionWC, e, _c);
                this._setTransform(n);
                var r = tT(this.direction);
                return this._setTransform(t), r
            }
        }
    },
    roll: {
        get: function() {
            if (this._mode !== k.MORPHING) {
                var e = this._projection.ellipsoid,
                    t = S.clone(this._transform, dc),
                    n = xe.eastNorthUpToFixedFrame(this.positionWC, e, _c);
                this._setTransform(n);
                var r = nT(this.direction, this.up, this.right);
                return this._setTransform(t), r
            }
        }
    },
    moveStart: {
        get: function() {
            return this._moveStart
        }
    },
    moveEnd: {
        get: function() {
            return this._moveEnd
        }
    },
    changed: {
        get: function() {
            return this._changed
        }
    }
});
se.prototype.update = function(e) {
    var t = !1;
    if (e !== this._mode && (this._mode = e, this._modeChanged = e !== k.MORPHING, t = this._mode === k.SCENE2D), t) {
        var n = this._max2Dfrustum = this.frustum.clone(),
            r = 2,
            i = n.top / n.right;
        n.right = this._maxCoord.x * r, n.left = -n.right, n.top = i * n.right, n.bottom = -n.top
    }
    this._mode === k.SCENE2D && oT(this, this.position)
};
var Mb = new u,
    Nb = new u,
    bb = new u;
se.prototype._setTransform = function(e) {
    var t = u.clone(this.positionWC, Mb),
        n = u.clone(this.upWC, Nb),
        r = u.clone(this.directionWC, bb);
    S.clone(e, this._transform), this._transformChanged = !0, mn(this);
    var i = this._actualInvTransform;
    S.multiplyByPoint(i, t, this.position), S.multiplyByPointAsVector(i, r, this.direction), S.multiplyByPointAsVector(i, n, this.up), u.cross(this.direction, this.up, this.right), mn(this)
};
var Fb = new R,
    Lb = new Ke,
    Ub = new u,
    zb = new u;

function rT(e) {
    if (!S.equals(S.IDENTITY, e.transform)) return u.magnitude(e.position);
    var t = e._scene,
        n = t.globe,
        r = Fb;
    r.x = t.drawingBufferWidth / 2, r.y = t.drawingBufferHeight / 2;
    var i;
    if (l(n)) {
        var a = e.getPickRay(r, Lb);
        i = n.pickWorldCoordinates(a, t, !0, Ub)
    }
    var o;
    t.pickPositionSupported && (o = t.pickPositionWorldCoordinates(r, zb));
    var s;
    if (l(i) || l(o)) {
        var c = l(o) ? u.distance(o, e.positionWC) : Number.POSITIVE_INFINITY,
            f = l(i) ? u.distance(i, e.positionWC) : Number.POSITIVE_INFINITY;
        s = Math.min(c, f)
    } else s = Math.max(e.positionCartographic.height, 0);
    return s
}
se.prototype._adjustOrthographicFrustum = function(e) {
    this.frustum instanceof lt && (!e && this._positionCartographic.height < 15e4 || (this.frustum.width = rT(this)))
};
var Bc = new u,
    Ud = new S,
    Bb = new S,
    zd = new X,
    Bd = new N,
    iT = new K;

function Vb(e, t, n) {
    var r = S.clone(e.transform, Ud),
        i = xe.eastNorthUpToFixedFrame(t, e._projection.ellipsoid, Bb);
    e._setTransform(i), u.clone(u.ZERO, e.position), n.heading = n.heading - T.PI_OVER_TWO;
    var a = X.fromHeadingPitchRoll(n, zd),
        o = N.fromQuaternion(a, Bd);
    N.getColumn(o, 0, e.direction), N.getColumn(o, 2, e.up), u.cross(e.direction, e.up, e.right), e._setTransform(r), e._adjustOrthographicFrustum(!0)
}

function Gb(e, t, n, r) {
    var i = S.clone(e.transform, Ud);
    if (e._setTransform(S.IDENTITY), !u.equals(t, e.positionWC)) {
        if (r) {
            var a = e._projection,
                o = a.ellipsoid.cartesianToCartographic(t, iT);
            t = a.project(o, Bc)
        }
        u.clone(t, e.position)
    }
    n.heading = n.heading - T.PI_OVER_TWO;
    var s = X.fromHeadingPitchRoll(n, zd),
        c = N.fromQuaternion(s, Bd);
    N.getColumn(c, 0, e.direction), N.getColumn(c, 2, e.up), u.cross(e.direction, e.up, e.right), e._setTransform(i), e._adjustOrthographicFrustum(!0)
}

function Hb(e, t, n, r) {
    var i = S.clone(e.transform, Ud);
    if (e._setTransform(S.IDENTITY), !u.equals(t, e.positionWC)) {
        if (r) {
            var a = e._projection,
                o = a.ellipsoid.cartesianToCartographic(t, iT);
            t = a.project(o, Bc)
        }
        R.clone(t, e.position);
        var s = -t.z * .5,
            c = -s,
            f = e.frustum;
        if (c > s) {
            var h = f.top / f.right;
            f.right = c, f.left = s, f.top = f.right * h, f.bottom = -f.top
        }
    }
    if (e._scene.mapMode2D === Do.ROTATE) {
        n.heading = n.heading - T.PI_OVER_TWO, n.pitch = -T.PI_OVER_TWO, n.roll = 0;
        var d = X.fromHeadingPitchRoll(n, zd),
            _ = N.fromQuaternion(d, Bd);
        N.getColumn(_, 2, e.up), u.cross(e.direction, e.up, e.right)
    }
    e._setTransform(i)
}
var kb = new u,
    Wb = new u,
    qb = new u;

function aT(e, t, n, r) {
    var i = u.clone(n.direction, kb),
        a = u.clone(n.up, Wb);
    if (e._scene.mode === k.SCENE3D) {
        var o = e._projection.ellipsoid,
            s = xe.eastNorthUpToFixedFrame(t, o, dc),
            c = S.inverseTransformation(s, _c);
        S.multiplyByPointAsVector(c, i, i), S.multiplyByPointAsVector(c, a, a)
    }
    var f = u.cross(i, a, qb);
    return r.heading = eT(i, a), r.pitch = tT(i), r.roll = nT(i, a, f), r
}
var Fl = {
        destination: void 0,
        orientation: {
            direction: void 0,
            up: void 0,
            heading: void 0,
            pitch: void 0,
            roll: void 0
        },
        convert: void 0,
        endTransform: void 0
    },
    fo = new Xt;
se.prototype.setView = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = p(e.orientation, p.EMPTY_OBJECT),
        n = this._mode;
    if (n !== k.MORPHING) {
        l(e.endTransform) && this._setTransform(e.endTransform);
        var r = p(e.convert, !0),
            i = p(e.destination, u.clone(this.positionWC, Bc));
        l(i) && l(i.west) && (i = this.getRectangleCameraCoordinates(i, Bc), r = !1), l(t.direction) && (t = aT(this, i, t, Fl.orientation)), fo.heading = p(t.heading, 0), fo.pitch = p(t.pitch, -T.PI_OVER_TWO), fo.roll = p(t.roll, 0), n === k.SCENE3D ? Vb(this, i, fo) : n === k.SCENE2D ? Hb(this, i, fo, r) : Gb(this, i, fo, r)
    }
};
var Yb = new u;
se.prototype.flyHome = function(e) {
    var t = this._mode;
    if (t === k.MORPHING && this._scene.completeMorph(), t === k.SCENE2D) this.flyTo({
        destination: se.DEFAULT_VIEW_RECTANGLE,
        duration: e,
        endTransform: S.IDENTITY
    });
    else if (t === k.SCENE3D) {
        var n = this.getRectangleCameraCoordinates(se.DEFAULT_VIEW_RECTANGLE),
            r = u.magnitude(n);
        r += r * se.DEFAULT_VIEW_FACTOR, u.normalize(n, n), u.multiplyByScalar(n, r, n), this.flyTo({
            destination: n,
            duration: e,
            endTransform: S.IDENTITY
        })
    } else if (t === k.COLUMBUS_VIEW) {
        var i = this._projection.ellipsoid.maximumRadius,
            a = new u(0, -1, 1);
        a = u.multiplyByScalar(u.normalize(a, a), 5 * i, a), this.flyTo({
            destination: a,
            duration: e,
            orientation: {
                heading: 0,
                pitch: -Math.acos(u.normalize(a, Yb).z),
                roll: 0
            },
            endTransform: S.IDENTITY,
            convert: !1
        })
    }
};
se.prototype.worldToCameraCoordinates = function(e, t) {
    return l(t) || (t = new U), mn(this), S.multiplyByVector(this._actualInvTransform, e, t)
};
se.prototype.worldToCameraCoordinatesPoint = function(e, t) {
    return l(t) || (t = new u), mn(this), S.multiplyByPoint(this._actualInvTransform, e, t)
};
se.prototype.worldToCameraCoordinatesVector = function(e, t) {
    return l(t) || (t = new u), mn(this), S.multiplyByPointAsVector(this._actualInvTransform, e, t)
};
se.prototype.cameraToWorldCoordinates = function(e, t) {
    return l(t) || (t = new U), mn(this), S.multiplyByVector(this._actualTransform, e, t)
};
se.prototype.cameraToWorldCoordinatesPoint = function(e, t) {
    return l(t) || (t = new u), mn(this), S.multiplyByPoint(this._actualTransform, e, t)
};
se.prototype.cameraToWorldCoordinatesVector = function(e, t) {
    return l(t) || (t = new u), mn(this), S.multiplyByPointAsVector(this._actualTransform, e, t)
};

function oT(e, t) {
    var n = e._scene.mapMode2D === Do.ROTATE,
        r = e._maxCoord.x,
        i = e._maxCoord.y,
        a, o;
    n ? (o = r, a = -o) : (o = t.x - r * 2, a = t.x + r * 2), t.x > r && (t.x = o), t.x < -r && (t.x = a), t.y > i && (t.y = i), t.y < -i && (t.y = -i)
}
var Pm = new u;
se.prototype.move = function(e, t) {
    var n = this.position;
    u.multiplyByScalar(e, t, Pm), u.add(n, Pm, n), this._mode === k.SCENE2D && oT(this, n), this._adjustOrthographicFrustum(!0)
};
se.prototype.moveForward = function(e) {
    e = p(e, this.defaultMoveAmount), this._mode === k.SCENE2D ? af(this, e) : this.move(this.direction, e)
};
se.prototype.moveBackward = function(e) {
    e = p(e, this.defaultMoveAmount), this._mode === k.SCENE2D ? af(this, -e) : this.move(this.direction, -e)
};
se.prototype.moveUp = function(e) {
    e = p(e, this.defaultMoveAmount), this.move(this.up, e)
};
se.prototype.moveDown = function(e) {
    e = p(e, this.defaultMoveAmount), this.move(this.up, -e)
};
se.prototype.moveRight = function(e) {
    e = p(e, this.defaultMoveAmount), this.move(this.right, e)
};
se.prototype.moveLeft = function(e) {
    e = p(e, this.defaultMoveAmount), this.move(this.right, -e)
};
se.prototype.lookLeft = function(e) {
    e = p(e, this.defaultLookAmount), this._mode !== k.SCENE2D && this.look(this.up, -e)
};
se.prototype.lookRight = function(e) {
    e = p(e, this.defaultLookAmount), this._mode !== k.SCENE2D && this.look(this.up, e)
};
se.prototype.lookUp = function(e) {
    e = p(e, this.defaultLookAmount), this._mode !== k.SCENE2D && this.look(this.right, -e)
};
se.prototype.lookDown = function(e) {
    e = p(e, this.defaultLookAmount), this._mode !== k.SCENE2D && this.look(this.right, e)
};
var Xb = new X,
    jb = new N;
se.prototype.look = function(e, t) {
    var n = p(t, this.defaultLookAmount),
        r = X.fromAxisAngle(e, -n, Xb),
        i = N.fromQuaternion(r, jb),
        a = this.direction,
        o = this.up,
        s = this.right;
    N.multiplyByVector(i, a, a), N.multiplyByVector(i, o, o), N.multiplyByVector(i, s, s)
};
se.prototype.twistLeft = function(e) {
    e = p(e, this.defaultLookAmount), this.look(this.direction, e)
};
se.prototype.twistRight = function(e) {
    e = p(e, this.defaultLookAmount), this.look(this.direction, -e)
};
var Zb = new X,
    Kb = new N;
se.prototype.rotate = function(e, t) {
    var n = p(t, this.defaultRotateAmount),
        r = X.fromAxisAngle(e, -n, Zb),
        i = N.fromQuaternion(r, Kb);
    N.multiplyByVector(i, this.position, this.position), N.multiplyByVector(i, this.direction, this.direction), N.multiplyByVector(i, this.up, this.up), u.cross(this.direction, this.up, this.right), u.cross(this.right, this.direction, this.up), this._adjustOrthographicFrustum(!1)
};
se.prototype.rotateDown = function(e) {
    e = p(e, this.defaultRotateAmount), sT(this, e)
};
se.prototype.rotateUp = function(e) {
    e = p(e, this.defaultRotateAmount), sT(this, -e)
};
var $b = new u,
    Jb = new u,
    Qb = new u,
    Om = new u;

function sT(e, t) {
    var n = e.position;
    if (l(e.constrainedAxis) && !u.equalsEpsilon(e.position, u.ZERO, T.EPSILON2)) {
        var r = u.normalize(n, $b),
            i = u.equalsEpsilon(r, e.constrainedAxis, T.EPSILON2),
            a = u.equalsEpsilon(r, u.negate(e.constrainedAxis, Om), T.EPSILON2);
        if (!i && !a) {
            var o = u.normalize(e.constrainedAxis, Jb),
                s = u.dot(r, o),
                c = T.acosClamped(s);
            t > 0 && t > c && (t = c - T.EPSILON4), s = u.dot(r, u.negate(o, Om)), c = T.acosClamped(s), t < 0 && -t > c && (t = -c + T.EPSILON4);
            var f = u.cross(o, r, Qb);
            e.rotate(f, t)
        } else(i && t < 0 || a && t > 0) && e.rotate(e.right, t)
    } else e.rotate(e.right, t)
}
se.prototype.rotateRight = function(e) {
    e = p(e, this.defaultRotateAmount), uT(this, -e)
};
se.prototype.rotateLeft = function(e) {
    e = p(e, this.defaultRotateAmount), uT(this, e)
};

function uT(e, t) {
    l(e.constrainedAxis) ? e.rotate(e.constrainedAxis, t) : e.rotate(e.up, t)
}

function af(e, t) {
    var n = e.frustum,
        r;
    if (t = t * .5, Math.abs(n.top) + Math.abs(n.bottom) > Math.abs(n.left) + Math.abs(n.right)) {
        var i = n.top - t,
            a = n.bottom + t,
            o = e._maxCoord.y;
        e._scene.mapMode2D === Do.ROTATE && (o *= e.maximumZoomFactor), a > o && (a = o, i = -o), i <= a && (i = 1, a = -1), r = n.right / n.top, n.top = i, n.bottom = a, n.right = n.top * r, n.left = -n.right
    } else {
        var s = n.right - t,
            c = n.left + t,
            f = e._maxCoord.x;
        e._scene.mapMode2D === Do.ROTATE && (f *= e.maximumZoomFactor), s > f && (s = f, c = -f), s <= c && (s = 1, c = -1), r = n.top / n.right, n.right = s, n.left = c, n.top = n.right * r, n.bottom = -n.top
    }
}

function cT(e, t) {
    e.move(e.direction, t)
}
se.prototype.zoomIn = function(e) {
    e = p(e, this.defaultZoomAmount), this._mode === k.SCENE2D ? af(this, e) : cT(this, e)
};
se.prototype.zoomOut = function(e) {
    e = p(e, this.defaultZoomAmount), this._mode === k.SCENE2D ? af(this, -e) : cT(this, -e)
};
se.prototype.getMagnitude = function() {
    if (this._mode === k.SCENE3D) return u.magnitude(this.position);
    if (this._mode === k.COLUMBUS_VIEW) return Math.abs(this.position.z);
    if (this._mode === k.SCENE2D) return Math.max(this.frustum.right - this.frustum.left, this.frustum.top - this.frustum.bottom)
};
var e2 = new S;
se.prototype.lookAt = function(e, t) {
    var n = xe.eastNorthUpToFixedFrame(e, ne.WGS84, e2);
    this.lookAtTransform(n, t)
};
var t2 = new u,
    n2 = new X,
    r2 = new X,
    i2 = new N;

function fT(e, t, n) {
    t = T.clamp(t, -T.PI_OVER_TWO, T.PI_OVER_TWO), e = T.zeroToTwoPi(e) - T.PI_OVER_TWO;
    var r = X.fromAxisAngle(u.UNIT_Y, -t, n2),
        i = X.fromAxisAngle(u.UNIT_Z, -e, r2),
        a = X.multiply(i, r, i),
        o = N.fromQuaternion(a, i2),
        s = u.clone(u.UNIT_X, t2);
    return N.multiplyByVector(o, s, s), u.negate(s, s), u.multiplyByScalar(s, n, s), s
}
se.prototype.lookAtTransform = function(e, t) {
    if (this._setTransform(e), !!l(t)) {
        var n;
        if (l(t.heading) ? n = fT(t.heading, t.pitch, t.range) : n = t, this._mode === k.SCENE2D) {
            R.clone(R.ZERO, this.position), u.negate(n, this.up), this.up.z = 0, u.magnitudeSquared(this.up) < T.EPSILON10 && u.clone(u.UNIT_Y, this.up), u.normalize(this.up, this.up), this._setTransform(S.IDENTITY), u.negate(u.UNIT_Z, this.direction), u.cross(this.direction, this.up, this.right), u.normalize(this.right, this.right);
            var r = this.frustum,
                i = r.top / r.right;
            r.right = u.magnitude(n) * .5, r.left = -r.right, r.top = i * r.right, r.bottom = -r.top, this._setTransform(e);
            return
        }
        u.clone(n, this.position), u.negate(this.position, this.direction), u.normalize(this.direction, this.direction), u.cross(this.direction, u.UNIT_Z, this.right), u.magnitudeSquared(this.right) < T.EPSILON10 && u.clone(u.UNIT_X, this.right), u.normalize(this.right, this.right), u.cross(this.right, this.direction, this.up), u.normalize(this.up, this.up), this._adjustOrthographicFrustum(!0)
    }
};
var os = new K,
    a2 = new K,
    o2 = new u,
    s2 = new u,
    u2 = new u,
    c2 = new u,
    f2 = new u,
    h2 = new u,
    l2 = new u,
    Lh = new u,
    d2 = {
        direction: new u,
        right: new u,
        up: new u
    },
    Mm;

function dn(e, t, n, r) {
    var i = Math.abs(u.dot(t, n));
    return i / r - u.dot(e, n)
}

function hT(e, t, n, r) {
    var i = e._projection.ellipsoid,
        a = r ? e : d2,
        o = t.north,
        s = t.south,
        c = t.east,
        f = t.west;
    f > c && (c += T.TWO_PI);
    var h = (f + c) * .5,
        d;
    if (s < -T.PI_OVER_TWO + T.RADIANS_PER_DEGREE && o > T.PI_OVER_TWO - T.RADIANS_PER_DEGREE) d = 0;
    else {
        var _ = os;
        _.longitude = h, _.latitude = o, _.height = 0;
        var v = a2;
        v.longitude = h, v.latitude = s, v.height = 0;
        var m = Mm;
        (!l(m) || m.ellipsoid !== i) && (Mm = m = new Gs(void 0, void 0, i)), m.setEndPoints(_, v), d = m.interpolateUsingFraction(.5, os).latitude
    }
    var g = os;
    g.longitude = h, g.latitude = d, g.height = 0;
    var y = i.cartographicToCartesian(g, l2),
        E = os;
    E.longitude = c, E.latitude = o;
    var w = i.cartographicToCartesian(E, o2);
    E.longitude = f;
    var C = i.cartographicToCartesian(E, u2);
    E.longitude = h;
    var A = i.cartographicToCartesian(E, f2);
    E.latitude = s;
    var x = i.cartographicToCartesian(E, h2);
    E.longitude = c;
    var P = i.cartographicToCartesian(E, c2);
    E.longitude = f;
    var I = i.cartographicToCartesian(E, s2);
    u.subtract(C, y, C), u.subtract(P, y, P), u.subtract(w, y, w), u.subtract(I, y, I), u.subtract(A, y, A), u.subtract(x, y, x);
    var D = i.geodeticSurfaceNormal(y, a.direction);
    u.negate(D, D);
    var O = u.cross(D, u.UNIT_Z, a.right);
    u.normalize(O, O);
    var F = u.cross(O, D, a.up),
        z;
    if (e.frustum instanceof lt) {
        var b = Math.max(u.distance(w, C), u.distance(P, I)),
            M = Math.max(u.distance(w, P), u.distance(C, I)),
            G, V, B = e.frustum._offCenterFrustum.right / e.frustum._offCenterFrustum.top,
            Y = M * B;
        b > Y ? (G = b, V = G / B) : (V = M, G = Y), z = Math.max(G, V)
    } else {
        var j = Math.tan(e.frustum.fovy * .5),
            Z = e.frustum.aspectRatio * j;
        if (z = Math.max(dn(D, F, C, j), dn(D, F, P, j), dn(D, F, w, j), dn(D, F, I, j), dn(D, F, A, j), dn(D, F, x, j), dn(D, O, C, Z), dn(D, O, P, Z), dn(D, O, w, Z), dn(D, O, I, Z), dn(D, O, A, Z), dn(D, O, x, Z)), s < 0 && o > 0) {
            var Q = os;
            Q.longitude = f, Q.latitude = 0, Q.height = 0;
            var ie = i.cartographicToCartesian(Q, Lh);
            u.subtract(ie, y, ie), z = Math.max(z, dn(D, F, ie, j), dn(D, O, ie, Z)), Q.longitude = c, ie = i.cartographicToCartesian(Q, Lh), u.subtract(ie, y, ie), z = Math.max(z, dn(D, F, ie, j), dn(D, O, ie, Z))
        }
    }
    return u.add(y, u.multiplyByScalar(D, -z, Lh), n)
}
var _2 = new K,
    v2 = new u,
    m2 = new u;

function p2(e, t, n) {
    var r = e._projection;
    t.west > t.east && (t = W.MAX_VALUE);
    var i = e._actualTransform,
        a = e._actualInvTransform,
        o = _2;
    o.longitude = t.east, o.latitude = t.north;
    var s = r.project(o, v2);
    S.multiplyByPoint(i, s, s), S.multiplyByPoint(a, s, s), o.longitude = t.west, o.latitude = t.south;
    var c = r.project(o, m2);
    if (S.multiplyByPoint(i, c, c), S.multiplyByPoint(a, c, c), n.x = (s.x - c.x) * .5 + c.x, n.y = (s.y - c.y) * .5 + c.y, l(e.frustum.fovy)) {
        var f = Math.tan(e.frustum.fovy * .5),
            h = e.frustum.aspectRatio * f;
        n.z = Math.max((s.x - c.x) / h, (s.y - c.y) / f) * .5
    } else {
        var d = s.x - c.x,
            _ = s.y - c.y;
        n.z = Math.max(d, _)
    }
    return n
}
var g2 = new K,
    y2 = new u,
    T2 = new u;

function E2(e, t, n) {
    var r = e._projection,
        i = t.east;
    t.west > t.east && (e._scene.mapMode2D === Do.INFINITE_SCROLL ? i += T.TWO_PI : (t = W.MAX_VALUE, i = t.east));
    var a = g2;
    a.longitude = i, a.latitude = t.north;
    var o = r.project(a, y2);
    a.longitude = t.west, a.latitude = t.south;
    var s = r.project(a, T2),
        c = Math.abs(o.x - s.x) * .5,
        f = Math.abs(o.y - s.y) * .5,
        h, d, _ = e.frustum.right / e.frustum.top,
        v = f * _;
    return c > v ? (h = c, d = h / _) : (d = f, h = v), f = Math.max(2 * h, 2 * d), n.x = (o.x - s.x) * .5 + s.x, n.y = (o.y - s.y) * .5 + s.y, a = r.unproject(n, a), a.height = f, n = r.project(a, n), n
}
se.prototype.getRectangleCameraCoordinates = function(e, t) {
    var n = this._mode;
    if (l(t) || (t = new u), n === k.SCENE3D) return hT(this, e, t);
    if (n === k.COLUMBUS_VIEW) return p2(this, e, t);
    if (n === k.SCENE2D) return E2(this, e, t)
};
var A2 = new Ke;

function C2(e, t, n, r) {
    n = p(n, ne.WGS84);
    var i = e.getPickRay(t, A2),
        a = Me.rayEllipsoid(i, n);
    if (!!a) {
        var o = a.start > 0 ? a.start : a.stop;
        return Ke.getPoint(i, o, r)
    }
}
var w2 = new Ke;

function x2(e, t, n, r) {
    var i = e.getPickRay(t, w2),
        a = i.origin;
    a = u.fromElements(a.y, a.z, 0, a);
    var o = n.unproject(a);
    if (!(o.latitude < -T.PI_OVER_TWO || o.latitude > T.PI_OVER_TWO)) return n.ellipsoid.cartographicToCartesian(o, r)
}
var S2 = new Ke;

function R2(e, t, n, r) {
    var i = e.getPickRay(t, S2),
        a = -i.origin.x / i.direction.x;
    Ke.getPoint(i, a, r);
    var o = n.unproject(new u(r.y, r.z, 0));
    if (!(o.latitude < -T.PI_OVER_TWO || o.latitude > T.PI_OVER_TWO || o.longitude < -Math.PI || o.longitude > Math.PI)) return n.ellipsoid.cartographicToCartesian(o, r)
}
se.prototype.pickEllipsoid = function(e, t, n) {
    var r = this._scene.canvas;
    if (!(r.clientWidth === 0 || r.clientHeight === 0)) {
        if (l(n) || (n = new u), t = p(t, ne.WGS84), this._mode === k.SCENE3D) n = C2(this, e, t, n);
        else if (this._mode === k.SCENE2D) n = x2(this, e, this._projection, n);
        else if (this._mode === k.COLUMBUS_VIEW) n = R2(this, e, this._projection, n);
        else return;
        return n
    }
};
var D2 = new u,
    I2 = new u,
    P2 = new u;

function O2(e, t, n) {
    var r = e._scene.canvas,
        i = r.clientWidth,
        a = r.clientHeight,
        o = Math.tan(e.frustum.fovy * .5),
        s = e.frustum.aspectRatio * o,
        c = e.frustum.near,
        f = 2 / i * t.x - 1,
        h = 2 / a * (a - t.y) - 1,
        d = e.positionWC;
    u.clone(d, n.origin);
    var _ = u.multiplyByScalar(e.directionWC, c, D2);
    u.add(d, _, _);
    var v = u.multiplyByScalar(e.rightWC, f * c * s, I2),
        m = u.multiplyByScalar(e.upWC, h * c * o, P2),
        g = u.add(_, v, n.direction);
    return u.add(g, m, g), u.subtract(g, d, g), u.normalize(g, g), n
}
var ku = new u;

function M2(e, t, n) {
    var r = e._scene.canvas,
        i = r.clientWidth,
        a = r.clientHeight,
        o = e.frustum;
    l(o._offCenterFrustum) && (o = o._offCenterFrustum);
    var s = 2 / i * t.x - 1;
    s *= (o.right - o.left) * .5;
    var c = 2 / a * (a - t.y) - 1;
    c *= (o.top - o.bottom) * .5;
    var f = n.origin;
    return u.clone(e.position, f), u.multiplyByScalar(e.right, s, ku), u.add(ku, f, f), u.multiplyByScalar(e.up, c, ku), u.add(ku, f, f), u.clone(e.directionWC, n.direction), (e._mode === k.COLUMBUS_VIEW || e._mode === k.SCENE2D) && u.fromElements(n.origin.z, n.origin.x, n.origin.y, n.origin), n
}
se.prototype.getPickRay = function(e, t) {
    l(t) || (t = new Ke);
    var n = this.frustum;
    return l(n.aspectRatio) && l(n.fov) && l(n.near) ? O2(this, e, t) : M2(this, e, t)
};
var N2 = new u,
    b2 = new u;
se.prototype.distanceToBoundingSphere = function(e) {
    var t = u.subtract(this.positionWC, e.center, N2),
        n = u.multiplyByScalar(this.directionWC, u.dot(t, this.directionWC), b2);
    return Math.max(0, u.magnitude(n) - e.radius)
};
var F2 = new R;
se.prototype.getPixelSize = function(e, t, n) {
    var r = this.distanceToBoundingSphere(e),
        i = this.frustum.getPixelDimensions(t, n, r, this._scene.pixelRatio, F2);
    return Math.max(i.x, i.y)
};

function L2(e, t, n, r, i, a) {
    var o = u.clone(t);
    n.y > r ? o.y -= n.y - r : n.y < -r && (o.y += -r - n.y), n.z > i ? o.z -= n.z - i : n.z < -i && (o.z += -i - n.z);

    function s(c) {
        var f = u.lerp(t, o, c.time, new u);
        e.worldToCameraCoordinatesPoint(f, e.position)
    }
    return {
        easingFunction: Uc.EXPONENTIAL_OUT,
        startObject: {
            time: 0
        },
        stopObject: {
            time: 1
        },
        duration: a,
        update: s
    }
}
var U2 = new u,
    Nm = new u,
    z2 = new u,
    B2 = new u;

function V2(e, t) {
    var n = e.position,
        r = e.direction,
        i = e.worldToCameraCoordinatesVector(u.UNIT_X, U2),
        a = -u.dot(i, n) / u.dot(i, r),
        o = u.add(n, u.multiplyByScalar(r, a, Nm), Nm);
    e.cameraToWorldCoordinatesPoint(o, o), n = e.cameraToWorldCoordinatesPoint(e.position, z2);
    var s = Math.tan(e.frustum.fovy * .5),
        c = e.frustum.aspectRatio * s,
        f = u.magnitude(u.subtract(n, o, B2)),
        h = c * f,
        d = s * f,
        _ = e._maxCoord.x,
        v = e._maxCoord.y,
        m = Math.max(h - _, _),
        g = Math.max(d - v, v);
    if (n.z < -m || n.z > m || n.y < -g || n.y > g) {
        var y = o.y < -m || o.y > m,
            E = o.z < -g || o.z > g;
        if (y || E) return L2(e, n, o, m, g, t)
    }
}
se.prototype.createCorrectPositionTween = function(e) {
    if (this._mode === k.COLUMBUS_VIEW) return V2(this, e)
};
var G2 = new u,
    Wt = {
        destination: void 0,
        heading: void 0,
        pitch: void 0,
        roll: void 0,
        duration: void 0,
        complete: void 0,
        cancel: void 0,
        endTransform: void 0,
        maximumHeight: void 0,
        easingFunction: void 0
    };
se.prototype.cancelFlight = function() {
    l(this._currentFlight) && (this._currentFlight.cancelTween(), this._currentFlight = void 0)
};
se.prototype.completeFlight = function() {
    if (l(this._currentFlight)) {
        this._currentFlight.cancelTween();
        var e = {
            destination: void 0,
            orientation: {
                heading: void 0,
                pitch: void 0,
                roll: void 0
            }
        };
        e.destination = Wt.destination, e.orientation.heading = Wt.heading, e.orientation.pitch = Wt.pitch, e.orientation.roll = Wt.roll, this.setView(e), l(this._currentFlight.complete) && this._currentFlight.complete(), this._currentFlight = void 0
    }
};
se.prototype.flyTo = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.destination,
        n = this._mode;
    if (n !== k.MORPHING) {
        this.cancelFlight();
        var r = p(e.orientation, p.EMPTY_OBJECT);
        if (l(r.direction) && (r = aT(this, t, r, Fl.orientation)), l(e.duration) && e.duration <= 0) {
            var i = Fl;
            i.destination = e.destination, i.orientation.heading = r.heading, i.orientation.pitch = r.pitch, i.orientation.roll = r.roll, i.convert = e.convert, i.endTransform = e.endTransform, this.setView(i), typeof e.complete == "function" && e.complete();
            return
        }
        var a = l(t.west);
        a && (t = this.getRectangleCameraCoordinates(t, G2));
        var o = this,
            s;
        Wt.destination = t, Wt.heading = r.heading, Wt.pitch = r.pitch, Wt.roll = r.roll, Wt.duration = e.duration, Wt.complete = function() {
            s === o._currentFlight && (o._currentFlight = void 0), l(e.complete) && e.complete()
        }, Wt.cancel = e.cancel, Wt.endTransform = e.endTransform, Wt.convert = a ? !1 : e.convert, Wt.maximumHeight = e.maximumHeight, Wt.pitchAdjustHeight = e.pitchAdjustHeight, Wt.flyOverLongitude = e.flyOverLongitude, Wt.flyOverLongitudeWeight = e.flyOverLongitudeWeight, Wt.easingFunction = e.easingFunction;
        var c = this._scene,
            f = $y.createTween(c, Wt);
        if (f.duration === 0) {
            typeof f.complete == "function" && f.complete();
            return
        }
        s = c.tweens.add(f), this._currentFlight = s;
        var h = this._scene.preloadFlightCamera;
        this._mode !== k.SCENE2D && (l(h) || (h = se.clone(this)), h.setView({
            destination: t,
            orientation: r
        }), this._scene.preloadFlightCullingVolume = h.frustum.computeCullingVolume(h.positionWC, h.directionWC, h.upWC))
    }
};

function H2(e, t) {
    var n = e.frustum,
        r = Math.tan(n.fovy * .5),
        i = n.aspectRatio * r;
    return Math.max(t / i, t / r)
}

function k2(e, t) {
    var n = e.frustum;
    l(n._offCenterFrustum) && (n = n._offCenterFrustum);
    var r, i, a = n.right / n.top,
        o = t * a;
    return t > o ? (r = t, i = r / a) : (i = t, r = o), Math.max(r, i) * 1.5
}
var W2 = 100;

function lT(e, t, n) {
    n = zc.clone(l(n) ? n : se.DEFAULT_OFFSET);
    var r = e._scene.screenSpaceCameraController.minimumZoomDistance,
        i = e._scene.screenSpaceCameraController.maximumZoomDistance,
        a = n.range;
    if (!l(a) || a === 0) {
        var o = t.radius;
        o === 0 ? n.range = W2 : e.frustum instanceof lt || e._mode === k.SCENE2D ? n.range = k2(e, o) : n.range = H2(e, o), n.range = T.clamp(n.range, r, i)
    }
    return n
}
se.prototype.viewBoundingSphere = function(e, t) {
    t = lT(this, e, t), this.lookAt(e.center, t)
};
var q2 = new S,
    Y2 = new u,
    X2 = new u,
    j2 = new u,
    Z2 = new u,
    K2 = new U,
    $2 = new X,
    J2 = new N;
se.prototype.flyToBoundingSphere = function(e, t) {
    t = p(t, p.EMPTY_OBJECT);
    var n = this._mode === k.SCENE2D || this._mode === k.COLUMBUS_VIEW;
    this._setTransform(S.IDENTITY);
    var r = lT(this, e, t.offset),
        i;
    n ? i = u.multiplyByScalar(u.UNIT_Z, r.range, Y2) : i = fT(r.heading, r.pitch, r.range);
    var a = xe.eastNorthUpToFixedFrame(e.center, ne.WGS84, q2);
    S.multiplyByPoint(a, i, i);
    var o, s;
    if (!n) {
        if (o = u.subtract(e.center, i, X2), u.normalize(o, o), s = S.multiplyByPointAsVector(a, u.UNIT_Z, j2), 1 - Math.abs(u.dot(o, s)) < T.EPSILON6) {
            var c = X.fromAxisAngle(o, r.heading, $2),
                f = N.fromQuaternion(c, J2);
            u.fromCartesian4(S.getColumn(a, 1, K2), s), N.multiplyByVector(f, s, s)
        }
        var h = u.cross(o, s, Z2);
        u.cross(h, o, s), u.normalize(s, s)
    }
    this.flyTo({
        destination: i,
        orientation: {
            direction: o,
            up: s
        },
        duration: t.duration,
        complete: t.complete,
        cancel: t.cancel,
        endTransform: t.endTransform,
        maximumHeight: t.maximumHeight,
        easingFunction: t.easingFunction,
        flyOverLongitude: t.flyOverLongitude,
        flyOverLongitudeWeight: t.flyOverLongitudeWeight,
        pitchAdjustHeight: t.pitchAdjustHeight
    })
};
var bm = new u,
    Fm = new u,
    Uh = new u,
    Lm = new u,
    ss = [new u, new u, new u, new u];

function Q2(e, t) {
    var n = t.radii,
        r = e.positionWC,
        i = u.multiplyComponents(t.oneOverRadii, r, bm),
        a = u.magnitude(i),
        o = u.normalize(i, Fm),
        s, c;
    u.equalsEpsilon(o, u.UNIT_Z, T.EPSILON10) ? (s = new u(0, 1, 0), c = new u(0, 0, 1)) : (s = u.normalize(u.cross(u.UNIT_Z, o, Uh), Uh), c = u.normalize(u.cross(o, s, Lm), Lm));
    var f = Math.sqrt(u.magnitudeSquared(i) - 1),
        h = u.multiplyByScalar(o, 1 / a, bm),
        d = f / a,
        _ = u.multiplyByScalar(s, d, Fm),
        v = u.multiplyByScalar(c, d, Uh),
        m = u.add(h, v, ss[0]);
    u.subtract(m, _, m), u.multiplyComponents(n, m, m);
    var g = u.subtract(h, v, ss[1]);
    u.subtract(g, _, g), u.multiplyComponents(n, g, g);
    var y = u.subtract(h, v, ss[2]);
    u.add(y, _, y), u.multiplyComponents(n, y, y);
    var E = u.add(h, v, ss[3]);
    return u.add(E, _, E), u.multiplyComponents(n, E, E), ss
}
var zh = new R,
    e3 = new u,
    Xi = [new K, new K, new K, new K];

function Wu(e, t, n, r, i, a) {
    zh.x = e, zh.y = t;
    var o = r.pickEllipsoid(zh, i, e3);
    return l(o) ? (Xi[n] = i.cartesianToCartographic(o, Xi[n]), 1) : (Xi[n] = i.cartesianToCartographic(a[n], Xi[n]), 0)
}
se.prototype.computeViewRectangle = function(e, t) {
    e = p(e, ne.WGS84);
    var n = this.frustum.computeCullingVolume(this.positionWC, this.directionWC, this.upWC),
        r = new q(u.ZERO, e.maximumRadius),
        i = n.computeVisibility(r);
    if (i !== nt.OUTSIDE) {
        var a = this._scene.canvas,
            o = a.clientWidth,
            s = a.clientHeight,
            c = 0,
            f = Q2(this, e);
        if (c += Wu(0, 0, 0, this, e, f), c += Wu(0, s, 1, this, e, f), c += Wu(o, s, 2, this, e, f), c += Wu(o, 0, 3, this, e, f), c < 2) return W.MAX_VALUE;
        t = W.fromCartographicArray(Xi, t);
        for (var h = 0, d = Xi[3].longitude, _ = 0; _ < 4; ++_) {
            var v = Xi[_].longitude,
                m = Math.abs(v - d);
            m > T.PI ? h += T.TWO_PI - m : h += m, d = v
        }
        return T.equalsEpsilon(Math.abs(h), T.TWO_PI, T.EPSILON9) && (t.west = -T.PI, t.east = T.PI, Xi[0].latitude >= 0 ? t.north = T.PI_OVER_TWO : t.south = -T.PI_OVER_TWO), t
    }
};
se.prototype.switchToPerspectiveFrustum = function() {
    if (!(this._mode === k.SCENE2D || this.frustum instanceof en)) {
        var e = this._scene;
        this.frustum = new en, this.frustum.aspectRatio = e.drawingBufferWidth / e.drawingBufferHeight, this.frustum.fov = T.toRadians(60)
    }
};
se.prototype.switchToOrthographicFrustum = function() {
    if (!(this._mode === k.SCENE2D || this.frustum instanceof lt)) {
        var e = rT(this),
            t = this._scene;
        this.frustum = new lt, this.frustum.aspectRatio = t.drawingBufferWidth / t.drawingBufferHeight, this.frustum.width = e
    }
};
se.clone = function(e, t) {
    return l(t) || (t = new se(e._scene)), u.clone(e.position, t.position), u.clone(e.direction, t.direction), u.clone(e.up, t.up), u.clone(e.right, t.right), S.clone(e._transform, t.transform), t._transformChanged = !0, t.frustum = e.frustum.clone(), t
};

function aa() {}

function Wr(e, t, n) {}
Wr.prototype.addCredit = aa;
Wr.prototype.addDefaultCredit = aa;
Wr.prototype.removeDefaultCredit = aa;
Wr.prototype.showLightbox = aa;
Wr.prototype.hideLightbox = aa;
Wr.prototype.update = aa;
Wr.prototype.beginFrame = aa;
Wr.prototype.endFrame = aa;
Wr.prototype.destroy = function() {
    return Pe(this)
};
Wr.prototype.isDestroyed = function() {
    return !1
};
const t3 = `varying vec4 positionEC;
void main()
{
vec3 position;
vec3 direction;
if (czm_orthographicIn3D == 1.0)
{
vec2 uv = (gl_FragCoord.xy -  czm_viewport.xy) / czm_viewport.zw;
vec2 minPlane = vec2(czm_frustumPlanes.z, czm_frustumPlanes.y);
vec2 maxPlane = vec2(czm_frustumPlanes.w, czm_frustumPlanes.x);
position = vec3(mix(minPlane, maxPlane, uv), 0.0);
direction = vec3(0.0, 0.0, -1.0);
}
else
{
position = vec3(0.0);
direction = normalize(positionEC.xyz);
}
czm_ray ray = czm_ray(position, direction);
vec3 ellipsoid_center = czm_view[3].xyz;
czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);
if (!czm_isEmpty(intersection))
{
gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
}
else
{
discard;
}
czm_writeLogDepth();
}
`,
    n3 = `attribute vec4 position;
varying vec4 positionEC;
void main()
{
positionEC = czm_modelView * position;
gl_Position = czm_projection * positionEC;
czm_vertexLogDepth();
}
`;

function Hs() {
    this._rs = void 0, this._sp = void 0, this._va = void 0, this._command = void 0, this._mode = void 0, this._useLogDepth = !1
}
var us = An.supportsTypedArrays() ? new Float32Array(12) : [],
    Um = new u,
    zm = new u,
    Bh = new u,
    Bm = new u,
    qu = new u;

function r3(e, t) {
    var n = e.radii,
        r = t.camera,
        i, a, o;
    if (r.frustum instanceof lt) i = u.ZERO, a = r.rightWC, o = r.upWC;
    else {
        var s = r.positionWC,
            c = u.multiplyComponents(e.oneOverRadii, s, Um),
            f = u.normalize(c, zm),
            h = u.normalize(u.cross(u.UNIT_Z, c, Bh), Bh),
            d = u.normalize(u.cross(f, h, Bm), Bm),
            _ = u.magnitude(c),
            v = Math.sqrt(_ * _ - 1);
        i = u.multiplyByScalar(f, 1 / _, Um);
        var m = v / _;
        a = u.multiplyByScalar(h, m, zm), o = u.multiplyByScalar(d, m, Bh)
    }
    var g = u.add(i, o, qu);
    u.subtract(g, a, g), u.multiplyComponents(n, g, g), u.pack(g, us, 0);
    var y = u.subtract(i, o, qu);
    u.subtract(y, a, y), u.multiplyComponents(n, y, y), u.pack(y, us, 3);
    var E = u.add(i, o, qu);
    u.add(E, a, E), u.multiplyComponents(n, E, E), u.pack(E, us, 6);
    var w = u.subtract(i, o, qu);
    return u.add(w, a, w), u.multiplyComponents(n, w, w), u.pack(w, us, 9), us
}
Hs.prototype.update = function(e) {
    if (this._mode = e.mode, e.mode === k.SCENE3D) {
        var t = e.context,
            n = e.mapProjection.ellipsoid,
            r = e.useLogDepth;
        if (l(this._command) || (this._rs = Ge.fromCache({
                cull: {
                    enabled: !0
                },
                depthTest: {
                    enabled: !0
                },
                colorMask: {
                    red: !1,
                    green: !1,
                    blue: !1,
                    alpha: !1
                }
            }), this._command = new an({
                renderState: this._rs,
                boundingVolume: new q(u.ZERO, n.maximumRadius),
                pass: ue.OPAQUE,
                owner: this
            })), !l(this._sp) || this._useLogDepth !== r) {
            this._useLogDepth = r;
            var i = new Re({
                    sources: [n3]
                }),
                a = new Re({
                    sources: [t3]
                });
            if (r) {
                var o = `#ifdef GL_EXT_frag_depth 
#extension GL_EXT_frag_depth : enable 
#endif 

`;
                a.sources.push(o), a.defines.push("LOG_DEPTH"), i.defines.push("LOG_DEPTH")
            }
            this._sp = Mt.replaceCache({
                shaderProgram: this._sp,
                context: t,
                vertexShaderSource: i,
                fragmentShaderSource: a,
                attributeLocations: {
                    position: 0
                }
            }), this._command.shaderProgram = this._sp
        }
        var s = r3(n, e);
        if (l(this._va)) this._va.getAttribute(0).vertexBuffer.copyFromArrayView(s);
        else {
            var c = new rt({
                attributes: {
                    position: new ze({
                        componentDatatype: ee.FLOAT,
                        componentsPerAttribute: 3,
                        values: s
                    })
                },
                indices: [0, 1, 2, 2, 1, 3],
                primitiveType: Ve.TRIANGLES
            });
            this._va = Cn.fromGeometry({
                context: t,
                geometry: c,
                attributeLocations: {
                    position: 0
                },
                bufferUsage: Ye.DYNAMIC_DRAW
            }), this._command.vertexArray = this._va
        }
    }
};
Hs.prototype.execute = function(e, t) {
    this._mode === k.SCENE3D && this._command.execute(e, t)
};
Hs.prototype.isDestroyed = function() {
    return !1
};
Hs.prototype.destroy = function() {
    this._sp = this._sp && this._sp.destroy(), this._va = this._va && this._va.destroy()
};

function ba() {}
var i3 = /\bgl_FragDepthEXT\b/,
    a3 = /\bdiscard\b/;

function o3(e, t) {
    var n = e.shaderCache.getDerivedShaderProgram(t, "depthOnly");
    if (!l(n)) {
        var r = t._attributeLocations,
            i = t.fragmentShaderSource,
            a, o = !1,
            s = i.sources,
            c = s.length;
        for (a = 0; a < c; ++a)
            if (i3.test(s[a]) || a3.test(s[a])) {
                o = !0;
                break
            }
        var f = !1,
            h = i.defines;
        for (c = h.length, a = 0; a < c; ++a)
            if (h[a] === "LOG_DEPTH") {
                f = !0;
                break
            }
        var d;
        !o && !f ? (d = `void main() 
{ 
    gl_FragColor = vec4(1.0); 
} 
`, i = new Re({
            sources: [d]
        })) : !o && f && (d = `#ifdef GL_EXT_frag_depth 
#extension GL_EXT_frag_depth : enable 
#endif 

void main() 
{ 
    gl_FragColor = vec4(1.0); 
    czm_writeLogDepth(); 
} 
`, i = new Re({
            defines: ["LOG_DEPTH"],
            sources: [d]
        })), n = e.shaderCache.createDerivedShaderProgram(t, "depthOnly", {
            vertexShaderSource: t.vertexShaderSource,
            fragmentShaderSource: i,
            attributeLocations: r
        })
    }
    return n
}

function s3(e, t) {
    var n = e._depthOnlyRenderStateCache,
        r = n[t.id];
    if (!l(r)) {
        var i = Ge.getState(t);
        i.depthMask = !0, i.colorMask = {
            red: !1,
            green: !1,
            blue: !1,
            alpha: !1
        }, r = Ge.fromCache(i), n[t.id] = r
    }
    return r
}
ba.createDepthOnlyDerivedCommand = function(e, t, n, r) {
    l(r) || (r = {});
    var i, a;
    return l(r.depthOnlyCommand) && (i = r.depthOnlyCommand.shaderProgram, a = r.depthOnlyCommand.renderState), r.depthOnlyCommand = an.shallowClone(t, r.depthOnlyCommand), !l(i) || r.shaderProgramId !== t.shaderProgram.id ? (r.depthOnlyCommand.shaderProgram = o3(n, t.shaderProgram), r.depthOnlyCommand.renderState = s3(e, t.renderState), r.shaderProgramId = t.shaderProgram.id) : (r.depthOnlyCommand.shaderProgram = i, r.depthOnlyCommand.renderState = a), r
};
var u3 = /\s+czm_writeLogDepth\(/,
    c3 = /\s+czm_vertexLogDepth\(/,
    f3 = /\s*#extension\s+GL_EXT_frag_depth\s*:\s*enable/;

function h3(e, t) {
    var n = e.shaderCache.getDerivedShaderProgram(t, "logDepth");
    if (!l(n)) {
        var r = t._attributeLocations,
            i = t.vertexShaderSource.clone(),
            a = t.fragmentShaderSource.clone();
        i.defines = l(i.defines) ? i.defines.slice(0) : [], i.defines.push("LOG_DEPTH"), a.defines = l(a.defines) ? a.defines.slice(0) : [], a.defines.push("LOG_DEPTH");
        var o, s, c = !1,
            f = i.sources,
            h = f.length;
        for (o = 0; o < h; ++o)
            if (c3.test(f[o])) {
                c = !0;
                break
            }
        if (!c) {
            for (o = 0; o < h; ++o) f[o] = Re.replaceMain(f[o], "czm_log_depth_main");
            s = `

void main() 
{ 
    czm_log_depth_main(); 
    czm_vertexLogDepth(); 
} 
`, f.push(s)
        }
        for (f = a.sources, h = f.length, c = !1, o = 0; o < h; ++o) u3.test(f[o]) && (c = !0);
        a.defines.indexOf("LOG_DEPTH_WRITE") !== -1 && (c = !0);
        var d = !0;
        for (o = 0; o < h; ++o) f3.test(f[o]) && (d = !1);
        var _ = "";
        if (d && (_ += `#ifdef GL_EXT_frag_depth 
#extension GL_EXT_frag_depth : enable 
#endif 

`), !c) {
            for (o = 0; o < h; o++) f[o] = Re.replaceMain(f[o], "czm_log_depth_main");
            _ += `
void main() 
{ 
    czm_log_depth_main(); 
    czm_writeLogDepth(); 
} 
`
        }
        f.push(_), n = e.shaderCache.createDerivedShaderProgram(t, "logDepth", {
            vertexShaderSource: i,
            fragmentShaderSource: a,
            attributeLocations: r
        })
    }
    return n
}
ba.createLogDepthCommand = function(e, t, n) {
    l(n) || (n = {});
    var r;
    return l(n.command) && (r = n.command.shaderProgram), n.command = an.shallowClone(e, n.command), !l(r) || n.shaderProgramId !== e.shaderProgram.id ? (n.command.shaderProgram = h3(t, e.shaderProgram), n.shaderProgramId = e.shaderProgram.id) : n.command.shaderProgram = r, n
};

function l3(e, t) {
    var n = e.shaderCache.getDerivedShaderProgram(t, "HDR");
    if (!l(n)) {
        var r = t._attributeLocations,
            i = t.vertexShaderSource.clone(),
            a = t.fragmentShaderSource.clone();
        i.defines = l(i.defines) ? i.defines.slice(0) : [], i.defines.push("HDR"), a.defines = l(a.defines) ? a.defines.slice(0) : [], a.defines.push("HDR"), n = e.shaderCache.createDerivedShaderProgram(t, "HDR", {
            vertexShaderSource: i,
            fragmentShaderSource: a,
            attributeLocations: r
        })
    }
    return n
}
ba.createHdrCommand = function(e, t, n) {
    l(n) || (n = {});
    var r;
    return l(n.command) && (r = n.command.shaderProgram), n.command = an.shallowClone(e, n.command), !l(r) || n.shaderProgramId !== e.shaderProgram.id ? (n.command.shaderProgram = l3(t, e.shaderProgram), n.shaderProgramId = e.shaderProgram.id) : n.command.shaderProgram = r, n
};

function dT() {
    this.enabled = !0, this.density = 2e-4, this.screenSpaceErrorFactor = 2, this.minimumBrightness = .03
}
var vc = [359.393, 800.749, 1275.6501, 2151.1192, 3141.7763, 4777.5198, 6281.2493, 12364.307, 15900.765, 49889.0549, 78026.8259, 99260.7344, 120036.3873, 151011.0158, 156091.1953, 203849.3112, 274866.9803, 319916.3149, 493552.0528, 628733.5874],
    ii = [2e-5, 2e-4, 1e-4, 7e-5, 5e-5, 4e-5, 3e-5, 19e-6, 1e-5, 85e-7, 62e-7, 58e-7, 53e-7, 52e-7, 51e-7, 42e-7, 4e-6, 34e-7, 26e-7, 22e-7];
for (var Vh = 0; Vh < ii.length; ++Vh) ii[Vh] *= 1e6;
var _T = ii[1],
    Ll = ii[ii.length - 1];
for (var Yu = 0; Yu < ii.length; ++Yu) ii[Yu] = (ii[Yu] - Ll) / (_T - Ll);
var Kt = 0;

function d3(e) {
    var t = vc,
        n = t.length;
    if (e < t[0]) return Kt = 0, Kt;
    if (e > t[n - 1]) return Kt = n - 2, Kt;
    if (e >= t[Kt]) {
        if (Kt + 1 < n && e < t[Kt + 1]) return Kt;
        if (Kt + 2 < n && e < t[Kt + 2]) return ++Kt, Kt
    } else if (Kt - 1 >= 0 && e >= t[Kt - 1]) return --Kt, Kt;
    var r;
    for (r = 0; r < n - 2 && !(e >= t[r] && e < t[r + 1]); ++r);
    return Kt = r, Kt
}
var _3 = new u;
dT.prototype.update = function(e) {
    var t = e.fog.enabled = this.enabled;
    if (!!t) {
        var n = e.camera,
            r = n.positionCartographic;
        if (!l(r) || r.height > 8e5 || e.mode !== k.SCENE3D) {
            e.fog.enabled = !1;
            return
        }
        var i = r.height,
            a = d3(i),
            o = T.clamp((i - vc[a]) / (vc[a + 1] - vc[a]), 0, 1),
            s = T.lerp(ii[a], ii[a + 1], o),
            c = this.density * 1e6,
            f = c / _T * Ll;
        s = s * (c - f) * 1e-6;
        var h = u.normalize(n.positionWC, _3),
            d = Math.abs(u.dot(n.directionWC, h));
        s *= 1 - d, e.fog.density = s, e.fog.sse = this.screenSpaceErrorFactor, e.fog.minimumBrightness = this.minimumBrightness
    }
};

function v3(e, t, n) {
    this.context = e, this.commandList = [], this.shadowMaps = [], this.brdfLutGenerator = void 0, this.environmentMap = void 0, this.sphericalHarmonicCoefficients = void 0, this.specularEnvironmentMaps = void 0, this.specularEnvironmentMapsMaximumLOD = void 0, this.mode = k.SCENE3D, this.morphTime = k.getMorphTime(k.SCENE3D), this.frameNumber = 0, this.newFrame = !1, this.time = void 0, this.jobScheduler = n, this.mapProjection = void 0, this.camera = void 0, this.cameraUnderground = !1, this.globeTranslucencyState = void 0, this.cullingVolume = void 0, this.occluder = void 0, this.maximumScreenSpaceError = void 0, this.pixelRatio = 1, this.passes = {
        render: !1,
        pick: !1,
        depth: !1,
        postProcess: !1,
        offscreen: !1
    }, this.creditDisplay = t, this.afterRender = [], this.scene3DOnly = !1, this.fog = {
        enabled: !1,
        density: void 0,
        sse: void 0,
        minimumBrightness: void 0
    }, this.terrainExaggeration = 1, this.shadowState = {
        shadowsEnabled: !0,
        shadowMaps: [],
        lightShadowMaps: [],
        nearPlane: 1,
        farPlane: 5e3,
        closestObjectSize: 1e3,
        lastDirtyTime: 0,
        outOfView: !0
    }, this.imagerySplitPosition = 0, this.frustumSplits = [], this.backgroundColor = void 0, this.light = void 0, this.minimumDisableDepthTestDistance = void 0, this.invertClassification = !1, this.invertClassificationColor = void 0, this.useLogDepth = !1, this.tilesetPassState = void 0, this.minimumTerrainHeight = 0
}
const mc = `uniform sampler2D colorTexture;
varying vec2 v_textureCoordinates;
void main()
{
gl_FragColor = texture2D(colorTexture, v_textureCoordinates);
}
`,
    Ul = `uniform highp sampler2D u_depthTexture;
varying vec2 v_textureCoordinates;
void main()
{
gl_FragColor = czm_packDepth(texture2D(u_depthTexture, v_textureCoordinates).r);
}
`;
var m3 = {
    NEVER: L.NEVER,
    LESS: L.LESS,
    EQUAL: L.EQUAL,
    LESS_OR_EQUAL: L.LEQUAL,
    GREATER: L.GREATER,
    NOT_EQUAL: L.NOTEQUAL,
    GREATER_OR_EQUAL: L.GEQUAL,
    ALWAYS: L.ALWAYS
};
const $i = Object.freeze(m3);
var p3 = {
    ZERO: L.ZERO,
    KEEP: L.KEEP,
    REPLACE: L.REPLACE,
    INCREMENT: L.INCR,
    DECREMENT: L.DECR,
    INVERT: L.INVERT,
    INCREMENT_WRAP: L.INCR_WRAP,
    DECREMENT_WRAP: L.DECR_WRAP
};
const Dn = Object.freeze(p3);
var pc = {
    CESIUM_3D_TILE_MASK: 128,
    SKIP_LOD_MASK: 112,
    SKIP_LOD_BIT_SHIFT: 4,
    CLASSIFICATION_MASK: 15
};
pc.setCesium3DTileBit = function() {
    return {
        enabled: !0,
        frontFunction: $i.ALWAYS,
        frontOperation: {
            fail: Dn.KEEP,
            zFail: Dn.KEEP,
            zPass: Dn.REPLACE
        },
        backFunction: $i.ALWAYS,
        backOperation: {
            fail: Dn.KEEP,
            zFail: Dn.KEEP,
            zPass: Dn.REPLACE
        },
        reference: pc.CESIUM_3D_TILE_MASK,
        mask: pc.CESIUM_3D_TILE_MASK
    }
};
const Fa = Object.freeze(pc);

function xr() {
    this._globeColorTexture = void 0, this._primitiveColorTexture = void 0, this._depthStencilTexture = void 0, this._globeDepthTexture = void 0, this._tempGlobeDepthTexture = void 0, this._tempCopyDepthTexture = void 0, this._globeColorFramebuffer = void 0, this._primitiveColorFramebuffer = void 0, this._copyDepthFramebuffer = void 0, this._tempCopyDepthFramebuffer = void 0, this._updateDepthFramebuffer = void 0, this._clearGlobeColorCommand = void 0, this._clearPrimitiveColorCommand = void 0, this._copyColorCommand = void 0, this._copyDepthCommand = void 0, this._tempCopyDepthCommand = void 0, this._updateDepthCommand = void 0, this._mergeColorCommand = void 0, this._viewport = new ge, this._rs = void 0, this._rsBlend = void 0, this._rsUpdate = void 0, this._useScissorTest = !1, this._scissorRectangle = void 0, this._useLogDepth = void 0, this._useHdr = void 0, this._clearGlobeDepth = void 0, this._debugGlobeDepthViewportCommand = void 0
}
Object.defineProperties(xr.prototype, {
    framebuffer: {
        get: function() {
            return this._globeColorFramebuffer
        }
    },
    primitiveFramebuffer: {
        get: function() {
            return this._primitiveColorFramebuffer
        }
    }
});

function g3(e, t, n, r) {
    if (!l(e._debugGlobeDepthViewportCommand) || r !== e._useLogDepth) {
        var i = `uniform highp sampler2D u_depthTexture;
varying vec2 v_textureCoordinates;
void main()
{
    float z_window = czm_unpackDepth(texture2D(u_depthTexture, v_textureCoordinates));
    z_window = czm_reverseLogDepth(z_window); 
    float n_range = czm_depthRange.near;
    float f_range = czm_depthRange.far;
    float z_ndc = (2.0 * z_window - n_range - f_range) / (f_range - n_range);
    float scale = pow(z_ndc * 0.5 + 0.5, 8.0);
    gl_FragColor = vec4(mix(vec3(0.0), vec3(1.0), scale), 1.0);
}
`,
            a = new Re({
                defines: [r ? "LOG_DEPTH" : ""],
                sources: [i]
            });
        e._debugGlobeDepthViewportCommand = t.createViewportQuadCommand(a, {
            uniformMap: {
                u_depthTexture: function() {
                    return e._globeDepthTexture
                }
            },
            owner: e
        }), e._useLogDepth = r
    }
    e._debugGlobeDepthViewportCommand.execute(t, n)
}

function vT(e) {
    e._globeColorTexture = e._globeColorTexture && !e._globeColorTexture.isDestroyed() && e._globeColorTexture.destroy(), e._depthStencilTexture = e._depthStencilTexture && !e._depthStencilTexture.isDestroyed() && e._depthStencilTexture.destroy(), e._globeDepthTexture = e._globeDepthTexture && !e._globeDepthTexture.isDestroyed() && e._globeDepthTexture.destroy()
}

function mT(e) {
    e._globeColorFramebuffer = e._globeColorFramebuffer && !e._globeColorFramebuffer.isDestroyed() && e._globeColorFramebuffer.destroy(), e._copyDepthFramebuffer = e._copyDepthFramebuffer && !e._copyDepthFramebuffer.isDestroyed() && e._copyDepthFramebuffer.destroy()
}

function pT(e) {
    e._tempCopyDepthFramebuffer = e._tempCopyDepthFramebuffer && !e._tempCopyDepthFramebuffer.isDestroyed() && e._tempCopyDepthFramebuffer.destroy(), e._updateDepthFramebuffer = e._updateDepthFramebuffer && !e._updateDepthFramebuffer.isDestroyed() && e._updateDepthFramebuffer.destroy(), e._tempGlobeDepthTexture = e._tempGlobeDepthTexture && !e._tempGlobeDepthTexture.isDestroyed() && e._tempGlobeDepthTexture.destroy()
}

function y3(e, t, n, r, i) {
    e._tempGlobeDepthTexture = new be({
        context: t,
        width: n,
        height: r,
        pixelFormat: de.RGBA,
        pixelDatatype: ae.UNSIGNED_BYTE,
        sampler: gt.NEAREST
    }), e._tempCopyDepthFramebuffer = new xt({
        context: t,
        colorTextures: [e._tempGlobeDepthTexture],
        destroyAttachments: !1
    }), e._updateDepthFramebuffer = new xt({
        context: t,
        colorTextures: [e._globeDepthTexture],
        depthStencilTexture: i.framebuffer.depthStencilTexture,
        destroyAttachments: !1
    })
}

function T3(e, t, n, r, i) {
    var a = i ? t.halfFloatingPointTexture ? ae.HALF_FLOAT : ae.FLOAT : ae.UNSIGNED_BYTE;
    e._globeColorTexture = new be({
        context: t,
        width: n,
        height: r,
        pixelFormat: de.RGBA,
        pixelDatatype: a,
        sampler: gt.NEAREST
    }), e._depthStencilTexture = new be({
        context: t,
        width: n,
        height: r,
        pixelFormat: de.DEPTH_STENCIL,
        pixelDatatype: ae.UNSIGNED_INT_24_8
    }), e._globeDepthTexture = new be({
        context: t,
        width: n,
        height: r,
        pixelFormat: de.RGBA,
        pixelDatatype: ae.UNSIGNED_BYTE,
        sampler: gt.NEAREST
    })
}

function E3(e, t) {
    e._globeColorFramebuffer = new xt({
        context: t,
        colorTextures: [e._globeColorTexture],
        depthStencilTexture: e._depthStencilTexture,
        destroyAttachments: !1
    }), e._copyDepthFramebuffer = new xt({
        context: t,
        colorTextures: [e._globeDepthTexture],
        destroyAttachments: !1
    })
}

function A3(e, t, n, r, i) {
    var a = i ? t.halfFloatingPointTexture ? ae.HALF_FLOAT : ae.FLOAT : ae.UNSIGNED_BYTE;
    e._primitiveColorTexture = new be({
        context: t,
        width: n,
        height: r,
        pixelFormat: de.RGBA,
        pixelDatatype: a,
        sampler: gt.NEAREST
    }), e._primitiveColorFramebuffer = new xt({
        context: t,
        colorTextures: [e._primitiveColorTexture],
        depthStencilTexture: e._depthStencilTexture,
        destroyAttachments: !1
    })
}

function gT(e) {
    e._primitiveColorTexture = e._primitiveColorTexture && !e._primitiveColorTexture.isDestroyed() && e._primitiveColorTexture.destroy(), e._primitiveColorFramebuffer = e._primitiveColorFramebuffer && !e._primitiveColorFramebuffer.isDestroyed() && e._primitiveColorFramebuffer.destroy()
}

function C3(e, t, n, r, i, a) {
    var o = e._globeColorTexture,
        s = !l(o) || o.width !== n || o.height !== r || i !== e._useHdr;
    s && (vT(e), mT(e), T3(e, t, n, r, i), E3(e, t)), (s || a !== e._clearGlobeDepth) && (gT(e), a && A3(e, t, n, r, i))
}

function yT(e, t, n, r, i) {
    e._viewport.width = n, e._viewport.height = r;
    var a = !ge.equals(e._viewport, i.viewport),
        o = a !== e._useScissorTest;
    e._useScissorTest = a, ge.equals(e._scissorRectangle, i.viewport) || (e._scissorRectangle = ge.clone(i.viewport, e._scissorRectangle), o = !0), (!l(e._rs) || !ge.equals(e._viewport, e._rs.viewport) || o) && (e._rs = Ge.fromCache({
        viewport: e._viewport,
        scissorTest: {
            enabled: e._useScissorTest,
            rectangle: e._scissorRectangle
        }
    }), e._rsBlend = Ge.fromCache({
        viewport: e._viewport,
        scissorTest: {
            enabled: e._useScissorTest,
            rectangle: e._scissorRectangle
        },
        blending: fi.ALPHA_BLEND
    }), e._rsUpdate = Ge.fromCache({
        viewport: e._viewport,
        scissorTest: {
            enabled: e._useScissorTest,
            rectangle: e._scissorRectangle
        },
        stencilTest: {
            enabled: !0,
            frontFunction: $i.EQUAL,
            frontOperation: {
                fail: Dn.KEEP,
                zFail: Dn.KEEP,
                zPass: Dn.KEEP
            },
            backFunction: $i.NEVER,
            reference: Fa.CESIUM_3D_TILE_MASK,
            mask: Fa.CESIUM_3D_TILE_MASK
        }
    })), l(e._copyDepthCommand) || (e._copyDepthCommand = t.createViewportQuadCommand(Ul, {
        uniformMap: {
            u_depthTexture: function() {
                return e._depthStencilTexture
            }
        },
        owner: e
    })), e._copyDepthCommand.framebuffer = e._copyDepthFramebuffer, e._copyDepthCommand.renderState = e._rs, l(e._copyColorCommand) || (e._copyColorCommand = t.createViewportQuadCommand(mc, {
        uniformMap: {
            colorTexture: function() {
                return e._globeColorTexture
            }
        },
        owner: e
    })), e._copyColorCommand.renderState = e._rs, l(e._tempCopyDepthCommand) || (e._tempCopyDepthCommand = t.createViewportQuadCommand(Ul, {
        uniformMap: {
            u_depthTexture: function() {
                return e._tempCopyDepthTexture
            }
        },
        owner: e
    })), e._tempCopyDepthCommand.framebuffer = e._tempCopyDepthFramebuffer, e._tempCopyDepthCommand.renderState = e._rs, l(e._updateDepthCommand) || (e._updateDepthCommand = t.createViewportQuadCommand(mc, {
        uniformMap: {
            colorTexture: function() {
                return e._tempGlobeDepthTexture
            }
        },
        owner: e
    })), e._updateDepthCommand.framebuffer = e._updateDepthFramebuffer, e._updateDepthCommand.renderState = e._rsUpdate, l(e._clearGlobeColorCommand) || (e._clearGlobeColorCommand = new on({
        color: new H(0, 0, 0, 0),
        stencil: 0,
        owner: e
    })), e._clearGlobeColorCommand.framebuffer = e._globeColorFramebuffer, l(e._clearPrimitiveColorCommand) || (e._clearPrimitiveColorCommand = new on({
        color: new H(0, 0, 0, 0),
        stencil: 0,
        owner: e
    })), e._clearPrimitiveColorCommand.framebuffer = e._primitiveColorFramebuffer, l(e._mergeColorCommand) || (e._mergeColorCommand = t.createViewportQuadCommand(mc, {
        uniformMap: {
            colorTexture: function() {
                return e._primitiveColorTexture
            }
        },
        owner: e
    })), e._mergeColorCommand.framebuffer = e._globeColorFramebuffer, e._mergeColorCommand.renderState = e._rsBlend
}
xr.prototype.executeDebugGlobeDepth = function(e, t, n) {
    g3(this, e, t, n)
};
xr.prototype.update = function(e, t, n, r, i) {
    var a = n.width,
        o = n.height;
    C3(this, e, a, o, r, i), yT(this, e, a, o, t), e.uniformState.globeDepthTexture = void 0, this._useHdr = r, this._clearGlobeDepth = i
};
xr.prototype.executeCopyDepth = function(e, t) {
    l(this._copyDepthCommand) && (this._copyDepthCommand.execute(e, t), e.uniformState.globeDepthTexture = this._globeDepthTexture)
};
xr.prototype.executeUpdateDepth = function(e, t, n) {
    var r = t.framebuffer.depthStencilTexture;
    if (n || r !== this._depthStencilTexture) {
        if (l(this._updateDepthCommand)) {
            if (!l(this._updateDepthFramebuffer) || this._updateDepthFramebuffer.depthStencilTexture !== r || this._updateDepthFramebuffer.getColorTexture(0) !== this._globeDepthTexture) {
                var i = this._globeDepthTexture.width,
                    a = this._globeDepthTexture.height;
                pT(this), y3(this, e, i, a, t), yT(this, e, i, a, t)
            }
            this._tempCopyDepthTexture = r, this._tempCopyDepthCommand.execute(e, t), this._updateDepthCommand.execute(e, t)
        }
        return
    }
    l(this._copyDepthCommand) && this._copyDepthCommand.execute(e, t)
};
xr.prototype.executeCopyColor = function(e, t) {
    l(this._copyColorCommand) && this._copyColorCommand.execute(e, t)
};
xr.prototype.executeMergeColor = function(e, t) {
    l(this._mergeColorCommand) && this._mergeColorCommand.execute(e, t)
};
xr.prototype.clear = function(e, t, n) {
    var r = this._clearGlobeColorCommand;
    l(r) && (H.clone(n, r.color), r.execute(e, t)), r = this._clearPrimitiveColorCommand, l(r) && l(this._primitiveColorFramebuffer) && r.execute(e, t)
};
xr.prototype.isDestroyed = function() {
    return !1
};
xr.prototype.destroy = function() {
    return vT(this), mT(this), gT(this), pT(this), l(this._copyColorCommand) && (this._copyColorCommand.shaderProgram = this._copyColorCommand.shaderProgram.destroy()), l(this._copyDepthCommand) && (this._copyDepthCommand.shaderProgram = this._copyDepthCommand.shaderProgram.destroy()), l(this._tempCopyDepthCommand) && (this._tempCopyDepthCommand.shaderProgram = this._tempCopyDepthCommand.shaderProgram.destroy()), l(this._updateDepthCommand) && (this._updateDepthCommand.shaderProgram = this._updateDepthCommand.shaderProgram.destroy()), l(this._mergeColorCommand) && (this._mergeColorCommand.shaderProgram = this._mergeColorCommand.shaderProgram.destroy()), l(this._debugGlobeDepthViewportCommand) && (this._debugGlobeDepthViewportCommand.shaderProgram = this._debugGlobeDepthViewportCommand.shaderProgram.destroy()), Pe(this)
};
var $t = {
        OPAQUE_FRONT_FACE: 0,
        OPAQUE_BACK_FACE: 1,
        DEPTH_ONLY_FRONT_FACE: 2,
        DEPTH_ONLY_BACK_FACE: 3,
        DEPTH_ONLY_FRONT_AND_BACK_FACE: 4,
        TRANSLUCENT_FRONT_FACE: 5,
        TRANSLUCENT_BACK_FACE: 6,
        TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST: 7,
        TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST: 8,
        PICK_FRONT_FACE: 9,
        PICK_BACK_FACE: 10,
        DERIVED_COMMANDS_MAXIMUM_LENGTH: 11
    },
    xa = $t.DERIVED_COMMANDS_MAXIMUM_LENGTH,
    TT = ["opaqueFrontFaceCommand", "opaqueBackFaceCommand", "depthOnlyFrontFaceCommand", "depthOnlyBackFaceCommand", "depthOnlyFrontAndBackFaceCommand", "translucentFrontFaceCommand", "translucentBackFaceCommand", "translucentFrontFaceManualDepthTestCommand", "translucentBackFaceManualDepthTestCommand", "pickFrontFaceCommand", "pickBackFaceCommand"];

function Ha() {
    this._frontFaceAlphaByDistance = new at(0, 1, 0, 1), this._backFaceAlphaByDistance = new at(0, 1, 0, 1), this._frontFaceTranslucent = !1, this._backFaceTranslucent = !1, this._requiresManualDepthTest = !1, this._sunVisibleThroughGlobe = !1, this._environmentVisible = !1, this._useDepthPlane = !1, this._numberOfTextureUniforms = 0, this._globeTranslucencyFramebuffer = void 0, this._rectangle = W.clone(W.MAX_VALUE), this._derivedCommandKey = 0, this._derivedCommandsDirty = !1, this._derivedCommandPacks = void 0, this._derivedCommandTypes = new Array(xa), this._derivedBlendCommandTypes = new Array(xa), this._derivedPickCommandTypes = new Array(xa), this._derivedCommandTypesToUpdate = new Array(xa), this._derivedCommandsLength = 0, this._derivedBlendCommandsLength = 0, this._derivedPickCommandsLength = 0, this._derivedCommandsToUpdateLength = 0
}
Object.defineProperties(Ha.prototype, {
    frontFaceAlphaByDistance: {
        get: function() {
            return this._frontFaceAlphaByDistance
        }
    },
    backFaceAlphaByDistance: {
        get: function() {
            return this._backFaceAlphaByDistance
        }
    },
    translucent: {
        get: function() {
            return this._frontFaceTranslucent
        }
    },
    sunVisibleThroughGlobe: {
        get: function() {
            return this._sunVisibleThroughGlobe
        }
    },
    environmentVisible: {
        get: function() {
            return this._environmentVisible
        }
    },
    useDepthPlane: {
        get: function() {
            return this._useDepthPlane
        }
    },
    numberOfTextureUniforms: {
        get: function() {
            return this._numberOfTextureUniforms
        }
    },
    rectangle: {
        get: function() {
            return this._rectangle
        }
    }
});
Ha.prototype.update = function(e) {
    var t = e.globe;
    if (!l(t) || !t.show) {
        this._frontFaceTranslucent = !1, this._backFaceTranslucent = !1, this._sunVisibleThroughGlobe = !0, this._environmentVisible = !0, this._useDepthPlane = !1;
        return
    }
    this._frontFaceAlphaByDistance = Vm(t.translucency.enabled, t.translucency.frontFaceAlpha, t.translucency.frontFaceAlphaByDistance, this._frontFaceAlphaByDistance), this._backFaceAlphaByDistance = Vm(t.translucency.enabled, t.translucency.backFaceAlpha, t.translucency.backFaceAlphaByDistance, this._backFaceAlphaByDistance), this._frontFaceTranslucent = Gm(t.translucency.enabled, this._frontFaceAlphaByDistance, t), this._backFaceTranslucent = Gm(t.translucency.enabled, this._backFaceAlphaByDistance, t), this._requiresManualDepthTest = R3(this, e, t), this._sunVisibleThroughGlobe = w3(this, e), this._environmentVisible = x3(this, e), this._useDepthPlane = S3(this, e), this._numberOfTextureUniforms = D3(this), this._rectangle = W.clone(t.translucency.rectangle, this._rectangle), I3(this, e)
};

function Vm(e, t, n, r) {
    return e ? l(n) ? (at.clone(n, r), r.nearValue *= t, r.farValue *= t, r) : (r.nearValue = t, r.farValue = t, r) : (r.nearValue = 1, r.farValue = 1, r)
}

function Gm(e, t, n) {
    return e && (n.baseColor.alpha < 1 || t.nearValue < 1 || t.farValue < 1)
}

function w3(e, t) {
    var n = e._frontFaceTranslucent,
        r = e._backFaceTranslucent;
    return n && (t.cameraUnderground || r)
}

function x3(e, t) {
    return !t.cameraUnderground || e._frontFaceTranslucent
}

function S3(e, t) {
    return !t.cameraUnderground && !e._frontFaceTranslucent
}

function R3(e, t, n) {
    return e._frontFaceTranslucent && !e._backFaceTranslucent && !n.depthTestAgainstTerrain && t.mode !== k.SCENE2D && t.context.depthTexture
}

function D3(e) {
    var t = 0;
    return e._frontFaceTranslucent && ++t, e._requiresManualDepthTest && ++t, t
}

function I3(e, t) {
    e._derivedCommandsLength = Gh(e, t, !1, !1, e._derivedCommandTypes), e._derivedBlendCommandsLength = Gh(e, t, !0, !1, e._derivedBlendCommandTypes), e._derivedPickCommandsLength = Gh(e, t, !1, !0, e._derivedPickCommandTypes);
    var n, r = 0;
    for (n = 0; n < e._derivedCommandsLength; ++n) r |= 1 << e._derivedCommandTypes[n];
    for (n = 0; n < e._derivedBlendCommandsLength; ++n) r |= 1 << e._derivedBlendCommandTypes[n];
    for (n = 0; n < e._derivedPickCommandsLength; ++n) r |= 1 << e._derivedPickCommandTypes[n];
    var i = 0;
    for (n = 0; n < xa; ++n)(r & 1 << n) > 0 && (e._derivedCommandTypesToUpdate[i++] = n);
    e._derivedCommandsToUpdateLength = i;
    var a = r !== e._derivedCommandKey;
    e._derivedCommandKey = r, e._derivedCommandsDirty = a, !l(e._derivedCommandPacks) && e._frontFaceTranslucent && (e._derivedCommandPacks = W3())
}

function Gh(e, t, n, r, i) {
    var a = 0,
        o = e._frontFaceTranslucent,
        s = e._backFaceTranslucent;
    if (!o) return a;
    var c = t.cameraUnderground,
        f = e._requiresManualDepthTest,
        h = r ? $t.PICK_FRONT_FACE : f ? $t.TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST : $t.TRANSLUCENT_FRONT_FACE,
        d = r ? $t.PICK_BACK_FACE : f ? $t.TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST : $t.TRANSLUCENT_BACK_FACE;
    return t.mode === k.SCENE2D ? (i[a++] = $t.DEPTH_ONLY_FRONT_FACE, i[a++] = h, a) : (s ? (n || (i[a++] = $t.DEPTH_ONLY_FRONT_AND_BACK_FACE), c ? (i[a++] = h, i[a++] = d) : (i[a++] = d, i[a++] = h)) : c ? (n || (i[a++] = $t.DEPTH_ONLY_BACK_FACE), i[a++] = $t.OPAQUE_FRONT_FACE, i[a++] = d) : (n || (i[a++] = $t.DEPTH_ONLY_FRONT_FACE), i[a++] = $t.OPAQUE_BACK_FACE, i[a++] = h), a)
}

function pr(e, t) {
    var n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}

function Hm(e, t) {
    return e.indexOf(t) > -1
}

function P3(e, t) {
    pr(e.defines, "TRANSLUCENT"), pr(t.defines, "TRANSLUCENT")
}

function O3(e, t) {
    pr(e.defines, "GROUND_ATMOSPHERE"), pr(t.defines, "GROUND_ATMOSPHERE"), pr(e.defines, "FOG"), pr(t.defines, "FOG"), pr(e.defines, "TRANSLUCENT"), pr(t.defines, "TRANSLUCENT")
}

function Hh(e, t) {
    if (!(Hm(t.defines, "TILE_LIMIT_RECTANGLE") || Hm(t.defines, "ENABLE_CLIPPING_PLANES"))) {
        var n = `void main() 
{ 
    gl_FragColor = vec4(1.0); 
} 
`;
        t.sources = [n]
    }
}

function Vd(e, t) {
    for (var n = t.sources, r = n.length, i = 0; i < r; ++i) n[i] = Re.replaceMain(n[i], "czm_globe_translucency_main");
    var a = `

uniform sampler2D u_classificationTexture; 
void main() 
{ 
    vec2 st = gl_FragCoord.xy / czm_viewport.zw; 
#ifdef MANUAL_DEPTH_TEST 
    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st)); 
    if (logDepthOrDepth != 0.0) 
    { 
        vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); 
        float depthEC = eyeCoordinate.z / eyeCoordinate.w; 
        if (v_positionEC.z < depthEC) 
        { 
            discard; 
        } 
    } 
#endif 
    czm_globe_translucency_main(); 
    vec4 classificationColor = texture2D(u_classificationTexture, st); 
    if (classificationColor.a > 0.0) 
    { 
        // Reverse premultiplication process to get the correct composited result of the classification primitives 
        classificationColor.rgb /= classificationColor.a; 
    } 
    gl_FragColor = classificationColor * vec4(classificationColor.aaa, 1.0) + gl_FragColor * (1.0 - classificationColor.a); 
} 
`;
    n.push(a)
}

function ET(e, t) {
    Vd(e, t), pr(e.defines, "GROUND_ATMOSPHERE"), pr(t.defines, "GROUND_ATMOSPHERE"), pr(e.defines, "FOG"), pr(t.defines, "FOG")
}

function M3(e, t) {
    Vd(e, t), e.defines.push("GENERATE_POSITION"), t.defines.push("MANUAL_DEPTH_TEST")
}

function N3(e, t) {
    ET(e, t), e.defines.push("GENERATE_POSITION"), t.defines.push("MANUAL_DEPTH_TEST")
}

function km(e, t) {
    var n = `uniform sampler2D u_classificationTexture; 
void main() 
{ 
    vec2 st = gl_FragCoord.xy / czm_viewport.zw; 
    vec4 pickColor = texture2D(u_classificationTexture, st); 
    if (pickColor == vec4(0.0)) 
    { 
        discard; 
    } 
    gl_FragColor = pickColor; 
} 
`;
    t.sources = [n]
}

function b3(e, t, n, r, i, a) {
    if (!l(i)) return t;
    if (!r && l(n)) return n;
    var o = e.shaderCache.getDerivedShaderProgram(t, a);
    if (!l(o)) {
        var s = t._attributeLocations,
            c = t.vertexShaderSource.clone(),
            f = t.fragmentShaderSource.clone();
        c.defines = l(c.defines) ? c.defines.slice(0) : [], f.defines = l(f.defines) ? f.defines.slice(0) : [], i(c, f), o = e.shaderCache.createDerivedShaderProgram(t, a, {
            vertexShaderSource: c,
            fragmentShaderSource: f,
            attributeLocations: s
        })
    }
    return o
}

function F3(e) {
    e.cull.face = Qn.BACK, e.cull.enabled = !0
}

function L3(e) {
    e.cull.face = Qn.FRONT, e.cull.enabled = !0
}

function U3(e) {
    e.cull.face = Qn.BACK, e.cull.enabled = !0, e.colorMask = {
        red: !1,
        green: !1,
        blue: !1,
        alpha: !1
    }
}

function z3(e) {
    e.cull.face = Qn.FRONT, e.cull.enabled = !0, e.colorMask = {
        red: !1,
        green: !1,
        blue: !1,
        alpha: !1
    }
}

function B3(e) {
    e.cull.enabled = !1, e.colorMask = {
        red: !1,
        green: !1,
        blue: !1,
        alpha: !1
    }
}

function Wm(e) {
    e.cull.face = Qn.BACK, e.cull.enabled = !0, e.depthMask = !1, e.blending = fi.ALPHA_BLEND
}

function qm(e) {
    e.cull.face = Qn.FRONT, e.cull.enabled = !0, e.depthMask = !1, e.blending = fi.ALPHA_BLEND
}

function V3(e) {
    e.cull.face = Qn.BACK, e.cull.enabled = !0, e.blending.enabled = !1
}

function G3(e) {
    e.cull.face = Qn.FRONT, e.cull.enabled = !0, e.blending.enabled = !1
}

function H3(e, t, n, r, i) {
    if (!l(r)) return e;
    if (!n && l(t)) return t;
    var a = i[e.id];
    if (!l(a)) {
        var o = Ge.getState(e);
        r(o), a = Ge.fromCache(o), i[e.id] = a
    }
    return a
}

function ho(e) {
    return {
        u_classificationTexture: function() {
            return e._globeTranslucencyFramebuffer.classificationTexture
        }
    }
}

function k3(e, t, n, r, i) {
    return l(i) ? !r && l(n) ? n : En(t, i(e), !1) : t
}

function Or(e) {
    this.pass = e.pass, this.pickOnly = e.pickOnly, this.getShaderProgramFunction = e.getShaderProgramFunction, this.getRenderStateFunction = e.getRenderStateFunction, this.getUniformMapFunction = e.getUniformMapFunction, this.renderStateCache = {}
}

function W3() {
    return [new Or({
        pass: ue.GLOBE,
        pickOnly: !1,
        getShaderProgramFunction: P3,
        getRenderStateFunction: F3,
        getUniformMapFunction: void 0
    }), new Or({
        pass: ue.GLOBE,
        pickOnly: !1,
        getShaderProgramFunction: O3,
        getRenderStateFunction: L3,
        getUniformMapFunction: void 0
    }), new Or({
        pass: ue.GLOBE,
        pickOnly: !1,
        getShaderProgramFunction: Hh,
        getRenderStateFunction: U3,
        getUniformMapFunction: void 0
    }), new Or({
        pass: ue.GLOBE,
        pickOnly: !1,
        getShaderProgramFunction: Hh,
        getRenderStateFunction: z3,
        getUniformMapFunction: void 0
    }), new Or({
        pass: ue.GLOBE,
        pickOnly: !1,
        getShaderProgramFunction: Hh,
        getRenderStateFunction: B3,
        getUniformMapFunction: void 0
    }), new Or({
        pass: ue.TRANSLUCENT,
        pickOnly: !1,
        getShaderProgramFunction: Vd,
        getRenderStateFunction: Wm,
        getUniformMapFunction: ho
    }), new Or({
        pass: ue.TRANSLUCENT,
        pickOnly: !1,
        getShaderProgramFunction: ET,
        getRenderStateFunction: qm,
        getUniformMapFunction: ho
    }), new Or({
        pass: ue.TRANSLUCENT,
        pickOnly: !1,
        getShaderProgramFunction: M3,
        getRenderStateFunction: Wm,
        getUniformMapFunction: ho
    }), new Or({
        pass: ue.TRANSLUCENT,
        pickOnly: !1,
        getShaderProgramFunction: N3,
        getRenderStateFunction: qm,
        getUniformMapFunction: ho
    }), new Or({
        pass: ue.TRANSLUCENT,
        pickOnly: !0,
        getShaderProgramFunction: km,
        getRenderStateFunction: V3,
        getUniformMapFunction: ho
    }), new Or({
        pass: ue.TRANSLUCENT,
        pickOnly: !0,
        getShaderProgramFunction: km,
        getRenderStateFunction: G3,
        getUniformMapFunction: ho
    })]
}
var Ym = new Array(xa),
    Xm = new Array(xa);
Ha.prototype.updateDerivedCommands = function(e, t) {
    var n = this._derivedCommandTypesToUpdate,
        r = this._derivedCommandsToUpdateLength;
    if (r !== 0) {
        for (var i = 0; i < r; ++i) Xm[i] = this._derivedCommandPacks[n[i]], Ym[i] = TT[n[i]];
        q3(this, e, r, n, Ym, Xm, t)
    }
};

function q3(e, t, n, r, i, a, o) {
    var s = t.derivedCommands.globeTranslucency,
        c = e._derivedCommandsDirty;
    if (t.dirty || !l(s) || c) {
        t.dirty = !1, l(s) || (s = {}, t.derivedCommands.globeTranslucency = s);
        var f = o.frameNumber,
            h = p(s.uniformMapDirtyFrame, 0),
            d = p(s.shaderProgramDirtyFrame, 0),
            _ = p(s.renderStateDirtyFrame, 0),
            v = s.uniformMap !== t.uniformMap,
            m = s.shaderProgramId !== t.shaderProgram.id,
            g = s.renderStateId !== t.renderState.id;
        v && (s.uniformMapDirtyFrame = f), m && (s.shaderProgramDirtyFrame = f), g && (s.renderStateDirtyFrame = f), s.uniformMap = t.uniformMap, s.shaderProgramId = t.shaderProgram.id, s.renderStateId = t.renderState.id;
        for (var y = 0; y < n; ++y) {
            var E = a[y],
                w = r[y],
                C = i[y],
                A = s[C],
                x, P, I;
            l(A) ? (x = A.uniformMap, P = A.shaderProgram, I = A.renderState) : (x = void 0, P = void 0, I = void 0), A = an.shallowClone(t, A), s[C] = A;
            var D = p(A.derivedCommands.uniformMapDirtyFrame, 0),
                O = p(A.derivedCommands.shaderProgramDirtyFrame, 0),
                F = p(A.derivedCommands.renderStateDirtyFrame, 0),
                z = v || D < h,
                b = m || O < d,
                M = g || F < _;
            z && (A.derivedCommands.uniformMapDirtyFrame = f), b && (A.derivedCommands.shaderProgramDirtyFrame = f), M && (A.derivedCommands.renderStateDirtyFrame = f), A.derivedCommands.type = w, A.pass = E.pass, A.pickOnly = E.pickOnly, A.uniformMap = k3(e, t.uniformMap, x, z, E.getUniformMapFunction), A.shaderProgram = b3(o.context, t.shaderProgram, P, b, E.getShaderProgramFunction, C), A.renderState = H3(t.renderState, I, M, E.getRenderStateFunction, E.renderStateCache)
        }
    }
}
Ha.prototype.pushDerivedCommands = function(e, t, n) {
    var r = n.passes.pick;
    if (!(r && t)) {
        var i = this._derivedCommandTypes,
            a = this._derivedCommandsLength;
        if (r ? (i = this._derivedPickCommandTypes, a = this._derivedPickCommandsLength) : t && (i = this._derivedBlendCommandTypes, a = this._derivedBlendCommandsLength), a === 0) {
            n.commandList.push(e);
            return
        }
        for (var o = e.derivedCommands.globeTranslucency, s = 0; s < a; ++s) {
            var c = TT[i[s]];
            n.commandList.push(o[c])
        }
    }
};

function AT(e, t, n, r, i, a, o) {
    for (var s = 0; s < t; ++s) {
        var c = e[s],
            f = c.derivedCommands.type;
        (!l(o) || o.indexOf(f) > -1) && n(c, r, i, a)
    }
}

function jm(e, t, n, r, i, a) {
    for (var o = 0; o < t; ++o) n(e[o], r, i, a)
}
var Y3 = [$t.OPAQUE_FRONT_FACE, $t.OPAQUE_BACK_FACE],
    X3 = [$t.DEPTH_ONLY_FRONT_FACE, $t.DEPTH_ONLY_BACK_FACE, $t.DEPTH_ONLY_FRONT_AND_BACK_FACE];
Ha.prototype.executeGlobeCommands = function(e, t, n, r, i) {
    var a = r.context,
        o = e.commands[ue.GLOBE],
        s = e.indices[ue.GLOBE];
    s !== 0 && (this._globeTranslucencyFramebuffer = n, n.clearClassification(a, i), AT(o, s, t, r, a, i, Y3))
};
Ha.prototype.executeGlobeClassificationCommands = function(e, t, n, r, i) {
    var a = r.context,
        o = e.commands[ue.GLOBE],
        s = e.indices[ue.GLOBE],
        c = e.commands[ue.TERRAIN_CLASSIFICATION],
        f = e.indices[ue.TERRAIN_CLASSIFICATION];
    if (!(s === 0 || f === 0)) {
        var h = this._frontFaceTranslucent,
            d = this._backFaceTranslucent;
        if ((!h || !d) && jm(c, f, t, r, a, i), !(!h && !d)) {
            this._globeTranslucencyFramebuffer = n;
            var _ = a.uniformState.globeDepthTexture,
                v = i.framebuffer;
            if (i.framebuffer = n.classificationFramebuffer, AT(o, s, t, r, a, i, X3), a.depthTexture) {
                var m = n.packDepth(a, i);
                a.uniformState.globeDepthTexture = m
            }
            jm(c, f, t, r, a, i), a.uniformState.globeDepthTexture = _, i.framebuffer = v
        }
    }
};

function li() {
    this.previousFramebuffer = void 0, this._previousFramebuffer = void 0, this._texture = void 0, this._classifiedTexture = void 0, this._depthStencilTexture = void 0, this._fbo = void 0, this._fboClassified = void 0, this._rsUnclassified = void 0, this._rsClassified = void 0, this._unclassifiedCommand = void 0, this._classifiedCommand = void 0, this._translucentCommand = void 0, this._clearColorCommand = new on({
        color: new H(0, 0, 0, 0),
        owner: this
    }), this._clearCommand = new on({
        color: new H(0, 0, 0, 0),
        depth: 1,
        stencil: 0
    });
    var e = this;
    this._uniformMap = {
        colorTexture: function() {
            return e._texture
        },
        depthTexture: function() {
            return e._depthStencilTexture
        },
        classifiedTexture: function() {
            return e._classifiedTexture
        }
    }
}
Object.defineProperties(li.prototype, {
    unclassifiedCommand: {
        get: function() {
            return this._unclassifiedCommand
        }
    }
});
li.isTranslucencySupported = function(e) {
    return e.depthTexture && e.fragmentDepth
};
var j3 = {
        depthMask: !1,
        stencilTest: {
            enabled: !0,
            frontFunction: $i.EQUAL,
            frontOperation: {
                fail: Dn.KEEP,
                zFail: Dn.KEEP,
                zPass: Dn.KEEP
            },
            backFunction: $i.NEVER,
            reference: 0,
            mask: Fa.CLASSIFICATION_MASK
        },
        blending: fi.ALPHA_BLEND
    },
    Z3 = {
        depthMask: !1,
        stencilTest: {
            enabled: !0,
            frontFunction: $i.NOT_EQUAL,
            frontOperation: {
                fail: Dn.KEEP,
                zFail: Dn.KEEP,
                zPass: Dn.KEEP
            },
            backFunction: $i.NEVER,
            reference: 0,
            mask: Fa.CLASSIFICATION_MASK
        },
        blending: fi.ALPHA_BLEND
    },
    K3 = {
        depthMask: !0,
        depthTest: {
            enabled: !0
        },
        stencilTest: Fa.setCesium3DTileBit(),
        stencilMask: Fa.CESIUM_3D_TILE_MASK,
        blending: fi.ALPHA_BLEND
    },
    $3 = `#extension GL_EXT_frag_depth : enable
uniform sampler2D colorTexture;
uniform sampler2D depthTexture;
uniform sampler2D classifiedTexture;
varying vec2 v_textureCoordinates;
void main()
{
    vec4 color = texture2D(colorTexture, v_textureCoordinates);
    if (color.a == 0.0)
    {
        discard;
    }
    bool isClassified = all(equal(texture2D(classifiedTexture, v_textureCoordinates), vec4(0.0)));
#ifdef UNCLASSIFIED
    vec4 highlightColor = czm_invertClassificationColor;
    if (isClassified)
    {
        discard;
    }
#else
    vec4 highlightColor = vec4(1.0);
    if (!isClassified)
    {
        discard;
    }
#endif
    gl_FragColor = color * highlightColor;
    gl_FragDepthEXT = texture2D(depthTexture, v_textureCoordinates).r;
}
`,
    J3 = `uniform sampler2D colorTexture;
varying vec2 v_textureCoordinates;
void main()
{
    vec4 color = texture2D(colorTexture, v_textureCoordinates);
    if (color.a == 0.0)
    {
        discard;
    }
#ifdef UNCLASSIFIED
    gl_FragColor = color * czm_invertClassificationColor;
#else
    gl_FragColor = color;
#endif
}
`;
li.prototype.update = function(e) {
    var t = this._texture,
        n = !l(t) || this.previousFramebuffer !== this._previousFramebuffer;
    this._previousFramebuffer = this.previousFramebuffer;
    var r = e.drawingBufferWidth,
        i = e.drawingBufferHeight,
        a = !l(t) || t.width !== r || t.height !== i;
    if ((a || n) && (this._texture = this._texture && this._texture.destroy(), this._classifiedTexture = this._classifiedTexture && this._classifiedTexture.destroy(), this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy(), this._texture = new be({
            context: e,
            width: r,
            height: i,
            pixelFormat: de.RGBA,
            pixelDatatype: ae.UNSIGNED_BYTE,
            sampler: new gt({
                wrapS: gn.CLAMP_TO_EDGE,
                wrapT: gn.CLAMP_TO_EDGE,
                minificationFilter: Ot.LINEAR,
                magnificationFilter: zr.LINEAR
            })
        }), l(this._previousFramebuffer) || (this._classifiedTexture = new be({
            context: e,
            width: r,
            height: i,
            pixelFormat: de.RGBA,
            pixelDatatype: ae.UNSIGNED_BYTE,
            sampler: new gt({
                wrapS: gn.CLAMP_TO_EDGE,
                wrapT: gn.CLAMP_TO_EDGE,
                minificationFilter: Ot.LINEAR,
                magnificationFilter: zr.LINEAR
            })
        }), this._depthStencilTexture = new be({
            context: e,
            width: r,
            height: i,
            pixelFormat: de.DEPTH_STENCIL,
            pixelDatatype: ae.UNSIGNED_INT_24_8
        }))), !l(this._fbo) || a || n) {
        this._fbo = this._fbo && this._fbo.destroy(), this._fboClassified = this._fboClassified && this._fboClassified.destroy();
        var o, s;
        l(this._previousFramebuffer) ? (o = this._previousFramebuffer.depthStencilTexture, s = this._previousFramebuffer.depthStencilRenderbuffer) : o = this._depthStencilTexture, this._fbo = new xt({
            context: e,
            colorTextures: [this._texture],
            depthStencilTexture: o,
            depthStencilRenderbuffer: s,
            destroyAttachments: !1
        }), l(this._previousFramebuffer) || (this._fboClassified = new xt({
            context: e,
            colorTextures: [this._classifiedTexture],
            depthStencilTexture: o,
            destroyAttachments: !1
        }))
    }
    if (l(this._rsUnclassified) || (this._rsUnclassified = Ge.fromCache(j3), this._rsClassified = Ge.fromCache(Z3), this._rsDefault = Ge.fromCache(K3)), !l(this._unclassifiedCommand) || n) {
        l(this._unclassifiedCommand) && (this._unclassifiedCommand.shaderProgram = this._unclassifiedCommand.shaderProgram && this._unclassifiedCommand.shaderProgram.destroy(), this._classifiedCommand.shaderProgram = this._classifiedCommand.shaderProgram && this._classifiedCommand.shaderProgram.destroy());
        var c = l(this._previousFramebuffer) ? J3 : $3,
            f = new Re({
                defines: ["UNCLASSIFIED"],
                sources: [c]
            }),
            h = new Re({
                sources: [c]
            });
        this._unclassifiedCommand = e.createViewportQuadCommand(f, {
            renderState: l(this._previousFramebuffer) ? this._rsUnclassified : this._rsDefault,
            uniformMap: this._uniformMap,
            owner: this
        }), this._classifiedCommand = e.createViewportQuadCommand(h, {
            renderState: l(this._previousFramebuffer) ? this._rsClassified : this._rsDefault,
            uniformMap: this._uniformMap,
            owner: this
        }), l(this._translucentCommand) && (this._translucentCommand.shaderProgram = this._translucentCommand.shaderProgram && this._translucentCommand.shaderProgram.destroy()), l(this._previousFramebuffer) || (this._translucentCommand = e.createViewportQuadCommand(mc, {
            renderState: this._rsUnclassified,
            uniformMap: this._uniformMap,
            owner: this
        }))
    }
};
li.prototype.clear = function(e, t) {
    var n = t.framebuffer;
    l(this._previousFramebuffer) ? (t.framebuffer = this._fbo, this._clearColorCommand.execute(e, t)) : (t.framebuffer = this._fbo, this._clearCommand.execute(e, t), t.framebuffer = this._fboClassified, this._clearCommand.execute(e, t)), t.framebuffer = n
};
li.prototype.executeClassified = function(e, t) {
    if (!l(this._previousFramebuffer)) {
        var n = t.framebuffer;
        t.framebuffer = this._fboClassified, this._translucentCommand.execute(e, t), t.framebuffer = n
    }
    this._classifiedCommand.execute(e, t)
};
li.prototype.executeUnclassified = function(e, t) {
    this._unclassifiedCommand.execute(e, t)
};
li.prototype.isDestroyed = function() {
    return !1
};
li.prototype.destroy = function() {
    return this._fbo = this._fbo && this._fbo.destroy(), this._texture = this._texture && this._texture.destroy(), this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy(), l(this._unclassifiedCommand) && (this._unclassifiedCommand.shaderProgram = this._unclassifiedCommand.shaderProgram && this._unclassifiedCommand.shaderProgram.destroy(), this._classifiedCommand.shaderProgram = this._classifiedCommand.shaderProgram && this._classifiedCommand.shaderProgram.destroy()), Pe(this)
};
var Q3 = {
    TEXTURE: 0,
    PROGRAM: 1,
    BUFFER: 2,
    NUMBER_OF_JOB_TYPES: 3
};
const ya = Object.freeze(Q3);

function gc(e) {
    this._total = e, this.usedThisFrame = 0, this.stolenFromMeThisFrame = 0, this.starvedThisFrame = !1, this.starvedLastFrame = !1
}
Object.defineProperties(gc.prototype, {
    total: {
        get: function() {
            return this._total
        }
    }
});

function ji(e) {
    var t = new Array(ya.NUMBER_OF_JOB_TYPES);
    t[ya.TEXTURE] = new gc(l(e) ? e[ya.TEXTURE] : 10), t[ya.PROGRAM] = new gc(l(e) ? e[ya.PROGRAM] : 10), t[ya.BUFFER] = new gc(l(e) ? e[ya.BUFFER] : 30);
    var n = t.length,
        r, i = 0;
    for (r = 0; r < n; ++r) i += t[r].total;
    var a = new Array(n);
    for (r = 0; r < n; ++r) a[r] = !1;
    this._totalBudget = i, this._totalUsedThisFrame = 0, this._budgets = t, this._executedThisFrame = a
}
ji.getTimestamp = bn;
Object.defineProperties(ji.prototype, {
    totalBudget: {
        get: function() {
            return this._totalBudget
        }
    }
});
ji.prototype.disableThisFrame = function() {
    this._totalUsedThisFrame = this._totalBudget
};
ji.prototype.resetBudgets = function() {
    for (var e = this._budgets, t = e.length, n = 0; n < t; ++n) {
        var r = e[n];
        r.starvedLastFrame = r.starvedThisFrame, r.starvedThisFrame = !1, r.usedThisFrame = 0, r.stolenFromMeThisFrame = 0
    }
    this._totalUsedThisFrame = 0
};
ji.prototype.execute = function(e, t) {
    var n = this._budgets,
        r = n[t],
        i = this._executedThisFrame[t];
    if (this._totalUsedThisFrame >= this._totalBudget && i) return r.starvedThisFrame = !0, !1;
    var a;
    if (r.usedThisFrame + r.stolenFromMeThisFrame >= r.total) {
        var o = n.length,
            s;
        for (s = 0; s < o && (a = n[s], !(a.usedThisFrame + a.stolenFromMeThisFrame < a.total && !a.starvedLastFrame)); ++s);
        if (s === o && i) return !1;
        i && (r.starvedThisFrame = !0)
    }
    var c = ji.getTimestamp();
    e.execute();
    var f = ji.getTimestamp() - c;
    return this._totalUsedThisFrame += f, a ? a.stolenFromMeThisFrame += f : r.usedThisFrame += f, this._executedThisFrame[t] = !0, !0
};

function La(e, t, n, r) {
    this._format = e, this._width = t, this._height = n, this._buffer = r
}
Object.defineProperties(La.prototype, {
    internalFormat: {
        get: function() {
            return this._format
        }
    },
    width: {
        get: function() {
            return this._width
        }
    },
    height: {
        get: function() {
            return this._height
        }
    },
    bufferView: {
        get: function() {
            return this._buffer
        }
    }
});
La.clone = function(e) {
    if (!!l(e)) return new La(e._format, e._width, e._height, e._buffer)
};
La.prototype.clone = function() {
    return La.clone(this)
};

function CT(e) {
    var t;
    if (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) t = he.resolve(e);
    else {
        var n = J.createIfNeeded(e);
        t = n.fetchArrayBuffer()
    }
    if (!!l(t)) return t.then(function(r) {
        if (l(r)) return tF(r)
    })
}
var Zm = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10],
    eF = 67305985,
    Km = ["positiveX", "negativeX", "positiveY", "negativeY", "positiveZ", "negativeZ"],
    Bn = 4;

function tF(e) {
    var t = new Uint8Array(e),
        n = !0,
        r;
    for (r = 0; r < Zm.length; ++r)
        if (Zm[r] !== t[r]) {
            n = !1;
            break
        }
    if (!n) throw new je("Invalid KTX file.");
    var i, a;
    l(e.buffer) ? (i = new DataView(e.buffer), a = e.byteOffset) : (i = new DataView(e), a = 0), a += 12;
    var o = i.getUint32(a, !0);
    if (a += Bn, o !== eF) throw new je("File is the wrong endianness.");
    var s = i.getUint32(a, !0);
    a += Bn;
    var c = i.getUint32(a, !0);
    a += Bn;
    var f = i.getUint32(a, !0);
    a += Bn;
    var h = i.getUint32(a, !0);
    a += Bn;
    var d = i.getUint32(a, !0);
    a += Bn;
    var _ = i.getUint32(a, !0);
    a += Bn;
    var v = i.getUint32(a, !0);
    a += Bn;
    var m = i.getUint32(a, !0);
    a += Bn;
    var g = i.getUint32(a, !0);
    a += Bn;
    var y = i.getUint32(a, !0);
    a += Bn;
    var E = i.getUint32(a, !0);
    a += Bn;
    var w = i.getUint32(a, !0);
    a += Bn, a += w;
    var C = i.getUint32(a, !0);
    a += Bn;
    var A;
    if (l(e.buffer) ? A = new Uint8Array(e.buffer, a, C) : A = new Uint8Array(e, a, C), h === L.RGB8 ? h = de.RGB : h === L.RGBA8 && (h = de.RGBA), !de.validate(h)) throw new je("glInternalFormat is not a valid format.");
    if (de.isCompressedFormat(h)) {
        if (s !== 0) throw new je("glType must be zero when the texture is compressed.");
        if (c !== 1) throw new je("The type size for compressed textures must be 1.");
        if (f !== 0) throw new je("glFormat must be zero when the texture is compressed.")
    } else {
        if (s !== L.UNSIGNED_BYTE) throw new je("Only unsigned byte buffers are supported.");
        if (d !== f) throw new je("The base internal format must be the same as the format for uncompressed textures.")
    }
    if (m !== 0) throw new je("3D textures are unsupported.");
    if (g !== 0) throw new je("Texture arrays are unsupported.");
    var x = A.byteOffset,
        P = new Array(E);
    for (r = 0; r < E; ++r) {
        for (var I = P[r] = {}, D = 0; D < y; ++D) {
            var O = _ >> r,
                F = v >> r,
                z = de.isCompressedFormat(h) ? de.compressedTextureSizeInBytes(h, O, F) : de.textureSizeInBytes(h, s, O, F),
                b = new Uint8Array(A.buffer, x, z);
            I[Km[D]] = new La(h, O, F, b), x += z
        }
        x += 3 - (x + 3) % 4 + 4
    }
    var M = P;
    if (y === 1)
        for (r = 0; r < E; ++r) M[r] = M[r][Km[0]];
    return E === 1 && (M = M[0]), M
}
const nF = `varying vec2 v_textureCoordinates;
uniform float originalSize;
uniform sampler2D texture0;
uniform sampler2D texture1;
uniform sampler2D texture2;
uniform sampler2D texture3;
uniform sampler2D texture4;
uniform sampler2D texture5;
const float yMipLevel1 = 1.0 - (1.0 / pow(2.0, 1.0));
const float yMipLevel2 = 1.0 - (1.0 / pow(2.0, 2.0));
const float yMipLevel3 = 1.0 - (1.0 / pow(2.0, 3.0));
const float yMipLevel4 = 1.0 - (1.0 / pow(2.0, 4.0));
void main()
{
vec2 uv = v_textureCoordinates;
vec2 textureSize = vec2(originalSize * 1.5 + 2.0, originalSize);
vec2 pixel = 1.0 / textureSize;
float mipLevel = 0.0;
if (uv.x - pixel.x > (textureSize.y / textureSize.x))
{
mipLevel = 1.0;
if (uv.y - pixel.y > yMipLevel1)
{
mipLevel = 2.0;
if (uv.y - pixel.y * 3.0 > yMipLevel2)
{
mipLevel = 3.0;
if (uv.y - pixel.y * 5.0 > yMipLevel3)
{
mipLevel = 4.0;
if (uv.y - pixel.y * 7.0 > yMipLevel4)
{
mipLevel = 5.0;
}
}
}
}
}
if (mipLevel > 0.0)
{
float scale = pow(2.0, mipLevel);
uv.y -= (pixel.y * (mipLevel - 1.0) * 2.0);
uv.x *= ((textureSize.x - 2.0) / textureSize.y);
uv.x -= 1.0 + pixel.x;
uv.y -= (1.0 - (1.0 / pow(2.0, mipLevel - 1.0)));
uv *= scale;
}
else
{
uv.x *= (textureSize.x / textureSize.y);
}
if(mipLevel == 0.0)
{
gl_FragColor = texture2D(texture0, uv);
}
else if(mipLevel == 1.0)
{
gl_FragColor = texture2D(texture1, uv);
}
else if(mipLevel == 2.0)
{
gl_FragColor = texture2D(texture2, uv);
}
else if(mipLevel == 3.0)
{
gl_FragColor = texture2D(texture3, uv);
}
else if(mipLevel == 4.0)
{
gl_FragColor = texture2D(texture4, uv);
}
else if(mipLevel == 5.0)
{
gl_FragColor = texture2D(texture5, uv);
}
else
{
gl_FragColor = vec4(0.0);
}
}
`,
    rF = `varying vec3 v_cubeMapCoordinates;
uniform samplerCube cubeMap;
void main()
{
vec4 rgbm = textureCube(cubeMap, v_cubeMapCoordinates);
float m = rgbm.a * 16.0;
vec3 r = rgbm.rgb * m;
gl_FragColor = vec4(r * r, 1.0);
}
`,
    iF = `attribute vec4 position;
attribute vec3 cubeMapCoordinates;
varying vec3 v_cubeMapCoordinates;
void main()
{
gl_Position = position;
v_cubeMapCoordinates = cubeMapCoordinates;
}
`;

function Ji(e) {
    this._url = e, this._cubeMapBuffers = void 0, this._cubeMaps = void 0, this._texture = void 0, this._mipTextures = void 0, this._va = void 0, this._sp = void 0, this._maximumMipmapLevel = void 0, this._loading = !1, this._ready = !1, this._readyPromise = he.defer()
}
Object.defineProperties(Ji.prototype, {
    url: {
        get: function() {
            return this._url
        }
    },
    texture: {
        get: function() {
            return this._texture
        }
    },
    maximumMipmapLevel: {
        get: function() {
            return this._maximumMipmapLevel
        }
    },
    ready: {
        get: function() {
            return this._ready
        }
    },
    readyPromise: {
        get: function() {
            return this._readyPromise.promise
        }
    }
});
Ji.isSupported = function(e) {
    return e.colorBufferHalfFloat && e.halfFloatingPointTexture || e.floatingPointTexture && e.colorBufferFloat
};
var aF = new u(1, 0, 0),
    oF = new u(0, 0, 1),
    sF = new u(-1, 0, 0),
    uF = new u(0, 0, -1),
    Xu = new u(0, 1, 0),
    cF = new u(0, -1, 0),
    wT = [Xu, sF, oF, cF, aF, Xu, uF, Xu, Xu],
    xT = wT.length,
    ST = new Float32Array(xT * 3),
    $m = 0;
for (var kh = 0; kh < xT; ++kh, $m += 3) u.pack(wT[kh], ST, $m);
var fF = new Float32Array([-1, 1, -1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, -1, -1, -1, 1, -1]),
    hF = new Uint16Array([0, 1, 2, 2, 3, 1, 7, 6, 1, 3, 6, 1, 2, 5, 4, 3, 4, 2, 4, 8, 6, 3, 4, 6]);

function lF(e) {
    var t = _t.createVertexBuffer({
            context: e,
            typedArray: fF,
            usage: Ye.STATIC_DRAW
        }),
        n = _t.createVertexBuffer({
            context: e,
            typedArray: ST,
            usage: Ye.STATIC_DRAW
        }),
        r = _t.createIndexBuffer({
            context: e,
            typedArray: hF,
            usage: Ye.STATIC_DRAW,
            indexDatatype: yt.UNSIGNED_SHORT
        }),
        i = [{
            index: 0,
            vertexBuffer: t,
            componentsPerAttribute: 2,
            componentDatatype: ee.FLOAT
        }, {
            index: 1,
            vertexBuffer: n,
            componentsPerAttribute: 3,
            componentDatatype: ee.FLOAT
        }];
    return new Cn({
        context: e,
        attributes: i,
        indexBuffer: r
    })
}

function Jm(e) {
    return function() {
        return e
    }
}

function zl(e) {
    e._va = e._va && e._va.destroy(), e._sp = e._sp && e._sp.destroy();
    var t, n, r = e._cubeMaps;
    if (l(r))
        for (n = r.length, t = 0; t < n; ++t) r[t].destroy();
    var i = e._mipTextures;
    if (l(i))
        for (n = i.length, t = 0; t < n; ++t) i[t].destroy();
    e._va = void 0, e._sp = void 0, e._cubeMaps = void 0, e._cubeMapBuffers = void 0, e._mipTextures = void 0
}
Ji.prototype.update = function(e) {
    var t = e.context;
    if (!!Ji.isSupported(t) && (l(this._texture) && l(this._va) && zl(this), !l(this._texture))) {
        if (!l(this._texture) && !this._loading) {
            var n = t.textureCache.getTexture(this._url);
            if (l(n)) {
                zl(this), this._texture = n, this._maximumMipmapLevel = this._texture.maximumMipmapLevel, this._ready = !0, this._readyPromise.resolve();
                return
            }
        }
        var r = this._cubeMapBuffers;
        if (!l(r) && !this._loading) {
            var i = this;
            CT(this._url).then(function(C) {
                i._cubeMapBuffers = C, i._loading = !1
            }).otherwise(this._readyPromise.reject), this._loading = !0
        }
        if (!!l(this._cubeMapBuffers)) {
            this._va = lF(t), this._sp = Mt.fromCache({
                context: t,
                vertexShaderSource: iF,
                fragmentShaderSource: rF,
                attributeLocations: {
                    position: 0,
                    cubeMapCoordinates: 1
                }
            });
            var a = Math.min(r.length, 6);
            this._maximumMipmapLevel = a - 1;
            for (var o = this._cubeMaps = new Array(a), s = this._mipTextures = new Array(a), c = r[0].positiveX.width * 2, f = {
                    originalSize: function() {
                        return c
                    }
                }, h = t.halfFloatingPointTexture ? ae.HALF_FLOAT : ae.FLOAT, d = de.RGBA, _ = 0; _ < a; ++_) {
                var v = r[_].positiveY;
                r[_].positiveY = r[_].negativeY, r[_].negativeY = v;
                var m = o[_] = new Fo({
                        context: t,
                        source: r[_]
                    }),
                    g = o[_].width * 2,
                    y = s[_] = new be({
                        context: t,
                        width: g,
                        height: g,
                        pixelDatatype: h,
                        pixelFormat: d
                    }),
                    E = new bc({
                        vertexArray: this._va,
                        shaderProgram: this._sp,
                        uniformMap: {
                            cubeMap: Jm(m)
                        },
                        outputTexture: y,
                        persists: !0,
                        owner: this
                    });
                e.commandList.push(E), f["texture" + _] = Jm(y)
            }
            this._texture = new be({
                context: t,
                width: c * 1.5 + 2,
                height: c,
                pixelDatatype: h,
                pixelFormat: d
            }), this._texture.maximumMipmapLevel = this._maximumMipmapLevel, t.textureCache.addTexture(this._url, this._texture);
            var w = new bc({
                fragmentShaderSource: nF,
                uniformMap: f,
                outputTexture: this._texture,
                persists: !1,
                owner: this
            });
            e.commandList.push(w), this._ready = !0, this._readyPromise.resolve()
        }
    }
};
Ji.prototype.isDestroyed = function() {
    return !1
};
Ji.prototype.destroy = function() {
    return zl(this), this._texture = this._texture && this._texture.destroy(), Pe(this)
};

function dF(e) {
    if (typeof e == "string") {
        var t = document.getElementById(e);
        e = t
    }
    return e
}

function of (e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = dF(e.container);
    this._container = t;
    var n = document.createElement("div");
    n.className = "cesium-performanceDisplay";
    var r = document.createElement("div");
    r.className = "cesium-performanceDisplay-fps", this._fpsText = document.createTextNode(""), r.appendChild(this._fpsText);
    var i = document.createElement("div");
    i.className = "cesium-performanceDisplay-ms", this._msText = document.createTextNode(""), i.appendChild(this._msText), n.appendChild(i), n.appendChild(r), this._container.appendChild(n), this._lastFpsSampleTime = bn(), this._lastMsSampleTime = bn(), this._fpsFrameCount = 0, this._msFrameCount = 0, this._throttled = !1;
    var a = document.createElement("div");
    a.className = "cesium-performanceDisplay-throttled", this._throttledText = document.createTextNode(""), a.appendChild(this._throttledText), n.appendChild(a)
}
Object.defineProperties( of .prototype, {
    throttled: {
        get: function() {
            return this._throttled
        },
        set: function(e) {
            this._throttled !== e && (e ? this._throttledText.nodeValue = "(throttled)" : this._throttledText.nodeValue = "", this._throttled = e)
        }
    }
}); of .prototype.update = function(e) {
    var t = bn(),
        n = p(e, !0);
    this._fpsFrameCount++;
    var r = t - this._lastFpsSampleTime;
    if (r > 1e3) {
        var i = "N/A";
        n && (i = this._fpsFrameCount * 1e3 / r | 0), this._fpsText.nodeValue = i + " FPS", this._lastFpsSampleTime = t, this._fpsFrameCount = 0
    }
    this._msFrameCount++;
    var a = t - this._lastMsSampleTime;
    if (a > 200) {
        var o = "N/A";
        n && (o = (a / this._msFrameCount).toFixed(2)), this._msText.nodeValue = o + " MS", this._lastMsSampleTime = t, this._msFrameCount = 0
    }
}; of .prototype.destroy = function() {
    return Pe(this)
};

function jt(e) {
    e = p(e, p.EMPTY_OBJECT), this._primitives = [], this._guid = Oi(), this._zIndex = void 0, this.show = p(e.show, !0), this.destroyPrimitives = p(e.destroyPrimitives, !0)
}
Object.defineProperties(jt.prototype, {
    length: {
        get: function() {
            return this._primitives.length
        }
    }
});
jt.prototype.add = function(e, t) {
    var n = l(t),
        r = e._external = e._external || {},
        i = r._composites = r._composites || {};
    return i[this._guid] = {
        collection: this
    }, n ? this._primitives.splice(t, 0, e) : this._primitives.push(e), e
};
jt.prototype.remove = function(e) {
    if (this.contains(e)) {
        var t = this._primitives.indexOf(e);
        if (t !== -1) return this._primitives.splice(t, 1), delete e._external._composites[this._guid], this.destroyPrimitives && e.destroy(), !0
    }
    return !1
};
jt.prototype.removeAndDestroy = function(e) {
    var t = this.remove(e);
    return t && !this.destroyPrimitives && e.destroy(), t
};
jt.prototype.removeAll = function() {
    for (var e = this._primitives, t = e.length, n = 0; n < t; ++n) delete e[n]._external._composites[this._guid], this.destroyPrimitives && e[n].destroy();
    this._primitives = []
};
jt.prototype.contains = function(e) {
    return !!(l(e) && e._external && e._external._composites && e._external._composites[this._guid])
};

function sf(e, t) {
    return e._primitives.indexOf(t)
}
jt.prototype.raise = function(e) {
    if (l(e)) {
        var t = sf(this, e),
            n = this._primitives;
        if (t !== n.length - 1) {
            var r = n[t];
            n[t] = n[t + 1], n[t + 1] = r
        }
    }
};
jt.prototype.raiseToTop = function(e) {
    if (l(e)) {
        var t = sf(this, e),
            n = this._primitives;
        t !== n.length - 1 && (n.splice(t, 1), n.push(e))
    }
};
jt.prototype.lower = function(e) {
    if (l(e)) {
        var t = sf(this, e),
            n = this._primitives;
        if (t !== 0) {
            var r = n[t];
            n[t] = n[t - 1], n[t - 1] = r
        }
    }
};
jt.prototype.lowerToBottom = function(e) {
    if (l(e)) {
        var t = sf(this, e),
            n = this._primitives;
        t !== 0 && (n.splice(t, 1), n.unshift(e))
    }
};
jt.prototype.get = function(e) {
    return this._primitives[e]
};
jt.prototype.update = function(e) {
    if (!!this.show)
        for (var t = this._primitives, n = 0; n < t.length; ++n) t[n].update(e)
};
jt.prototype.prePassesUpdate = function(e) {
    for (var t = this._primitives, n = 0; n < t.length; ++n) {
        var r = t[n];
        l(r.prePassesUpdate) && r.prePassesUpdate(e)
    }
};
jt.prototype.updateForPass = function(e, t) {
    for (var n = this._primitives, r = 0; r < n.length; ++r) {
        var i = n[r];
        l(i.updateForPass) && i.updateForPass(e, t)
    }
};
jt.prototype.postPassesUpdate = function(e) {
    for (var t = this._primitives, n = 0; n < t.length; ++n) {
        var r = t[n];
        l(r.postPassesUpdate) && r.postPassesUpdate(e)
    }
};
jt.prototype.isDestroyed = function() {
    return !1
};
jt.prototype.destroy = function() {
    return this.removeAll(), Pe(this)
};

function Vc(e, t, n, r, i, a, o, s, c, f) {
    this._tweens = e, this._tweenjs = t, this._startObject = sn(n), this._stopObject = sn(r), this._duration = i, this._delay = a, this._easingFunction = o, this._update = s, this._complete = c, this.cancel = f, this.needsStart = !0
}
Object.defineProperties(Vc.prototype, {
    startObject: {
        get: function() {
            return this._startObject
        }
    },
    stopObject: {
        get: function() {
            return this._stopObject
        }
    },
    duration: {
        get: function() {
            return this._duration
        }
    },
    delay: {
        get: function() {
            return this._delay
        }
    },
    easingFunction: {
        get: function() {
            return this._easingFunction
        }
    },
    update: {
        get: function() {
            return this._update
        }
    },
    complete: {
        get: function() {
            return this._complete
        }
    },
    tweenjs: {
        get: function() {
            return this._tweenjs
        }
    }
});
Vc.prototype.cancelTween = function() {
    this._tweens.remove(this)
};

function Sr() {
    this._tweens = []
}
Object.defineProperties(Sr.prototype, {
    length: {
        get: function() {
            return this._tweens.length
        }
    }
});
Sr.prototype.add = function(e) {
    if (e = p(e, p.EMPTY_OBJECT), e.duration === 0) return l(e.complete) && e.complete(), new Vc(this);
    var t = e.duration / pt.SECONDS_PER_MILLISECOND,
        n = p(e.delay, 0),
        r = n / pt.SECONDS_PER_MILLISECOND,
        i = p(e.easingFunction, Uc.LINEAR_NONE),
        a = e.startObject,
        o = new Se.Tween(a);
    o.to(sn(e.stopObject), t), o.delay(r), o.easing(i), l(e.update) && o.onUpdate(function() {
        e.update(a)
    }), o.onComplete(p(e.complete, null)), o.repeat(p(e._repeat, 0));
    var s = new Vc(this, o, e.startObject, e.stopObject, e.duration, n, i, e.update, e.complete, e.cancel);
    return this._tweens.push(s), s
};
Sr.prototype.addProperty = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.object,
        n = e.property,
        r = e.startValue,
        i = e.stopValue;

    function a(o) {
        t[n] = o.value
    }
    return this.add({
        startObject: {
            value: r
        },
        stopObject: {
            value: i
        },
        duration: p(e.duration, 3),
        delay: e.delay,
        easingFunction: e.easingFunction,
        update: a,
        complete: e.complete,
        cancel: e.cancel,
        _repeat: e._repeat
    })
};
Sr.prototype.addAlpha = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.material,
        n = [];
    for (var r in t.uniforms) t.uniforms.hasOwnProperty(r) && l(t.uniforms[r]) && l(t.uniforms[r].alpha) && n.push(r);

    function i(a) {
        for (var o = n.length, s = 0; s < o; ++s) t.uniforms[n[s]].alpha = a.alpha
    }
    return this.add({
        startObject: {
            alpha: p(e.startValue, 0)
        },
        stopObject: {
            alpha: p(e.stopValue, 1)
        },
        duration: p(e.duration, 3),
        delay: e.delay,
        easingFunction: e.easingFunction,
        update: i,
        complete: e.complete,
        cancel: e.cancel
    })
};
Sr.prototype.addOffsetIncrement = function(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.material,
        n = t.uniforms;
    return this.addProperty({
        object: n,
        property: "offset",
        startValue: n.offset,
        stopValue: n.offset + 1,
        duration: e.duration,
        delay: e.delay,
        easingFunction: e.easingFunction,
        update: e.update,
        cancel: e.cancel,
        _repeat: 1 / 0
    })
};
Sr.prototype.remove = function(e) {
    if (!l(e)) return !1;
    var t = this._tweens.indexOf(e);
    return t !== -1 ? (e.tweenjs.stop(), l(e.cancel) && e.cancel(), this._tweens.splice(t, 1), !0) : !1
};
Sr.prototype.removeAll = function() {
    for (var e = this._tweens, t = 0; t < e.length; ++t) {
        var n = e[t];
        n.tweenjs.stop(), l(n.cancel) && n.cancel()
    }
    e.length = 0
};
Sr.prototype.contains = function(e) {
    return l(e) && this._tweens.indexOf(e) !== -1
};
Sr.prototype.get = function(e) {
    return this._tweens[e]
};
Sr.prototype.update = function(e) {
    var t = this._tweens,
        n = 0;
    for (e = l(e) ? e / pt.SECONDS_PER_MILLISECOND : bn(); n < t.length;) {
        var r = t[n],
            i = r.tweenjs;
        r.needsStart ? (r.needsStart = !1, i.start(e)) : i.update(e) ? n++ : (i.stop(), t.splice(n, 1))
    }
};

function ks(e) {
    this.enableInputs = !0, this.enableTranslate = !0, this.enableZoom = !0, this.enableRotate = !0, this.enableTilt = !0, this.enableLook = !0, this.inertiaSpin = .9, this.inertiaTranslate = .9, this.inertiaZoom = .8, this.maximumMovementRatio = .1, this.bounceAnimationTime = 3, this.minimumZoomDistance = 1, this.maximumZoomDistance = Number.POSITIVE_INFINITY, this.translateEventTypes = tt.LEFT_DRAG, this.zoomEventTypes = [tt.RIGHT_DRAG, tt.WHEEL, tt.PINCH], this.rotateEventTypes = tt.LEFT_DRAG, this.tiltEventTypes = [tt.MIDDLE_DRAG, tt.PINCH, {
        eventType: tt.LEFT_DRAG,
        modifier: gr.CTRL
    }, {
        eventType: tt.RIGHT_DRAG,
        modifier: gr.CTRL
    }], this.lookEventTypes = {
        eventType: tt.LEFT_DRAG,
        modifier: gr.SHIFT
    }, this.minimumPickingTerrainHeight = 15e4, this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight, this.minimumCollisionTerrainHeight = 15e3, this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight, this.minimumTrackBallHeight = 75e5, this._minimumTrackBallHeight = this.minimumTrackBallHeight, this.enableCollisionDetection = !0, this._scene = e, this._globe = void 0, this._ellipsoid = void 0, this._aggregator = new Ar(e.canvas), this._lastInertiaSpinMovement = void 0, this._lastInertiaZoomMovement = void 0, this._lastInertiaTranslateMovement = void 0, this._lastInertiaTiltMovement = void 0, this._inertiaDisablers = {
        _lastInertiaZoomMovement: ["_lastInertiaSpinMovement", "_lastInertiaTranslateMovement", "_lastInertiaTiltMovement"],
        _lastInertiaTiltMovement: ["_lastInertiaSpinMovement", "_lastInertiaTranslateMovement"]
    }, this._tweens = new Sr, this._tween = void 0, this._horizontalRotationAxis = void 0, this._tiltCenterMousePosition = new R(-1, -1), this._tiltCenter = new u, this._rotateMousePosition = new R(-1, -1), this._rotateStartPosition = new u, this._strafeStartPosition = new u, this._strafeMousePosition = new R, this._strafeEndMousePosition = new R, this._zoomMouseStart = new R(-1, -1), this._zoomWorldPosition = new u, this._useZoomWorldPosition = !1, this._tiltCVOffMap = !1, this._looking = !1, this._rotating = !1, this._strafing = !1, this._zoomingOnVector = !1, this._zoomingUnderground = !1, this._rotatingZoom = !1, this._adjustedHeightForTerrain = !1, this._cameraUnderground = !1;
    var t = e.mapProjection;
    this._maxCoord = t.project(new K(Math.PI, T.PI_OVER_TWO)), this._zoomFactor = 5, this._rotateFactor = void 0, this._rotateRateRangeAdjustment = void 0, this._maximumRotateRate = 1.77, this._minimumRotateRate = 1 / 5e3, this._minimumZoomRate = 20, this._maximumZoomRate = 5906376272e3, this._minimumUndergroundPickDistance = 2e3, this._maximumUndergroundPickDistance = 1e4
}

function _F(e, t) {
    if (e < 0) return 0;
    var n = (1 - t) * 25;
    return Math.exp(-n * e)
}

function vF(e) {
    return R.equalsEpsilon(e.startPosition, e.endPosition, T.EPSILON14)
}
var mF = .4;

function pF(e, t, n, r, i, a, o) {
    var s = a[o];
    l(s) || (s = a[o] = {
        startPosition: new R,
        endPosition: new R,
        motion: new R,
        inertiaEnabled: !0
    });
    var c = e.getButtonPressTime(t, n),
        f = e.getButtonReleaseTime(t, n),
        h = c && f && (f.getTime() - c.getTime()) / 1e3,
        d = new Date,
        _ = f && (d.getTime() - f.getTime()) / 1e3;
    if (c && f && h < mF) {
        var v = _F(_, r),
            m = e.getLastMovement(t, n);
        if (!l(m) || vF(m) || !s.inertiaEnabled || (s.motion.x = (m.endPosition.x - m.startPosition.x) * .5, s.motion.y = (m.endPosition.y - m.startPosition.y) * .5, s.startPosition = R.clone(m.startPosition, s.startPosition), s.endPosition = R.multiplyByScalar(s.motion, v, s.endPosition), s.endPosition = R.add(s.startPosition, s.endPosition, s.endPosition), isNaN(s.endPosition.x) || isNaN(s.endPosition.y) || R.distance(s.startPosition, s.endPosition) < .5)) return;
        if (!e.isButtonDown(t, n)) {
            var g = e.getStartMousePosition(t, n);
            i(a, g, s)
        }
    }
}

function gF(e, t) {
    if (l(t)) {
        var n = e[t];
        l(n) && (n.inertiaEnabled = !0);
        var r = e._inertiaDisablers[t];
        if (l(r))
            for (var i = r.length, a = 0; a < i; ++a) n = e[r[a]], l(n) && (n.inertiaEnabled = !1)
    }
}
var Qm = [];

function In(e, t, n, r, i, a) {
    if (!!l(n)) {
        var o = e._aggregator;
        Array.isArray(n) || (Qm[0] = n, n = Qm);
        for (var s = n.length, c = 0; c < s; ++c) {
            var f = n[c],
                h = l(f.eventType) ? f.eventType : f,
                d = f.modifier,
                _ = o.isMoving(h, d) && o.getMovement(h, d),
                v = o.getStartMousePosition(h, d);
            e.enableInputs && t && (_ ? (r(e, v, _), gF(e, a)) : i < 1 && pF(o, h, d, i, r, e, a))
        }
    }
}
var ju = new Ke,
    yF = new u,
    TF = new R,
    EF = new u,
    AF = new R,
    CF = new u,
    wF = new u,
    xF = new u,
    SF = new u,
    RF = new u,
    DF = new u,
    IF = new u,
    PF = new u,
    OF = new u,
    MF = new u,
    NF = new u,
    bF = new u,
    FF = new u,
    LF = new u,
    UF = new u,
    Ta = new u,
    ep = new u,
    tp = new u,
    Wh = {
        orientation: new Xt
    };

function Gd(e, t, n, r, i, a) {
    var o = 1;
    l(a) && (o = T.clamp(Math.abs(a), .25, 1));
    var s = e.minimumZoomDistance * o,
        c = e.maximumZoomDistance,
        f = i - s,
        h = r * f;
    h = T.clamp(h, e._minimumZoomRate, e._maximumZoomRate);
    var d = n.endPosition.y - n.startPosition.y,
        _ = d / e._scene.canvas.clientHeight;
    _ = Math.min(_, e.maximumMovementRatio);
    var v = h * _;
    if (e.enableCollisionDetection || e.minimumZoomDistance === 0 || !l(e._globe)) {
        if (v > 0 && Math.abs(i - s) < 1 || v < 0 && Math.abs(i - c) < 1) return;
        i - v < s ? v = i - s - 1 : i - v > c && (v = i - c)
    }
    var m = e._scene,
        g = m.camera,
        y = m.mode,
        E = Wh.orientation;
    if (E.heading = g.heading, E.pitch = g.pitch, E.roll = g.roll, g.frustum instanceof lt) {
        Math.abs(v) > 0 && (g.zoomIn(v), g._adjustOrthographicFrustum());
        return
    }
    var w = R.equals(t, e._zoomMouseStart),
        C = e._zoomingOnVector,
        A = e._rotatingZoom,
        x;
    if (w || (e._zoomMouseStart = R.clone(t, e._zoomMouseStart), l(e._globe) && (y === k.SCENE2D ? (x = g.getPickRay(t, ju).origin, x = u.fromElements(x.y, x.z, x.x)) : x = Qi(e, t, yF)), l(x) ? (e._useZoomWorldPosition = !0, e._zoomWorldPosition = u.clone(x, e._zoomWorldPosition)) : e._useZoomWorldPosition = !1, C = e._zoomingOnVector = !1, A = e._rotatingZoom = !1, e._zoomingUnderground = e._cameraUnderground), !e._useZoomWorldPosition) {
        g.zoomIn(v);
        return
    }
    var P = y === k.COLUMBUS_VIEW;
    if (g.positionCartographic.height < 2e6 && (A = !0), !w || A) {
        if (y === k.SCENE2D) {
            var I = e._zoomWorldPosition,
                D = g.position;
            if (!u.equals(I, D) && g.positionCartographic.height < e._maxCoord.x * 2) {
                var O = g.position.x,
                    F = u.subtract(I, D, EF);
                u.normalize(F, F);
                var z = u.distance(I, D) * v / (g.getMagnitude() * .5);
                g.move(F, z * .5), (g.position.x < 0 && O > 0 || g.position.x > 0 && O < 0) && (x = g.getPickRay(t, ju).origin, x = u.fromElements(x.y, x.z, x.x), e._zoomWorldPosition = u.clone(x, e._zoomWorldPosition))
            }
        } else if (y === k.SCENE3D) {
            var b = u.normalize(g.position, RF);
            if (e._cameraUnderground || e._zoomingUnderground || g.positionCartographic.height < 3e3 && Math.abs(u.dot(g.direction, b)) < .6) P = !0;
            else {
                var M = m.canvas,
                    G = AF;
                G.x = M.clientWidth / 2, G.y = M.clientHeight / 2;
                var V = Qi(e, G, CF);
                if (!l(V)) P = !0;
                else if (g.positionCartographic.height < 1e6)
                    if (u.dot(g.direction, b) >= -.5) P = !0;
                    else {
                        var B = IF;
                        u.clone(g.position, B);
                        var Y = e._zoomWorldPosition,
                            j = DF;
                        if (j = u.normalize(Y, j), u.dot(j, b) < 0) return;
                        var Z = UF,
                            Q = MF;
                        u.clone(g.direction, Q), u.add(B, u.multiplyByScalar(Q, 1e3, Ta), Z);
                        var ie = NF,
                            Ae = bF;
                        u.subtract(Y, B, ie), u.normalize(ie, Ae);
                        var re = u.dot(b, Ae);
                        if (re >= 0) {
                            e._zoomMouseStart.x = -1;
                            return
                        }
                        var ve = Math.acos(-re),
                            qe = u.magnitude(B),
                            De = u.magnitude(Y),
                            _e = qe - v,
                            Oe = u.magnitude(ie),
                            Fe = Math.asin(T.clamp(Oe / De * Math.sin(ve), -1, 1)),
                            ce = Math.asin(T.clamp(_e / De * Math.sin(ve), -1, 1)),
                            He = Fe - ce + ve,
                            le = PF;
                        u.normalize(B, le);
                        var ft = OF;
                        ft = u.cross(Ae, le, ft), ft = u.normalize(ft, ft), u.normalize(u.cross(le, ft, Ta), Q), u.multiplyByScalar(u.normalize(Z, Ta), u.magnitude(Z) - v, Z), u.normalize(B, B), u.multiplyByScalar(B, _e, B);
                        var Pt = FF;
                        u.multiplyByScalar(u.add(u.multiplyByScalar(le, Math.cos(He) - 1, ep), u.multiplyByScalar(Q, Math.sin(He), tp), Ta), _e, Pt), u.add(B, Pt, B), u.normalize(Z, le), u.normalize(u.cross(le, ft, Ta), Q);
                        var Ie = LF;
                        u.multiplyByScalar(u.add(u.multiplyByScalar(le, Math.cos(He) - 1, ep), u.multiplyByScalar(Q, Math.sin(He), tp), Ta), u.magnitude(Z), Ie), u.add(Z, Ie, Z), u.clone(B, g.position), u.normalize(u.subtract(Z, B, Ta), g.direction), u.clone(g.direction, g.direction), u.cross(g.direction, g.up, g.right), u.cross(g.right, g.direction, g.up), g.setView(Wh);
                        return
                    }
                else {
                    var xn = u.normalize(V, wF),
                        Sn = u.normalize(e._zoomWorldPosition, xF),
                        St = u.dot(Sn, xn);
                    if (St > 0 && St < 1) {
                        var rr = T.acosClamped(St),
                            bt = u.cross(Sn, xn, SF),
                            cn = Math.abs(rr) > T.toRadians(20) ? g.positionCartographic.height * .75 : g.positionCartographic.height - v,
                            Rr = v / cn;
                        g.rotate(bt, rr * Rr)
                    }
                }
            }
        }
        e._rotatingZoom = !P
    }
    if (!w && P || C) {
        var fn, ir = Ht.wgs84ToWindowCoordinates(m, e._zoomWorldPosition, TF);
        y !== k.COLUMBUS_VIEW && R.equals(t, e._zoomMouseStart) && l(ir) ? fn = g.getPickRay(ir, ju) : fn = g.getPickRay(t, ju);
        var hn = fn.direction;
        (y === k.COLUMBUS_VIEW || y === k.SCENE2D) && u.fromElements(hn.y, hn.z, hn.x, hn), g.move(hn, v), e._zoomingOnVector = !0
    } else g.zoomIn(v);
    e._cameraUnderground || g.setView(Wh)
}
var zF = new Ke,
    BF = new Ke,
    VF = new u;

function GF(e, t, n) {
    var r = e._scene,
        i = r.camera,
        a = i.getPickRay(n.startPosition, zF).origin,
        o = i.getPickRay(n.endPosition, BF).origin;
    a = u.fromElements(a.y, a.z, a.x, a), o = u.fromElements(o.y, o.z, o.x, o);
    var s = u.subtract(a, o, VF),
        c = u.magnitude(s);
    c > 0 && (u.normalize(s, s), i.move(s, c))
}

function np(e, t, n) {
    l(n.distance) && (n = n.distance);
    var r = e._scene,
        i = r.camera;
    Gd(e, t, n, e._zoomFactor, i.getMagnitude())
}
var HF = new R,
    kF = new R;

function rp(e, t, n) {
    if (l(n.angleAndHeight)) {
        WF(e, t, n.angleAndHeight);
        return
    }
    var r = e._scene,
        i = r.camera,
        a = r.canvas,
        o = a.clientWidth,
        s = a.clientHeight,
        c = HF;
    c.x = 2 / o * n.startPosition.x - 1, c.y = 2 / s * (s - n.startPosition.y) - 1, c = R.normalize(c, c);
    var f = kF;
    f.x = 2 / o * n.endPosition.x - 1, f.y = 2 / s * (s - n.endPosition.y) - 1, f = R.normalize(f, f);
    var h = T.acosClamped(c.x);
    c.y < 0 && (h = T.TWO_PI - h);
    var d = T.acosClamped(f.x);
    f.y < 0 && (d = T.TWO_PI - d);
    var _ = d - h;
    i.twistRight(_)
}

function WF(e, t, n) {
    var r = e._rotateFactor * e._rotateRateRangeAdjustment;
    r > e._maximumRotateRate && (r = e._maximumRotateRate), r < e._minimumRotateRate && (r = e._minimumRotateRate);
    var i = e._scene,
        a = i.camera,
        o = i.canvas,
        s = (n.endPosition.x - n.startPosition.x) / o.clientWidth;
    s = Math.min(s, e.maximumMovementRatio);
    var c = r * s * Math.PI * 4;
    a.twistRight(c)
}

function qF(e) {
    var t = e._scene.mapMode2D === Do.ROTATE;
    S.equals(S.IDENTITY, e._scene.camera.transform) ? (In(e, e.enableTranslate, e.translateEventTypes, GF, e.inertiaTranslate, "_lastInertiaTranslateMovement"), In(e, e.enableZoom, e.zoomEventTypes, np, e.inertiaZoom, "_lastInertiaZoomMovement"), t && In(e, e.enableRotate, e.tiltEventTypes, rp, e.inertiaSpin, "_lastInertiaTiltMovement")) : (In(e, e.enableZoom, e.zoomEventTypes, np, e.inertiaZoom, "_lastInertiaZoomMovement"), t && In(e, e.enableRotate, e.translateEventTypes, rp, e.inertiaSpin, "_lastInertiaSpinMovement"))
}
var RT = new Ke,
    YF = new u,
    XF = new u;

function Qi(e, t, n) {
    var r = e._scene,
        i = e._globe,
        a = r.camera;
    if (!!l(i)) {
        var o = !e._cameraUnderground,
            s;
        r.pickPositionSupported && (s = r.pickPositionWorldCoordinates(t, YF));
        var c = a.getPickRay(t, RT),
            f = i.pickWorldCoordinates(c, r, o, XF),
            h = l(s) ? u.distance(s, a.positionWC) : Number.POSITIVE_INFINITY,
            d = l(f) ? u.distance(f, a.positionWC) : Number.POSITIVE_INFINITY;
        return h < d ? u.clone(s, n) : u.clone(f, n)
    }
}
var jF = new K;

function Gc(e) {
    var t = e._ellipsoid,
        n = e._scene,
        r = n.camera,
        i = n.mode,
        a = 0;
    if (i === k.SCENE3D) {
        var o = t.cartesianToCartographic(r.position, jF);
        l(o) && (a = o.height)
    } else a = r.position.z;
    var s = p(e._scene.globeHeight, 0),
        c = Math.abs(s - a);
    return c
}
var ZF = new u;

function DT(e, t) {
    var n = t.origin,
        r = t.direction,
        i = Gc(e),
        a = u.normalize(n, ZF),
        o = Math.abs(u.dot(a, r));
    return o = Math.max(o, .5) * 2, i * o
}

function IT(e, t, n, r) {
    var i = u.distance(t.origin, n),
        a = Gc(e),
        o = T.clamp(a * 5, e._minimumUndergroundPickDistance, e._maximumUndergroundPickDistance);
    return i > o && (i = Math.min(i, a / 5), i = Math.max(i, 100)), Ke.getPoint(t, i, r)
}

function PT(e, t, n, r) {
    var i;
    return l(n) ? (i = u.distance(t.origin, n), i > e._maximumUndergroundPickDistance && (i = Gc(e))) : i = Gc(e), Ke.getPoint(t, i, r)
}
var KF = new R;

function OT(e, t) {
    var n = t.endPosition,
        r = R.subtract(t.endPosition, t.startPosition, KF),
        i = e._strafeEndMousePosition;
    R.add(i, r, i), t.endPosition = i, Hd(e, t, e._strafeStartPosition), t.endPosition = n
}
var ip = new Ke,
    $F = new Ke,
    qh = new u,
    JF = new u,
    QF = new u,
    eL = new u,
    tL = new Ne(u.UNIT_X, 0),
    nL = new R,
    rL = new R;

function iL(e, t, n) {
    if (u.equals(t, e._translateMousePosition) || (e._looking = !1), u.equals(t, e._strafeMousePosition) || (e._strafing = !1), e._looking) {
        nr(e, t, n);
        return
    }
    if (e._strafing) {
        OT(e, n);
        return
    }
    var r = e._scene,
        i = r.camera,
        a = e._cameraUnderground,
        o = R.clone(n.startPosition, nL),
        s = R.clone(n.endPosition, rL),
        c = i.getPickRay(o, ip),
        f = u.clone(u.ZERO, eL),
        h = u.UNIT_X,
        d;
    if (i.position.z < e._minimumPickingTerrainHeight && (d = Qi(e, o, qh), l(d) && (f.x = d.x)), a || f.x > i.position.z && l(d)) {
        var _ = d;
        a && (_ = PT(e, c, d, qh)), R.clone(t, e._strafeMousePosition), R.clone(t, e._strafeEndMousePosition), u.clone(_, e._strafeStartPosition), e._strafing = !0, Hd(e, n, e._strafeStartPosition);
        return
    }
    var v = Ne.fromPointNormal(f, h, tL);
    c = i.getPickRay(o, ip);
    var m = Me.rayPlane(c, v, qh),
        g = i.getPickRay(s, $F),
        y = Me.rayPlane(g, v, JF);
    if (!l(m) || !l(y)) {
        e._looking = !0, nr(e, t, n), R.clone(t, e._translateMousePosition);
        return
    }
    var E = u.subtract(m, y, QF),
        w = E.x;
    E.x = E.y, E.y = E.z, E.z = w;
    var C = u.magnitude(E);
    C > T.EPSILON6 && (u.normalize(E, E), i.move(E, C))
}
var MT = new R,
    yc = new Ke,
    Tc = new u,
    aL = new u,
    NT = new S,
    oL = new S,
    sL = new u,
    uL = new Ne(u.UNIT_X, 0),
    Yh = new u,
    Bl = new K,
    bT = new S,
    cL = new X,
    fL = new N,
    Ec = new u;

function hL(e, t, n) {
    if (l(n.angleAndHeight) && (n = n.angleAndHeight), R.equals(t, e._tiltCenterMousePosition) || (e._tiltCVOffMap = !1, e._looking = !1), e._looking) {
        nr(e, t, n);
        return
    }
    var r = e._scene,
        i = r.camera;
    e._tiltCVOffMap || !e.onMap() || Math.abs(i.position.z) > e._minimumPickingTerrainHeight ? (e._tiltCVOffMap = !0, lL(e, t, n)) : dL(e, t, n)
}

function lL(e, t, n) {
    var r = e._scene,
        i = r.camera,
        a = r.canvas,
        o = MT;
    o.x = a.clientWidth / 2, o.y = a.clientHeight / 2;
    var s = i.getPickRay(o, yc),
        c = u.UNIT_X,
        f = s.origin,
        h = s.direction,
        d, _ = u.dot(c, h);
    if (Math.abs(_) > T.EPSILON6 && (d = -u.dot(c, f) / _), !l(d) || d <= 0) {
        e._looking = !0, nr(e, t, n), R.clone(t, e._tiltCenterMousePosition);
        return
    }
    var v = u.multiplyByScalar(h, d, Tc);
    u.add(f, v, v);
    var m = r.mapProjection,
        g = m.ellipsoid;
    u.fromElements(v.y, v.z, v.x, v);
    var y = m.unproject(v, Bl);
    g.cartographicToCartesian(y, v);
    var E = xe.eastNorthUpToFixedFrame(v, g, NT),
        w = e._globe,
        C = e._ellipsoid;
    e._globe = void 0, e._ellipsoid = ne.UNIT_SPHERE, e._rotateFactor = 1, e._rotateRateRangeAdjustment = 1;
    var A = S.clone(i.transform, bT);
    i._setTransform(E), tr(e, t, n, u.UNIT_Z), i._setTransform(A), e._globe = w, e._ellipsoid = C;
    var x = C.maximumRadius;
    e._rotateFactor = 1 / x, e._rotateRateRangeAdjustment = x
}

function dL(e, t, n) {
    var r = e._scene,
        i = r.camera,
        a = e._cameraUnderground,
        o, s, c = u.UNIT_X;
    if (R.equals(t, e._tiltCenterMousePosition)) o = u.clone(e._tiltCenter, Tc);
    else {
        if (i.position.z < e._minimumPickingTerrainHeight && (o = Qi(e, t, Tc)), !l(o)) {
            s = i.getPickRay(t, yc);
            var f = s.origin,
                h = s.direction,
                d, _ = u.dot(c, h);
            if (Math.abs(_) > T.EPSILON6 && (d = -u.dot(c, f) / _), !l(d) || d <= 0) {
                e._looking = !0, nr(e, t, n), R.clone(t, e._tiltCenterMousePosition);
                return
            }
            o = u.multiplyByScalar(h, d, Tc), u.add(f, o, o)
        }
        a && (l(s) || (s = i.getPickRay(t, yc)), IT(e, s, o, o)), R.clone(t, e._tiltCenterMousePosition), u.clone(o, e._tiltCenter)
    }
    var v = r.canvas,
        m = MT;
    m.x = v.clientWidth / 2, m.y = e._tiltCenterMousePosition.y, s = i.getPickRay(m, yc);
    var g = u.clone(u.ZERO, sL);
    g.x = o.x;
    var y = Ne.fromPointNormal(g, c, uL),
        E = Me.rayPlane(s, y, aL),
        w = i._projection,
        C = w.ellipsoid;
    u.fromElements(o.y, o.z, o.x, o);
    var A = w.unproject(o, Bl);
    C.cartographicToCartesian(A, o);
    var x = xe.eastNorthUpToFixedFrame(o, C, NT),
        P;
    l(E) ? (u.fromElements(E.y, E.z, E.x, E), A = w.unproject(E, Bl), C.cartographicToCartesian(A, E), P = xe.eastNorthUpToFixedFrame(E, C, oL)) : P = x;
    var I = e._globe,
        D = e._ellipsoid;
    e._globe = void 0, e._ellipsoid = ne.UNIT_SPHERE, e._rotateFactor = 1, e._rotateRateRangeAdjustment = 1;
    var O = u.UNIT_Z,
        F = S.clone(i.transform, bT);
    i._setTransform(x);
    var z = u.cross(u.UNIT_Z, u.normalize(i.position, Yh), Yh),
        b = u.dot(i.right, z);
    if (tr(e, t, n, O, !1, !0), i._setTransform(P), b < 0) {
        var M = n.startPosition.y - n.endPosition.y;
        (a && M < 0 || !a && M > 0) && (O = void 0);
        var G = i.constrainedAxis;
        i.constrainedAxis = void 0, tr(e, t, n, O, !0, !1), i.constrainedAxis = G
    } else tr(e, t, n, O, !0, !1);
    if (l(i.constrainedAxis)) {
        var V = u.cross(i.direction, i.constrainedAxis, Ec);
        u.equalsEpsilon(V, u.ZERO, T.EPSILON6) || (u.dot(V, i.right) < 0 && u.negate(V, V), u.cross(V, i.direction, i.up), u.cross(i.direction, i.up, i.right), u.normalize(i.up, i.up), u.normalize(i.right, i.right))
    }
    i._setTransform(F), e._globe = I, e._ellipsoid = D;
    var B = D.maximumRadius;
    e._rotateFactor = 1 / B, e._rotateRateRangeAdjustment = B;
    var Y = u.clone(i.positionWC, Yh);
    if (e.enableCollisionDetection && qd(e), !u.equals(i.positionWC, Y)) {
        i._setTransform(P), i.worldToCameraCoordinatesPoint(Y, Y);
        var j = u.magnitudeSquared(Y);
        u.magnitudeSquared(i.position) > j && (u.normalize(i.position, i.position), u.multiplyByScalar(i.position, Math.sqrt(j), i.position));
        var Z = u.angleBetween(Y, i.position),
            Q = u.cross(Y, i.position, Y);
        u.normalize(Q, Q);
        var ie = X.fromAxisAngle(Q, Z, cL),
            Ae = N.fromQuaternion(ie, fL);
        N.multiplyByVector(Ae, i.direction, i.direction), N.multiplyByVector(Ae, i.up, i.up), u.cross(i.direction, i.up, i.right), u.cross(i.right, i.direction, i.up), i._setTransform(F)
    }
}
var FT = new R,
    LT = new Ke,
    UT = new u;

function _L(e, t, n) {
    l(n.distance) && (n = n.distance);
    var r = e._scene,
        i = r.camera,
        a = r.canvas,
        o = e._cameraUnderground,
        s;
    o ? s = t : (s = FT, s.x = a.clientWidth / 2, s.y = a.clientHeight / 2);
    var c = i.getPickRay(s, LT),
        f = c.origin,
        h = c.direction,
        d = i.position.z,
        _;
    d < e._minimumPickingTerrainHeight && (_ = Qi(e, s, UT));
    var v;
    if (l(_) && (v = u.distance(f, _)), o) {
        var m = DT(e, c);
        l(v) ? v = Math.min(v, m) : v = m
    }
    if (!l(v)) {
        var g = u.UNIT_X;
        v = -u.dot(g, f) / u.dot(g, h)
    }
    Gd(e, t, n, e._zoomFactor, v)
}

function vL(e) {
    var t = e._scene,
        n = t.camera;
    if (!S.equals(S.IDENTITY, n.transform)) In(e, e.enableRotate, e.rotateEventTypes, tr, e.inertiaSpin, "_lastInertiaSpinMovement"), In(e, e.enableZoom, e.zoomEventTypes, zT, e.inertiaZoom, "_lastInertiaZoomMovement");
    else {
        var r = e._tweens;
        if (e._aggregator.anyButtonDown && r.removeAll(), In(e, e.enableTilt, e.tiltEventTypes, hL, e.inertiaSpin, "_lastInertiaTiltMovement"), In(e, e.enableTranslate, e.translateEventTypes, iL, e.inertiaTranslate, "_lastInertiaTranslateMovement"), In(e, e.enableZoom, e.zoomEventTypes, _L, e.inertiaZoom, "_lastInertiaZoomMovement"), In(e, e.enableLook, e.lookEventTypes, nr), !e._aggregator.anyButtonDown && !r.contains(e._tween)) {
            var i = n.createCorrectPositionTween(e.bounceAnimationTime);
            l(i) && (e._tween = r.add(i))
        }
        r.update()
    }
}
var mL = new Ke,
    pL = new Ne(u.UNIT_X, 0),
    gL = new u,
    yL = new u,
    TL = new u;

function Hd(e, t, n) {
    var r = e._scene,
        i = r.camera,
        a = i.getPickRay(t.endPosition, mL),
        o = u.clone(i.direction, yL);
    r.mode === k.COLUMBUS_VIEW && u.fromElements(o.z, o.x, o.y, o);
    var s = Ne.fromPointNormal(n, o, pL),
        c = Me.rayPlane(a, s, gL);
    !l(c) || (o = u.subtract(n, c, o), r.mode === k.COLUMBUS_VIEW && u.fromElements(o.y, o.z, o.x, o), u.add(i.position, o, i.position))
}
var ap = new u,
    EL = new K,
    Vl = new u,
    Gl = new ne,
    AL = new u,
    CL = new u;

function wL(e, t, n) {
    var r = e._scene,
        i = r.camera,
        a = e._cameraUnderground,
        o = e._ellipsoid;
    if (!S.equals(i.transform, S.IDENTITY)) {
        tr(e, t, n);
        return
    }
    var s, c, f = o.geodeticSurfaceNormal(i.position, AL);
    if (R.equals(t, e._rotateMousePosition)) {
        if (e._looking) nr(e, t, n, f);
        else if (e._rotating) tr(e, t, n);
        else if (e._strafing) OT(e, n);
        else {
            if (u.magnitude(i.position) < u.magnitude(e._rotateStartPosition)) return;
            s = u.magnitude(e._rotateStartPosition), c = Vl, c.x = c.y = c.z = s, o = ne.fromCartesian3(c, Gl), jh(e, t, n, o)
        }
        return
    }
    e._looking = !1, e._rotating = !1, e._strafing = !1;
    var h = o.cartesianToCartographic(i.positionWC, EL).height,
        d = e._globe;
    if (l(d) && h < e._minimumPickingTerrainHeight) {
        var _ = Qi(e, n.startPosition, TL);
        if (l(_)) {
            var v = !1,
                m = i.getPickRay(n.startPosition, RT);
            if (a) v = !0, PT(e, m, _, _);
            else {
                var g = o.geodeticSurfaceNormal(_, CL),
                    y = Math.abs(u.dot(m.direction, g)) < .05;
                y ? v = !0 : v = u.magnitude(i.position) < u.magnitude(_)
            }
            v ? (R.clone(t, e._strafeEndMousePosition), u.clone(_, e._strafeStartPosition), e._strafing = !0, Hd(e, n, e._strafeStartPosition)) : (s = u.magnitude(_), c = Vl, c.x = c.y = c.z = s, o = ne.fromCartesian3(c, Gl), jh(e, t, n, o), u.clone(_, e._rotateStartPosition))
        } else e._looking = !0, nr(e, t, n, f)
    } else l(i.pickEllipsoid(n.startPosition, e._ellipsoid, ap)) ? (jh(e, t, n, e._ellipsoid), u.clone(ap, e._rotateStartPosition)) : h > e._minimumTrackBallHeight ? (e._rotating = !0, tr(e, t, n)) : (e._looking = !0, nr(e, t, n, f));
    R.clone(t, e._rotateMousePosition)
}

function tr(e, t, n, r, i, a) {
    i = p(i, !1), a = p(a, !1);
    var o = e._scene,
        s = o.camera,
        c = o.canvas,
        f = s.constrainedAxis;
    l(r) && (s.constrainedAxis = r);
    var h = u.magnitude(s.position),
        d = e._rotateFactor * (h - e._rotateRateRangeAdjustment);
    d > e._maximumRotateRate && (d = e._maximumRotateRate), d < e._minimumRotateRate && (d = e._minimumRotateRate);
    var _ = (n.startPosition.x - n.endPosition.x) / c.clientWidth,
        v = (n.startPosition.y - n.endPosition.y) / c.clientHeight;
    _ = Math.min(_, e.maximumMovementRatio), v = Math.min(v, e.maximumMovementRatio);
    var m = d * _ * Math.PI * 2,
        g = d * v * Math.PI;
    i || s.rotateRight(m), a || s.rotateUp(g), s.constrainedAxis = f
}
var xL = U.clone(U.UNIT_W),
    SL = U.clone(U.UNIT_W),
    Zu = new u,
    Xh = new u,
    RL = new u,
    DL = new u,
    IL = new R,
    PL = new R;

function jh(e, t, n, r) {
    var i = e._scene,
        a = i.camera,
        o = R.clone(n.startPosition, IL),
        s = R.clone(n.endPosition, PL),
        c = a.pickEllipsoid(o, r, xL),
        f = a.pickEllipsoid(s, r, SL);
    if (!l(c) || !l(f)) {
        e._rotating = !0, tr(e, t, n);
        return
    }
    if (c = a.worldToCameraCoordinates(c, c), f = a.worldToCameraCoordinates(f, f), l(a.constrainedAxis)) {
        var v = a.constrainedAxis,
            m = u.mostOrthogonalAxis(v, Zu);
        u.cross(m, v, m), u.normalize(m, m);
        var g = u.cross(v, m, Xh),
            y = u.magnitude(c),
            E = u.dot(v, c),
            w = Math.acos(E / y),
            C = u.multiplyByScalar(v, E, RL);
        u.subtract(c, C, C), u.normalize(C, C);
        var A = u.magnitude(f),
            x = u.dot(v, f),
            P = Math.acos(x / A),
            I = u.multiplyByScalar(v, x, DL);
        u.subtract(f, I, I), u.normalize(I, I);
        var D = Math.acos(u.dot(C, m));
        u.dot(C, g) < 0 && (D = T.TWO_PI - D);
        var O = Math.acos(u.dot(I, m));
        u.dot(I, g) < 0 && (O = T.TWO_PI - O);
        var F = D - O,
            z;
        u.equalsEpsilon(v, a.position, T.EPSILON2) ? z = a.right : z = u.cross(v, a.position, Zu);
        var b = u.cross(v, z, Zu),
            M = u.dot(b, u.subtract(c, v, Xh)),
            G = u.dot(b, u.subtract(f, v, Xh)),
            V;
        M > 0 && G > 0 ? V = P - w : M > 0 && G <= 0 ? u.dot(a.position, v) > 0 ? V = -w - P : V = w + P : V = w - P, a.rotateRight(F), a.rotateUp(V)
    } else {
        u.normalize(c, c), u.normalize(f, f);
        var h = u.dot(c, f),
            d = u.cross(c, f, Zu);
        if (h < 1 && !u.equalsEpsilon(d, u.ZERO, T.EPSILON14)) {
            var _ = Math.acos(h);
            a.rotate(d, _)
        }
    }
}
var OL = new u,
    ML = new K;

function zT(e, t, n) {
    l(n.distance) && (n = n.distance);
    var r = e._ellipsoid,
        i = e._scene,
        a = i.camera,
        o = i.canvas,
        s = e._cameraUnderground,
        c;
    s ? c = t : (c = FT, c.x = o.clientWidth / 2, c.y = o.clientHeight / 2);
    var f = a.getPickRay(c, LT),
        h, d = r.cartesianToCartographic(a.position, ML).height;
    d < e._minimumPickingTerrainHeight && (h = Qi(e, c, UT));
    var _;
    if (l(h) && (_ = u.distance(f.origin, h)), s) {
        var v = DT(e, f);
        l(_) ? _ = Math.min(_, v) : _ = v
    }
    l(_) || (_ = d);
    var m = u.normalize(a.position, OL);
    Gd(e, t, n, e._zoomFactor, _, u.dot(m, a.direction))
}
var BT = new R,
    Ac = new Ke,
    Es = new u,
    NL = new u,
    VT = new S,
    bL = new S,
    GT = new S,
    FL = new X,
    LL = new N,
    kd = new K,
    Wd = new u;

function UL(e, t, n) {
    var r = e._scene,
        i = r.camera;
    if (!!S.equals(i.transform, S.IDENTITY)) {
        if (l(n.angleAndHeight) && (n = n.angleAndHeight), R.equals(t, e._tiltCenterMousePosition) || (e._tiltOnEllipsoid = !1, e._looking = !1), e._looking) {
            var a = e._ellipsoid.geodeticSurfaceNormal(i.position, Wd);
            nr(e, t, n, a);
            return
        }
        var o = e._ellipsoid,
            s = o.cartesianToCartographic(i.position, kd);
        e._tiltOnEllipsoid || s.height > e._minimumCollisionTerrainHeight ? (e._tiltOnEllipsoid = !0, BL(e, t, n)) : VL(e, t, n)
    }
}
var zL = new K;

function BL(e, t, n) {
    var r = e._ellipsoid,
        i = e._scene,
        a = i.camera,
        o = e.minimumZoomDistance * .25,
        s = r.cartesianToCartographic(a.positionWC, zL).height;
    if (!(s - o - 1 < T.EPSILON3 && n.endPosition.y - n.startPosition.y < 0)) {
        var c = i.canvas,
            f = BT;
        f.x = c.clientWidth / 2, f.y = c.clientHeight / 2;
        var h = a.getPickRay(f, Ac),
            d, _ = Me.rayEllipsoid(h, r);
        if (l(_)) d = Ke.getPoint(h, _.start, Es);
        else if (s > e._minimumTrackBallHeight) {
            var v = Me.grazingAltitudeLocation(h, r);
            if (!l(v)) return;
            var m = r.cartesianToCartographic(v, kd);
            m.height = 0, d = r.cartographicToCartesian(m, Es)
        } else {
            e._looking = !0;
            var g = e._ellipsoid.geodeticSurfaceNormal(a.position, Wd);
            nr(e, t, n, g), R.clone(t, e._tiltCenterMousePosition);
            return
        }
        var y = xe.eastNorthUpToFixedFrame(d, r, VT),
            E = e._globe,
            w = e._ellipsoid;
        e._globe = void 0, e._ellipsoid = ne.UNIT_SPHERE, e._rotateFactor = 1, e._rotateRateRangeAdjustment = 1;
        var C = S.clone(a.transform, GT);
        a._setTransform(y), tr(e, t, n, u.UNIT_Z), a._setTransform(C), e._globe = E, e._ellipsoid = w;
        var A = w.maximumRadius;
        e._rotateFactor = 1 / A, e._rotateRateRangeAdjustment = A
    }
}

function VL(e, t, n) {
    var r = e._ellipsoid,
        i = e._scene,
        a = i.camera,
        o = e._cameraUnderground,
        s, c, f;
    if (R.equals(t, e._tiltCenterMousePosition)) s = u.clone(e._tiltCenter, Es);
    else {
        if (s = Qi(e, t, Es), !l(s)) {
            if (c = a.getPickRay(t, Ac), f = Me.rayEllipsoid(c, r), !l(f)) {
                var h = r.cartesianToCartographic(a.position, kd);
                if (h.height <= e._minimumTrackBallHeight) {
                    e._looking = !0;
                    var d = e._ellipsoid.geodeticSurfaceNormal(a.position, Wd);
                    nr(e, t, n, d), R.clone(t, e._tiltCenterMousePosition)
                }
                return
            }
            s = Ke.getPoint(c, f.start, Es)
        }
        o && (l(c) || (c = a.getPickRay(t, Ac)), IT(e, c, s, s)), R.clone(t, e._tiltCenterMousePosition), u.clone(s, e._tiltCenter)
    }
    var _ = i.canvas,
        v = BT;
    v.x = _.clientWidth / 2, v.y = e._tiltCenterMousePosition.y, c = a.getPickRay(v, Ac);
    var m = u.magnitude(s),
        g = u.fromElements(m, m, m, Vl),
        y = ne.fromCartesian3(g, Gl);
    if (f = Me.rayEllipsoid(c, y), !!l(f)) {
        var E = u.magnitude(c.origin) > m ? f.start : f.stop,
            w = Ke.getPoint(c, E, NL),
            C = xe.eastNorthUpToFixedFrame(s, r, VT),
            A = xe.eastNorthUpToFixedFrame(w, y, bL),
            x = e._globe,
            P = e._ellipsoid;
        e._globe = void 0, e._ellipsoid = ne.UNIT_SPHERE, e._rotateFactor = 1, e._rotateRateRangeAdjustment = 1;
        var I = u.UNIT_Z,
            D = S.clone(a.transform, GT);
        a._setTransform(C);
        var O = u.cross(w, a.positionWC, Ec),
            F = u.dot(a.rightWC, O);
        if (tr(e, t, n, I, !1, !0), a._setTransform(A), F < 0) {
            var z = n.startPosition.y - n.endPosition.y;
            (o && z < 0 || !o && z > 0) && (I = void 0);
            var b = a.constrainedAxis;
            a.constrainedAxis = void 0, tr(e, t, n, I, !0, !1), a.constrainedAxis = b
        } else tr(e, t, n, I, !0, !1);
        if (l(a.constrainedAxis)) {
            var M = u.cross(a.direction, a.constrainedAxis, Ec);
            u.equalsEpsilon(M, u.ZERO, T.EPSILON6) || (u.dot(M, a.right) < 0 && u.negate(M, M), u.cross(M, a.direction, a.up), u.cross(a.direction, a.up, a.right), u.normalize(a.up, a.up), u.normalize(a.right, a.right))
        }
        a._setTransform(D), e._globe = x, e._ellipsoid = P;
        var G = P.maximumRadius;
        e._rotateFactor = 1 / G, e._rotateRateRangeAdjustment = G;
        var V = u.clone(a.positionWC, Ec);
        if (e.enableCollisionDetection && qd(e), !u.equals(a.positionWC, V)) {
            a._setTransform(A), a.worldToCameraCoordinatesPoint(V, V);
            var B = u.magnitudeSquared(V);
            u.magnitudeSquared(a.position) > B && (u.normalize(a.position, a.position), u.multiplyByScalar(a.position, Math.sqrt(B), a.position));
            var Y = u.angleBetween(V, a.position),
                j = u.cross(V, a.position, V);
            u.normalize(j, j);
            var Z = X.fromAxisAngle(j, Y, FL),
                Q = N.fromQuaternion(Z, LL);
            N.multiplyByVector(Q, a.direction, a.direction), N.multiplyByVector(Q, a.up, a.up), u.cross(a.direction, a.up, a.right), u.cross(a.right, a.direction, a.up), a._setTransform(D)
        }
    }
}
var GL = new R,
    HL = new R,
    op = new Ke,
    sp = new Ke,
    kL = new u,
    WL = new u;

function nr(e, t, n, r) {
    var i = e._scene,
        a = i.camera,
        o = GL;
    o.x = n.startPosition.x, o.y = 0;
    var s = HL;
    s.x = n.endPosition.x, s.y = 0;
    var c = a.getPickRay(o, op),
        f = a.getPickRay(s, sp),
        h = 0,
        d, _;
    a.frustum instanceof lt ? (d = c.origin, _ = f.origin, u.add(a.direction, d, d), u.add(a.direction, _, _), u.subtract(d, a.position, d), u.subtract(_, a.position, _), u.normalize(d, d), u.normalize(_, _)) : (d = c.direction, _ = f.direction);
    var v = u.dot(d, _);
    v < 1 && (h = Math.acos(v)), h = n.startPosition.x > n.endPosition.x ? -h : h;
    var m = e._horizontalRotationAxis;
    if (l(r) ? a.look(r, -h) : l(m) ? a.look(m, -h) : a.lookLeft(h), o.x = 0, o.y = n.startPosition.y, s.x = 0, s.y = n.endPosition.y, c = a.getPickRay(o, op), f = a.getPickRay(s, sp), h = 0, a.frustum instanceof lt ? (d = c.origin, _ = f.origin, u.add(a.direction, d, d), u.add(a.direction, _, _), u.subtract(d, a.position, d), u.subtract(_, a.position, _), u.normalize(d, d), u.normalize(_, _)) : (d = c.direction, _ = f.direction), v = u.dot(d, _), v < 1 && (h = Math.acos(v)), h = n.startPosition.y > n.endPosition.y ? -h : h, r = p(r, m), l(r)) {
        var g = a.direction,
            y = u.negate(r, kL),
            E = u.equalsEpsilon(g, r, T.EPSILON2),
            w = u.equalsEpsilon(g, y, T.EPSILON2);
        if (!E && !w) {
            v = u.dot(g, r);
            var C = T.acosClamped(v);
            h > 0 && h > C && (h = C - T.EPSILON4), v = u.dot(g, y), C = T.acosClamped(v), h < 0 && -h > C && (h = -C + T.EPSILON4);
            var A = u.cross(r, g, WL);
            a.look(A, h)
        } else(E && h < 0 || w && h > 0) && a.look(a.right, -h)
    } else a.lookUp(h)
}

function qL(e) {
    In(e, e.enableRotate, e.rotateEventTypes, wL, e.inertiaSpin, "_lastInertiaSpinMovement"), In(e, e.enableZoom, e.zoomEventTypes, zT, e.inertiaZoom, "_lastInertiaZoomMovement"), In(e, e.enableTilt, e.tiltEventTypes, UL, e.inertiaSpin, "_lastInertiaTiltMovement"), In(e, e.enableLook, e.lookEventTypes, nr)
}
var YL = new S,
    XL = new K;

function qd(e) {
    e._adjustedHeightForTerrain = !0;
    var t = e._scene,
        n = t.mode,
        r = t.globe;
    if (!(!l(r) || n === k.SCENE2D || n === k.MORPHING)) {
        var i = t.camera,
            a = r.ellipsoid,
            o = t.mapProjection,
            s, c;
        S.equals(i.transform, S.IDENTITY) || (s = S.clone(i.transform, YL), c = u.magnitude(i.position), i._setTransform(S.IDENTITY));
        var f = XL;
        n === k.SCENE3D ? a.cartesianToCartographic(i.position, f) : o.unproject(i.position, f);
        var h = !1;
        if (f.height < e._minimumCollisionTerrainHeight) {
            var d = e._scene.globeHeight;
            if (l(d)) {
                var _ = d + e.minimumZoomDistance;
                f.height < _ && (f.height = _, n === k.SCENE3D ? a.cartographicToCartesian(f, i.position) : o.project(f, i.position), h = !0)
            }
        }
        l(s) && (i._setTransform(s), h && (u.normalize(i.position, i.position), u.negate(i.position, i.direction), u.multiplyByScalar(i.position, Math.max(c, e.minimumZoomDistance), i.position), u.normalize(i.direction, i.direction), u.cross(i.direction, i.up, i.right), u.cross(i.right, i.direction, i.up)))
    }
}
ks.prototype.onMap = function() {
    var e = this._scene,
        t = e.mode,
        n = e.camera;
    return t === k.COLUMBUS_VIEW ? Math.abs(n.position.x) - this._maxCoord.x < 0 && Math.abs(n.position.y) - this._maxCoord.y < 0 : !0
};
var jL = new u,
    ZL = new u;
ks.prototype.update = function() {
    var e = this._scene,
        t = e.camera,
        n = e.globe,
        r = e.mode;
    S.equals(t.transform, S.IDENTITY) ? (this._globe = n, this._ellipsoid = l(this._globe) ? this._globe.ellipsoid : e.mapProjection.ellipsoid) : (this._globe = void 0, this._ellipsoid = ne.UNIT_SPHERE), this._cameraUnderground = e.cameraUnderground && l(this._globe), this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight * e.terrainExaggeration, this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight * e.terrainExaggeration, this._minimumTrackBallHeight = this.minimumTrackBallHeight * e.terrainExaggeration;
    var i = this._ellipsoid.maximumRadius;
    this._rotateFactor = 1 / i, this._rotateRateRangeAdjustment = i, this._adjustedHeightForTerrain = !1;
    var a = u.clone(t.positionWC, jL),
        o = u.clone(t.directionWC, ZL);
    if (r === k.SCENE2D ? qF(this) : r === k.COLUMBUS_VIEW ? (this._horizontalRotationAxis = u.UNIT_Z, vL(this)) : r === k.SCENE3D && (this._horizontalRotationAxis = void 0, qL(this)), this.enableCollisionDetection && !this._adjustedHeightForTerrain) {
        var s = !u.equals(a, t.positionWC) || !u.equals(o, t.directionWC);
        s && qd(this)
    }
    this._aggregator.reset()
};
ks.prototype.isDestroyed = function() {
    return !1
};
ks.prototype.destroy = function() {
    return this._tweens.removeAll(), this._aggregator = this._aggregator && this._aggregator.destroy(), Pe(this)
};

function KL(e, t) {
    this.near = p(e, 0), this.far = p(t, 0);
    for (var n = ue.NUMBER_OF_PASSES, r = new Array(n), i = new Array(n), a = 0; a < n; ++a) r[a] = [], i[a] = 0;
    this.commands = r, this.indices = i
}
var Ea = {
    RGBA4: L.RGBA4,
    RGB5_A1: L.RGB5_A1,
    RGB565: L.RGB565,
    DEPTH_COMPONENT16: L.DEPTH_COMPONENT16,
    STENCIL_INDEX8: L.STENCIL_INDEX8,
    DEPTH_STENCIL: L.DEPTH_STENCIL,
    validate: function(e) {
        return e === Ea.RGBA4 || e === Ea.RGB5_A1 || e === Ea.RGB565 || e === Ea.DEPTH_COMPONENT16 || e === Ea.STENCIL_INDEX8 || e === Ea.DEPTH_STENCIL
    }
};
const Os = Object.freeze(Ea);

function ea(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.context,
        n = t._gl;
    pe.maximumRenderbufferSize;
    var r = p(e.format, Os.RGBA4),
        i = l(e.width) ? e.width : n.drawingBufferWidth,
        a = l(e.height) ? e.height : n.drawingBufferHeight;
    this._gl = n, this._format = r, this._width = i, this._height = a, this._renderbuffer = this._gl.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, this._renderbuffer), n.renderbufferStorage(n.RENDERBUFFER, r, i, a), n.bindRenderbuffer(n.RENDERBUFFER, null)
}
Object.defineProperties(ea.prototype, {
    format: {
        get: function() {
            return this._format
        }
    },
    width: {
        get: function() {
            return this._width
        }
    },
    height: {
        get: function() {
            return this._height
        }
    }
});
ea.prototype._getRenderbuffer = function() {
    return this._renderbuffer
};
ea.prototype.isDestroyed = function() {
    return !1
};
ea.prototype.destroy = function() {
    return this._gl.deleteRenderbuffer(this._renderbuffer), Pe(this)
};

function ka() {
    this._colorTexture = void 0, this._depthStencilTexture = void 0, this._depthStencilRenderbuffer = void 0, this._framebuffer = void 0, this._packedDepthTexture = void 0, this._packedDepthFramebuffer = void 0, this._renderState = void 0, this._packedDepthCommand = void 0, this._clearCommand = void 0, this._viewport = new ge, this._useScissorTest = !1, this._scissorRectangle = void 0, this._useHdr = void 0
}
Object.defineProperties(ka.prototype, {
    classificationTexture: {
        get: function() {
            return this._colorTexture
        }
    },
    classificationFramebuffer: {
        get: function() {
            return this._framebuffer
        }
    }
});

function HT(e) {
    e._colorTexture = e._colorTexture && !e._colorTexture.isDestroyed() && e._colorTexture.destroy(), e._depthStencilTexture = e._depthStencilTexture && !e._depthStencilTexture.isDestroyed() && e._depthStencilTexture.destroy(), e._depthStencilRenderbuffer = e._depthStencilRenderbuffer && !e._depthStencilRenderbuffer.isDestroyed() && e._depthStencilRenderbuffer.destroy(), e._framebuffer = e._framebuffer && !e._framebuffer.isDestroyed() && e._framebuffer.destroy(), e._packedDepthTexture = e._packedDepthTexture && !e._packedDepthTexture.isDestroyed() && e._packedDepthTexture.destroy(), e._packedDepthFramebuffer = e._packedDepthFramebuffer && !e._packedDepthFramebuffer.isDestroyed() && e._packedDepthFramebuffer.destroy()
}

function $L(e, t, n, r, i) {
    var a = i ? t.halfFloatingPointTexture ? ae.HALF_FLOAT : ae.FLOAT : ae.UNSIGNED_BYTE;
    e._colorTexture = new be({
        context: t,
        width: n,
        height: r,
        pixelFormat: de.RGBA,
        pixelDatatype: a,
        sampler: gt.NEAREST
    }), t.depthTexture ? e._depthStencilTexture = new be({
        context: t,
        width: n,
        height: r,
        pixelFormat: de.DEPTH_STENCIL,
        pixelDatatype: ae.UNSIGNED_INT_24_8
    }) : e._depthStencilRenderbuffer = new ea({
        context: t,
        width: n,
        height: r,
        format: Os.DEPTH_STENCIL
    }), e._framebuffer = new xt({
        context: t,
        colorTextures: [e._colorTexture],
        depthStencilTexture: e._depthStencilTexture,
        depthStencilRenderbuffer: e._depthStencilRenderbuffer,
        destroyAttachments: !1
    }), e._packedDepthTexture = new be({
        context: t,
        width: n,
        height: r,
        pixelFormat: de.RGBA,
        pixelDatatype: ae.UNSIGNED_BYTE,
        sampler: gt.NEAREST
    }), e._packedDepthFramebuffer = new xt({
        context: t,
        colorTextures: [e._packedDepthTexture],
        destroyAttachments: !1
    })
}

function JL(e, t, n, r, i) {
    var a = e._colorTexture,
        o = !l(a) || a.width !== n || a.height !== r || i !== e._useHdr;
    o && (HT(e), $L(e, t, n, r, i))
}

function QL(e, t, n, r, i) {
    e._viewport.width = n, e._viewport.height = r;
    var a = !ge.equals(e._viewport, i.viewport),
        o = a !== e._useScissorTest;
    e._useScissorTest = a, ge.equals(e._scissorRectangle, i.viewport) || (e._scissorRectangle = ge.clone(i.viewport, e._scissorRectangle), o = !0), (!l(e._renderState) || !ge.equals(e._viewport, e._renderState.viewport) || o) && (e._renderState = Ge.fromCache({
        viewport: e._viewport,
        scissorTest: {
            enabled: e._useScissorTest,
            rectangle: e._scissorRectangle
        }
    })), l(e._packedDepthCommand) || (e._packedDepthCommand = t.createViewportQuadCommand(Ul, {
        uniformMap: {
            u_depthTexture: function() {
                return e._depthStencilTexture
            }
        },
        owner: e
    })), l(e._clearCommand) || (e._clearCommand = new on({
        color: new H(0, 0, 0, 0),
        depth: 1,
        stencil: 0,
        owner: e
    })), e._packedDepthCommand.framebuffer = e._packedDepthFramebuffer, e._packedDepthCommand.renderState = e._renderState, e._clearCommand.framebuffer = e._framebuffer, e._clearCommand.renderState = e._renderState
}
ka.prototype.updateAndClear = function(e, t, n, r) {
    var i = t.width,
        a = t.height;
    JL(this, n, i, a, e), QL(this, n, i, a, r), this._useHdr = e
};
ka.prototype.clearClassification = function(e, t) {
    this._clearCommand.execute(e, t)
};
ka.prototype.packDepth = function(e, t) {
    return this._packedDepthCommand.execute(e, t), this._packedDepthTexture
};
ka.prototype.isDestroyed = function() {
    return !1
};
ka.prototype.destroy = function() {
    return HT(this), Pe(this)
};

function uf() {
    this._depthStencilTexture = void 0, this._framebuffer = void 0, this._passState = void 0
}

function kT(e) {
    e._framebuffer = e._framebuffer && e._framebuffer.destroy(), e._depthStencilTexture = e._depthStencilTexture && e._depthStencilTexture.destroy()
}

function eU(e, t) {
    var n = t.drawingBufferWidth,
        r = t.drawingBufferHeight;
    e._depthStencilTexture = new be({
        context: t,
        width: n,
        height: r,
        pixelFormat: de.DEPTH_STENCIL,
        pixelDatatype: ae.UNSIGNED_INT_24_8
    }), e._framebuffer = new xt({
        context: t,
        depthStencilTexture: e._depthStencilTexture,
        destroyAttachments: !1
    });
    var i = new rf(t);
    i.blendingEnabled = !1, i.scissorTest = {
        enabled: !0,
        rectangle: new ge
    }, i.viewport = new ge, e._passState = i
}
uf.prototype.update = function(e, t, n) {
    var r = n.width,
        i = n.height;
    (!l(this._framebuffer) || r !== this._depthStencilTexture.width || i !== this._depthStencilTexture.height) && (kT(this), eU(this, e));
    var a = this._framebuffer,
        o = this._passState;
    return o.framebuffer = a, o.viewport.width = r, o.viewport.height = i, o.scissorTest.rectangle.x = t.x, o.scissorTest.rectangle.y = i - t.y, o.scissorTest.rectangle.width = 1, o.scissorTest.rectangle.height = 1, o
};
uf.prototype.isDestroyed = function() {
    return !1
};
uf.prototype.destroy = function() {
    return kT(this), Pe(this)
};

function Ws(e) {
    var t = new rf(e);
    t.blendingEnabled = !1, t.scissorTest = {
        enabled: !0,
        rectangle: new ge
    }, t.viewport = new ge, this._context = e, this._fb = void 0, this._passState = t, this._width = 0, this._height = 0
}
Ws.prototype.begin = function(e, t) {
    var n = this._context,
        r = t.width,
        i = t.height;
    return ge.clone(e, this._passState.scissorTest.rectangle), (!l(this._fb) || this._width !== r || this._height !== i) && (this._width = r, this._height = i, this._fb = this._fb && this._fb.destroy(), this._fb = new xt({
        context: n,
        colorTextures: [new be({
            context: n,
            width: r,
            height: i
        })],
        depthStencilRenderbuffer: new ea({
            context: n,
            width: r,
            height: i,
            format: Os.DEPTH_STENCIL
        })
    }), this._passState.framebuffer = this._fb), this._passState.viewport.width = r, this._passState.viewport.height = i, this._passState
};
var cs = new H;
Ws.prototype.end = function(e) {
    for (var t = p(e.width, 1), n = p(e.height, 1), r = this._context, i = r.readPixels({
            x: e.x,
            y: e.y,
            width: t,
            height: n,
            framebuffer: this._fb
        }), a = Math.max(t, n), o = a * a, s = Math.floor(t * .5), c = Math.floor(n * .5), f = 0, h = 0, d = 0, _ = -1, v = 0; v < o; ++v) {
        if (-s <= f && f <= s && -c <= h && h <= c) {
            var m = 4 * ((c - h) * t + f + s);
            cs.red = H.byteToFloat(i[m]), cs.green = H.byteToFloat(i[m + 1]), cs.blue = H.byteToFloat(i[m + 2]), cs.alpha = H.byteToFloat(i[m + 3]);
            var g = r.getObjectByPickColor(cs);
            if (l(g)) return g
        }
        if (f === h || f < 0 && -f === h || f > 0 && f === 1 - h) {
            var y = d;
            d = -_, _ = y
        }
        f += d, h += _
    }
};
Ws.prototype.isDestroyed = function() {
    return !1
};
Ws.prototype.destroy = function() {
    return this._fb = this._fb && this._fb.destroy(), Pe(this)
};

function Wa() {
    this._colorTexture = void 0, this._idTexture = void 0, this._depthStencilTexture = void 0, this._depthStencilRenderbuffer = void 0, this._framebuffer = void 0, this._idFramebuffer = void 0, this._idClearColor = new H(0, 0, 0, 0), this._useHdr = void 0, this._clearCommand = new on({
        color: new H(0, 0, 0, 0),
        depth: 1,
        owner: this
    })
}

function WT(e) {
    e._framebuffer = e._framebuffer && e._framebuffer.destroy(), e._idFramebuffer = e._idFramebuffer && e._idFramebuffer.destroy(), e._colorTexture = e._colorTexture && e._colorTexture.destroy(), e._idTexture = e._idTexture && e._idTexture.destroy(), e._depthStencilTexture = e._depthStencilTexture && e._depthStencilTexture.destroy(), e._depthStencilRenderbuffer = e._depthStencilRenderbuffer && e._depthStencilRenderbuffer.destroy(), e._depthStencilIdTexture = e._depthStencilIdTexture && e._depthStencilIdTexture.destroy(), e._depthStencilIdRenderbuffer = e._depthStencilIdRenderbuffer && e._depthStencilIdRenderbuffer.destroy(), e._framebuffer = void 0, e._idFramebuffer = void 0, e._colorTexture = void 0, e._idTexture = void 0, e._depthStencilTexture = void 0, e._depthStencilRenderbuffer = void 0, e._depthStencilIdTexture = void 0, e._depthStencilIdRenderbuffer = void 0
}
Wa.prototype.update = function(e, t, n) {
    var r = t.width,
        i = t.height,
        a = this._colorTexture;
    if (!(l(a) && a.width === r && a.height === i && n === this._useHdr)) {
        WT(this), this._useHdr = n;
        var o = n ? e.halfFloatingPointTexture ? ae.HALF_FLOAT : ae.FLOAT : ae.UNSIGNED_BYTE;
        this._colorTexture = new be({
            context: e,
            width: r,
            height: i,
            pixelFormat: de.RGBA,
            pixelDatatype: o,
            sampler: gt.NEAREST
        }), this._idTexture = new be({
            context: e,
            width: r,
            height: i,
            pixelFormat: de.RGBA,
            pixelDatatype: ae.UNSIGNED_BYTE,
            sampler: gt.NEAREST
        }), e.depthTexture ? (this._depthStencilTexture = new be({
            context: e,
            width: r,
            height: i,
            pixelFormat: de.DEPTH_STENCIL,
            pixelDatatype: ae.UNSIGNED_INT_24_8,
            sampler: gt.NEAREST
        }), this._depthStencilIdTexture = new be({
            context: e,
            width: r,
            height: i,
            pixelFormat: de.DEPTH_STENCIL,
            pixelDatatype: ae.UNSIGNED_INT_24_8,
            sampler: gt.NEAREST
        })) : (this._depthStencilRenderbuffer = new ea({
            context: e,
            width: r,
            height: i,
            format: Os.DEPTH_STENCIL
        }), this._depthStencilIdRenderbuffer = new ea({
            context: e,
            width: r,
            height: i,
            format: Os.DEPTH_STENCIL
        })), this._framebuffer = new xt({
            context: e,
            colorTextures: [this._colorTexture],
            depthStencilTexture: this._depthStencilTexture,
            depthStencilRenderbuffer: this._depthStencilRenderbuffer,
            destroyAttachments: !1
        }), this._idFramebuffer = new xt({
            context: e,
            colorTextures: [this._idTexture],
            depthStencilTexture: this._depthStencilIdTexture,
            depthStencilRenderbuffer: this._depthStencilIdRenderbuffer,
            destroyAttachments: !1
        })
    }
};
Wa.prototype.clear = function(e, t, n) {
    var r = t.framebuffer;
    t.framebuffer = this._framebuffer, H.clone(n, this._clearCommand.color), this._clearCommand.execute(e, t), t.framebuffer = this._idFramebuffer, H.clone(this._idClearColor, this._clearCommand.color), this._clearCommand.execute(e, t), t.framebuffer = r
};
Wa.prototype.getFramebuffer = function() {
    return this._framebuffer
};
Wa.prototype.getIdFramebuffer = function() {
    return this._idFramebuffer
};
Wa.prototype.isDestroyed = function() {
    return !1
};
Wa.prototype.destroy = function() {
    return WT(this), Pe(this)
};

function tU() {
    this.command = void 0, this.near = void 0, this.far = void 0
}

function cf(e, t, n) {
    var r = e.context,
        i;
    r.depthTexture && (i = new xr);
    var a = new rf(r);
    a.viewport = ge.clone(n), this.camera = t, this._cameraClone = se.clone(t), this._cameraStartFired = !1, this._cameraMovedTime = void 0, this.viewport = n, this.passState = a, this.pickFramebuffer = new Ws(r), this.pickDepthFramebuffer = new uf, this.sceneFramebuffer = new Wa, this.globeDepth = i, this.globeTranslucencyFramebuffer = new ka, this.pickDepths = [], this.debugGlobeDepths = [], this.frustumCommandsList = [], this.debugFrustumStatistics = void 0, this._commandExtents = []
}
var up = new u,
    cp = new u;

function nU(e, t) {
    var n = Math.max(Math.abs(e.x), Math.abs(t.x)),
        r = Math.max(Math.abs(e.y), Math.abs(t.y)),
        i = Math.max(Math.abs(e.z), Math.abs(t.z));
    return Math.max(Math.max(n, r), i)
}

function rU(e, t, n) {
    var r = 1 / Math.max(1, nU(e.position, t.position));
    return u.multiplyByScalar(e.position, r, up), u.multiplyByScalar(t.position, r, cp), u.equalsEpsilon(up, cp, n) && u.equalsEpsilon(e.direction, t.direction, n) && u.equalsEpsilon(e.up, t.up, n) && u.equalsEpsilon(e.right, t.right, n) && S.equalsEpsilon(e.transform, t.transform, n) && e.frustum.equalsEpsilon(t.frustum, n)
}
cf.prototype.checkForCameraUpdates = function(e) {
    var t = this.camera,
        n = this._cameraClone;
    return rU(t, n, T.EPSILON15) ? (this._cameraStartFired && bn() - this._cameraMovedTime > e.cameraEventWaitTime && (t.moveEnd.raiseEvent(), this._cameraStartFired = !1), !1) : (this._cameraStartFired || (t.moveStart.raiseEvent(), this._cameraStartFired = !0), this._cameraMovedTime = bn(), se.clone(t, n), !0)
};

function iU(e, t, n, r) {
    var i = t.frameState,
        a = i.camera,
        o = i.useLogDepth ? t.logarithmicDepthFarToNearRatio : t.farToNearRatio,
        s = t.mode === k.SCENE2D,
        c = t.nearToFarDistance2D;
    r *= 1 + T.EPSILON2, n = Math.min(Math.max(n, a.frustum.near), a.frustum.far), r = Math.max(Math.min(r, a.frustum.far), n);
    var f;
    s ? (r = Math.min(r, a.position.z + t.nearToFarDistance2D), n = Math.min(n, r), f = Math.ceil(Math.max(1, r - n) / t.nearToFarDistance2D)) : f = Math.ceil(Math.log(r / n) / Math.log(o));
    var h = e.frustumCommandsList;
    h.length = f;
    for (var d = 0; d < f; ++d) {
        var _, v;
        s ? (_ = Math.min(r - c, n + d * c), v = Math.min(r, _ + c)) : (_ = Math.max(n, Math.pow(o, d) * n), v = Math.min(r, o * _));
        var m = h[d];
        l(m) ? (m.near = _, m.far = v) : m = h[d] = new KL(_, v)
    }
}

function aU(e, t, n, r, i) {
    t.debugShowFrustums && (n.debugOverlappingFrustums = 0);
    for (var a = e.frustumCommandsList, o = a.length, s = 0; s < o; ++s) {
        var c = a[s],
            f = c.near,
            h = c.far;
        if (!(r > h)) {
            if (i < f) break;
            var d = n.pass,
                _ = c.indices[d]++;
            if (c.commands[d][_] = n, t.debugShowFrustums && (n.debugOverlappingFrustums |= 1 << s), n.executeInClosestFrustum) break
        }
    }
    if (t.debugShowFrustums) {
        var v = e.debugFrustumStatistics.commandsInFrustums;
        v[n.debugOverlappingFrustums] = l(v[n.debugOverlappingFrustums]) ? v[n.debugOverlappingFrustums] + 1 : 1, ++e.debugFrustumStatistics.totalCommands
    }
    t.updateDerivedCommands(n)
}
var fp = new Pn,
    oU = new Yi;
cf.prototype.createPotentiallyVisibleSet = function(e) {
    var t = e.frameState,
        n = t.camera,
        r = n.directionWC,
        i = n.positionWC,
        a = e._computeCommandList,
        o = e._overlayCommandList,
        s = t.commandList;
    e.debugShowFrustums && (this.debugFrustumStatistics = {
        totalCommands: 0,
        commandsInFrustums: {}
    });
    for (var c = this.frustumCommandsList, f = c.length, h = ue.NUMBER_OF_PASSES, d = 0; d < f; ++d)
        for (var _ = 0; _ < h; ++_) c[d].indices[_] = 0;
    a.length = 0, o.length = 0;
    for (var v = this._commandExtents, m = v.length, g = 0, y = +Number.MAX_VALUE, E = -Number.MAX_VALUE, w = t.shadowState.shadowsEnabled, C = +Number.MAX_VALUE, A = -Number.MAX_VALUE, x = Number.MAX_VALUE, P = t.mode === k.SCENE3D ? t.occluder : void 0, I = t.cullingVolume, D = fp.planes, O = 0; O < 5; ++O) D[O] = I.planes[O];
    I = fp;
    for (var F = s.length, z = 0; z < F; ++z) {
        var b = s[z],
            M = b.pass;
        if (M === ue.COMPUTE) a.push(b);
        else if (M === ue.OVERLAY) o.push(b);
        else {
            var G, V, B = b.boundingVolume;
            if (l(B)) {
                if (!e.isVisible(b, I, P)) continue;
                var Y = B.computePlaneDistances(i, r, oU);
                G = Y.start, V = Y.stop, y = Math.min(y, G), E = Math.max(E, V)
            } else b instanceof on ? (G = n.frustum.near, V = n.frustum.far) : (G = n.frustum.near, V = n.frustum.far, y = Math.min(y, G), E = Math.max(E, V));
            var j = v[g];
            l(j) || (j = v[g] = new tU), j.command = b, j.near = G, j.far = V, g++
        }
    }
    w && (C = Math.min(Math.max(C, n.frustum.near), n.frustum.far), A = Math.max(Math.min(A, n.frustum.far), C)), w && (t.shadowState.nearPlane = C, t.shadowState.farPlane = A, t.shadowState.closestObjectSize = x), iU(this, e, y, E);
    var Z, Q;
    for (Z = 0; Z < g; Z++) Q = v[Z], aU(this, e, Q.command, Q.near, Q.far);
    if (g < m)
        for (Z = g; Z < m && (Q = v[Z], !!l(Q.command)); Z++) Q.command = void 0;
    var ie = c.length,
        Ae = t.frustumSplits;
    Ae.length = ie + 1;
    for (var re = 0; re < ie; ++re) Ae[re] = c[re].near, re === ie - 1 && (Ae[re + 1] = c[re].far)
};
cf.prototype.destroy = function() {
    this.pickFramebuffer = this.pickFramebuffer && this.pickFramebuffer.destroy(), this.pickDepthFramebuffer = this.pickDepthFramebuffer && this.pickDepthFramebuffer.destroy(), this.sceneFramebuffer = this.sceneFramebuffer && this.sceneFramebuffer.destroy(), this.globeDepth = this.globeDepth && this.globeDepth.destroy(), this.globeTranslucencyFramebuffer = this.globeTranslucencyFramebuffer && this.globeTranslucencyFramebuffer.destroy();
    var e, t, n = this.pickDepths,
        r = this.debugGlobeDepths;
    for (t = n.length, e = 0; e < t; ++e) n[e].destroy();
    for (t = r.length, e = 0; e < t; ++e) r[e].destroy()
};
var Hc = function(e) {
    return function() {
        e.frameState.afterRender.push(function() {
            e.requestRender()
        })
    }
};

function dt(e) {
    e = p(e, p.EMPTY_OBJECT);
    var t = e.canvas,
        n = e.creditContainer,
        r = e.creditViewport,
        i = sn(e.contextOptions);
    l(i) || (i = {}), l(i.webgl) || (i.webgl = {}), i.webgl.powerPreference = p(i.webgl.powerPreference, "high-performance");
    var a = l(n),
        o = new wr(t, i);
    a || (n = document.createElement("div"), n.style.position = "absolute", n.style.bottom = "0", n.style["text-shadow"] = "0 0 2px #000000", n.style.color = "#ffffff", n.style["font-size"] = "10px", n.style["padding-right"] = "5px", t.parentNode.appendChild(n)), l(r) || (r = t.parentNode), this._id = Oi(), this._jobScheduler = new ji, this._frameState = new v3(o, new Wr, this._jobScheduler), this._frameState.scene3DOnly = p(e.scene3DOnly, !1), this._removeCreditContainer = !a, this._creditContainer = n, this._canvas = t, this._context = o, this._computeEngine = new nf(o), this._globe = void 0, this._globeTranslucencyState = new Ha, this._primitives = new jt, this._groundPrimitives = new jt, this._globeHeight = void 0, this._cameraUnderground = !1, this._logDepthBuffer = o.fragmentDepth, this._logDepthBufferDirty = !0, this._tweens = new Sr, this._shaderFrameCount = 0, this._computeCommandList = [], this._overlayCommandList = [], this._useOIT = p(e.orderIndependentTranslucency, !0), this._executeOITFunction = void 0, this._depthPlane = new Hs, this._clearColorCommand = new on({
        color: new H,
        stencil: 0,
        owner: this
    }), this._depthClearCommand = new on({
        depth: 1,
        owner: this
    }), this._stencilClearCommand = new on({
        stencil: 0
    }), this._classificationStencilClearCommand = new on({
        stencil: 0,
        renderState: Ge.fromCache({
            stencilMask: Fa.CLASSIFICATION_MASK
        })
    }), this._depthOnlyRenderStateCache = {}, this._preUpdate = new ht, this._postUpdate = new ht, this._renderError = new ht, this._preRender = new ht, this._postRender = new ht, this._minimumDisableDepthTestDistance = 0, this.rethrowRenderErrors = !1, this.completeMorphOnUserInput = !0, this.morphStart = new ht, this.morphComplete = new ht, this.skyBox = void 0, this.skyAtmosphere = void 0, this.sun = void 0, this.sunBloom = !0, this._sunBloom = void 0, this.moon = void 0, this.backgroundColor = H.clone(H.BLACK), this._mode = k.SCENE3D, this._mapProjection = l(e.mapProjection) ? e.mapProjection : new un, this.morphTime = 1, this.farToNearRatio = 1e3, this.logarithmicDepthFarToNearRatio = 1e9, this.nearToFarDistance2D = 175e4, this.debugCommandFilter = void 0, this.debugShowCommands = !1, this.debugShowFrustums = !1, this.debugShowFramesPerSecond = !1, this.debugShowGlobeDepth = !1, this.debugShowDepthFrustum = 1, this.debugShowFrustumPlanes = !1, this._debugShowFrustumPlanes = !1, this._debugFrustumPlanes = void 0, this.pickTranslucentDepth = !1, this.cameraEventWaitTime = 500, this.fog = new dT, this._shadowMapCamera = new se(this), this.invertClassification = !1, this.invertClassificationColor = H.clone(H.WHITE), this._actualInvertClassificationColor = H.clone(this._invertClassificationColor), this._invertClassification = new li, this._brdfLutGenerator = new Bs, this._terrainExaggeration = p(e.terrainExaggeration, 1), this._performanceDisplay = void 0, this._debugVolume = void 0, this._screenSpaceCameraController = new ks(this), this._cameraUnderground = !1, this._environmentState = {
        skyBoxCommand: void 0,
        skyAtmosphereCommand: void 0,
        sunDrawCommand: void 0,
        sunComputeCommand: void 0,
        moonCommand: void 0,
        isSunVisible: !1,
        isMoonVisible: !1,
        isReadyForAtmosphere: !1,
        isSkyAtmosphereVisible: !1,
        clearGlobeDepth: !1,
        useDepthPlane: !1,
        originalFramebuffer: void 0,
        useGlobeDepthFramebuffer: !1,
        separatePrimitiveFramebuffer: !1,
        useOIT: !1,
        useInvertClassification: !1,
        usePostProcess: !1,
        usePostProcessSelected: !1
    }, this.requestRenderMode = p(e.requestRenderMode, !1), this._renderRequested = !0, this.maximumRenderTimeChange = p(e.maximumRenderTimeChange, 0), this._lastRenderTime = void 0, this._frameRateMonitor = void 0, this._removeRequestListenerCallback = Et.requestCompletedEvent.addEventListener(Hc(this)), this._removeTaskProcessorListenerCallback = Lt.taskCompletedEvent.addEventListener(Hc(this)), this._removeGlobeCallbacks = [];
    var s = new ge(0, 0, o.drawingBufferWidth, o.drawingBufferHeight),
        c = new se(this);
    this._logDepthBuffer && (c.frustum.near = .1, c.frustum.far = 1e10), this.preloadFlightCamera = new se(this), this.preloadFlightCullingVolume = void 0, this._picking = {
        pickPositionWorldCoordinates: function() {}
    }, this._defaultView = new cf(this, c, s), this._view = this._defaultView, this._hdr = void 0, this._hdrDirty = void 0, this.highDynamicRange = !1, this.gamma = 2.2, this.sphericalHarmonicCoefficients = void 0, this.specularEnvironmentMaps = void 0, this._specularEnvironmentMapAtlas = void 0, qT(this, 0, $.now()), this.updateFrameState(), this.initializeFrame()
}

function sU(e, t) {
    for (var n = 0; n < e._removeGlobeCallbacks.length; ++n) e._removeGlobeCallbacks[n]();
    e._removeGlobeCallbacks.length = 0;
    var r = [];
    l(t) && (r.push(t.imageryLayersUpdatedEvent.addEventListener(Hc(e))), r.push(t.terrainProviderChanged.addEventListener(Hc(e)))), e._removeGlobeCallbacks = r
}
Object.defineProperties(dt.prototype, {
    canvas: {
        get: function() {
            return this._canvas
        }
    },
    drawingBufferHeight: {
        get: function() {
            return this._context.drawingBufferHeight
        }
    },
    drawingBufferWidth: {
        get: function() {
            return this._context.drawingBufferWidth
        }
    },
    maximumAliasedLineWidth: {
        get: function() {
            return pe.maximumAliasedLineWidth
        }
    },
    maximumCubeMapSize: {
        get: function() {
            return pe.maximumCubeMapSize
        }
    },
    pickPositionSupported: {
        get: function() {
            return this._context.depthTexture
        }
    },
    sampleHeightSupported: {
        get: function() {
            return this._context.depthTexture
        }
    },
    clampToHeightSupported: {
        get: function() {
            return this._context.depthTexture
        }
    },
    invertClassificationSupported: {
        get: function() {
            return this._context.depthTexture
        }
    },
    specularEnvironmentMapsSupported: {
        get: function() {
            return Ji.isSupported(this._context)
        }
    },
    globe: {
        get: function() {
            return this._globe
        },
        set: function(e) {
            this._globe = this._globe && this._globe.destroy(), this._globe = e, sU(this, e)
        }
    },
    primitives: {
        get: function() {
            return this._primitives
        }
    },
    groundPrimitives: {
        get: function() {
            return this._groundPrimitives
        }
    },
    camera: {
        get: function() {
            return this._view.camera
        },
        set: function(e) {
            this._view.camera = e
        }
    },
    view: {
        get: function() {
            return this._view
        },
        set: function(e) {
            this._view = e
        }
    },
    defaultView: {
        get: function() {
            return this._defaultView
        }
    },
    screenSpaceCameraController: {
        get: function() {
            return this._screenSpaceCameraController
        }
    },
    mapProjection: {
        get: function() {
            return this._mapProjection
        }
    },
    jobScheduler: {
        get: function() {
            return this._jobScheduler
        }
    },
    frameState: {
        get: function() {
            return this._frameState
        }
    },
    environmentState: {
        get: function() {
            return this._environmentState
        }
    },
    tweens: {
        get: function() {
            return this._tweens
        }
    },
    imageryLayers: {
        get: function() {
            if (!!l(this.globe)) return this.globe.imageryLayers
        }
    },
    terrainProvider: {
        get: function() {
            if (!!l(this.globe)) return this.globe.terrainProvider
        },
        set: function(e) {
            l(this.globe) && (this.globe.terrainProvider = e)
        }
    },
    terrainProviderChanged: {
        get: function() {
            if (!!l(this.globe)) return this.globe.terrainProviderChanged
        }
    },
    preUpdate: {
        get: function() {
            return this._preUpdate
        }
    },
    postUpdate: {
        get: function() {
            return this._postUpdate
        }
    },
    renderError: {
        get: function() {
            return this._renderError
        }
    },
    preRender: {
        get: function() {
            return this._preRender
        }
    },
    postRender: {
        get: function() {
            return this._postRender
        }
    },
    lastRenderTime: {
        get: function() {
            return this._lastRenderTime
        }
    },
    context: {
        get: function() {
            return this._context
        }
    },
    debugFrustumStatistics: {
        get: function() {
            return this._view.debugFrustumStatistics
        }
    },
    scene3DOnly: {
        get: function() {
            return this._frameState.scene3DOnly
        }
    },
    orderIndependentTranslucency: {
        get: function() {
            return this._useOIT
        }
    },
    id: {
        get: function() {
            return this._id
        }
    },
    mode: {
        get: function() {
            return this._mode
        },
        set: function(e) {
            e === k.SCENE2D ? this.morphTo2D(0) : e === k.SCENE3D ? this.morphTo3D(0) : e === k.COLUMBUS_VIEW && this.morphToColumbusView(0), this._mode = e
        }
    },
    frustumCommandsList: {
        get: function() {
            return this._view.frustumCommandsList
        }
    },
    numberOfFrustums: {
        get: function() {
            return this._view.frustumCommandsList.length
        }
    },
    terrainExaggeration: {
        get: function() {
            return this._terrainExaggeration
        }
    },
    imagerySplitPosition: {
        get: function() {
            return this._frameState.imagerySplitPosition
        },
        set: function(e) {
            this._frameState.imagerySplitPosition = e
        }
    },
    minimumDisableDepthTestDistance: {
        get: function() {
            return this._minimumDisableDepthTestDistance
        },
        set: function(e) {
            this._minimumDisableDepthTestDistance = e
        }
    },
    logarithmicDepthBuffer: {
        get: function() {
            return this._logDepthBuffer
        },
        set: function(e) {
            e = this._context.fragmentDepth && e, this._logDepthBuffer !== e && (this._logDepthBuffer = e, this._logDepthBufferDirty = !0)
        }
    },
    gamma: {
        get: function() {
            return this._context.uniformState.gamma
        },
        set: function(e) {
            this._context.uniformState.gamma = e
        }
    },
    highDynamicRange: {
        get: function() {
            return this._hdr
        },
        set: function(e) {
            var t = this._context,
                n = e && t.depthTexture && (t.colorBufferFloat || t.colorBufferHalfFloat);
            this._hdrDirty = n !== this._hdr, this._hdr = n
        }
    },
    highDynamicRangeSupported: {
        get: function() {
            var e = this._context;
            return e.depthTexture && (e.colorBufferFloat || e.colorBufferHalfFloat)
        }
    },
    cameraUnderground: {
        get: function() {
            return this._cameraUnderground
        }
    },
    pixelRatio: {
        get: function() {
            return this._frameState.pixelRatio
        },
        set: function(e) {
            this._frameState.pixelRatio = e
        }
    },
    opaqueFrustumNearOffset: {
        get: function() {
            return .9999
        }
    },
    globeHeight: {
        get: function() {
            return this._globeHeight
        }
    }
});
dt.prototype.getCompressedTextureFormatSupported = function(e) {
    var t = this.context;
    return (e === "WEBGL_compressed_texture_s3tc" || e === "s3tc") && t.s3tc || (e === "WEBGL_compressed_texture_pvrtc" || e === "pvrtc") && t.pvrtc || (e === "WEBGL_compressed_texture_etc1" || e === "etc1") && t.etc1
};

function hp(e, t, n) {
    var r = e._context,
        i = e._view.oit,
        a = t.derivedCommands;
    t.pickOnly || (a.depth = ba.createDepthOnlyDerivedCommand(e, t, r, a.depth)), a.originalCommand = t, e._hdr && (a.hdr = ba.createHdrCommand(t, r, a.hdr), t = a.hdr.command, a = t.derivedCommands), t.pass === ue.TRANSLUCENT && l(i) && i.isSupported() && (a.oit = i.createDerivedCommands(t, r, a.oit))
}
dt.prototype.updateDerivedCommands = function(e) {
    if (!!l(e.derivedCommands)) {
        var t = this._frameState,
            n = this._context,
            r = t.shadowState.lastDirtyTime;
        e.lastDirtyTime !== r && (e.lastDirtyTime = r, e.dirty = !0);
        var i = t.useLogDepth,
            a = this._hdr,
            o = e.derivedCommands,
            s = l(o.logDepth),
            c = l(o.hdr),
            f = l(o.originalCommand),
            h = i && !s,
            d = a && !c,
            _ = (!i || !a) && !f;
        e.dirty = e.dirty || h || d || _, e.dirty && (e.dirty = !1, (s || h) && (o.logDepth = ba.createLogDepthCommand(e, n, o.logDepth), hp(this, o.logDepth.command)), (f || _) && hp(this, e))
    }
};
var lp = new q,
    Zh;

function uU(e) {
    var t = e.globe;
    if (e._mode === k.SCENE3D && l(t) && t.show && !e._cameraUnderground && !e._globeTranslucencyState.translucent) {
        var n = t.ellipsoid,
            r = e.frameState.minimumTerrainHeight;
        return lp.radius = n.minimumRadius + r, Zh = Tn.fromBoundingSphere(lp, e.camera.positionWC, Zh), Zh
    }
}
dt.prototype.clearPasses = function(e) {
    e.render = !1, e.pick = !1, e.depth = !1, e.postProcess = !1, e.offscreen = !1
};

function qT(e, t, n) {
    var r = e._frameState;
    r.frameNumber = t, r.time = $.clone(n, r.time)
}
dt.prototype.updateFrameState = function() {
    var e = this.camera,
        t = this._frameState;
    t.commandList.length = 0, t.brdfLutGenerator = this._brdfLutGenerator, t.environmentMap = this.skyBox && this.skyBox._cubeMap, t.mode = this._mode, t.morphTime = this.morphTime, t.mapProjection = this.mapProjection, t.camera = e, t.cullingVolume = e.frustum.computeCullingVolume(e.positionWC, e.directionWC, e.upWC), t.occluder = uU(this), t.terrainExaggeration = this._terrainExaggeration, t.minimumTerrainHeight = 0, t.minimumDisableDepthTestDistance = this._minimumDisableDepthTestDistance, t.invertClassification = this.invertClassification, t.useLogDepth = this._logDepthBuffer && !(this.camera.frustum instanceof lt || this.camera.frustum instanceof Wn), t.light = this.light, t.cameraUnderground = this._cameraUnderground, t.globeTranslucencyState = this._globeTranslucencyState, l(this._specularEnvironmentMapAtlas) && this._specularEnvironmentMapAtlas.ready ? (t.specularEnvironmentMaps = this._specularEnvironmentMapAtlas.texture, t.specularEnvironmentMapsMaximumLOD = this._specularEnvironmentMapAtlas.maximumMipmapLevel) : (t.specularEnvironmentMaps = void 0, t.specularEnvironmentMapsMaximumLOD = void 0), t.sphericalHarmonicCoefficients = this.sphericalHarmonicCoefficients, this._actualInvertClassificationColor = H.clone(this.invertClassificationColor, this._actualInvertClassificationColor), li.isTranslucencySupported(this._context) || (this._actualInvertClassificationColor.alpha = 1), t.invertClassificationColor = this._actualInvertClassificationColor, l(this.globe) ? t.maximumScreenSpaceError = this.globe.maximumScreenSpaceError : t.maximumScreenSpaceError = 2, this.clearPasses(t.passes), t.tilesetPassState = void 0
};
dt.prototype.isVisible = function(e, t, n) {
    return l(e) && (!l(e.boundingVolume) || !e.cull || t.computeVisibility(e.boundingVolume) !== nt.OUTSIDE && (!l(n) || !e.occlude || !e.boundingVolume.isOccluded(n)))
};
var Cc = new S(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
Cc = S.inverseTransformation(Cc, Cc);

function cU(e, t, n, r) {
    var i = t._frameState,
        a = i.context,
        o = e.boundingVolume;
    l(t._debugVolume) && t._debugVolume.destroy();
    var s, c = u.clone(o.center);
    if (i.mode !== k.SCENE3D) {
        c = S.multiplyByPoint(Cc, c, c);
        var f = i.mapProjection,
            h = f.unproject(c);
        c = f.ellipsoid.cartographicToCartesian(h)
    }
    if (l(o.radius)) {
        var d = o.radius;
        s = Qe.toWireframe(ri.createGeometry(new ri({
            radii: new u(d, d, d),
            vertexFormat: Gn.FLAT_VERTEX_FORMAT
        }))), t._debugVolume = new mt({
            geometryInstances: new ws({
                geometry: s,
                modelMatrix: S.fromTranslation(c),
                attributes: {
                    color: new ui(1, 0, 0, 1)
                }
            }),
            appearance: new Gn({
                flat: !0,
                translucent: !1
            }),
            asynchronous: !1
        })
    } else {
        var _ = o.halfAxes;
        s = Qe.toWireframe(kn.createGeometry(kn.fromDimensions({
            dimensions: new u(2, 2, 2),
            vertexFormat: Gn.FLAT_VERTEX_FORMAT
        }))), t._debugVolume = new mt({
            geometryInstances: new ws({
                geometry: s,
                modelMatrix: S.fromRotationTranslation(_, c, new S),
                attributes: {
                    color: new ui(1, 0, 0, 1)
                }
            }),
            appearance: new Gn({
                flat: !0,
                translucent: !1
            }),
            asynchronous: !1
        })
    }
    var v = i.commandList,
        m = i.commandList = [];
    if (t._debugVolume.update(i), e = m[0], i.useLogDepth) {
        var g = ba.createLogDepthCommand(e, a);
        e = g.command
    }
    var y;
    l(r) && (y = n.framebuffer, n.framebuffer = r), e.execute(a, n), l(y) && (n.framebuffer = y), i.commandList = v
}

function Zn(e, t, n, r, i) {
    var a = t._frameState;
    if (!(l(t.debugCommandFilter) && !t.debugCommandFilter(e))) {
        if (e instanceof on) {
            e.execute(n, r);
            return
        }
        e.debugShowBoundingVolume && l(e.boundingVolume) && cU(e, t, r, i), a.useLogDepth && l(e.derivedCommands.logDepth) && (e = e.derivedCommands.logDepth.command);
        var o = a.passes;
        if (!o.pick && !o.depth && t._hdr && l(e.derivedCommands) && l(e.derivedCommands.hdr) && (e = e.derivedCommands.hdr.command), o.pick || o.depth) {
            if (o.pick && !o.depth && l(e.derivedCommands.picking)) {
                e = e.derivedCommands.picking.pickCommand, e.execute(n, r);
                return
            } else if (l(e.derivedCommands.depth)) {
                e = e.derivedCommands.depth.depthOnlyCommand, e.execute(n, r);
                return
            }
        }
        a.shadowState.lightShadowsEnabled && e.receiveShadows && l(e.derivedCommands.shadows) ? e.derivedCommands.shadows.receiveCommand.execute(n, r) : e.execute(n, r)
    }
}

function fs(e, t, n, r) {
    var i = t._frameState,
        a = e.derivedCommands;
    !l(a) || (i.useLogDepth && l(a.logDepth) && (e = a.logDepth.command), a = e.derivedCommands, l(a.picking) ? (e = a.picking.pickCommand, e.execute(n, r)) : l(a.depth) && (e = a.depth.depthOnlyCommand, e.execute(n, r)))
}

function fU(e, t, n) {
    return t.boundingVolume.distanceSquaredTo(n) - e.boundingVolume.distanceSquaredTo(n)
}

function hU(e, t, n) {
    return e.boundingVolume.distanceSquaredTo(n) - t.boundingVolume.distanceSquaredTo(n) + T.EPSILON12
}

function lU(e, t, n, r, i) {
    var a = e.context;
    Hy(r, fU, e.camera.positionWC), l(i) && t(i.unclassifiedCommand, e, a, n);
    for (var o = r.length, s = 0; s < o; ++s) t(r[s], e, a, n)
}

function dU(e, t, n, r, i) {
    var a = e.context;
    Hy(r, hU, e.camera.positionWC), l(i) && t(i.unclassifiedCommand, e, a, n);
    for (var o = r.length, s = 0; s < o; ++s) t(r[s], e, a, n)
}

function YT(e, t) {
    var n = e._view.debugGlobeDepths,
        r = n[t];
    return !l(r) && e.context.depthTexture && (r = new xr, n[t] = r), r
}
var _U = new en,
    vU = new Er,
    mU = new lt,
    pU = new Wn;

function gU(e, t) {
    var n = e.camera,
        r = e.context,
        i = e.frameState,
        a = r.uniformState;
    a.updateCamera(n);
    var o;
    l(n.frustum.fov) ? o = n.frustum.clone(_U) : l(n.frustum.infiniteProjectionMatrix) ? o = n.frustum.clone(vU) : l(n.frustum.width) ? o = n.frustum.clone(mU) : o = n.frustum.clone(pU), o.near = n.frustum.near, o.far = n.frustum.far, a.updateFrustum(o), a.updatePass(ue.ENVIRONMENT);
    var s = i.passes,
        c = s.pick,
        f = e._environmentState,
        h = e._view,
        d = f.renderTranslucentDepthForPick;
    if (!c) {
        var _ = f.skyBoxCommand;
        l(_) && Zn(_, e, r, t), f.isSkyAtmosphereVisible && Zn(f.skyAtmosphereCommand, e, r, t), f.isSunVisible && f.sunDrawCommand.execute(r, t), f.isMoonVisible && f.moonCommand.execute(r, t)
    }
    var v;
    f.useOIT ? (l(e._executeOITFunction) || (e._executeOITFunction = function(qe, De, _e, Oe, Fe) {
        h.oit.executeCommands(qe, De, _e, Oe, Fe)
    }), v = e._executeOITFunction) : s.render ? v = lU : v = dU;
    for (var m = h.frustumCommandsList, g = m.length, y = f.clearGlobeDepth, E = f.useDepthPlane, w = e._globeTranslucencyState, C = w.translucent, A = e._view.globeTranslucencyFramebuffer, x = f.separatePrimitiveFramebuffer = !1, P = e._depthClearCommand, I = e._stencilClearCommand, D = e._classificationStencilClearCommand, O = e._depthPlane, F = f.usePostProcessSelected, z = n.position.z, b, M = 0; M < g; ++M) {
        var G = g - M - 1,
            V = m[G];
        e.mode === k.SCENE2D ? (n.position.z = z - V.near + 1, o.far = Math.max(1, V.far - V.near), o.near = 1, a.update(i), a.updateFrustum(o)) : (o.near = G !== 0 ? V.near * e.opaqueFrustumNearOffset : V.near, o.far = V.far, a.updateFrustum(o));
        var B = e.debugShowGlobeDepth ? YT(e, G) : h.globeDepth;
        x && (t.framebuffer = B.framebuffer);
        var Y;
        e.debugShowGlobeDepth && l(B) && f.useGlobeDepthFramebuffer && (B.update(r, t, h.viewport, e._hdr, y), B.clear(r, t, e._clearColorCommand.color), Y = t.framebuffer, t.framebuffer = B.framebuffer), P.execute(r, t), r.stencilBuffer && I.execute(r, t), a.updatePass(ue.GLOBE);
        var j = V.commands[ue.GLOBE],
            Z = V.indices[ue.GLOBE];
        if (C) w.executeGlobeCommands(V, Zn, A, e, t);
        else
            for (b = 0; b < Z; ++b) Zn(j[b], e, r, t);
        if (l(B) && f.useGlobeDepthFramebuffer && B.executeCopyDepth(r, t), e.debugShowGlobeDepth && l(B) && f.useGlobeDepthFramebuffer && (t.framebuffer = Y), !f.renderTranslucentDepthForPick)
            if (a.updatePass(ue.TERRAIN_CLASSIFICATION), j = V.commands[ue.TERRAIN_CLASSIFICATION], Z = V.indices[ue.TERRAIN_CLASSIFICATION], C) w.executeGlobeClassificationCommands(V, Zn, A, e, t);
            else
                for (b = 0; b < Z; ++b) Zn(j[b], e, r, t);
        if (y && (P.execute(r, t), E && O.execute(r, t)), x && (t.framebuffer = B.primitiveFramebuffer), !f.useInvertClassification || c || f.renderTranslucentDepthForPick) {
            for (a.updatePass(ue.CESIUM_3D_TILE), j = V.commands[ue.CESIUM_3D_TILE], Z = V.indices[ue.CESIUM_3D_TILE], b = 0; b < Z; ++b) Zn(j[b], e, r, t);
            if (Z > 0 && (l(B) && f.useGlobeDepthFramebuffer && B.executeUpdateDepth(r, t, y), !f.renderTranslucentDepthForPick))
                for (a.updatePass(ue.CESIUM_3D_TILE_CLASSIFICATION), j = V.commands[ue.CESIUM_3D_TILE_CLASSIFICATION], Z = V.indices[ue.CESIUM_3D_TILE_CLASSIFICATION], b = 0; b < Z; ++b) Zn(j[b], e, r, t)
        } else {
            e._invertClassification.clear(r, t);
            var Q = t.framebuffer;
            for (t.framebuffer = e._invertClassification._fbo, a.updatePass(ue.CESIUM_3D_TILE), j = V.commands[ue.CESIUM_3D_TILE], Z = V.indices[ue.CESIUM_3D_TILE], b = 0; b < Z; ++b) Zn(j[b], e, r, t);
            for (l(B) && f.useGlobeDepthFramebuffer && B.executeUpdateDepth(r, t, y), a.updatePass(ue.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW), j = V.commands[ue.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW], Z = V.indices[ue.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW], b = 0; b < Z; ++b) Zn(j[b], e, r, t);
            for (t.framebuffer = Q, e._invertClassification.executeClassified(r, t), i.invertClassificationColor.alpha === 1 && e._invertClassification.executeUnclassified(r, t), Z > 0 && r.stencilBuffer && D.execute(r, t), a.updatePass(ue.CESIUM_3D_TILE_CLASSIFICATION), j = V.commands[ue.CESIUM_3D_TILE_CLASSIFICATION], Z = V.indices[ue.CESIUM_3D_TILE_CLASSIFICATION], b = 0; b < Z; ++b) Zn(j[b], e, r, t)
        }
        for (Z > 0 && r.stencilBuffer && I.execute(r, t), a.updatePass(ue.OPAQUE), j = V.commands[ue.OPAQUE], Z = V.indices[ue.OPAQUE], b = 0; b < Z; ++b) Zn(j[b], e, r, t);
        G !== 0 && e.mode !== k.SCENE2D && (o.near = V.near, a.updateFrustum(o));
        var ie;
        if (!c && f.useInvertClassification && i.invertClassificationColor.alpha < 1 && (ie = e._invertClassification), a.updatePass(ue.TRANSLUCENT), j = V.commands[ue.TRANSLUCENT], j.length = V.indices[ue.TRANSLUCENT], v(e, Zn, t, j, ie), r.depthTexture && e.useDepthPicking && (f.useGlobeDepthFramebuffer || d)) {
            var Ae = d ? t.framebuffer.depthStencilTexture : B.framebuffer.depthStencilTexture,
                re = e._picking.getPickDepth(e, G);
            re.update(r, Ae), re.executeCopyDepth(r, t)
        }
        if (x && (t.framebuffer = B.framebuffer), !(c || !F)) {
            var ve = t.framebuffer;
            if (t.framebuffer = h.sceneFramebuffer.getIdFramebuffer(), o.near = G !== 0 ? V.near * e.opaqueFrustumNearOffset : V.near, o.far = V.far, a.updateFrustum(o), a.updatePass(ue.GLOBE), j = V.commands[ue.GLOBE], Z = V.indices[ue.GLOBE], C) w.executeGlobeCommands(V, fs, A, e, t);
            else
                for (b = 0; b < Z; ++b) fs(j[b], e, r, t);
            for (y && (P.framebuffer = t.framebuffer, P.execute(r, t), P.framebuffer = void 0), y && E && O.execute(r, t), a.updatePass(ue.CESIUM_3D_TILE), j = V.commands[ue.CESIUM_3D_TILE], Z = V.indices[ue.CESIUM_3D_TILE], b = 0; b < Z; ++b) fs(j[b], e, r, t);
            for (a.updatePass(ue.OPAQUE), j = V.commands[ue.OPAQUE], Z = V.indices[ue.OPAQUE], b = 0; b < Z; ++b) fs(j[b], e, r, t);
            for (a.updatePass(ue.TRANSLUCENT), j = V.commands[ue.TRANSLUCENT], Z = V.indices[ue.TRANSLUCENT], b = 0; b < Z; ++b) fs(j[b], e, r, t);
            t.framebuffer = ve
        }
    }
}

function yU(e) {
    var t = e.context.uniformState;
    t.updatePass(ue.COMPUTE);
    var n = e._environmentState.sunComputeCommand;
    l(n) && n.execute(e._computeEngine);
    for (var r = e._computeCommandList, i = r.length, a = 0; a < i; ++a) r[a].execute(e._computeEngine)
}

function TU(e, t) {
    var n = e.context.uniformState;
    n.updatePass(ue.OVERLAY);
    for (var r = e.context, i = e._overlayCommandList, a = i.length, o = 0; o < a; ++o) i[o].execute(r, t)
}
dt.prototype.updateAndExecuteCommands = function(e, t) {
    EU(!0, this, e, t)
};

function EU(e, t, n, r) {
    var i = t._environmentState,
        a = t._view,
        o = i.renderTranslucentDepthForPick;
    !e && !o && (t.frameState.commandList.length = 0), o || AU(t), a.createPotentiallyVisibleSet(t), e && (l(r) && CU(t, n, r), o || yU(t)), gU(t, n)
}
var dp = new Pn;
dt.prototype.updateEnvironment = function() {
    var e = this._frameState,
        t = this._view,
        n = this._environmentState,
        r = e.passes.render,
        i = this.skyAtmosphere,
        a = this.globe,
        o = this._globeTranslucencyState;
    if (!r || this._mode !== k.SCENE2D && t.camera.frustum instanceof lt || !o.environmentVisible) n.skyAtmosphereCommand = void 0, n.skyBoxCommand = void 0, n.sunDrawCommand = void 0, n.sunComputeCommand = void 0, n.moonCommand = void 0;
    else {
        l(i) ? (l(a) && (i.setDynamicAtmosphereColor(a.enableLighting && a.dynamicAtmosphereLighting, a.dynamicAtmosphereLightingFromSun), n.isReadyForAtmosphere = n.isReadyForAtmosphere || a._surface._tilesToRender.length > 0), n.skyAtmosphereCommand = i.update(e, a), l(n.skyAtmosphereCommand) && this.updateDerivedCommands(n.skyAtmosphereCommand)) : n.skyAtmosphereCommand = void 0, n.skyBoxCommand = l(this.skyBox) ? this.skyBox.update(e, this._hdr) : void 0;
        var s = l(this.sun) ? this.sun.update(e, t.passState, this._hdr) : void 0;
        n.sunDrawCommand = l(s) ? s.drawCommand : void 0, n.sunComputeCommand = l(s) ? s.computeCommand : void 0, n.moonCommand = l(this.moon) ? this.moon.update(e) : void 0
    }
    var c = n.clearGlobeDepth = l(a) && a.show && (!a.depthTestAgainstTerrain || this.mode === k.SCENE2D),
        f = n.useDepthPlane = c && this.mode === k.SCENE3D && o.useDepthPlane;
    f && this._depthPlane.update(e), n.renderTranslucentDepthForPick = !1;
    for (var h = e.mode === k.SCENE3D && !o.sunVisibleThroughGlobe ? e.occluder : void 0, d = e.cullingVolume, _ = dp.planes, v = 0; v < 5; ++v) _[v] = d.planes[v];
    d = dp, n.isSkyAtmosphereVisible = l(n.skyAtmosphereCommand) && n.isReadyForAtmosphere, n.isSunVisible = this.isVisible(n.sunDrawCommand, d, h), n.isMoonVisible = this.isVisible(n.moonCommand, d, h);
    var m = this.specularEnvironmentMaps,
        g = this._specularEnvironmentMapAtlas;
    l(m) && (!l(g) || g.url !== m) ? (g = g && g.destroy(), this._specularEnvironmentMapAtlas = new Ji(m)) : !l(m) && l(g) && (g.destroy(), this._specularEnvironmentMapAtlas = void 0), l(this._specularEnvironmentMapAtlas) && this._specularEnvironmentMapAtlas.update(e)
};

function AU(e) {
    var t = e._frameState;
    e._groundPrimitives.update(t), e._primitives.update(t), e._globe && e._globe.render(t)
}

function CU(e, t, n) {
    var r = e._context,
        i = e._environmentState,
        a = e._view,
        o = e._frameState.passes,
        s = o.pick;
    i.originalFramebuffer = t.framebuffer;
    var c = e._clearColorCommand;
    H.clone(n, c.color), c.execute(r, t);
    var f = i.useGlobeDepthFramebuffer = l(a.globeDepth);
    f && (a.globeDepth.update(r, t, a.viewport, e._hdr, i.clearGlobeDepth), a.globeDepth.clear(r, t, n));
    var h = a.oit,
        d = i.useOIT = !s && l(h) && h.isSupported();
    d && (h.update(r, t, a.globeDepth.framebuffer, e._hdr), h.clear(r, t, n), i.useOIT = h.isSupported()), f && (t.framebuffer = a.globeDepth.framebuffer), l(t.framebuffer) && c.execute(r, t);
    var _ = i.useInvertClassification = !s && l(t.framebuffer) && e.invertClassification;
    if (_) {
        var v;
        if (e.frameState.invertClassificationColor.alpha === 1 && i.useGlobeDepthFramebuffer && (v = a.globeDepth.framebuffer), l(v) || r.depthTexture) {
            if (e._invertClassification.previousFramebuffer = v, e._invertClassification.update(r), e._invertClassification.clear(r, t), e.frameState.invertClassificationColor.alpha < 1 && d) {
                var m = e._invertClassification.unclassifiedCommand,
                    g = m.derivedCommands;
                g.oit = h.createDerivedCommands(m, r, g.oit)
            }
        } else i.useInvertClassification = !1
    }
    e._globeTranslucencyState.translucent && a.globeTranslucencyFramebuffer.updateAndClear(e._hdr, a.viewport, r, t)
}
dt.prototype.resolveFramebuffers = function(e) {
    var t = this._context,
        n = this._frameState,
        r = this._environmentState,
        i = this._view,
        a = i.globeDepth,
        o = r.useOIT,
        s = r.useGlobeDepthFramebuffer,
        c = r.usePostProcess,
        f = r.originalFramebuffer,
        h = i.sceneFramebuffer.getFramebuffer();
    r.separatePrimitiveFramebuffer && a.executeMergeColor(t, e), o && (e.framebuffer = c ? h : f, i.oit.execute(t, e)), !o && !c && s && (e.framebuffer = f, a.executeCopyColor(t, e));
    var d = n.useLogDepth;
    if (this.debugShowGlobeDepth && s) {
        var _ = YT(this, this.debugShowDepthFrustum - 1);
        _.executeDebugGlobeDepth(t, e, d)
    }
    if (this.debugShowPickDepth && s) {
        var v = this._picking.getPickDepth(this, this.debugShowDepthFrustum - 1);
        v.executeDebugPickDepth(t, e, d)
    }
};

function wU(e) {
    for (var t = e._frameState.afterRender, n = 0, r = t.length; n < r; ++n) t[n](), e.requestRender();
    t.length = 0
}

function xU(e) {
    var t = e._globe,
        n = e.camera,
        r = n.positionCartographic;
    if (l(t) && t.show && l(r)) return t.getHeight(r)
}

function SU(e) {
    var t = e.camera,
        n = e._mode,
        r = e.globe,
        i = e._screenSpaceCameraController,
        a = t.positionCartographic;
    if (!l(a)) return !1;
    if (!i.onMap() && a.height < 0) return !0;
    if (!l(r) || !r.show || n === k.SCENE2D || n === k.MORPHING) return !1;
    var o = e._globeHeight;
    return l(o) && a.height < o
}
dt.prototype.initializeFrame = function() {
    this._shaderFrameCount++ === 120 && (this._shaderFrameCount = 0, this._context.shaderCache.destroyReleasedShaderPrograms(), this._context.textureCache.destroyReleasedTextures()), this._tweens.update(), this._globeHeight = xU(this), this._cameraUnderground = SU(this), this._globeTranslucencyState.update(this), this._screenSpaceCameraController.update(), l(this._deviceOrientationCameraController) && this._deviceOrientationCameraController.update(), this.camera.update(this._mode), this.camera._updateCameraChanged()
};

function RU(e, t) {
    if (e.debugShowFramesPerSecond) {
        if (!l(e._performanceDisplay)) {
            var n = document.createElement("div");
            n.className = "cesium-performanceDisplay-defaultContainer";
            var r = e._canvas.parentNode;
            r.appendChild(n);
            var i = new of ({
                container: n
            });
            e._performanceDisplay = i, e._performanceContainer = n
        }
        e._performanceDisplay.throttled = e.requestRenderMode, e._performanceDisplay.update(t)
    } else l(e._performanceDisplay) && (e._performanceDisplay = e._performanceDisplay && e._performanceDisplay.destroy(), e._performanceContainer.parentNode.removeChild(e._performanceContainer))
}

function DU(e) {
    e._jobScheduler.resetBudgets();
    var t = e._frameState,
        n = e.primitives;
    n.prePassesUpdate(t), l(e.globe) && e.globe.update(t), t.creditDisplay.update()
}

function IU(e) {
    var t = e._frameState,
        n = e.primitives;
    n.postPassesUpdate(t), Et.update()
}
var PU = new H;

function OU(e) {
    var t = e._frameState,
        n = e.context,
        r = n.uniformState,
        i = e._defaultView;
    e._view = i, e.updateFrameState(), t.passes.render = !0;
    var a = p(e.backgroundColor, H.BLACK);
    e._hdr && (a = H.clone(a, PU), a.red = Math.pow(a.red, e.gamma), a.green = Math.pow(a.green, e.gamma), a.blue = Math.pow(a.blue, e.gamma)), t.backgroundColor = a, e.fog.update(t), r.update(t), e._computeCommandList.length = 0, e._overlayCommandList.length = 0;
    var o = i.viewport;
    o.x = 0, o.y = 0, o.width = n.drawingBufferWidth, o.height = n.drawingBufferHeight;
    var s = i.passState;
    s.framebuffer = void 0, s.blendingEnabled = void 0, s.scissorTest = void 0, s.viewport = ge.clone(o, s.viewport), l(e.globe) && e.globe.beginFrame(t), e.updateEnvironment(), e.updateAndExecuteCommands(s, a), e.resolveFramebuffers(s), s.framebuffer = void 0, TU(e, s), l(e.globe) && (e.globe.endFrame(t), e.globe.tilesLoaded || (e._renderRequested = !0)), n.endFrame()
}

function Kh(e, t) {
    try {
        t(e)
    } catch (n) {
        if (e._renderError.raiseEvent(e, n), e.rethrowRenderErrors) throw n
    }
}
dt.prototype.render = function(e) {
    this._preUpdate.raiseEvent(this, e);
    var t = this._frameState;
    t.newFrame = !1, l(e) || (e = $.now());
    var n = this._view.checkForCameraUpdates(this),
        r = !this.requestRenderMode || this._renderRequested || n || this._logDepthBufferDirty || this._hdrDirty || this.mode === k.MORPHING;
    if (!r && l(this.maximumRenderTimeChange) && l(this._lastRenderTime)) {
        var i = Math.abs($.secondsDifference(this._lastRenderTime, e));
        r = r || i > this.maximumRenderTimeChange
    }
    if (r) {
        this._lastRenderTime = $.clone(e, this._lastRenderTime), this._renderRequested = !1, this._logDepthBufferDirty = !1, this._hdrDirty = !1;
        var a = T.incrementWrap(t.frameNumber, 15e6, 1);
        qT(this, a, e), t.newFrame = !0
    }
    Kh(this, DU), this._postUpdate.raiseEvent(this, e), r && (this._preRender.raiseEvent(this, e), t.creditDisplay.beginFrame(), Kh(this, OU)), RU(this, r), Kh(this, IU), wU(this), r && (this._postRender.raiseEvent(this, e), t.creditDisplay.endFrame())
};
dt.prototype.forceRender = function(e) {
    this._renderRequested = !0, this.render(e)
};
dt.prototype.requestRender = function() {
    this._renderRequested = !0
};
dt.prototype.clampLineWidth = function(e) {
    return Math.max(pe.minimumAliasedLineWidth, Math.min(e, pe.maximumAliasedLineWidth))
};
dt.prototype.pick = function(e, t, n) {
    return this._picking.pick(this, e, t, n)
};
dt.prototype.pickPositionWorldCoordinates = function(e, t) {
    return this._picking.pickPositionWorldCoordinates(this, e, t)
};
dt.prototype.pickPosition = function(e, t) {
    return this._picking.pickPosition(this, e, t)
};
dt.prototype.drillPick = function(e, t, n, r) {
    return this._picking.drillPick(this, e, t, n, r)
};
dt.prototype.pickFromRay = function(e, t, n) {
    return this._picking.pickFromRay(this, e, t, n)
};
dt.prototype.drillPickFromRay = function(e, t, n, r) {
    return this._picking.drillPickFromRay(this, e, t, n, r)
};
dt.prototype.pickFromRayMostDetailed = function(e, t, n) {
    return this._picking.pickFromRayMostDetailed(this, e, t, n)
};
dt.prototype.drillPickFromRayMostDetailed = function(e, t, n, r) {
    return this._picking.drillPickFromRayMostDetailed(this, e, t, n, r)
};
dt.prototype.sampleHeight = function(e, t, n) {
    return this._picking.sampleHeight(this, e, t, n)
};
dt.prototype.clampToHeight = function(e, t, n, r) {
    return this._picking.clampToHeight(this, e, t, n, r)
};
dt.prototype.sampleHeightMostDetailed = function(e, t, n) {
    return this._picking.sampleHeightMostDetailed(this, e, t, n)
};
dt.prototype.clampToHeightMostDetailed = function(e, t, n) {
    return this._picking.clampToHeightMostDetailed(this, e, t, n)
};
dt.prototype.cartesianToCanvasCoordinates = function(e, t) {
    return Ht.wgs84ToWindowCoordinates(this, e, t)
};
dt.prototype.isDestroyed = function() {
    return !1
};
dt.prototype.destroy = function() {
    this._tweens.removeAll(), this._computeEngine = this._computeEngine && this._computeEngine.destroy(), this._screenSpaceCameraController = this._screenSpaceCameraController && this._screenSpaceCameraController.destroy(), this._deviceOrientationCameraController = this._deviceOrientationCameraController && !this._deviceOrientationCameraController.isDestroyed() && this._deviceOrientationCameraController.destroy(), this._primitives = this._primitives && this._primitives.destroy(), this._groundPrimitives = this._groundPrimitives && this._groundPrimitives.destroy(), this._globe = this._globe && this._globe.destroy(), this.skyBox = this.skyBox && this.skyBox.destroy(), this.skyAtmosphere = this.skyAtmosphere && this.skyAtmosphere.destroy(), this._debugSphere = this._debugSphere && this._debugSphere.destroy(), this.sun = this.sun && this.sun.destroy(), this._sunPostProcess = this._sunPostProcess && this._sunPostProcess.destroy(), this._depthPlane = this._depthPlane && this._depthPlane.destroy(), this._debugFrustumPlanes = this._debugFrustumPlanes && this._debugFrustumPlanes.destroy(), this._brdfLutGenerator = this._brdfLutGenerator && this._brdfLutGenerator.destroy(), this._picking = this._picking && this._picking.destroy(), this._defaultView = this._defaultView && this._defaultView.destroy(), this._view = void 0, this._removeCreditContainer && this._canvas.parentNode.removeChild(this._creditContainer), this._context = this._context && this._context.destroy(), this._frameState.creditDisplay = this._frameState.creditDisplay && this._frameState.creditDisplay.destroy(), l(this._performanceDisplay) && (this._performanceDisplay = this._performanceDisplay && this._performanceDisplay.destroy(), this._performanceContainer.parentNode.removeChild(this._performanceContainer)), this._removeRequestListenerCallback(), this._removeTaskProcessorListenerCallback();
    for (var e = 0; e < this._removeGlobeCallbacks.length; ++e) this._removeGlobeCallbacks[e]();
    return this._removeGlobeCallbacks.length = 0, Pe(this)
};
var MU = 0,
    $h = {};

function Pi(e, t) {
    var n, r = e;
    l($h[r]) ? n = $h[r] : (n = MU++, $h[r] = n), t = p(t, !1), this._id = n, this._html = e, this._showOnScreen = t, this._element = void 0
}
Object.defineProperties(Pi.prototype, {
    html: {
        get: function() {
            return this._html
        }
    },
    id: {
        get: function() {
            return this._id
        }
    },
    showOnScreen: {
        get: function() {
            return this._showOnScreen
        }
    },
    element: {
        get: function() {
            if (!l(this._element)) {
                var e = this._html,
                    t = document.createElement("div");
                t._creditId = this._id, t.style.display = "inline", t.innerHTML = e;
                for (var n = t.querySelectorAll("a"), r = 0; r < n.length; r++) n[r].setAttribute("target", "_blank");
                this._element = t
            }
            return this._element
        }
    }
});
Pi.equals = function(e, t) {
    return e === t || l(e) && l(t) && e._id === t._id
};
Pi.prototype.equals = function(e) {
    return Pi.equals(this, e)
};
Pi.getIonCredit = function(e) {
    var t = l(e.collapsible) && !e.collapsible,
        n = new Pi(e.html, t);
    return n._isIon = n.html.indexOf("ion-credit.png") !== -1, n
};
Pi.clone = function(e) {
    if (l(e)) return new Pi(e.html, e.showOnScreen)
};

function oa(e) {
    if (e = p(e, p.EMPTY_OBJECT), this._ellipsoid = p(e.ellipsoid, ne.WGS84), this._numberOfLevelZeroTilesX = p(e.numberOfLevelZeroTilesX, 1), this._numberOfLevelZeroTilesY = p(e.numberOfLevelZeroTilesY, 1), this._projection = new st(this._ellipsoid), l(e.rectangleSouthwestInMeters) && l(e.rectangleNortheastInMeters)) this._rectangleSouthwestInMeters = e.rectangleSouthwestInMeters, this._rectangleNortheastInMeters = e.rectangleNortheastInMeters;
    else {
        var t = this._ellipsoid.maximumRadius * Math.PI;
        this._rectangleSouthwestInMeters = new R(-t, -t), this._rectangleNortheastInMeters = new R(t, t)
    }
    var n = this._projection.unproject(this._rectangleSouthwestInMeters),
        r = this._projection.unproject(this._rectangleNortheastInMeters);
    this._rectangle = new W(n.longitude, n.latitude, r.longitude, r.latitude)
}
Object.defineProperties(oa.prototype, {
    ellipsoid: {
        get: function() {
            return this._ellipsoid
        }
    },
    rectangle: {
        get: function() {
            return this._rectangle
        }
    },
    projection: {
        get: function() {
            return this._projection
        }
    }
});
oa.prototype.getNumberOfXTilesAtLevel = function(e) {
    return this._numberOfLevelZeroTilesX << e
};
oa.prototype.getNumberOfYTilesAtLevel = function(e) {
    return this._numberOfLevelZeroTilesY << e
};
oa.prototype.rectangleToNativeRectangle = function(e, t) {
    var n = this._projection,
        r = n.project(W.southwest(e)),
        i = n.project(W.northeast(e));
    return l(t) ? (t.west = r.x, t.south = r.y, t.east = i.x, t.north = i.y, t) : new W(r.x, r.y, i.x, i.y)
};
oa.prototype.tileXYToNativeRectangle = function(e, t, n, r) {
    var i = this.getNumberOfXTilesAtLevel(n),
        a = this.getNumberOfYTilesAtLevel(n),
        o = (this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x) / i,
        s = this._rectangleSouthwestInMeters.x + e * o,
        c = this._rectangleSouthwestInMeters.x + (e + 1) * o,
        f = (this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y) / a,
        h = this._rectangleNortheastInMeters.y - t * f,
        d = this._rectangleNortheastInMeters.y - (t + 1) * f;
    return l(r) ? (r.west = s, r.south = d, r.east = c, r.north = h, r) : new W(s, d, c, h)
};
oa.prototype.tileXYToRectangle = function(e, t, n, r) {
    var i = this.tileXYToNativeRectangle(e, t, n, r),
        a = this._projection,
        o = a.unproject(new R(i.west, i.south)),
        s = a.unproject(new R(i.east, i.north));
    return i.west = o.longitude, i.south = o.latitude, i.east = s.longitude, i.north = s.latitude, i
};
oa.prototype.positionToTileXY = function(e, t, n) {
    var r = this._rectangle;
    if (!!W.contains(r, e)) {
        var i = this.getNumberOfXTilesAtLevel(t),
            a = this.getNumberOfYTilesAtLevel(t),
            o = this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x,
            s = o / i,
            c = this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y,
            f = c / a,
            h = this._projection,
            d = h.project(e),
            _ = d.x - this._rectangleSouthwestInMeters.x,
            v = this._rectangleNortheastInMeters.y - d.y,
            m = _ / s | 0;
        m >= i && (m = i - 1);
        var g = v / f | 0;
        return g >= a && (g = a - 1), l(n) ? (n.x = m, n.y = g, n) : new R(m, g)
    }
};
var NU = new Lt("transcodeCRNToDXT", Number.POSITIVE_INFINITY);

function bU(e) {
    var t;
    if (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) t = he.resolve(e);
    else {
        var n = J.createIfNeeded(e);
        t = n.fetchArrayBuffer()
    }
    if (!!l(t)) return t.then(function(r) {
        if (!!l(r)) {
            var i = [];
            return r instanceof ArrayBuffer ? i.push(r) : (r.byteOffset === 0 && r.byteLength === r.buffer.byteLength || (r = r.slice(0, r.length)), i.push(r.buffer)), NU.scheduleTask(r, i)
        }
    }).then(function(r) {
        return La.clone(r)
    })
}

function Uo() {
    this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0, we.throwInstantiationError()
}
Object.defineProperties(Uo.prototype, {
    ready: {
        get: we.throwInstantiationError
    },
    readyPromise: {
        get: we.throwInstantiationError
    },
    rectangle: {
        get: we.throwInstantiationError
    },
    tileWidth: {
        get: we.throwInstantiationError
    },
    tileHeight: {
        get: we.throwInstantiationError
    },
    maximumLevel: {
        get: we.throwInstantiationError
    },
    minimumLevel: {
        get: we.throwInstantiationError
    },
    tilingScheme: {
        get: we.throwInstantiationError
    },
    tileDiscardPolicy: {
        get: we.throwInstantiationError
    },
    errorEvent: {
        get: we.throwInstantiationError
    },
    credit: {
        get: we.throwInstantiationError
    },
    proxy: {
        get: we.throwInstantiationError
    },
    hasAlphaChannel: {
        get: we.throwInstantiationError
    }
});
Uo.prototype.getTileCredits = function(e, t, n) {
    we.throwInstantiationError()
};
Uo.prototype.requestImage = function(e, t, n, r) {
    we.throwInstantiationError()
};
Uo.prototype.pickFeatures = function(e, t, n, r, i) {
    we.throwInstantiationError()
};
var FU = /\.ktx$/i,
    LU = /\.crn$/i;
Uo.loadImage = function(e, t) {
    var n = J.createIfNeeded(t);
    return FU.test(n.url) ? CT(n) : LU.test(n.url) ? bU(n) : l(e) && l(e.tileDiscardPolicy) ? n.fetchImage({
        preferBlob: !0,
        preferImageBitmap: !0,
        flipY: !0
    }) : n.fetchImage({
        preferImageBitmap: !0,
        flipY: !0
    })
};
var XT = /{[^}]+}/g,
    jT = {
        x: VU,
        y: HU,
        z: qU,
        s: YU,
        reverseX: GU,
        reverseY: kU,
        reverseZ: WU,
        westDegrees: XU,
        southDegrees: jU,
        eastDegrees: ZU,
        northDegrees: KU,
        westProjected: $U,
        southProjected: JU,
        eastProjected: QU,
        northProjected: ez,
        width: tz,
        height: nz
    },
    UU = En(jT, {
        i: rz,
        j: iz,
        reverseI: az,
        reverseJ: oz,
        longitudeDegrees: uz,
        latitudeDegrees: cz,
        longitudeProjected: fz,
        latitudeProjected: hz,
        format: dz
    });

function qs(e) {
    this._errorEvent = new ht, this._resource = void 0, this._urlSchemeZeroPadding = void 0, this._pickFeaturesResource = void 0, this._tileWidth = void 0, this._tileHeight = void 0, this._maximumLevel = void 0, this._minimumLevel = void 0, this._tilingScheme = void 0, this._rectangle = void 0, this._tileDiscardPolicy = void 0, this._credit = void 0, this._hasAlphaChannel = void 0, this._readyPromise = void 0, this._tags = void 0, this._pickFeaturesTags = void 0, this.defaultAlpha = void 0, this.defaultNightAlpha = void 0, this.defaultDayAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, this.defaultMinificationFilter = void 0, this.defaultMagnificationFilter = void 0, this.enablePickFeatures = !0, this.reinitialize(e)
}
Object.defineProperties(qs.prototype, {
    url: {
        get: function() {
            return this._resource.url
        }
    },
    urlSchemeZeroPadding: {
        get: function() {
            return this._urlSchemeZeroPadding
        }
    },
    pickFeaturesUrl: {
        get: function() {
            return this._pickFeaturesResource.url
        }
    },
    proxy: {
        get: function() {
            return this._resource.proxy
        }
    },
    tileWidth: {
        get: function() {
            return this._tileWidth
        }
    },
    tileHeight: {
        get: function() {
            return this._tileHeight
        }
    },
    maximumLevel: {
        get: function() {
            return this._maximumLevel
        }
    },
    minimumLevel: {
        get: function() {
            return this._minimumLevel
        }
    },
    tilingScheme: {
        get: function() {
            return this._tilingScheme
        }
    },
    rectangle: {
        get: function() {
            return this._rectangle
        }
    },
    tileDiscardPolicy: {
        get: function() {
            return this._tileDiscardPolicy
        }
    },
    errorEvent: {
        get: function() {
            return this._errorEvent
        }
    },
    ready: {
        get: function() {
            return l(this._resource)
        }
    },
    readyPromise: {
        get: function() {
            return this._readyPromise
        }
    },
    credit: {
        get: function() {
            return this._credit
        }
    },
    hasAlphaChannel: {
        get: function() {
            return this._hasAlphaChannel
        }
    }
});
qs.prototype.reinitialize = function(e) {
    var t = this;
    t._readyPromise = he(e).then(function(n) {
        var r = n.customTags,
            i = En(jT, r),
            a = En(UU, r),
            o = J.createIfNeeded(n.url),
            s = J.createIfNeeded(n.pickFeaturesUrl);
        t.enablePickFeatures = p(n.enablePickFeatures, t.enablePickFeatures), t._urlSchemeZeroPadding = p(n.urlSchemeZeroPadding, t.urlSchemeZeroPadding), t._tileDiscardPolicy = n.tileDiscardPolicy, t._getFeatureInfoFormats = n.getFeatureInfoFormats, t._subdomains = n.subdomains, Array.isArray(t._subdomains) ? t._subdomains = t._subdomains.slice() : l(t._subdomains) && t._subdomains.length > 0 ? t._subdomains = t._subdomains.split("") : t._subdomains = ["a", "b", "c"], t._tileWidth = p(n.tileWidth, 256), t._tileHeight = p(n.tileHeight, 256), t._minimumLevel = p(n.minimumLevel, 0), t._maximumLevel = n.maximumLevel, t._tilingScheme = p(n.tilingScheme, new oa({
            ellipsoid: n.ellipsoid
        })), t._rectangle = p(n.rectangle, t._tilingScheme.rectangle), t._rectangle = W.intersection(t._rectangle, t._tilingScheme.rectangle), t._hasAlphaChannel = p(n.hasAlphaChannel, !0);
        var c = n.credit;
        return typeof c == "string" && (c = new Pi(c)), t._credit = c, t._resource = o, t._tags = i, t._pickFeaturesResource = s, t._pickFeaturesTags = a, !0
    })
};
qs.prototype.getTileCredits = function(e, t, n) {};
qs.prototype.requestImage = function(e, t, n, r) {
    return Uo.loadImage(this, zU(this, e, t, n, r))
};
qs.prototype.pickFeatures = function(e, t, n, r, i) {
    if (!this.enablePickFeatures || !l(this._pickFeaturesResource) || this._getFeatureInfoFormats.length === 0) return;
    var a = 0,
        o = this;

    function s(f, h) {
        return f.callback(h)
    }

    function c() {
        if (a >= o._getFeatureInfoFormats.length) return he([]);
        var f = o._getFeatureInfoFormats[a],
            h = BU(o, e, t, n, r, i, f.format);
        return ++a, f.type === "json" ? h.fetchJson().then(f.callback).otherwise(c) : f.type === "xml" ? h.fetchXML().then(f.callback).otherwise(c) : f.type === "text" || f.type === "html" ? h.fetchText().then(f.callback).otherwise(c) : h.fetch({
            responseType: f.format
        }).then(s.bind(void 0, f)).otherwise(c)
    }
    return c()
};
var kc = !1,
    Kn = new W,
    Wc = !1,
    Ys = new W;

function zU(e, t, n, r, i) {
    kc = !1, Wc = !1;
    var a = e._resource,
        o = a.getUrlComponent(!0),
        s = e._tags,
        c = {},
        f = o.match(XT);
    return l(f) && f.forEach(function(h) {
        var d = h.substring(1, h.length - 1);
        l(s[d]) && (c[d] = s[d](e, t, n, r))
    }), a.getDerivedResource({
        request: i,
        templateValues: c
    })
}
var Hl = !1,
    Io = new R,
    kl = !1;

function BU(e, t, n, r, i, a, o) {
    kc = !1, Wc = !1, Hl = !1, kl = !1;
    var s = e._pickFeaturesResource,
        c = s.getUrlComponent(!0),
        f = e._pickFeaturesTags,
        h = {},
        d = c.match(XT);
    return l(d) && d.forEach(function(_) {
        var v = _.substring(1, _.length - 1);
        l(f[v]) && (h[v] = f[v](e, t, n, r, i, a, o))
    }), s.getDerivedResource({
        templateValues: h
    })
}

function zo(e, t, n) {
    if (e && e.urlSchemeZeroPadding && e.urlSchemeZeroPadding.hasOwnProperty(t)) {
        var r = e.urlSchemeZeroPadding[t];
        if (typeof r == "string") {
            var i = r.length;
            i > 1 && (n = n.length >= i ? n : new Array(i - n.toString().length + 1).join("0") + n)
        }
    }
    return n
}

function VU(e, t, n, r) {
    return zo(e, "{x}", t)
}

function GU(e, t, n, r) {
    var i = e.tilingScheme.getNumberOfXTilesAtLevel(r) - t - 1;
    return zo(e, "{reverseX}", i)
}

function HU(e, t, n, r) {
    return zo(e, "{y}", n)
}

function kU(e, t, n, r) {
    var i = e.tilingScheme.getNumberOfYTilesAtLevel(r) - n - 1;
    return zo(e, "{reverseY}", i)
}

function WU(e, t, n, r) {
    var i = e.maximumLevel,
        a = l(i) && r < i ? i - r - 1 : r;
    return zo(e, "{reverseZ}", a)
}

function qU(e, t, n, r) {
    return zo(e, "{z}", r)
}

function YU(e, t, n, r) {
    var i = (t + n + r) % e._subdomains.length;
    return e._subdomains[i]
}

function ff(e, t, n, r) {
    kc || (e.tilingScheme.tileXYToRectangle(t, n, r, Kn), Kn.west = T.toDegrees(Kn.west), Kn.south = T.toDegrees(Kn.south), Kn.east = T.toDegrees(Kn.east), Kn.north = T.toDegrees(Kn.north), kc = !0)
}

function XU(e, t, n, r) {
    return ff(e, t, n, r), Kn.west
}

function jU(e, t, n, r) {
    return ff(e, t, n, r), Kn.south
}

function ZU(e, t, n, r) {
    return ff(e, t, n, r), Kn.east
}

function KU(e, t, n, r) {
    return ff(e, t, n, r), Kn.north
}

function hf(e, t, n, r) {
    Wc || (e.tilingScheme.tileXYToNativeRectangle(t, n, r, Ys), Wc = !0)
}

function $U(e, t, n, r) {
    return hf(e, t, n, r), Ys.west
}

function JU(e, t, n, r) {
    return hf(e, t, n, r), Ys.south
}

function QU(e, t, n, r) {
    return hf(e, t, n, r), Ys.east
}

function ez(e, t, n, r) {
    return hf(e, t, n, r), Ys.north
}

function tz(e, t, n, r) {
    return e.tileWidth
}

function nz(e, t, n, r) {
    return e.tileHeight
}

function rz(e, t, n, r, i, a, o) {
    return lf(e, t, n, r, i, a), Io.x
}

function iz(e, t, n, r, i, a, o) {
    return lf(e, t, n, r, i, a), Io.y
}

function az(e, t, n, r, i, a, o) {
    return lf(e, t, n, r, i, a), e.tileWidth - Io.x - 1
}

function oz(e, t, n, r, i, a, o) {
    return lf(e, t, n, r, i, a), e.tileHeight - Io.y - 1
}
var sz = new W,
    po = new u;

function lf(e, t, n, r, i, a, o) {
    if (!Hl) {
        Yd(e, t, n, r, i, a);
        var s = po,
            c = e.tilingScheme.tileXYToNativeRectangle(t, n, r, sz);
        Io.x = e.tileWidth * (s.x - c.west) / c.width | 0, Io.y = e.tileHeight * (c.north - s.y) / c.height | 0, Hl = !0
    }
}

function uz(e, t, n, r, i, a, o) {
    return T.toDegrees(i)
}

function cz(e, t, n, r, i, a, o) {
    return T.toDegrees(a)
}

function fz(e, t, n, r, i, a, o) {
    return Yd(e, t, n, r, i, a), po.x
}

function hz(e, t, n, r, i, a, o) {
    return Yd(e, t, n, r, i, a), po.y
}
var lz = new K;

function Yd(e, t, n, r, i, a, o) {
    if (!kl) {
        if (e.tilingScheme.projection instanceof un) po.x = T.toDegrees(i), po.y = T.toDegrees(a);
        else {
            var s = lz;
            s.longitude = i, s.latitude = a, e.tilingScheme.projection.project(s, po)
        }
        kl = !0
    }
}

function dz(e, t, n, r, i, a, o) {
    return o
}
export {
    An as $, yt as A, ye as B, H as C, an as D, ne as E, ee as F, Da as G, Xt as H, Me as I, Oc as J, gr as K, Ee as L, S as M, at as N, lt as O, Ne as P, X as Q, Ke as R, k as S, Sr as T, Ra as U, Yt as V, L as W, dt as X, hi as Y, qs as Z, Vr as _, u as a, Gr as a0, ot as a1, U as b, tt as c, Ar as d, R as e, K as f, T as g, N as h, l as i, Pe as j, Ht as k, xe as l, p as m, Ye as n, rn as o, Mo as p, q, Mr as r, Ge as s, fi as t, pe as u, Re as v, Q0 as w, Mt as x, ue as y, _t as z
};